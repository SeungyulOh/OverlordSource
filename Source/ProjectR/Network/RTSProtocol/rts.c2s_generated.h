// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTSC2S_OVERLORD_RTS_C2S_H_
#define FLATBUFFERS_GENERATED_RTSC2S_OVERLORD_RTS_C2S_H_

#include "flatbuffers/flatbuffers.h"

#include "PDU_generated.h"
#include "rts.struct_generated.h"

namespace OVERLORD {
namespace RTS {
namespace C2S {

struct REQ_PING;
struct REQ_PINGT;

struct REQ_AUTH;
struct REQ_AUTHT;

struct CHAT_SUBSCRIBE;
struct CHAT_SUBSCRIBET;

struct CHAT_CHANNEL_MOVE;
struct CHAT_CHANNEL_MOVET;

struct CHAT_MESSAGE;
struct CHAT_MESSAGET;

struct REQ_MATCH;
struct REQ_MATCHT;

struct REQ_MATCH_JOIN;
struct REQ_MATCH_JOINT;

struct REQ_MATCH_CANCEL;
struct REQ_MATCH_CANCELT;

struct REQ_PARTY_UI_READY;
struct REQ_PARTY_UI_READYT;

struct REQ_PARTY_UPDATE_PUBLIC;
struct REQ_PARTY_UPDATE_PUBLICT;

struct REQ_DECK_SELECT;
struct REQ_DECK_SELECTT;

struct REQ_DECK_SELECT_READY;
struct REQ_DECK_SELECT_READYT;

struct REQ_PARTY_GO;
struct REQ_PARTY_GOT;

struct REQ_PLAY_READY;
struct REQ_PLAY_READYT;

struct ACK_CINEMATIC_DONE;
struct ACK_CINEMATIC_DONET;

struct ACK_STEP_AND_GO;
struct ACK_STEP_AND_GOT;

struct REQ_CS_PARTY_UI_READY;
struct REQ_CS_PARTY_UI_READYT;

struct REQ_CS_DECK_SELECT;
struct REQ_CS_DECK_SELECTT;

struct REQ_CS_DECK_SELECT_READY;
struct REQ_CS_DECK_SELECT_READYT;

struct REQ_BT_ACTOR_CREATE;
struct REQ_BT_ACTOR_CREATET;

struct REQ_BT_ENTER;
struct REQ_BT_ENTERT;

struct REQ_BT_EXIT;
struct REQ_BT_EXITT;

struct REQ_BT_ACTOR_SPAWN;
struct REQ_BT_ACTOR_SPAWNT;

struct REQ_BT_DROP_CREW;
struct REQ_BT_DROP_CREWT;

struct REQ_BT_CHANGE_CREW;
struct REQ_BT_CHANGE_CREWT;

struct REQ_BT_CHANGE_SPIRIT;
struct REQ_BT_CHANGE_SPIRITT;

struct REQ_BT_ACTOR_MOVE;
struct REQ_BT_ACTOR_MOVET;

struct REQ_BT_ATTACK_NOW;
struct REQ_BT_ATTACK_NOWT;

struct REQ_BT_SKILL_CAST;
struct REQ_BT_SKILL_CASTT;

struct REQ_BT_ACTOR_TELEPORT;
struct REQ_BT_ACTOR_TELEPORTT;

struct REQ_BT_ACTOR_FORMATION;
struct REQ_BT_ACTOR_FORMATIONT;

struct REQ_BT_DICE;
struct REQ_BT_DICET;

struct REQ_BT_PLAYER_SCORE;
struct REQ_BT_PLAYER_SCORET;

struct REQ_BT_ACTOR_SCORE;
struct REQ_BT_ACTOR_SCORET;

struct REQ_PINGT : public flatbuffers::NativeTable {
  typedef REQ_PING TableType;
  uint32_t frame;
  REQ_PINGT()
      : frame(0) {
  }
};

struct REQ_PING FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_PINGT NativeTableType;
  enum {
    VT_FRAME = 4
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           verifier.EndTable();
  }
  REQ_PINGT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_PINGT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_PING> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PINGT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_PINGBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(REQ_PING::VT_FRAME, frame, 0);
  }
  explicit REQ_PINGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_PINGBuilder &operator=(const REQ_PINGBuilder &);
  flatbuffers::Offset<REQ_PING> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_PING>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_PING> CreateREQ_PING(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0) {
  REQ_PINGBuilder builder_(_fbb);
  builder_.add_frame(frame);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_PING> CreateREQ_PING(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PINGT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_AUTHT : public flatbuffers::NativeTable {
  typedef REQ_AUTH TableType;
  std::string clientkey;
  std::string deviceid;
  uint32_t t;
  REQ_AUTHT()
      : t(0) {
  }
};

struct REQ_AUTH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_AUTHT NativeTableType;
  enum {
    VT_CLIENTKEY = 4,
    VT_DEVICEID = 6,
    VT_T = 8
  };
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  uint32_t t() const {
    return GetField<uint32_t>(VT_T, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyField<uint32_t>(verifier, VT_T) &&
           verifier.EndTable();
  }
  REQ_AUTHT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_AUTHT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_AUTH> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_AUTHT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_AUTHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(REQ_AUTH::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(REQ_AUTH::VT_DEVICEID, deviceid);
  }
  void add_t(uint32_t t) {
    fbb_.AddElement<uint32_t>(REQ_AUTH::VT_T, t, 0);
  }
  explicit REQ_AUTHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_AUTHBuilder &operator=(const REQ_AUTHBuilder &);
  flatbuffers::Offset<REQ_AUTH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_AUTH>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_AUTH> CreateREQ_AUTH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    uint32_t t = 0) {
  REQ_AUTHBuilder builder_(_fbb);
  builder_.add_t(t);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_AUTH> CreateREQ_AUTHDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    uint32_t t = 0) {
  return OVERLORD::RTS::C2S::CreateREQ_AUTH(
      _fbb,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      t);
}

flatbuffers::Offset<REQ_AUTH> CreateREQ_AUTH(flatbuffers::FlatBufferBuilder &_fbb, const REQ_AUTHT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_SUBSCRIBET : public flatbuffers::NativeTable {
  typedef CHAT_SUBSCRIBE TableType;
  std::string channel;
  CHAT_SUBSCRIBET() {
  }
};

struct CHAT_SUBSCRIBE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_SUBSCRIBET NativeTableType;
  enum {
    VT_CHANNEL = 4
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           verifier.EndTable();
  }
  CHAT_SUBSCRIBET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_SUBSCRIBET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_SUBSCRIBE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_SUBSCRIBEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_SUBSCRIBE::VT_CHANNEL, channel);
  }
  explicit CHAT_SUBSCRIBEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_SUBSCRIBEBuilder &operator=(const CHAT_SUBSCRIBEBuilder &);
  flatbuffers::Offset<CHAT_SUBSCRIBE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_SUBSCRIBE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_SUBSCRIBE> CreateCHAT_SUBSCRIBE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0) {
  CHAT_SUBSCRIBEBuilder builder_(_fbb);
  builder_.add_channel(channel);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_SUBSCRIBE> CreateCHAT_SUBSCRIBEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr) {
  return OVERLORD::RTS::C2S::CreateCHAT_SUBSCRIBE(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0);
}

flatbuffers::Offset<CHAT_SUBSCRIBE> CreateCHAT_SUBSCRIBE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_CHANNEL_MOVET : public flatbuffers::NativeTable {
  typedef CHAT_CHANNEL_MOVE TableType;
  std::string channel;
  CHAT_CHANNEL_MOVET() {
  }
};

struct CHAT_CHANNEL_MOVE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_CHANNEL_MOVET NativeTableType;
  enum {
    VT_CHANNEL = 4
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           verifier.EndTable();
  }
  CHAT_CHANNEL_MOVET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_CHANNEL_MOVET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_CHANNEL_MOVE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_CHANNEL_MOVEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_CHANNEL_MOVE::VT_CHANNEL, channel);
  }
  explicit CHAT_CHANNEL_MOVEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_CHANNEL_MOVEBuilder &operator=(const CHAT_CHANNEL_MOVEBuilder &);
  flatbuffers::Offset<CHAT_CHANNEL_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_CHANNEL_MOVE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_CHANNEL_MOVE> CreateCHAT_CHANNEL_MOVE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0) {
  CHAT_CHANNEL_MOVEBuilder builder_(_fbb);
  builder_.add_channel(channel);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_CHANNEL_MOVE> CreateCHAT_CHANNEL_MOVEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr) {
  return OVERLORD::RTS::C2S::CreateCHAT_CHANNEL_MOVE(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0);
}

flatbuffers::Offset<CHAT_CHANNEL_MOVE> CreateCHAT_CHANNEL_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_MESSAGET : public flatbuffers::NativeTable {
  typedef CHAT_MESSAGE TableType;
  std::string channel;
  uint8_t chattype;
  int32_t kId;
  std::string nick;
  std::string message;
  std::string data;
  CHAT_MESSAGET()
      : chattype(0),
        kId(0) {
  }
};

struct CHAT_MESSAGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_MESSAGET NativeTableType;
  enum {
    VT_CHANNEL = 4,
    VT_CHATTYPE = 6,
    VT_KID = 8,
    VT_NICK = 10,
    VT_MESSAGE = 12,
    VT_DATA = 14
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  uint8_t chattype() const {
    return GetField<uint8_t>(VT_CHATTYPE, 0);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyField<uint8_t>(verifier, VT_CHATTYPE) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           verifier.EndTable();
  }
  CHAT_MESSAGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_MESSAGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_MESSAGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_MESSAGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_CHANNEL, channel);
  }
  void add_chattype(uint8_t chattype) {
    fbb_.AddElement<uint8_t>(CHAT_MESSAGE::VT_CHATTYPE, chattype, 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(CHAT_MESSAGE::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_NICK, nick);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_DATA, data);
  }
  explicit CHAT_MESSAGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_MESSAGEBuilder &operator=(const CHAT_MESSAGEBuilder &);
  flatbuffers::Offset<CHAT_MESSAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_MESSAGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    uint8_t chattype = 0,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  CHAT_MESSAGEBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_channel(channel);
  builder_.add_chattype(chattype);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    uint8_t chattype = 0,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *message = nullptr,
    const char *data = nullptr) {
  return OVERLORD::RTS::C2S::CreateCHAT_MESSAGE(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0,
      chattype,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      message ? _fbb.CreateString(message) : 0,
      data ? _fbb.CreateString(data) : 0);
}

flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_MATCHT : public flatbuffers::NativeTable {
  typedef REQ_MATCH TableType;
  int32_t modType;
  std::string modId;
  bool bCreate;
  bool bPublic;
  REQ_MATCHT()
      : modType(0),
        bCreate(false),
        bPublic(false) {
  }
};

struct REQ_MATCH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_MATCHT NativeTableType;
  enum {
    VT_MODTYPE = 4,
    VT_MODID = 6,
    VT_BCREATE = 8,
    VT_BPUBLIC = 10
  };
  int32_t modType() const {
    return GetField<int32_t>(VT_MODTYPE, 0);
  }
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  bool bCreate() const {
    return GetField<uint8_t>(VT_BCREATE, 0) != 0;
  }
  bool bPublic() const {
    return GetField<uint8_t>(VT_BPUBLIC, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODTYPE) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyField<uint8_t>(verifier, VT_BCREATE) &&
           VerifyField<uint8_t>(verifier, VT_BPUBLIC) &&
           verifier.EndTable();
  }
  REQ_MATCHT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_MATCHT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_MATCH> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCHT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_MATCHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modType(int32_t modType) {
    fbb_.AddElement<int32_t>(REQ_MATCH::VT_MODTYPE, modType, 0);
  }
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(REQ_MATCH::VT_MODID, modId);
  }
  void add_bCreate(bool bCreate) {
    fbb_.AddElement<uint8_t>(REQ_MATCH::VT_BCREATE, static_cast<uint8_t>(bCreate), 0);
  }
  void add_bPublic(bool bPublic) {
    fbb_.AddElement<uint8_t>(REQ_MATCH::VT_BPUBLIC, static_cast<uint8_t>(bPublic), 0);
  }
  explicit REQ_MATCHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_MATCHBuilder &operator=(const REQ_MATCHBuilder &);
  flatbuffers::Offset<REQ_MATCH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_MATCH>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_MATCH> CreateREQ_MATCH(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    bool bCreate = false,
    bool bPublic = false) {
  REQ_MATCHBuilder builder_(_fbb);
  builder_.add_modId(modId);
  builder_.add_modType(modType);
  builder_.add_bPublic(bPublic);
  builder_.add_bCreate(bCreate);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_MATCH> CreateREQ_MATCHDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    const char *modId = nullptr,
    bool bCreate = false,
    bool bPublic = false) {
  return OVERLORD::RTS::C2S::CreateREQ_MATCH(
      _fbb,
      modType,
      modId ? _fbb.CreateString(modId) : 0,
      bCreate,
      bPublic);
}

flatbuffers::Offset<REQ_MATCH> CreateREQ_MATCH(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCHT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_MATCH_JOINT : public flatbuffers::NativeTable {
  typedef REQ_MATCH_JOIN TableType;
  int32_t modType;
  std::string modId;
  int32_t partyNo;
  std::string secret;
  REQ_MATCH_JOINT()
      : modType(0),
        partyNo(0) {
  }
};

struct REQ_MATCH_JOIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_MATCH_JOINT NativeTableType;
  enum {
    VT_MODTYPE = 4,
    VT_MODID = 6,
    VT_PARTYNO = 8,
    VT_SECRET = 10
  };
  int32_t modType() const {
    return GetField<int32_t>(VT_MODTYPE, 0);
  }
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  const flatbuffers::String *secret() const {
    return GetPointer<const flatbuffers::String *>(VT_SECRET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODTYPE) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           VerifyOffset(verifier, VT_SECRET) &&
           verifier.Verify(secret()) &&
           verifier.EndTable();
  }
  REQ_MATCH_JOINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_MATCH_JOINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_MATCH_JOIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_MATCH_JOINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modType(int32_t modType) {
    fbb_.AddElement<int32_t>(REQ_MATCH_JOIN::VT_MODTYPE, modType, 0);
  }
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(REQ_MATCH_JOIN::VT_MODID, modId);
  }
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(REQ_MATCH_JOIN::VT_PARTYNO, partyNo, 0);
  }
  void add_secret(flatbuffers::Offset<flatbuffers::String> secret) {
    fbb_.AddOffset(REQ_MATCH_JOIN::VT_SECRET, secret);
  }
  explicit REQ_MATCH_JOINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_MATCH_JOINBuilder &operator=(const REQ_MATCH_JOINBuilder &);
  flatbuffers::Offset<REQ_MATCH_JOIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_MATCH_JOIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_MATCH_JOIN> CreateREQ_MATCH_JOIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    int32_t partyNo = 0,
    flatbuffers::Offset<flatbuffers::String> secret = 0) {
  REQ_MATCH_JOINBuilder builder_(_fbb);
  builder_.add_secret(secret);
  builder_.add_partyNo(partyNo);
  builder_.add_modId(modId);
  builder_.add_modType(modType);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_MATCH_JOIN> CreateREQ_MATCH_JOINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    const char *modId = nullptr,
    int32_t partyNo = 0,
    const char *secret = nullptr) {
  return OVERLORD::RTS::C2S::CreateREQ_MATCH_JOIN(
      _fbb,
      modType,
      modId ? _fbb.CreateString(modId) : 0,
      partyNo,
      secret ? _fbb.CreateString(secret) : 0);
}

flatbuffers::Offset<REQ_MATCH_JOIN> CreateREQ_MATCH_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_MATCH_CANCELT : public flatbuffers::NativeTable {
  typedef REQ_MATCH_CANCEL TableType;
  REQ_MATCH_CANCELT() {
  }
};

struct REQ_MATCH_CANCEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_MATCH_CANCELT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_MATCH_CANCELT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_MATCH_CANCELT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_MATCH_CANCEL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_CANCELT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_MATCH_CANCELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_MATCH_CANCELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_MATCH_CANCELBuilder &operator=(const REQ_MATCH_CANCELBuilder &);
  flatbuffers::Offset<REQ_MATCH_CANCEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_MATCH_CANCEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_MATCH_CANCEL> CreateREQ_MATCH_CANCEL(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_MATCH_CANCELBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_MATCH_CANCEL> CreateREQ_MATCH_CANCEL(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_CANCELT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_PARTY_UI_READYT : public flatbuffers::NativeTable {
  typedef REQ_PARTY_UI_READY TableType;
  int32_t partyNo;
  REQ_PARTY_UI_READYT()
      : partyNo(0) {
  }
};

struct REQ_PARTY_UI_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_PARTY_UI_READYT NativeTableType;
  enum {
    VT_PARTYNO = 4
  };
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           verifier.EndTable();
  }
  REQ_PARTY_UI_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_PARTY_UI_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_PARTY_UI_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UI_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_PARTY_UI_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(REQ_PARTY_UI_READY::VT_PARTYNO, partyNo, 0);
  }
  explicit REQ_PARTY_UI_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_PARTY_UI_READYBuilder &operator=(const REQ_PARTY_UI_READYBuilder &);
  flatbuffers::Offset<REQ_PARTY_UI_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_PARTY_UI_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_PARTY_UI_READY> CreateREQ_PARTY_UI_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t partyNo = 0) {
  REQ_PARTY_UI_READYBuilder builder_(_fbb);
  builder_.add_partyNo(partyNo);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_PARTY_UI_READY> CreateREQ_PARTY_UI_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UI_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_PARTY_UPDATE_PUBLICT : public flatbuffers::NativeTable {
  typedef REQ_PARTY_UPDATE_PUBLIC TableType;
  int32_t partyNo;
  bool bPublic;
  REQ_PARTY_UPDATE_PUBLICT()
      : partyNo(0),
        bPublic(false) {
  }
};

struct REQ_PARTY_UPDATE_PUBLIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_PARTY_UPDATE_PUBLICT NativeTableType;
  enum {
    VT_PARTYNO = 4,
    VT_BPUBLIC = 6
  };
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  bool bPublic() const {
    return GetField<uint8_t>(VT_BPUBLIC, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           VerifyField<uint8_t>(verifier, VT_BPUBLIC) &&
           verifier.EndTable();
  }
  REQ_PARTY_UPDATE_PUBLICT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UPDATE_PUBLICT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_PARTY_UPDATE_PUBLICBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(REQ_PARTY_UPDATE_PUBLIC::VT_PARTYNO, partyNo, 0);
  }
  void add_bPublic(bool bPublic) {
    fbb_.AddElement<uint8_t>(REQ_PARTY_UPDATE_PUBLIC::VT_BPUBLIC, static_cast<uint8_t>(bPublic), 0);
  }
  explicit REQ_PARTY_UPDATE_PUBLICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_PARTY_UPDATE_PUBLICBuilder &operator=(const REQ_PARTY_UPDATE_PUBLICBuilder &);
  flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> CreateREQ_PARTY_UPDATE_PUBLIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t partyNo = 0,
    bool bPublic = false) {
  REQ_PARTY_UPDATE_PUBLICBuilder builder_(_fbb);
  builder_.add_partyNo(partyNo);
  builder_.add_bPublic(bPublic);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> CreateREQ_PARTY_UPDATE_PUBLIC(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_DECK_SELECTT : public flatbuffers::NativeTable {
  typedef REQ_DECK_SELECT TableType;
  uint8_t slot;
  uint8_t crewNo;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  REQ_DECK_SELECTT()
      : slot(0),
        crewNo(0),
        level(1) {
  }
};

struct REQ_DECK_SELECT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_DECK_SELECTT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_CREWNO = 6,
    VT_HEROUD = 8,
    VT_HEROID = 10,
    VT_LEVEL = 12
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  uint8_t crewNo() const {
    return GetField<uint8_t>(VT_CREWNO, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_CREWNO) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  REQ_DECK_SELECTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_DECK_SELECT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_DECK_SELECTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(REQ_DECK_SELECT::VT_SLOT, slot, 0);
  }
  void add_crewNo(uint8_t crewNo) {
    fbb_.AddElement<uint8_t>(REQ_DECK_SELECT::VT_CREWNO, crewNo, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(REQ_DECK_SELECT::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(REQ_DECK_SELECT::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(REQ_DECK_SELECT::VT_LEVEL, level, 1);
  }
  explicit REQ_DECK_SELECTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_DECK_SELECTBuilder &operator=(const REQ_DECK_SELECTBuilder &);
  flatbuffers::Offset<REQ_DECK_SELECT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_DECK_SELECT>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_DECK_SELECT> CreateREQ_DECK_SELECT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    uint8_t crewNo = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1) {
  REQ_DECK_SELECTBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  builder_.add_crewNo(crewNo);
  builder_.add_slot(slot);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_DECK_SELECT> CreateREQ_DECK_SELECTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    uint8_t crewNo = 0,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1) {
  return OVERLORD::RTS::C2S::CreateREQ_DECK_SELECT(
      _fbb,
      slot,
      crewNo,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level);
}

flatbuffers::Offset<REQ_DECK_SELECT> CreateREQ_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_DECK_SELECT_READYT : public flatbuffers::NativeTable {
  typedef REQ_DECK_SELECT_READY TableType;
  uint8_t slot;
  bool ready;
  REQ_DECK_SELECT_READYT()
      : slot(1),
        ready(false) {
  }
};

struct REQ_DECK_SELECT_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_DECK_SELECT_READYT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_READY = 6
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 1);
  }
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_READY) &&
           verifier.EndTable();
  }
  REQ_DECK_SELECT_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_DECK_SELECT_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_DECK_SELECT_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(REQ_DECK_SELECT_READY::VT_SLOT, slot, 1);
  }
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(REQ_DECK_SELECT_READY::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  explicit REQ_DECK_SELECT_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_DECK_SELECT_READYBuilder &operator=(const REQ_DECK_SELECT_READYBuilder &);
  flatbuffers::Offset<REQ_DECK_SELECT_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_DECK_SELECT_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_DECK_SELECT_READY> CreateREQ_DECK_SELECT_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 1,
    bool ready = false) {
  REQ_DECK_SELECT_READYBuilder builder_(_fbb);
  builder_.add_ready(ready);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_DECK_SELECT_READY> CreateREQ_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_PARTY_GOT : public flatbuffers::NativeTable {
  typedef REQ_PARTY_GO TableType;
  int32_t partyNo;
  REQ_PARTY_GOT()
      : partyNo(0) {
  }
};

struct REQ_PARTY_GO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_PARTY_GOT NativeTableType;
  enum {
    VT_PARTYNO = 4
  };
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           verifier.EndTable();
  }
  REQ_PARTY_GOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_PARTY_GOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_PARTY_GO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_PARTY_GOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(REQ_PARTY_GO::VT_PARTYNO, partyNo, 0);
  }
  explicit REQ_PARTY_GOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_PARTY_GOBuilder &operator=(const REQ_PARTY_GOBuilder &);
  flatbuffers::Offset<REQ_PARTY_GO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_PARTY_GO>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_PARTY_GO> CreateREQ_PARTY_GO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t partyNo = 0) {
  REQ_PARTY_GOBuilder builder_(_fbb);
  builder_.add_partyNo(partyNo);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_PARTY_GO> CreateREQ_PARTY_GO(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_PLAY_READYT : public flatbuffers::NativeTable {
  typedef REQ_PLAY_READY TableType;
  REQ_PLAY_READYT() {
  }
};

struct REQ_PLAY_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_PLAY_READYT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_PLAY_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_PLAY_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_PLAY_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PLAY_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_PLAY_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_PLAY_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_PLAY_READYBuilder &operator=(const REQ_PLAY_READYBuilder &);
  flatbuffers::Offset<REQ_PLAY_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_PLAY_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_PLAY_READY> CreateREQ_PLAY_READY(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_PLAY_READYBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_PLAY_READY> CreateREQ_PLAY_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PLAY_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CINEMATIC_DONET : public flatbuffers::NativeTable {
  typedef ACK_CINEMATIC_DONE TableType;
  uint8_t sequence;
  ACK_CINEMATIC_DONET()
      : sequence(0) {
  }
};

struct ACK_CINEMATIC_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CINEMATIC_DONET NativeTableType;
  enum {
    VT_SEQUENCE = 4
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
  ACK_CINEMATIC_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CINEMATIC_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CINEMATIC_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CINEMATIC_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(ACK_CINEMATIC_DONE::VT_SEQUENCE, sequence, 0);
  }
  explicit ACK_CINEMATIC_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CINEMATIC_DONEBuilder &operator=(const ACK_CINEMATIC_DONEBuilder &);
  flatbuffers::Offset<ACK_CINEMATIC_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CINEMATIC_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0) {
  ACK_CINEMATIC_DONEBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_STEP_AND_GOT : public flatbuffers::NativeTable {
  typedef ACK_STEP_AND_GO TableType;
  uint8_t sequence;
  ACK_STEP_AND_GOT()
      : sequence(0) {
  }
};

struct ACK_STEP_AND_GO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_STEP_AND_GOT NativeTableType;
  enum {
    VT_SEQUENCE = 4
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
  ACK_STEP_AND_GOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_STEP_AND_GOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_STEP_AND_GO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_AND_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_STEP_AND_GOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(ACK_STEP_AND_GO::VT_SEQUENCE, sequence, 0);
  }
  explicit ACK_STEP_AND_GOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_STEP_AND_GOBuilder &operator=(const ACK_STEP_AND_GOBuilder &);
  flatbuffers::Offset<ACK_STEP_AND_GO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_STEP_AND_GO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_STEP_AND_GO> CreateACK_STEP_AND_GO(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0) {
  ACK_STEP_AND_GOBuilder builder_(_fbb);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_STEP_AND_GO> CreateACK_STEP_AND_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_AND_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_CS_PARTY_UI_READYT : public flatbuffers::NativeTable {
  typedef REQ_CS_PARTY_UI_READY TableType;
  REQ_CS_PARTY_UI_READYT() {
  }
};

struct REQ_CS_PARTY_UI_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_CS_PARTY_UI_READYT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_CS_PARTY_UI_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_CS_PARTY_UI_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_CS_PARTY_UI_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_PARTY_UI_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_CS_PARTY_UI_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_CS_PARTY_UI_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_CS_PARTY_UI_READYBuilder &operator=(const REQ_CS_PARTY_UI_READYBuilder &);
  flatbuffers::Offset<REQ_CS_PARTY_UI_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_CS_PARTY_UI_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_CS_PARTY_UI_READY> CreateREQ_CS_PARTY_UI_READY(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_CS_PARTY_UI_READYBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_CS_PARTY_UI_READY> CreateREQ_CS_PARTY_UI_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_PARTY_UI_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_CS_DECK_SELECTT : public flatbuffers::NativeTable {
  typedef REQ_CS_DECK_SELECT TableType;
  uint8_t crewNo;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  REQ_CS_DECK_SELECTT()
      : crewNo(0),
        level(1) {
  }
};

struct REQ_CS_DECK_SELECT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_CS_DECK_SELECTT NativeTableType;
  enum {
    VT_CREWNO = 4,
    VT_HEROUD = 6,
    VT_HEROID = 8,
    VT_LEVEL = 10
  };
  uint8_t crewNo() const {
    return GetField<uint8_t>(VT_CREWNO, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CREWNO) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  REQ_CS_DECK_SELECTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_CS_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_CS_DECK_SELECT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_CS_DECK_SELECTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_crewNo(uint8_t crewNo) {
    fbb_.AddElement<uint8_t>(REQ_CS_DECK_SELECT::VT_CREWNO, crewNo, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(REQ_CS_DECK_SELECT::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(REQ_CS_DECK_SELECT::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(REQ_CS_DECK_SELECT::VT_LEVEL, level, 1);
  }
  explicit REQ_CS_DECK_SELECTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_CS_DECK_SELECTBuilder &operator=(const REQ_CS_DECK_SELECTBuilder &);
  flatbuffers::Offset<REQ_CS_DECK_SELECT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_CS_DECK_SELECT>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_CS_DECK_SELECT> CreateREQ_CS_DECK_SELECT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t crewNo = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1) {
  REQ_CS_DECK_SELECTBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  builder_.add_crewNo(crewNo);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_CS_DECK_SELECT> CreateREQ_CS_DECK_SELECTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t crewNo = 0,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1) {
  return OVERLORD::RTS::C2S::CreateREQ_CS_DECK_SELECT(
      _fbb,
      crewNo,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level);
}

flatbuffers::Offset<REQ_CS_DECK_SELECT> CreateREQ_CS_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_CS_DECK_SELECT_READYT : public flatbuffers::NativeTable {
  typedef REQ_CS_DECK_SELECT_READY TableType;
  bool ready;
  REQ_CS_DECK_SELECT_READYT()
      : ready(false) {
  }
};

struct REQ_CS_DECK_SELECT_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_CS_DECK_SELECT_READYT NativeTableType;
  enum {
    VT_READY = 4
  };
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_READY) &&
           verifier.EndTable();
  }
  REQ_CS_DECK_SELECT_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_CS_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_CS_DECK_SELECT_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(REQ_CS_DECK_SELECT_READY::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  explicit REQ_CS_DECK_SELECT_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_CS_DECK_SELECT_READYBuilder &operator=(const REQ_CS_DECK_SELECT_READYBuilder &);
  flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_CS_DECK_SELECT_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> CreateREQ_CS_DECK_SELECT_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool ready = false) {
  REQ_CS_DECK_SELECT_READYBuilder builder_(_fbb);
  builder_.add_ready(ready);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> CreateREQ_CS_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_CREATET : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_CREATE TableType;
  uint8_t category;
  std::string actorId;
  uint8_t role;
  std::vector<std::string> option;
  REQ_BT_ACTOR_CREATET()
      : category(0),
        role(0) {
  }
};

struct REQ_BT_ACTOR_CREATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_CREATET NativeTableType;
  enum {
    VT_CATEGORY = 4,
    VT_ACTORID = 6,
    VT_ROLE = 8,
    VT_OPTION = 10
  };
  uint8_t category() const {
    return GetField<uint8_t>(VT_CATEGORY, 0);
  }
  const flatbuffers::String *actorId() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTORID);
  }
  uint8_t role() const {
    return GetField<uint8_t>(VT_ROLE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *option() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OPTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CATEGORY) &&
           VerifyOffset(verifier, VT_ACTORID) &&
           verifier.Verify(actorId()) &&
           VerifyField<uint8_t>(verifier, VT_ROLE) &&
           VerifyOffset(verifier, VT_OPTION) &&
           verifier.Verify(option()) &&
           verifier.VerifyVectorOfStrings(option()) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_CREATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_CREATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_CREATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_CREATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_category(uint8_t category) {
    fbb_.AddElement<uint8_t>(REQ_BT_ACTOR_CREATE::VT_CATEGORY, category, 0);
  }
  void add_actorId(flatbuffers::Offset<flatbuffers::String> actorId) {
    fbb_.AddOffset(REQ_BT_ACTOR_CREATE::VT_ACTORID, actorId);
  }
  void add_role(uint8_t role) {
    fbb_.AddElement<uint8_t>(REQ_BT_ACTOR_CREATE::VT_ROLE, role, 0);
  }
  void add_option(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> option) {
    fbb_.AddOffset(REQ_BT_ACTOR_CREATE::VT_OPTION, option);
  }
  explicit REQ_BT_ACTOR_CREATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_CREATEBuilder &operator=(const REQ_BT_ACTOR_CREATEBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_CREATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_CREATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_CREATE> CreateREQ_BT_ACTOR_CREATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t category = 0,
    flatbuffers::Offset<flatbuffers::String> actorId = 0,
    uint8_t role = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> option = 0) {
  REQ_BT_ACTOR_CREATEBuilder builder_(_fbb);
  builder_.add_option(option);
  builder_.add_actorId(actorId);
  builder_.add_role(role);
  builder_.add_category(category);
  return builder_.Finish();
}

inline flatbuffers::Offset<REQ_BT_ACTOR_CREATE> CreateREQ_BT_ACTOR_CREATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t category = 0,
    const char *actorId = nullptr,
    uint8_t role = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *option = nullptr) {
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_CREATE(
      _fbb,
      category,
      actorId ? _fbb.CreateString(actorId) : 0,
      role,
      option ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*option) : 0);
}

flatbuffers::Offset<REQ_BT_ACTOR_CREATE> CreateREQ_BT_ACTOR_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ENTERT : public flatbuffers::NativeTable {
  typedef REQ_BT_ENTER TableType;
  REQ_BT_ENTERT() {
  }
};

struct REQ_BT_ENTER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ENTERT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_BT_ENTERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ENTERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ENTER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ENTERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ENTERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_BT_ENTERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ENTERBuilder &operator=(const REQ_BT_ENTERBuilder &);
  flatbuffers::Offset<REQ_BT_ENTER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ENTER>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ENTER> CreateREQ_BT_ENTER(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_BT_ENTERBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ENTER> CreateREQ_BT_ENTER(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ENTERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_EXITT : public flatbuffers::NativeTable {
  typedef REQ_BT_EXIT TableType;
  REQ_BT_EXITT() {
  }
};

struct REQ_BT_EXIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_EXITT NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_BT_EXITT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_EXITT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_EXIT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_EXITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_BT_EXITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_EXITBuilder &operator=(const REQ_BT_EXITBuilder &);
  flatbuffers::Offset<REQ_BT_EXIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_EXIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_EXIT> CreateREQ_BT_EXIT(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_BT_EXITBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_EXIT> CreateREQ_BT_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_SPAWNT : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_SPAWN TableType;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  REQ_BT_ACTOR_SPAWNT()
      : actorUK(0) {
  }
};

struct REQ_BT_ACTOR_SPAWN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_SPAWNT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_LOCATION = 6,
    VT_DIRECTION = 8
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_SPAWNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_SPAWNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_SPAWNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ACTOR_SPAWN::VT_ACTORUK, actorUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(REQ_BT_ACTOR_SPAWN::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(REQ_BT_ACTOR_SPAWN::VT_DIRECTION, direction);
  }
  explicit REQ_BT_ACTOR_SPAWNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_SPAWNBuilder &operator=(const REQ_BT_ACTOR_SPAWNBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_SPAWN>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> CreateREQ_BT_ACTOR_SPAWN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  REQ_BT_ACTOR_SPAWNBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> CreateREQ_BT_ACTOR_SPAWN(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_DROP_CREWT : public flatbuffers::NativeTable {
  typedef REQ_BT_DROP_CREW TableType;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  REQ_BT_DROP_CREWT()
      : actorUK(0) {
  }
};

struct REQ_BT_DROP_CREW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_DROP_CREWT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_LOCATION = 6,
    VT_DIRECTION = 8
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  REQ_BT_DROP_CREWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_DROP_CREWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_DROP_CREW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DROP_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_DROP_CREWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_DROP_CREW::VT_ACTORUK, actorUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(REQ_BT_DROP_CREW::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(REQ_BT_DROP_CREW::VT_DIRECTION, direction);
  }
  explicit REQ_BT_DROP_CREWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_DROP_CREWBuilder &operator=(const REQ_BT_DROP_CREWBuilder &);
  flatbuffers::Offset<REQ_BT_DROP_CREW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_DROP_CREW>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_DROP_CREW> CreateREQ_BT_DROP_CREW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  REQ_BT_DROP_CREWBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_DROP_CREW> CreateREQ_BT_DROP_CREW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DROP_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_CHANGE_CREWT : public flatbuffers::NativeTable {
  typedef REQ_BT_CHANGE_CREW TableType;
  uint16_t actorUK;
  uint16_t targetUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  REQ_BT_CHANGE_CREWT()
      : actorUK(0),
        targetUK(0) {
  }
};

struct REQ_BT_CHANGE_CREW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_CHANGE_CREWT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_TARGETUK = 6,
    VT_LOCATION = 8,
    VT_DIRECTION = 10
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  REQ_BT_CHANGE_CREWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_CHANGE_CREWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_CHANGE_CREW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_CHANGE_CREWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_CHANGE_CREW::VT_ACTORUK, actorUK, 0);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_CHANGE_CREW::VT_TARGETUK, targetUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(REQ_BT_CHANGE_CREW::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(REQ_BT_CHANGE_CREW::VT_DIRECTION, direction);
  }
  explicit REQ_BT_CHANGE_CREWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_CHANGE_CREWBuilder &operator=(const REQ_BT_CHANGE_CREWBuilder &);
  flatbuffers::Offset<REQ_BT_CHANGE_CREW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_CHANGE_CREW>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_CHANGE_CREW> CreateREQ_BT_CHANGE_CREW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint16_t targetUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  REQ_BT_CHANGE_CREWBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_targetUK(targetUK);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_CHANGE_CREW> CreateREQ_BT_CHANGE_CREW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_CHANGE_SPIRITT : public flatbuffers::NativeTable {
  typedef REQ_BT_CHANGE_SPIRIT TableType;
  uint16_t actorUK;
  uint16_t spiritIndex;
  REQ_BT_CHANGE_SPIRITT()
      : actorUK(0),
        spiritIndex(0) {
  }
};

struct REQ_BT_CHANGE_SPIRIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_CHANGE_SPIRITT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_SPIRITINDEX = 6
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t spiritIndex() const {
    return GetField<uint16_t>(VT_SPIRITINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_SPIRITINDEX) &&
           verifier.EndTable();
  }
  REQ_BT_CHANGE_SPIRITT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_CHANGE_SPIRITT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_SPIRITT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_CHANGE_SPIRITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_CHANGE_SPIRIT::VT_ACTORUK, actorUK, 0);
  }
  void add_spiritIndex(uint16_t spiritIndex) {
    fbb_.AddElement<uint16_t>(REQ_BT_CHANGE_SPIRIT::VT_SPIRITINDEX, spiritIndex, 0);
  }
  explicit REQ_BT_CHANGE_SPIRITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_CHANGE_SPIRITBuilder &operator=(const REQ_BT_CHANGE_SPIRITBuilder &);
  flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> CreateREQ_BT_CHANGE_SPIRIT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint16_t spiritIndex = 0) {
  REQ_BT_CHANGE_SPIRITBuilder builder_(_fbb);
  builder_.add_spiritIndex(spiritIndex);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> CreateREQ_BT_CHANGE_SPIRIT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_SPIRITT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_MOVET : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_MOVE TableType;
  uint32_t frame;
  uint16_t actorUK;
  bool isStop;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  REQ_BT_ACTOR_MOVET()
      : frame(0),
        actorUK(0),
        isStop(false) {
  }
};

struct REQ_BT_ACTOR_MOVE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_MOVET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ISSTOP = 8,
    VT_LOCATION = 10,
    VT_DIRECTION = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool isStop() const {
    return GetField<uint8_t>(VT_ISSTOP, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_ISSTOP) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_MOVET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_MOVET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_MOVE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_MOVEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(REQ_BT_ACTOR_MOVE::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ACTOR_MOVE::VT_ACTORUK, actorUK, 0);
  }
  void add_isStop(bool isStop) {
    fbb_.AddElement<uint8_t>(REQ_BT_ACTOR_MOVE::VT_ISSTOP, static_cast<uint8_t>(isStop), 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(REQ_BT_ACTOR_MOVE::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(REQ_BT_ACTOR_MOVE::VT_DIRECTION, direction);
  }
  explicit REQ_BT_ACTOR_MOVEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_MOVEBuilder &operator=(const REQ_BT_ACTOR_MOVEBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_MOVE>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_MOVE> CreateREQ_BT_ACTOR_MOVE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    bool isStop = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  REQ_BT_ACTOR_MOVEBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_isStop(isStop);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ACTOR_MOVE> CreateREQ_BT_ACTOR_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ATTACK_NOWT : public flatbuffers::NativeTable {
  typedef REQ_BT_ATTACK_NOW TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> actorLocation;
  uint16_t targetUK;
  bool bAttack;
  uint8_t sequence;
  REQ_BT_ATTACK_NOWT()
      : frame(0),
        actorUK(0),
        targetUK(0),
        bAttack(false),
        sequence(0) {
  }
};

struct REQ_BT_ATTACK_NOW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ATTACK_NOWT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ACTORLOCATION = 8,
    VT_TARGETUK = 10,
    VT_BATTACK = 12,
    VT_SEQUENCE = 14
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *actorLocation() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_ACTORLOCATION);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  bool bAttack() const {
    return GetField<uint8_t>(VT_BATTACK, 0) != 0;
  }
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_ACTORLOCATION) &&
           verifier.VerifyTable(actorLocation()) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyField<uint8_t>(verifier, VT_BATTACK) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           verifier.EndTable();
  }
  REQ_BT_ATTACK_NOWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ATTACK_NOWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ATTACK_NOW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ATTACK_NOWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ATTACK_NOWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(REQ_BT_ATTACK_NOW::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ATTACK_NOW::VT_ACTORUK, actorUK, 0);
  }
  void add_actorLocation(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation) {
    fbb_.AddOffset(REQ_BT_ATTACK_NOW::VT_ACTORLOCATION, actorLocation);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ATTACK_NOW::VT_TARGETUK, targetUK, 0);
  }
  void add_bAttack(bool bAttack) {
    fbb_.AddElement<uint8_t>(REQ_BT_ATTACK_NOW::VT_BATTACK, static_cast<uint8_t>(bAttack), 0);
  }
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(REQ_BT_ATTACK_NOW::VT_SEQUENCE, sequence, 0);
  }
  explicit REQ_BT_ATTACK_NOWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ATTACK_NOWBuilder &operator=(const REQ_BT_ATTACK_NOWBuilder &);
  flatbuffers::Offset<REQ_BT_ATTACK_NOW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ATTACK_NOW>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ATTACK_NOW> CreateREQ_BT_ATTACK_NOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation = 0,
    uint16_t targetUK = 0,
    bool bAttack = false,
    uint8_t sequence = 0) {
  REQ_BT_ATTACK_NOWBuilder builder_(_fbb);
  builder_.add_actorLocation(actorLocation);
  builder_.add_frame(frame);
  builder_.add_targetUK(targetUK);
  builder_.add_actorUK(actorUK);
  builder_.add_sequence(sequence);
  builder_.add_bAttack(bAttack);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ATTACK_NOW> CreateREQ_BT_ATTACK_NOW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ATTACK_NOWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_SKILL_CASTT : public flatbuffers::NativeTable {
  typedef REQ_BT_SKILL_CAST TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> actorLocation;
  uint8_t slot;
  uint16_t targetUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  REQ_BT_SKILL_CASTT()
      : frame(0),
        actorUK(0),
        slot(0),
        targetUK(0) {
  }
};

struct REQ_BT_SKILL_CAST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_SKILL_CASTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ACTORLOCATION = 8,
    VT_SLOT = 10,
    VT_TARGETUK = 12,
    VT_LOCATION = 14,
    VT_DIRECTION = 16
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *actorLocation() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_ACTORLOCATION);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_ACTORLOCATION) &&
           verifier.VerifyTable(actorLocation()) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  REQ_BT_SKILL_CASTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_SKILL_CASTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_SKILL_CAST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_SKILL_CASTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_SKILL_CASTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(REQ_BT_SKILL_CAST::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_SKILL_CAST::VT_ACTORUK, actorUK, 0);
  }
  void add_actorLocation(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation) {
    fbb_.AddOffset(REQ_BT_SKILL_CAST::VT_ACTORLOCATION, actorLocation);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(REQ_BT_SKILL_CAST::VT_SLOT, slot, 0);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_SKILL_CAST::VT_TARGETUK, targetUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(REQ_BT_SKILL_CAST::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(REQ_BT_SKILL_CAST::VT_DIRECTION, direction);
  }
  explicit REQ_BT_SKILL_CASTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_SKILL_CASTBuilder &operator=(const REQ_BT_SKILL_CASTBuilder &);
  flatbuffers::Offset<REQ_BT_SKILL_CAST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_SKILL_CAST>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_SKILL_CAST> CreateREQ_BT_SKILL_CAST(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation = 0,
    uint8_t slot = 0,
    uint16_t targetUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  REQ_BT_SKILL_CASTBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actorLocation(actorLocation);
  builder_.add_frame(frame);
  builder_.add_targetUK(targetUK);
  builder_.add_actorUK(actorUK);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_SKILL_CAST> CreateREQ_BT_SKILL_CAST(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_SKILL_CASTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_TELEPORTT : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_TELEPORT TableType;
  uint16_t actorUK;
  uint8_t portalNo;
  REQ_BT_ACTOR_TELEPORTT()
      : actorUK(0),
        portalNo(0) {
  }
};

struct REQ_BT_ACTOR_TELEPORT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_TELEPORTT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_PORTALNO = 6
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t portalNo() const {
    return GetField<uint8_t>(VT_PORTALNO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_PORTALNO) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_TELEPORTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_TELEPORTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_TELEPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_TELEPORTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ACTOR_TELEPORT::VT_ACTORUK, actorUK, 0);
  }
  void add_portalNo(uint8_t portalNo) {
    fbb_.AddElement<uint8_t>(REQ_BT_ACTOR_TELEPORT::VT_PORTALNO, portalNo, 0);
  }
  explicit REQ_BT_ACTOR_TELEPORTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_TELEPORTBuilder &operator=(const REQ_BT_ACTOR_TELEPORTBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> CreateREQ_BT_ACTOR_TELEPORT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint8_t portalNo = 0) {
  REQ_BT_ACTOR_TELEPORTBuilder builder_(_fbb);
  builder_.add_actorUK(actorUK);
  builder_.add_portalNo(portalNo);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> CreateREQ_BT_ACTOR_TELEPORT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_TELEPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_FORMATIONT : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_FORMATION TableType;
  uint16_t actorUK;
  REQ_BT_ACTOR_FORMATIONT()
      : actorUK(0) {
  }
};

struct REQ_BT_ACTOR_FORMATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_FORMATIONT NativeTableType;
  enum {
    VT_ACTORUK = 4
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_FORMATIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_FORMATIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_FORMATIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_FORMATIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(REQ_BT_ACTOR_FORMATION::VT_ACTORUK, actorUK, 0);
  }
  explicit REQ_BT_ACTOR_FORMATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_FORMATIONBuilder &operator=(const REQ_BT_ACTOR_FORMATIONBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_FORMATION>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> CreateREQ_BT_ACTOR_FORMATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0) {
  REQ_BT_ACTOR_FORMATIONBuilder builder_(_fbb);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> CreateREQ_BT_ACTOR_FORMATION(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_FORMATIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_DICET : public flatbuffers::NativeTable {
  typedef REQ_BT_DICE TableType;
  bool participate;
  REQ_BT_DICET()
      : participate(false) {
  }
};

struct REQ_BT_DICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_DICET NativeTableType;
  enum {
    VT_PARTICIPATE = 4
  };
  bool participate() const {
    return GetField<uint8_t>(VT_PARTICIPATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARTICIPATE) &&
           verifier.EndTable();
  }
  REQ_BT_DICET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_DICET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_DICE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DICET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_DICEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_participate(bool participate) {
    fbb_.AddElement<uint8_t>(REQ_BT_DICE::VT_PARTICIPATE, static_cast<uint8_t>(participate), 0);
  }
  explicit REQ_BT_DICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_DICEBuilder &operator=(const REQ_BT_DICEBuilder &);
  flatbuffers::Offset<REQ_BT_DICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_DICE>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_DICE> CreateREQ_BT_DICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool participate = false) {
  REQ_BT_DICEBuilder builder_(_fbb);
  builder_.add_participate(participate);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_DICE> CreateREQ_BT_DICE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DICET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_PLAYER_SCORET : public flatbuffers::NativeTable {
  typedef REQ_BT_PLAYER_SCORE TableType;
  REQ_BT_PLAYER_SCORET() {
  }
};

struct REQ_BT_PLAYER_SCORE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_PLAYER_SCORET NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_BT_PLAYER_SCORET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_PLAYER_SCORE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_PLAYER_SCOREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_BT_PLAYER_SCOREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_PLAYER_SCOREBuilder &operator=(const REQ_BT_PLAYER_SCOREBuilder &);
  flatbuffers::Offset<REQ_BT_PLAYER_SCORE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_PLAYER_SCORE>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_PLAYER_SCORE> CreateREQ_BT_PLAYER_SCORE(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_BT_PLAYER_SCOREBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_PLAYER_SCORE> CreateREQ_BT_PLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_BT_ACTOR_SCORET : public flatbuffers::NativeTable {
  typedef REQ_BT_ACTOR_SCORE TableType;
  REQ_BT_ACTOR_SCORET() {
  }
};

struct REQ_BT_ACTOR_SCORE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_BT_ACTOR_SCORET NativeTableType;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  REQ_BT_ACTOR_SCORET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_BT_ACTOR_SCORET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_BT_ACTOR_SCORE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_BT_ACTOR_SCOREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit REQ_BT_ACTOR_SCOREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_BT_ACTOR_SCOREBuilder &operator=(const REQ_BT_ACTOR_SCOREBuilder &);
  flatbuffers::Offset<REQ_BT_ACTOR_SCORE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_BT_ACTOR_SCORE>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_BT_ACTOR_SCORE> CreateREQ_BT_ACTOR_SCORE(
    flatbuffers::FlatBufferBuilder &_fbb) {
  REQ_BT_ACTOR_SCOREBuilder builder_(_fbb);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_BT_ACTOR_SCORE> CreateREQ_BT_ACTOR_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline REQ_PINGT *REQ_PING::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_PINGT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_PING::UnPackTo(REQ_PINGT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
}

inline flatbuffers::Offset<REQ_PING> REQ_PING::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PINGT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_PING(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_PING> CreateREQ_PING(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PINGT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_PINGT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  return OVERLORD::RTS::C2S::CreateREQ_PING(
      _fbb,
      _frame);
}

inline REQ_AUTHT *REQ_AUTH::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_AUTHT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_AUTH::UnPackTo(REQ_AUTHT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = t(); _o->t = _e; };
}

inline flatbuffers::Offset<REQ_AUTH> REQ_AUTH::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_AUTHT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_AUTH(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_AUTH> CreateREQ_AUTH(flatbuffers::FlatBufferBuilder &_fbb, const REQ_AUTHT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_AUTHT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _t = _o->t;
  return OVERLORD::RTS::C2S::CreateREQ_AUTH(
      _fbb,
      _clientkey,
      _deviceid,
      _t);
}

inline CHAT_SUBSCRIBET *CHAT_SUBSCRIBE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_SUBSCRIBET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_SUBSCRIBE::UnPackTo(CHAT_SUBSCRIBET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
}

inline flatbuffers::Offset<CHAT_SUBSCRIBE> CHAT_SUBSCRIBE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_SUBSCRIBE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_SUBSCRIBE> CreateCHAT_SUBSCRIBE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_SUBSCRIBET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  return OVERLORD::RTS::C2S::CreateCHAT_SUBSCRIBE(
      _fbb,
      _channel);
}

inline CHAT_CHANNEL_MOVET *CHAT_CHANNEL_MOVE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_CHANNEL_MOVET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_CHANNEL_MOVE::UnPackTo(CHAT_CHANNEL_MOVET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
}

inline flatbuffers::Offset<CHAT_CHANNEL_MOVE> CHAT_CHANNEL_MOVE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_CHANNEL_MOVE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_CHANNEL_MOVE> CreateCHAT_CHANNEL_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_CHANNEL_MOVET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  return OVERLORD::RTS::C2S::CreateCHAT_CHANNEL_MOVE(
      _fbb,
      _channel);
}

inline CHAT_MESSAGET *CHAT_MESSAGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_MESSAGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_MESSAGE::UnPackTo(CHAT_MESSAGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = chattype(); _o->chattype = _e; };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = data(); if (_e) _o->data = _e->str(); };
}

inline flatbuffers::Offset<CHAT_MESSAGE> CHAT_MESSAGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_MESSAGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_MESSAGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _chattype = _o->chattype;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  return OVERLORD::RTS::C2S::CreateCHAT_MESSAGE(
      _fbb,
      _channel,
      _chattype,
      _kId,
      _nick,
      _message,
      _data);
}

inline REQ_MATCHT *REQ_MATCH::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_MATCHT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_MATCH::UnPackTo(REQ_MATCHT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modType(); _o->modType = _e; };
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = bCreate(); _o->bCreate = _e; };
  { auto _e = bPublic(); _o->bPublic = _e; };
}

inline flatbuffers::Offset<REQ_MATCH> REQ_MATCH::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCHT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_MATCH(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_MATCH> CreateREQ_MATCH(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCHT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_MATCHT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modType = _o->modType;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _bCreate = _o->bCreate;
  auto _bPublic = _o->bPublic;
  return OVERLORD::RTS::C2S::CreateREQ_MATCH(
      _fbb,
      _modType,
      _modId,
      _bCreate,
      _bPublic);
}

inline REQ_MATCH_JOINT *REQ_MATCH_JOIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_MATCH_JOINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_MATCH_JOIN::UnPackTo(REQ_MATCH_JOINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modType(); _o->modType = _e; };
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = partyNo(); _o->partyNo = _e; };
  { auto _e = secret(); if (_e) _o->secret = _e->str(); };
}

inline flatbuffers::Offset<REQ_MATCH_JOIN> REQ_MATCH_JOIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_MATCH_JOIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_MATCH_JOIN> CreateREQ_MATCH_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_MATCH_JOINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modType = _o->modType;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _partyNo = _o->partyNo;
  auto _secret = _o->secret.empty() ? 0 : _fbb.CreateString(_o->secret);
  return OVERLORD::RTS::C2S::CreateREQ_MATCH_JOIN(
      _fbb,
      _modType,
      _modId,
      _partyNo,
      _secret);
}

inline REQ_MATCH_CANCELT *REQ_MATCH_CANCEL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_MATCH_CANCELT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_MATCH_CANCEL::UnPackTo(REQ_MATCH_CANCELT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_MATCH_CANCEL> REQ_MATCH_CANCEL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_CANCELT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_MATCH_CANCEL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_MATCH_CANCEL> CreateREQ_MATCH_CANCEL(flatbuffers::FlatBufferBuilder &_fbb, const REQ_MATCH_CANCELT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_MATCH_CANCELT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_MATCH_CANCEL(
      _fbb);
}

inline REQ_PARTY_UI_READYT *REQ_PARTY_UI_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_PARTY_UI_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_PARTY_UI_READY::UnPackTo(REQ_PARTY_UI_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = partyNo(); _o->partyNo = _e; };
}

inline flatbuffers::Offset<REQ_PARTY_UI_READY> REQ_PARTY_UI_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UI_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_PARTY_UI_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_PARTY_UI_READY> CreateREQ_PARTY_UI_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UI_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_PARTY_UI_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _partyNo = _o->partyNo;
  return OVERLORD::RTS::C2S::CreateREQ_PARTY_UI_READY(
      _fbb,
      _partyNo);
}

inline REQ_PARTY_UPDATE_PUBLICT *REQ_PARTY_UPDATE_PUBLIC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_PARTY_UPDATE_PUBLICT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_PARTY_UPDATE_PUBLIC::UnPackTo(REQ_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = partyNo(); _o->partyNo = _e; };
  { auto _e = bPublic(); _o->bPublic = _e; };
}

inline flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> REQ_PARTY_UPDATE_PUBLIC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UPDATE_PUBLICT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_PARTY_UPDATE_PUBLIC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_PARTY_UPDATE_PUBLIC> CreateREQ_PARTY_UPDATE_PUBLIC(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_PARTY_UPDATE_PUBLICT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _partyNo = _o->partyNo;
  auto _bPublic = _o->bPublic;
  return OVERLORD::RTS::C2S::CreateREQ_PARTY_UPDATE_PUBLIC(
      _fbb,
      _partyNo,
      _bPublic);
}

inline REQ_DECK_SELECTT *REQ_DECK_SELECT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_DECK_SELECTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_DECK_SELECT::UnPackTo(REQ_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = crewNo(); _o->crewNo = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<REQ_DECK_SELECT> REQ_DECK_SELECT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_DECK_SELECT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_DECK_SELECT> CreateREQ_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_DECK_SELECTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _crewNo = _o->crewNo;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  return OVERLORD::RTS::C2S::CreateREQ_DECK_SELECT(
      _fbb,
      _slot,
      _crewNo,
      _heroUD,
      _heroId,
      _level);
}

inline REQ_DECK_SELECT_READYT *REQ_DECK_SELECT_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_DECK_SELECT_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_DECK_SELECT_READY::UnPackTo(REQ_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = ready(); _o->ready = _e; };
}

inline flatbuffers::Offset<REQ_DECK_SELECT_READY> REQ_DECK_SELECT_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_DECK_SELECT_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_DECK_SELECT_READY> CreateREQ_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_DECK_SELECT_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _ready = _o->ready;
  return OVERLORD::RTS::C2S::CreateREQ_DECK_SELECT_READY(
      _fbb,
      _slot,
      _ready);
}

inline REQ_PARTY_GOT *REQ_PARTY_GO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_PARTY_GOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_PARTY_GO::UnPackTo(REQ_PARTY_GOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = partyNo(); _o->partyNo = _e; };
}

inline flatbuffers::Offset<REQ_PARTY_GO> REQ_PARTY_GO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_PARTY_GO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_PARTY_GO> CreateREQ_PARTY_GO(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PARTY_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_PARTY_GOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _partyNo = _o->partyNo;
  return OVERLORD::RTS::C2S::CreateREQ_PARTY_GO(
      _fbb,
      _partyNo);
}

inline REQ_PLAY_READYT *REQ_PLAY_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_PLAY_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_PLAY_READY::UnPackTo(REQ_PLAY_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_PLAY_READY> REQ_PLAY_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PLAY_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_PLAY_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_PLAY_READY> CreateREQ_PLAY_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_PLAY_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_PLAY_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_PLAY_READY(
      _fbb);
}

inline ACK_CINEMATIC_DONET *ACK_CINEMATIC_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CINEMATIC_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CINEMATIC_DONE::UnPackTo(ACK_CINEMATIC_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
}

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> ACK_CINEMATIC_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CINEMATIC_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CINEMATIC_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  return OVERLORD::RTS::C2S::CreateACK_CINEMATIC_DONE(
      _fbb,
      _sequence);
}

inline ACK_STEP_AND_GOT *ACK_STEP_AND_GO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_STEP_AND_GOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_STEP_AND_GO::UnPackTo(ACK_STEP_AND_GOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
}

inline flatbuffers::Offset<ACK_STEP_AND_GO> ACK_STEP_AND_GO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_AND_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_STEP_AND_GO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_STEP_AND_GO> CreateACK_STEP_AND_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_AND_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_STEP_AND_GOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  return OVERLORD::RTS::C2S::CreateACK_STEP_AND_GO(
      _fbb,
      _sequence);
}

inline REQ_CS_PARTY_UI_READYT *REQ_CS_PARTY_UI_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_CS_PARTY_UI_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_CS_PARTY_UI_READY::UnPackTo(REQ_CS_PARTY_UI_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_CS_PARTY_UI_READY> REQ_CS_PARTY_UI_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_PARTY_UI_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_CS_PARTY_UI_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_CS_PARTY_UI_READY> CreateREQ_CS_PARTY_UI_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_PARTY_UI_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_CS_PARTY_UI_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_CS_PARTY_UI_READY(
      _fbb);
}

inline REQ_CS_DECK_SELECTT *REQ_CS_DECK_SELECT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_CS_DECK_SELECTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_CS_DECK_SELECT::UnPackTo(REQ_CS_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = crewNo(); _o->crewNo = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<REQ_CS_DECK_SELECT> REQ_CS_DECK_SELECT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_CS_DECK_SELECT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_CS_DECK_SELECT> CreateREQ_CS_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_CS_DECK_SELECTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _crewNo = _o->crewNo;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  return OVERLORD::RTS::C2S::CreateREQ_CS_DECK_SELECT(
      _fbb,
      _crewNo,
      _heroUD,
      _heroId,
      _level);
}

inline REQ_CS_DECK_SELECT_READYT *REQ_CS_DECK_SELECT_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_CS_DECK_SELECT_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_CS_DECK_SELECT_READY::UnPackTo(REQ_CS_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ready(); _o->ready = _e; };
}

inline flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> REQ_CS_DECK_SELECT_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_CS_DECK_SELECT_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_CS_DECK_SELECT_READY> CreateREQ_CS_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CS_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_CS_DECK_SELECT_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ready = _o->ready;
  return OVERLORD::RTS::C2S::CreateREQ_CS_DECK_SELECT_READY(
      _fbb,
      _ready);
}

inline REQ_BT_ACTOR_CREATET *REQ_BT_ACTOR_CREATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_CREATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_CREATE::UnPackTo(REQ_BT_ACTOR_CREATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = category(); _o->category = _e; };
  { auto _e = actorId(); if (_e) _o->actorId = _e->str(); };
  { auto _e = role(); _o->role = _e; };
  { auto _e = option(); if (_e) { _o->option.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->option[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<REQ_BT_ACTOR_CREATE> REQ_BT_ACTOR_CREATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_CREATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_CREATE> CreateREQ_BT_ACTOR_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_CREATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _category = _o->category;
  auto _actorId = _o->actorId.empty() ? 0 : _fbb.CreateString(_o->actorId);
  auto _role = _o->role;
  auto _option = _o->option.size() ? _fbb.CreateVectorOfStrings(_o->option) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_CREATE(
      _fbb,
      _category,
      _actorId,
      _role,
      _option);
}

inline REQ_BT_ENTERT *REQ_BT_ENTER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ENTERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ENTER::UnPackTo(REQ_BT_ENTERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_BT_ENTER> REQ_BT_ENTER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ENTERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ENTER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ENTER> CreateREQ_BT_ENTER(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ENTERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ENTERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ENTER(
      _fbb);
}

inline REQ_BT_EXITT *REQ_BT_EXIT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_EXITT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_EXIT::UnPackTo(REQ_BT_EXITT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_BT_EXIT> REQ_BT_EXIT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_EXIT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_EXIT> CreateREQ_BT_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_EXITT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_BT_EXIT(
      _fbb);
}

inline REQ_BT_ACTOR_SPAWNT *REQ_BT_ACTOR_SPAWN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_SPAWNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_SPAWN::UnPackTo(REQ_BT_ACTOR_SPAWNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> REQ_BT_ACTOR_SPAWN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_SPAWN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_SPAWN> CreateREQ_BT_ACTOR_SPAWN(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_SPAWNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_SPAWN(
      _fbb,
      _actorUK,
      _location,
      _direction);
}

inline REQ_BT_DROP_CREWT *REQ_BT_DROP_CREW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_DROP_CREWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_DROP_CREW::UnPackTo(REQ_BT_DROP_CREWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_BT_DROP_CREW> REQ_BT_DROP_CREW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DROP_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_DROP_CREW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_DROP_CREW> CreateREQ_BT_DROP_CREW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DROP_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_DROP_CREWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_DROP_CREW(
      _fbb,
      _actorUK,
      _location,
      _direction);
}

inline REQ_BT_CHANGE_CREWT *REQ_BT_CHANGE_CREW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_CHANGE_CREWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_CHANGE_CREW::UnPackTo(REQ_BT_CHANGE_CREWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_BT_CHANGE_CREW> REQ_BT_CHANGE_CREW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_CHANGE_CREW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_CHANGE_CREW> CreateREQ_BT_CHANGE_CREW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_CHANGE_CREWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _targetUK = _o->targetUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_CHANGE_CREW(
      _fbb,
      _actorUK,
      _targetUK,
      _location,
      _direction);
}

inline REQ_BT_CHANGE_SPIRITT *REQ_BT_CHANGE_SPIRIT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_CHANGE_SPIRITT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_CHANGE_SPIRIT::UnPackTo(REQ_BT_CHANGE_SPIRITT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = spiritIndex(); _o->spiritIndex = _e; };
}

inline flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> REQ_BT_CHANGE_SPIRIT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_SPIRITT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_CHANGE_SPIRIT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_CHANGE_SPIRIT> CreateREQ_BT_CHANGE_SPIRIT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_CHANGE_SPIRITT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_CHANGE_SPIRITT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _spiritIndex = _o->spiritIndex;
  return OVERLORD::RTS::C2S::CreateREQ_BT_CHANGE_SPIRIT(
      _fbb,
      _actorUK,
      _spiritIndex);
}

inline REQ_BT_ACTOR_MOVET *REQ_BT_ACTOR_MOVE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_MOVET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_MOVE::UnPackTo(REQ_BT_ACTOR_MOVET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = isStop(); _o->isStop = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_BT_ACTOR_MOVE> REQ_BT_ACTOR_MOVE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_MOVE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_MOVE> CreateREQ_BT_ACTOR_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_MOVET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _isStop = _o->isStop;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_MOVE(
      _fbb,
      _frame,
      _actorUK,
      _isStop,
      _location,
      _direction);
}

inline REQ_BT_ATTACK_NOWT *REQ_BT_ATTACK_NOW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ATTACK_NOWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ATTACK_NOW::UnPackTo(REQ_BT_ATTACK_NOWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorLocation(); if (_e) _o->actorLocation = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = bAttack(); _o->bAttack = _e; };
  { auto _e = sequence(); _o->sequence = _e; };
}

inline flatbuffers::Offset<REQ_BT_ATTACK_NOW> REQ_BT_ATTACK_NOW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ATTACK_NOWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ATTACK_NOW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ATTACK_NOW> CreateREQ_BT_ATTACK_NOW(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ATTACK_NOWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ATTACK_NOWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _actorLocation = _o->actorLocation ? CreateRTS_VECTOR(_fbb, _o->actorLocation.get(), _rehasher) : 0;
  auto _targetUK = _o->targetUK;
  auto _bAttack = _o->bAttack;
  auto _sequence = _o->sequence;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ATTACK_NOW(
      _fbb,
      _frame,
      _actorUK,
      _actorLocation,
      _targetUK,
      _bAttack,
      _sequence);
}

inline REQ_BT_SKILL_CASTT *REQ_BT_SKILL_CAST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_SKILL_CASTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_SKILL_CAST::UnPackTo(REQ_BT_SKILL_CASTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorLocation(); if (_e) _o->actorLocation = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_BT_SKILL_CAST> REQ_BT_SKILL_CAST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_SKILL_CASTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_SKILL_CAST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_SKILL_CAST> CreateREQ_BT_SKILL_CAST(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_SKILL_CASTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_SKILL_CASTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _actorLocation = _o->actorLocation ? CreateRTS_VECTOR(_fbb, _o->actorLocation.get(), _rehasher) : 0;
  auto _slot = _o->slot;
  auto _targetUK = _o->targetUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::C2S::CreateREQ_BT_SKILL_CAST(
      _fbb,
      _frame,
      _actorUK,
      _actorLocation,
      _slot,
      _targetUK,
      _location,
      _direction);
}

inline REQ_BT_ACTOR_TELEPORTT *REQ_BT_ACTOR_TELEPORT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_TELEPORTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_TELEPORT::UnPackTo(REQ_BT_ACTOR_TELEPORTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = portalNo(); _o->portalNo = _e; };
}

inline flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> REQ_BT_ACTOR_TELEPORT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_TELEPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_TELEPORT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_TELEPORT> CreateREQ_BT_ACTOR_TELEPORT(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_TELEPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_TELEPORTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _portalNo = _o->portalNo;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_TELEPORT(
      _fbb,
      _actorUK,
      _portalNo);
}

inline REQ_BT_ACTOR_FORMATIONT *REQ_BT_ACTOR_FORMATION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_FORMATIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_FORMATION::UnPackTo(REQ_BT_ACTOR_FORMATIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
}

inline flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> REQ_BT_ACTOR_FORMATION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_FORMATIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_FORMATION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_FORMATION> CreateREQ_BT_ACTOR_FORMATION(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_FORMATIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_FORMATIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_FORMATION(
      _fbb,
      _actorUK);
}

inline REQ_BT_DICET *REQ_BT_DICE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_DICET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_DICE::UnPackTo(REQ_BT_DICET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = participate(); _o->participate = _e; };
}

inline flatbuffers::Offset<REQ_BT_DICE> REQ_BT_DICE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DICET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_DICE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_DICE> CreateREQ_BT_DICE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_DICET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_DICET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _participate = _o->participate;
  return OVERLORD::RTS::C2S::CreateREQ_BT_DICE(
      _fbb,
      _participate);
}

inline REQ_BT_PLAYER_SCORET *REQ_BT_PLAYER_SCORE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_PLAYER_SCORET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_PLAYER_SCORE::UnPackTo(REQ_BT_PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_BT_PLAYER_SCORE> REQ_BT_PLAYER_SCORE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_PLAYER_SCORE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_PLAYER_SCORE> CreateREQ_BT_PLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_PLAYER_SCORET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_BT_PLAYER_SCORE(
      _fbb);
}

inline REQ_BT_ACTOR_SCORET *REQ_BT_ACTOR_SCORE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_BT_ACTOR_SCORET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_BT_ACTOR_SCORE::UnPackTo(REQ_BT_ACTOR_SCORET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline flatbuffers::Offset<REQ_BT_ACTOR_SCORE> REQ_BT_ACTOR_SCORE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_BT_ACTOR_SCORE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_BT_ACTOR_SCORE> CreateREQ_BT_ACTOR_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const REQ_BT_ACTOR_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_BT_ACTOR_SCORET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return OVERLORD::RTS::C2S::CreateREQ_BT_ACTOR_SCORE(
      _fbb);
}

}  // namespace C2S
}  // namespace RTS
}  // namespace OVERLORD

#endif  // FLATBUFFERS_GENERATED_RTSC2S_OVERLORD_RTS_C2S_H_

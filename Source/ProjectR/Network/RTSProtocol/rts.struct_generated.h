// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTSSTRUCT_OVERLORD_RTS_IC_H_
#define FLATBUFFERS_GENERATED_RTSSTRUCT_OVERLORD_RTS_IC_H_

#include "flatbuffers/flatbuffers.h"

#include "PDU_generated.h"

namespace OVERLORD {
namespace RTS {
namespace STRUCT {

struct RTS_ERROR;
struct RTS_ERRORT;

struct RTS_VECTOR;
struct RTS_VECTORT;

struct PLAY_RESULT;
struct PLAY_RESULTT;

struct PLAYER;
struct PLAYERT;

struct PARTY_SLOT;
struct PARTY_SLOTT;

struct PARTY;
struct PARTYT;

struct TEAM;
struct TEAMT;

struct PLAYER_SCORE;
struct PLAYER_SCORET;

struct ITEM_OPTION;
struct ITEM_OPTIONT;

struct ITEM;
struct ITEMT;

struct ACTOR;
struct ACTORT;

struct APPLIER;
struct APPLIERT;

struct SLOT;
struct SLOTT;

struct ACTOR_UPDATE;
struct ACTOR_UPDATET;

struct ACTOR_HIT_UPDATE;
struct ACTOR_HIT_UPDATET;

struct ACTOR_SNA_UPDATE;
struct ACTOR_SNA_UPDATET;

struct COOLTIME_UPDATE;
struct COOLTIME_UPDATET;

struct SKILL_PIVOT;
struct SKILL_PIVOTT;

struct RTS_DECK;
struct RTS_DECKT;

struct DICE;
struct DICET;

}  // namespace STRUCT

namespace IC {

struct ROOM_JOIN;
struct ROOM_JOINT;

struct ROOM_REJOIN;
struct ROOM_REJOINT;

struct NPC_HANDLER_JOIN;
struct NPC_HANDLER_JOINT;

struct ROOM_PLAYER;
struct ROOM_PLAYERT;

struct ROOM_PLAYER_DISCONNECTED;
struct ROOM_PLAYER_DISCONNECTEDT;

struct ROOM_DISPOSE;
struct ROOM_DISPOSET;

struct IC_BT_ACTOR_MOVE;
struct IC_BT_ACTOR_MOVET;

struct IC_SPAWN_NPC;
struct IC_SPAWN_NPCT;

struct IC_BT_ACTOR_RESPAWN;
struct IC_BT_ACTOR_RESPAWNT;

struct IC_NPCHOST_STEP_ON;
struct IC_NPCHOST_STEP_ONT;

}  // namespace IC

namespace ENUM {

enum SessionState {
  SessionState_None = 0,
  SessionState_Connecting = 1,
  SessionState_Authorizing = 2,
  SessionState_Authorized = 3,
  SessionState_MatchWaiting = 4,
  SessionState_Matched = 5,
  SessionState_Playing = 6,
  SessionState_MIN = SessionState_None,
  SessionState_MAX = SessionState_Playing
};

inline SessionState (&EnumValuesSessionState())[7] {
  static SessionState values[] = {
    SessionState_None,
    SessionState_Connecting,
    SessionState_Authorizing,
    SessionState_Authorized,
    SessionState_MatchWaiting,
    SessionState_Matched,
    SessionState_Playing
  };
  return values;
}

inline const char **EnumNamesSessionState() {
  static const char *names[] = {
    "None",
    "Connecting",
    "Authorizing",
    "Authorized",
    "MatchWaiting",
    "Matched",
    "Playing",
    nullptr
  };
  return names;
}

inline const char *EnumNameSessionState(SessionState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSessionState()[index];
}

enum LazyCondition {
  LazyCondition_Healthy = 0,
  LazyCondition_Low = 1,
  LazyCondition_Middle = 2,
  LazyCondition_High = 3,
  LazyCondition_MIN = LazyCondition_Healthy,
  LazyCondition_MAX = LazyCondition_High
};

inline LazyCondition (&EnumValuesLazyCondition())[4] {
  static LazyCondition values[] = {
    LazyCondition_Healthy,
    LazyCondition_Low,
    LazyCondition_Middle,
    LazyCondition_High
  };
  return values;
}

inline const char **EnumNamesLazyCondition() {
  static const char *names[] = {
    "Healthy",
    "Low",
    "Middle",
    "High",
    nullptr
  };
  return names;
}

inline const char *EnumNameLazyCondition(LazyCondition e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLazyCondition()[index];
}

enum RTSState {
  RTSState_FailToEstablish = 0,
  RTSState_ErrorBeforeTryMatch = 1,
  RTSState_ErrorOnPlaying = 2,
  RTSState_MIN = RTSState_FailToEstablish,
  RTSState_MAX = RTSState_ErrorOnPlaying
};

inline RTSState (&EnumValuesRTSState())[3] {
  static RTSState values[] = {
    RTSState_FailToEstablish,
    RTSState_ErrorBeforeTryMatch,
    RTSState_ErrorOnPlaying
  };
  return values;
}

inline const char **EnumNamesRTSState() {
  static const char *names[] = {
    "FailToEstablish",
    "ErrorBeforeTryMatch",
    "ErrorOnPlaying",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSState(RTSState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSState()[index];
}

enum RTSZoneEvent {
  RTSZoneEvent_None = 0,
  RTSZoneEvent_PeaceOn = 1,
  RTSZoneEvent_PeaceOff = 2,
  RTSZoneEvent_ExchangeStart = 3,
  RTSZoneEvent_ExchangeCancel = 4,
  RTSZoneEvent_ExchangeComplete = 5,
  RTSZoneEvent_DoorOpen = 6,
  RTSZoneEvent_DoorClose = 7,
  RTSZoneEvent_MIN = RTSZoneEvent_None,
  RTSZoneEvent_MAX = RTSZoneEvent_DoorClose
};

inline RTSZoneEvent (&EnumValuesRTSZoneEvent())[8] {
  static RTSZoneEvent values[] = {
    RTSZoneEvent_None,
    RTSZoneEvent_PeaceOn,
    RTSZoneEvent_PeaceOff,
    RTSZoneEvent_ExchangeStart,
    RTSZoneEvent_ExchangeCancel,
    RTSZoneEvent_ExchangeComplete,
    RTSZoneEvent_DoorOpen,
    RTSZoneEvent_DoorClose
  };
  return values;
}

inline const char **EnumNamesRTSZoneEvent() {
  static const char *names[] = {
    "None",
    "PeaceOn",
    "PeaceOff",
    "ExchangeStart",
    "ExchangeCancel",
    "ExchangeComplete",
    "DoorOpen",
    "DoorClose",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSZoneEvent(RTSZoneEvent e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSZoneEvent()[index];
}

enum RTSZoneState {
  RTSZoneState_None = 0,
  RTSZoneState_ExchangeZoneOpen = 1,
  RTSZoneState_ExchangeZoneClose = 2,
  RTSZoneState_MIN = RTSZoneState_None,
  RTSZoneState_MAX = RTSZoneState_ExchangeZoneClose
};

inline RTSZoneState (&EnumValuesRTSZoneState())[3] {
  static RTSZoneState values[] = {
    RTSZoneState_None,
    RTSZoneState_ExchangeZoneOpen,
    RTSZoneState_ExchangeZoneClose
  };
  return values;
}

inline const char **EnumNamesRTSZoneState() {
  static const char *names[] = {
    "None",
    "ExchangeZoneOpen",
    "ExchangeZoneClose",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSZoneState(RTSZoneState e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSZoneState()[index];
}

enum RTSPartySlotIndex {
  RTSPartySlotIndex_SLOT1 = 1,
  RTSPartySlotIndex_SLOT2 = 2,
  RTSPartySlotIndex_SLOT3 = 3,
  RTSPartySlotIndex_SLOT4 = 4,
  RTSPartySlotIndex_SLOT5 = 5,
  RTSPartySlotIndex_MIN = RTSPartySlotIndex_SLOT1,
  RTSPartySlotIndex_MAX = RTSPartySlotIndex_SLOT5
};

inline RTSPartySlotIndex (&EnumValuesRTSPartySlotIndex())[5] {
  static RTSPartySlotIndex values[] = {
    RTSPartySlotIndex_SLOT1,
    RTSPartySlotIndex_SLOT2,
    RTSPartySlotIndex_SLOT3,
    RTSPartySlotIndex_SLOT4,
    RTSPartySlotIndex_SLOT5
  };
  return values;
}

inline const char **EnumNamesRTSPartySlotIndex() {
  static const char *names[] = {
    "SLOT1",
    "SLOT2",
    "SLOT3",
    "SLOT4",
    "SLOT5",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSPartySlotIndex(RTSPartySlotIndex e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(RTSPartySlotIndex_SLOT1);
  return EnumNamesRTSPartySlotIndex()[index];
}

enum RTSCrewSlotIndex {
  RTSCrewSlotIndex_LEADER = 1,
  RTSCrewSlotIndex_CREW11 = 2,
  RTSCrewSlotIndex_CREW12 = 3,
  RTSCrewSlotIndex_CREW21 = 4,
  RTSCrewSlotIndex_CREW22 = 5,
  RTSCrewSlotIndex_MIN = RTSCrewSlotIndex_LEADER,
  RTSCrewSlotIndex_MAX = RTSCrewSlotIndex_CREW22
};

inline RTSCrewSlotIndex (&EnumValuesRTSCrewSlotIndex())[5] {
  static RTSCrewSlotIndex values[] = {
    RTSCrewSlotIndex_LEADER,
    RTSCrewSlotIndex_CREW11,
    RTSCrewSlotIndex_CREW12,
    RTSCrewSlotIndex_CREW21,
    RTSCrewSlotIndex_CREW22
  };
  return values;
}

inline const char **EnumNamesRTSCrewSlotIndex() {
  static const char *names[] = {
    "LEADER",
    "CREW11",
    "CREW12",
    "CREW21",
    "CREW22",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSCrewSlotIndex(RTSCrewSlotIndex e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(RTSCrewSlotIndex_LEADER);
  return EnumNamesRTSCrewSlotIndex()[index];
}

enum RTSSpiritIndex {
  RTSSpiritIndex_SPIRIT11 = 0,
  RTSSpiritIndex_SPIRIT12 = 1,
  RTSSpiritIndex_SPIRIT21 = 2,
  RTSSpiritIndex_SPIRIT22 = 3,
  RTSSpiritIndex_MIN = RTSSpiritIndex_SPIRIT11,
  RTSSpiritIndex_MAX = RTSSpiritIndex_SPIRIT22
};

inline RTSSpiritIndex (&EnumValuesRTSSpiritIndex())[4] {
  static RTSSpiritIndex values[] = {
    RTSSpiritIndex_SPIRIT11,
    RTSSpiritIndex_SPIRIT12,
    RTSSpiritIndex_SPIRIT21,
    RTSSpiritIndex_SPIRIT22
  };
  return values;
}

inline const char **EnumNamesRTSSpiritIndex() {
  static const char *names[] = {
    "SPIRIT11",
    "SPIRIT12",
    "SPIRIT21",
    "SPIRIT22",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSSpiritIndex(RTSSpiritIndex e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSSpiritIndex()[index];
}

enum RTSPlayResult {
  RTSPlayResult_NONE = 0,
  RTSPlayResult_WIN = 1,
  RTSPlayResult_LOSE = 2,
  RTSPlayResult_MIN = RTSPlayResult_NONE,
  RTSPlayResult_MAX = RTSPlayResult_LOSE
};

inline RTSPlayResult (&EnumValuesRTSPlayResult())[3] {
  static RTSPlayResult values[] = {
    RTSPlayResult_NONE,
    RTSPlayResult_WIN,
    RTSPlayResult_LOSE
  };
  return values;
}

inline const char **EnumNamesRTSPlayResult() {
  static const char *names[] = {
    "NONE",
    "WIN",
    "LOSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSPlayResult(RTSPlayResult e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSPlayResult()[index];
}

enum RTSSequence {
  RTSSequence_STEP1 = 1,
  RTSSequence_STEP2 = 2,
  RTSSequence_STEP3 = 3,
  RTSSequence_STEP4 = 4,
  RTSSequence_STEP5 = 5,
  RTSSequence_MIN = RTSSequence_STEP1,
  RTSSequence_MAX = RTSSequence_STEP5
};

inline RTSSequence (&EnumValuesRTSSequence())[5] {
  static RTSSequence values[] = {
    RTSSequence_STEP1,
    RTSSequence_STEP2,
    RTSSequence_STEP3,
    RTSSequence_STEP4,
    RTSSequence_STEP5
  };
  return values;
}

inline const char **EnumNamesRTSSequence() {
  static const char *names[] = {
    "STEP1",
    "STEP2",
    "STEP3",
    "STEP4",
    "STEP5",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSSequence(RTSSequence e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(RTSSequence_STEP1);
  return EnumNamesRTSSequence()[index];
}

enum RTSCE {
  RTSCE_SUCCESS = 0,
  RTSCE_UNKNOWN = 1,
  RTSCE_OPERATION_FAIL = 2,
  RTSCE_SYSTEM_FAULT = 3,
  RTSCE_AUTH_FAIL = 4,
  RTSCE_MATCH_FAIL = 5,
  RTSCE_MATCH_TIMEOUT = 6,
  RTSCE_MATCH_VS_EXIT = 7,
  RTSCE_NEED_MORE_HERO = 8,
  RTSCE_HERO_SELECT_FAIL = 9,
  RTSCE_SKILL_NOT_READY = 10,
  RTSCE_SKILL_BLOCKED_CAST = 11,
  RTSCE_SKILL_INVALID_TARGET = 12,
  RTSCE_VS_EXIT = 13,
  RTSCE_DISCONNECTED = 14,
  RTSCE_MIN = RTSCE_SUCCESS,
  RTSCE_MAX = RTSCE_DISCONNECTED
};

inline RTSCE (&EnumValuesRTSCE())[15] {
  static RTSCE values[] = {
    RTSCE_SUCCESS,
    RTSCE_UNKNOWN,
    RTSCE_OPERATION_FAIL,
    RTSCE_SYSTEM_FAULT,
    RTSCE_AUTH_FAIL,
    RTSCE_MATCH_FAIL,
    RTSCE_MATCH_TIMEOUT,
    RTSCE_MATCH_VS_EXIT,
    RTSCE_NEED_MORE_HERO,
    RTSCE_HERO_SELECT_FAIL,
    RTSCE_SKILL_NOT_READY,
    RTSCE_SKILL_BLOCKED_CAST,
    RTSCE_SKILL_INVALID_TARGET,
    RTSCE_VS_EXIT,
    RTSCE_DISCONNECTED
  };
  return values;
}

inline const char **EnumNamesRTSCE() {
  static const char *names[] = {
    "SUCCESS",
    "UNKNOWN",
    "OPERATION_FAIL",
    "SYSTEM_FAULT",
    "AUTH_FAIL",
    "MATCH_FAIL",
    "MATCH_TIMEOUT",
    "MATCH_VS_EXIT",
    "NEED_MORE_HERO",
    "HERO_SELECT_FAIL",
    "SKILL_NOT_READY",
    "SKILL_BLOCKED_CAST",
    "SKILL_INVALID_TARGET",
    "VS_EXIT",
    "DISCONNECTED",
    nullptr
  };
  return names;
}

inline const char *EnumNameRTSCE(RTSCE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesRTSCE()[index];
}

enum CHAT_TYPE {
  CHAT_TYPE_NORMAL = 0,
  CHAT_TYPE_GET = 1,
  CHAT_TYPE_EVENT = 2,
  CHAT_TYPE_GM = 3,
  CHAT_TYPE_INVITE = 4,
  CHAT_TYPE_MIN = CHAT_TYPE_NORMAL,
  CHAT_TYPE_MAX = CHAT_TYPE_INVITE
};

inline CHAT_TYPE (&EnumValuesCHAT_TYPE())[5] {
  static CHAT_TYPE values[] = {
    CHAT_TYPE_NORMAL,
    CHAT_TYPE_GET,
    CHAT_TYPE_EVENT,
    CHAT_TYPE_GM,
    CHAT_TYPE_INVITE
  };
  return values;
}

inline const char **EnumNamesCHAT_TYPE() {
  static const char *names[] = {
    "NORMAL",
    "GET",
    "EVENT",
    "GM",
    "INVITE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCHAT_TYPE(CHAT_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCHAT_TYPE()[index];
}

}  // namespace ENUM

namespace STRUCT {

struct RTS_ERRORT : public flatbuffers::NativeTable {
  typedef RTS_ERROR TableType;
  uint8_t type;
  std::string code;
  std::string name;
  std::vector<std::string> desc;
  RTS_ERRORT()
      : type(0) {
  }
};

struct RTS_ERROR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RTS_ERRORT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CODE = 6,
    VT_NAME = 8,
    VT_DESC = 10
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *desc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DESC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           verifier.VerifyVectorOfStrings(desc()) &&
           verifier.EndTable();
  }
  RTS_ERRORT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RTS_ERRORT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RTS_ERROR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_ERRORT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RTS_ERRORBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(RTS_ERROR::VT_TYPE, type, 0);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(RTS_ERROR::VT_CODE, code);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RTS_ERROR::VT_NAME, name);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> desc) {
    fbb_.AddOffset(RTS_ERROR::VT_DESC, desc);
  }
  explicit RTS_ERRORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RTS_ERRORBuilder &operator=(const RTS_ERRORBuilder &);
  flatbuffers::Offset<RTS_ERROR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RTS_ERROR>(end);
    return o;
  }
};

inline flatbuffers::Offset<RTS_ERROR> CreateRTS_ERROR(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> desc = 0) {
  RTS_ERRORBuilder builder_(_fbb);
  builder_.add_desc(desc);
  builder_.add_name(name);
  builder_.add_code(code);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<RTS_ERROR> CreateRTS_ERRORDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    const char *code = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *desc = nullptr) {
  return OVERLORD::RTS::STRUCT::CreateRTS_ERROR(
      _fbb,
      type,
      code ? _fbb.CreateString(code) : 0,
      name ? _fbb.CreateString(name) : 0,
      desc ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*desc) : 0);
}

flatbuffers::Offset<RTS_ERROR> CreateRTS_ERROR(flatbuffers::FlatBufferBuilder &_fbb, const RTS_ERRORT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RTS_VECTORT : public flatbuffers::NativeTable {
  typedef RTS_VECTOR TableType;
  float X;
  float Y;
  float Z;
  RTS_VECTORT()
      : X(0.0f),
        Y(0.0f),
        Z(0.0f) {
  }
};

struct RTS_VECTOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RTS_VECTORT NativeTableType;
  enum {
    VT_X = 4,
    VT_Y = 6,
    VT_Z = 8
  };
  float X() const {
    return GetField<float>(VT_X, 0.0f);
  }
  float Y() const {
    return GetField<float>(VT_Y, 0.0f);
  }
  float Z() const {
    return GetField<float>(VT_Z, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_X) &&
           VerifyField<float>(verifier, VT_Y) &&
           VerifyField<float>(verifier, VT_Z) &&
           verifier.EndTable();
  }
  RTS_VECTORT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RTS_VECTORT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RTS_VECTOR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_VECTORT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RTS_VECTORBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_X(float X) {
    fbb_.AddElement<float>(RTS_VECTOR::VT_X, X, 0.0f);
  }
  void add_Y(float Y) {
    fbb_.AddElement<float>(RTS_VECTOR::VT_Y, Y, 0.0f);
  }
  void add_Z(float Z) {
    fbb_.AddElement<float>(RTS_VECTOR::VT_Z, Z, 0.0f);
  }
  explicit RTS_VECTORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RTS_VECTORBuilder &operator=(const RTS_VECTORBuilder &);
  flatbuffers::Offset<RTS_VECTOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RTS_VECTOR>(end);
    return o;
  }
};

inline flatbuffers::Offset<RTS_VECTOR> CreateRTS_VECTOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    float X = 0.0f,
    float Y = 0.0f,
    float Z = 0.0f) {
  RTS_VECTORBuilder builder_(_fbb);
  builder_.add_Z(Z);
  builder_.add_Y(Y);
  builder_.add_X(X);
  return builder_.Finish();
}

flatbuffers::Offset<RTS_VECTOR> CreateRTS_VECTOR(flatbuffers::FlatBufferBuilder &_fbb, const RTS_VECTORT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PLAY_RESULTT : public flatbuffers::NativeTable {
  typedef PLAY_RESULT TableType;
  int32_t kId;
  uint8_t playResult;
  PLAY_RESULTT()
      : kId(0),
        playResult(0) {
  }
};

struct PLAY_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PLAY_RESULTT NativeTableType;
  enum {
    VT_KID = 4,
    VT_PLAYRESULT = 6
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  uint8_t playResult() const {
    return GetField<uint8_t>(VT_PLAYRESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint8_t>(verifier, VT_PLAYRESULT) &&
           verifier.EndTable();
  }
  PLAY_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PLAY_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PLAY_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PLAY_RESULT::VT_KID, kId, 0);
  }
  void add_playResult(uint8_t playResult) {
    fbb_.AddElement<uint8_t>(PLAY_RESULT::VT_PLAYRESULT, playResult, 0);
  }
  explicit PLAY_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PLAY_RESULTBuilder &operator=(const PLAY_RESULTBuilder &);
  flatbuffers::Offset<PLAY_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PLAY_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<PLAY_RESULT> CreatePLAY_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    uint8_t playResult = 0) {
  PLAY_RESULTBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_playResult(playResult);
  return builder_.Finish();
}

flatbuffers::Offset<PLAY_RESULT> CreatePLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PLAYERT : public flatbuffers::NativeTable {
  typedef PLAYER TableType;
  int32_t kId;
  std::string nick;
  int32_t level;
  int32_t elevatedFloor;
  std::string guild;
  int32_t guild_id;
  std::vector<int32_t> ability;
  uint16_t team;
  uint8_t party;
  uint8_t slot;
  PLAYERT()
      : kId(0),
        level(0),
        elevatedFloor(1),
        guild_id(0),
        team(0),
        party(0),
        slot(0) {
  }
};

struct PLAYER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PLAYERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_LEVEL = 8,
    VT_ELEVATEDFLOOR = 10,
    VT_GUILD = 12,
    VT_GUILD_ID = 14,
    VT_ABILITY = 16,
    VT_TEAM = 18,
    VT_PARTY = 20,
    VT_SLOT = 22
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t elevatedFloor() const {
    return GetField<int32_t>(VT_ELEVATEDFLOOR, 1);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  const flatbuffers::Vector<int32_t> *ability() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ABILITY);
  }
  uint16_t team() const {
    return GetField<uint16_t>(VT_TEAM, 0);
  }
  uint8_t party() const {
    return GetField<uint8_t>(VT_PARTY, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ELEVATEDFLOOR) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           VerifyOffset(verifier, VT_ABILITY) &&
           verifier.Verify(ability()) &&
           VerifyField<uint16_t>(verifier, VT_TEAM) &&
           VerifyField<uint8_t>(verifier, VT_PARTY) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           verifier.EndTable();
  }
  PLAYERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PLAYER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PLAYERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PLAYER::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(PLAYER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PLAYER::VT_LEVEL, level, 0);
  }
  void add_elevatedFloor(int32_t elevatedFloor) {
    fbb_.AddElement<int32_t>(PLAYER::VT_ELEVATEDFLOOR, elevatedFloor, 1);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(PLAYER::VT_GUILD, guild);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(PLAYER::VT_GUILD_ID, guild_id, 0);
  }
  void add_ability(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability) {
    fbb_.AddOffset(PLAYER::VT_ABILITY, ability);
  }
  void add_team(uint16_t team) {
    fbb_.AddElement<uint16_t>(PLAYER::VT_TEAM, team, 0);
  }
  void add_party(uint8_t party) {
    fbb_.AddElement<uint8_t>(PLAYER::VT_PARTY, party, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(PLAYER::VT_SLOT, slot, 0);
  }
  explicit PLAYERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PLAYERBuilder &operator=(const PLAYERBuilder &);
  flatbuffers::Offset<PLAYER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PLAYER>(end);
    return o;
  }
};

inline flatbuffers::Offset<PLAYER> CreatePLAYER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    int32_t elevatedFloor = 1,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t guild_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability = 0,
    uint16_t team = 0,
    uint8_t party = 0,
    uint8_t slot = 0) {
  PLAYERBuilder builder_(_fbb);
  builder_.add_ability(ability);
  builder_.add_guild_id(guild_id);
  builder_.add_guild(guild);
  builder_.add_elevatedFloor(elevatedFloor);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_team(team);
  builder_.add_slot(slot);
  builder_.add_party(party);
  return builder_.Finish();
}

inline flatbuffers::Offset<PLAYER> CreatePLAYERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t level = 0,
    int32_t elevatedFloor = 1,
    const char *guild = nullptr,
    int32_t guild_id = 0,
    const std::vector<int32_t> *ability = nullptr,
    uint16_t team = 0,
    uint8_t party = 0,
    uint8_t slot = 0) {
  return OVERLORD::RTS::STRUCT::CreatePLAYER(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      elevatedFloor,
      guild ? _fbb.CreateString(guild) : 0,
      guild_id,
      ability ? _fbb.CreateVector<int32_t>(*ability) : 0,
      team,
      party,
      slot);
}

flatbuffers::Offset<PLAYER> CreatePLAYER(flatbuffers::FlatBufferBuilder &_fbb, const PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PARTY_SLOTT : public flatbuffers::NativeTable {
  typedef PARTY_SLOT TableType;
  uint8_t slot;
  int32_t kId;
  uint16_t actorUK;
  PARTY_SLOTT()
      : slot(0),
        kId(0),
        actorUK(0) {
  }
};

struct PARTY_SLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PARTY_SLOTT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_KID = 6,
    VT_ACTORUK = 8
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           verifier.EndTable();
  }
  PARTY_SLOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PARTY_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PARTY_SLOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PARTY_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PARTY_SLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(PARTY_SLOT::VT_SLOT, slot, 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PARTY_SLOT::VT_KID, kId, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(PARTY_SLOT::VT_ACTORUK, actorUK, 0);
  }
  explicit PARTY_SLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PARTY_SLOTBuilder &operator=(const PARTY_SLOTBuilder &);
  flatbuffers::Offset<PARTY_SLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PARTY_SLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<PARTY_SLOT> CreatePARTY_SLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    int32_t kId = 0,
    uint16_t actorUK = 0) {
  PARTY_SLOTBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_actorUK(actorUK);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<PARTY_SLOT> CreatePARTY_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const PARTY_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PARTYT : public flatbuffers::NativeTable {
  typedef PARTY TableType;
  uint8_t party;
  std::vector<std::unique_ptr<PARTY_SLOTT>> slots;
  PARTYT()
      : party(0) {
  }
};

struct PARTY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PARTYT NativeTableType;
  enum {
    VT_PARTY = 4,
    VT_SLOTS = 6
  };
  uint8_t party() const {
    return GetField<uint8_t>(VT_PARTY, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PARTY_SLOT>> *slots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PARTY_SLOT>> *>(VT_SLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PARTY) &&
           VerifyOffset(verifier, VT_SLOTS) &&
           verifier.Verify(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
  PARTYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PARTYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PARTY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PARTYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PARTYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_party(uint8_t party) {
    fbb_.AddElement<uint8_t>(PARTY::VT_PARTY, party, 0);
  }
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PARTY_SLOT>>> slots) {
    fbb_.AddOffset(PARTY::VT_SLOTS, slots);
  }
  explicit PARTYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PARTYBuilder &operator=(const PARTYBuilder &);
  flatbuffers::Offset<PARTY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PARTY>(end);
    return o;
  }
};

inline flatbuffers::Offset<PARTY> CreatePARTY(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t party = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PARTY_SLOT>>> slots = 0) {
  PARTYBuilder builder_(_fbb);
  builder_.add_slots(slots);
  builder_.add_party(party);
  return builder_.Finish();
}

inline flatbuffers::Offset<PARTY> CreatePARTYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t party = 0,
    const std::vector<flatbuffers::Offset<PARTY_SLOT>> *slots = nullptr) {
  return OVERLORD::RTS::STRUCT::CreatePARTY(
      _fbb,
      party,
      slots ? _fbb.CreateVector<flatbuffers::Offset<PARTY_SLOT>>(*slots) : 0);
}

flatbuffers::Offset<PARTY> CreatePARTY(flatbuffers::FlatBufferBuilder &_fbb, const PARTYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TEAMT : public flatbuffers::NativeTable {
  typedef TEAM TableType;
  uint16_t team;
  std::vector<std::unique_ptr<PARTYT>> parties;
  TEAMT()
      : team(0) {
  }
};

struct TEAM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TEAMT NativeTableType;
  enum {
    VT_TEAM = 4,
    VT_PARTIES = 6
  };
  uint16_t team() const {
    return GetField<uint16_t>(VT_TEAM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PARTY>> *parties() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PARTY>> *>(VT_PARTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TEAM) &&
           VerifyOffset(verifier, VT_PARTIES) &&
           verifier.Verify(parties()) &&
           verifier.VerifyVectorOfTables(parties()) &&
           verifier.EndTable();
  }
  TEAMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TEAMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TEAM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TEAMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TEAMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_team(uint16_t team) {
    fbb_.AddElement<uint16_t>(TEAM::VT_TEAM, team, 0);
  }
  void add_parties(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PARTY>>> parties) {
    fbb_.AddOffset(TEAM::VT_PARTIES, parties);
  }
  explicit TEAMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TEAMBuilder &operator=(const TEAMBuilder &);
  flatbuffers::Offset<TEAM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TEAM>(end);
    return o;
  }
};

inline flatbuffers::Offset<TEAM> CreateTEAM(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t team = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PARTY>>> parties = 0) {
  TEAMBuilder builder_(_fbb);
  builder_.add_parties(parties);
  builder_.add_team(team);
  return builder_.Finish();
}

inline flatbuffers::Offset<TEAM> CreateTEAMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t team = 0,
    const std::vector<flatbuffers::Offset<PARTY>> *parties = nullptr) {
  return OVERLORD::RTS::STRUCT::CreateTEAM(
      _fbb,
      team,
      parties ? _fbb.CreateVector<flatbuffers::Offset<PARTY>>(*parties) : 0);
}

flatbuffers::Offset<TEAM> CreateTEAM(flatbuffers::FlatBufferBuilder &_fbb, const TEAMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PLAYER_SCORET : public flatbuffers::NativeTable {
  typedef PLAYER_SCORE TableType;
  int32_t kId;
  std::string nick;
  uint16_t actorUK;
  uint8_t actorCategory;
  std::string actorId;
  uint32_t damage;
  uint32_t damageSkill;
  uint32_t heal;
  uint32_t damaged;
  uint16_t skill;
  uint16_t kill;
  uint16_t death;
  uint16_t medal;
  PLAYER_SCORET()
      : kId(0),
        actorUK(0),
        actorCategory(0),
        damage(0),
        damageSkill(0),
        heal(0),
        damaged(0),
        skill(0),
        kill(0),
        death(0),
        medal(0) {
  }
};

struct PLAYER_SCORE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PLAYER_SCORET NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_ACTORUK = 8,
    VT_ACTORCATEGORY = 10,
    VT_ACTORID = 12,
    VT_DAMAGE = 14,
    VT_DAMAGESKILL = 16,
    VT_HEAL = 18,
    VT_DAMAGED = 20,
    VT_SKILL = 22,
    VT_KILL = 24,
    VT_DEATH = 26,
    VT_MEDAL = 28
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t actorCategory() const {
    return GetField<uint8_t>(VT_ACTORCATEGORY, 0);
  }
  const flatbuffers::String *actorId() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTORID);
  }
  uint32_t damage() const {
    return GetField<uint32_t>(VT_DAMAGE, 0);
  }
  uint32_t damageSkill() const {
    return GetField<uint32_t>(VT_DAMAGESKILL, 0);
  }
  uint32_t heal() const {
    return GetField<uint32_t>(VT_HEAL, 0);
  }
  uint32_t damaged() const {
    return GetField<uint32_t>(VT_DAMAGED, 0);
  }
  uint16_t skill() const {
    return GetField<uint16_t>(VT_SKILL, 0);
  }
  uint16_t kill() const {
    return GetField<uint16_t>(VT_KILL, 0);
  }
  uint16_t death() const {
    return GetField<uint16_t>(VT_DEATH, 0);
  }
  uint16_t medal() const {
    return GetField<uint16_t>(VT_MEDAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_ACTORCATEGORY) &&
           VerifyOffset(verifier, VT_ACTORID) &&
           verifier.Verify(actorId()) &&
           VerifyField<uint32_t>(verifier, VT_DAMAGE) &&
           VerifyField<uint32_t>(verifier, VT_DAMAGESKILL) &&
           VerifyField<uint32_t>(verifier, VT_HEAL) &&
           VerifyField<uint32_t>(verifier, VT_DAMAGED) &&
           VerifyField<uint16_t>(verifier, VT_SKILL) &&
           VerifyField<uint16_t>(verifier, VT_KILL) &&
           VerifyField<uint16_t>(verifier, VT_DEATH) &&
           VerifyField<uint16_t>(verifier, VT_MEDAL) &&
           verifier.EndTable();
  }
  PLAYER_SCORET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PLAYER_SCORE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PLAYER_SCOREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PLAYER_SCORE::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(PLAYER_SCORE::VT_NICK, nick);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(PLAYER_SCORE::VT_ACTORUK, actorUK, 0);
  }
  void add_actorCategory(uint8_t actorCategory) {
    fbb_.AddElement<uint8_t>(PLAYER_SCORE::VT_ACTORCATEGORY, actorCategory, 0);
  }
  void add_actorId(flatbuffers::Offset<flatbuffers::String> actorId) {
    fbb_.AddOffset(PLAYER_SCORE::VT_ACTORID, actorId);
  }
  void add_damage(uint32_t damage) {
    fbb_.AddElement<uint32_t>(PLAYER_SCORE::VT_DAMAGE, damage, 0);
  }
  void add_damageSkill(uint32_t damageSkill) {
    fbb_.AddElement<uint32_t>(PLAYER_SCORE::VT_DAMAGESKILL, damageSkill, 0);
  }
  void add_heal(uint32_t heal) {
    fbb_.AddElement<uint32_t>(PLAYER_SCORE::VT_HEAL, heal, 0);
  }
  void add_damaged(uint32_t damaged) {
    fbb_.AddElement<uint32_t>(PLAYER_SCORE::VT_DAMAGED, damaged, 0);
  }
  void add_skill(uint16_t skill) {
    fbb_.AddElement<uint16_t>(PLAYER_SCORE::VT_SKILL, skill, 0);
  }
  void add_kill(uint16_t kill) {
    fbb_.AddElement<uint16_t>(PLAYER_SCORE::VT_KILL, kill, 0);
  }
  void add_death(uint16_t death) {
    fbb_.AddElement<uint16_t>(PLAYER_SCORE::VT_DEATH, death, 0);
  }
  void add_medal(uint16_t medal) {
    fbb_.AddElement<uint16_t>(PLAYER_SCORE::VT_MEDAL, medal, 0);
  }
  explicit PLAYER_SCOREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PLAYER_SCOREBuilder &operator=(const PLAYER_SCOREBuilder &);
  flatbuffers::Offset<PLAYER_SCORE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PLAYER_SCORE>(end);
    return o;
  }
};

inline flatbuffers::Offset<PLAYER_SCORE> CreatePLAYER_SCORE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    uint16_t actorUK = 0,
    uint8_t actorCategory = 0,
    flatbuffers::Offset<flatbuffers::String> actorId = 0,
    uint32_t damage = 0,
    uint32_t damageSkill = 0,
    uint32_t heal = 0,
    uint32_t damaged = 0,
    uint16_t skill = 0,
    uint16_t kill = 0,
    uint16_t death = 0,
    uint16_t medal = 0) {
  PLAYER_SCOREBuilder builder_(_fbb);
  builder_.add_damaged(damaged);
  builder_.add_heal(heal);
  builder_.add_damageSkill(damageSkill);
  builder_.add_damage(damage);
  builder_.add_actorId(actorId);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_medal(medal);
  builder_.add_death(death);
  builder_.add_kill(kill);
  builder_.add_skill(skill);
  builder_.add_actorUK(actorUK);
  builder_.add_actorCategory(actorCategory);
  return builder_.Finish();
}

inline flatbuffers::Offset<PLAYER_SCORE> CreatePLAYER_SCOREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    uint16_t actorUK = 0,
    uint8_t actorCategory = 0,
    const char *actorId = nullptr,
    uint32_t damage = 0,
    uint32_t damageSkill = 0,
    uint32_t heal = 0,
    uint32_t damaged = 0,
    uint16_t skill = 0,
    uint16_t kill = 0,
    uint16_t death = 0,
    uint16_t medal = 0) {
  return OVERLORD::RTS::STRUCT::CreatePLAYER_SCORE(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      actorUK,
      actorCategory,
      actorId ? _fbb.CreateString(actorId) : 0,
      damage,
      damageSkill,
      heal,
      damaged,
      skill,
      kill,
      death,
      medal);
}

flatbuffers::Offset<PLAYER_SCORE> CreatePLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ITEM_OPTIONT : public flatbuffers::NativeTable {
  typedef ITEM_OPTION TableType;
  std::string option;
  int32_t value;
  ITEM_OPTIONT()
      : value(0) {
  }
};

struct ITEM_OPTION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ITEM_OPTIONT NativeTableType;
  enum {
    VT_OPTION = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *option() const {
    return GetPointer<const flatbuffers::String *>(VT_OPTION);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OPTION) &&
           verifier.Verify(option()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  ITEM_OPTIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ITEM_OPTIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ITEM_OPTION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ITEM_OPTIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_option(flatbuffers::Offset<flatbuffers::String> option) {
    fbb_.AddOffset(ITEM_OPTION::VT_OPTION, option);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(ITEM_OPTION::VT_VALUE, value, 0);
  }
  explicit ITEM_OPTIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ITEM_OPTIONBuilder &operator=(const ITEM_OPTIONBuilder &);
  flatbuffers::Offset<ITEM_OPTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ITEM_OPTION>(end);
    return o;
  }
};

inline flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> option = 0,
    int32_t value = 0) {
  ITEM_OPTIONBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_option(option);
  return builder_.Finish();
}

inline flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *option = nullptr,
    int32_t value = 0) {
  return OVERLORD::RTS::STRUCT::CreateITEM_OPTION(
      _fbb,
      option ? _fbb.CreateString(option) : 0,
      value);
}

flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ITEMT : public flatbuffers::NativeTable {
  typedef ITEM TableType;
  std::string itemId;
  int32_t level;
  int32_t enchant;
  int32_t enchantValue;
  std::vector<std::unique_ptr<ITEM_OPTIONT>> options;
  std::vector<std::string> jewels;
  ITEMT()
      : level(0),
        enchant(0),
        enchantValue(0) {
  }
};

struct ITEM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ITEMT NativeTableType;
  enum {
    VT_ITEMID = 4,
    VT_LEVEL = 6,
    VT_ENCHANT = 8,
    VT_ENCHANTVALUE = 10,
    VT_OPTIONS = 12,
    VT_JEWELS = 14
  };
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t enchant() const {
    return GetField<int32_t>(VT_ENCHANT, 0);
  }
  int32_t enchantValue() const {
    return GetField<int32_t>(VT_ENCHANTVALUE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>> *options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>> *>(VT_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *jewels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_JEWELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_ENCHANT) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTVALUE) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.Verify(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           VerifyOffset(verifier, VT_JEWELS) &&
           verifier.Verify(jewels()) &&
           verifier.VerifyVectorOfStrings(jewels()) &&
           verifier.EndTable();
  }
  ITEMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ITEMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ITEM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ITEMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ITEM::VT_ITEMID, itemId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ITEM::VT_LEVEL, level, 0);
  }
  void add_enchant(int32_t enchant) {
    fbb_.AddElement<int32_t>(ITEM::VT_ENCHANT, enchant, 0);
  }
  void add_enchantValue(int32_t enchantValue) {
    fbb_.AddElement<int32_t>(ITEM::VT_ENCHANTVALUE, enchantValue, 0);
  }
  void add_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>>> options) {
    fbb_.AddOffset(ITEM::VT_OPTIONS, options);
  }
  void add_jewels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> jewels) {
    fbb_.AddOffset(ITEM::VT_JEWELS, jewels);
  }
  explicit ITEMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ITEMBuilder &operator=(const ITEMBuilder &);
  flatbuffers::Offset<ITEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ITEM>(end);
    return o;
  }
};

inline flatbuffers::Offset<ITEM> CreateITEM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    int32_t level = 0,
    int32_t enchant = 0,
    int32_t enchantValue = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>>> options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> jewels = 0) {
  ITEMBuilder builder_(_fbb);
  builder_.add_jewels(jewels);
  builder_.add_options(options);
  builder_.add_enchantValue(enchantValue);
  builder_.add_enchant(enchant);
  builder_.add_level(level);
  builder_.add_itemId(itemId);
  return builder_.Finish();
}

inline flatbuffers::Offset<ITEM> CreateITEMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *itemId = nullptr,
    int32_t level = 0,
    int32_t enchant = 0,
    int32_t enchantValue = 0,
    const std::vector<flatbuffers::Offset<ITEM_OPTION>> *options = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *jewels = nullptr) {
  return OVERLORD::RTS::STRUCT::CreateITEM(
      _fbb,
      itemId ? _fbb.CreateString(itemId) : 0,
      level,
      enchant,
      enchantValue,
      options ? _fbb.CreateVector<flatbuffers::Offset<ITEM_OPTION>>(*options) : 0,
      jewels ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*jewels) : 0);
}

flatbuffers::Offset<ITEM> CreateITEM(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACTORT : public flatbuffers::NativeTable {
  typedef ACTOR TableType;
  uint16_t actorUK;
  uint8_t actorCategory;
  std::string actorId;
  uint8_t role;
  int32_t kId;
  std::string nick;
  std::string subNick;
  std::vector<int32_t> ability;
  bool isSummon;
  uint16_t primaryUK;
  float primaryFE;
  uint32_t power;
  uint32_t maxHp;
  int16_t level;
  int16_t grade;
  std::vector<uint8_t> skills;
  std::vector<std::unique_ptr<ITEMT>> items;
  uint16_t team;
  uint8_t party;
  uint8_t slot;
  uint32_t teamCode;
  uint32_t curHp;
  ACTORT()
      : actorUK(0),
        actorCategory(0),
        role(0),
        kId(0),
        isSummon(false),
        primaryUK(0),
        primaryFE(0.0f),
        power(0),
        maxHp(0),
        level(0),
        grade(0),
        team(0),
        party(0),
        slot(0),
        teamCode(0),
        curHp(0) {
  }
};

struct ACTOR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACTORT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_ACTORCATEGORY = 6,
    VT_ACTORID = 8,
    VT_ROLE = 10,
    VT_KID = 12,
    VT_NICK = 14,
    VT_SUBNICK = 16,
    VT_ABILITY = 18,
    VT_ISSUMMON = 20,
    VT_PRIMARYUK = 22,
    VT_PRIMARYFE = 24,
    VT_POWER = 26,
    VT_MAXHP = 28,
    VT_LEVEL = 30,
    VT_GRADE = 32,
    VT_SKILLS = 34,
    VT_ITEMS = 36,
    VT_TEAM = 38,
    VT_PARTY = 40,
    VT_SLOT = 42,
    VT_TEAMCODE = 44,
    VT_CURHP = 46
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t actorCategory() const {
    return GetField<uint8_t>(VT_ACTORCATEGORY, 0);
  }
  const flatbuffers::String *actorId() const {
    return GetPointer<const flatbuffers::String *>(VT_ACTORID);
  }
  uint8_t role() const {
    return GetField<uint8_t>(VT_ROLE, 0);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *subNick() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBNICK);
  }
  const flatbuffers::Vector<int32_t> *ability() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ABILITY);
  }
  bool isSummon() const {
    return GetField<uint8_t>(VT_ISSUMMON, 0) != 0;
  }
  uint16_t primaryUK() const {
    return GetField<uint16_t>(VT_PRIMARYUK, 0);
  }
  float primaryFE() const {
    return GetField<float>(VT_PRIMARYFE, 0.0f);
  }
  uint32_t power() const {
    return GetField<uint32_t>(VT_POWER, 0);
  }
  uint32_t maxHp() const {
    return GetField<uint32_t>(VT_MAXHP, 0);
  }
  int16_t level() const {
    return GetField<int16_t>(VT_LEVEL, 0);
  }
  int16_t grade() const {
    return GetField<int16_t>(VT_GRADE, 0);
  }
  const flatbuffers::Vector<uint8_t> *skills() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SKILLS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *>(VT_ITEMS);
  }
  uint16_t team() const {
    return GetField<uint16_t>(VT_TEAM, 0);
  }
  uint8_t party() const {
    return GetField<uint8_t>(VT_PARTY, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  uint32_t teamCode() const {
    return GetField<uint32_t>(VT_TEAMCODE, 0);
  }
  uint32_t curHp() const {
    return GetField<uint32_t>(VT_CURHP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_ACTORCATEGORY) &&
           VerifyOffset(verifier, VT_ACTORID) &&
           verifier.Verify(actorId()) &&
           VerifyField<uint8_t>(verifier, VT_ROLE) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_SUBNICK) &&
           verifier.Verify(subNick()) &&
           VerifyOffset(verifier, VT_ABILITY) &&
           verifier.Verify(ability()) &&
           VerifyField<uint8_t>(verifier, VT_ISSUMMON) &&
           VerifyField<uint16_t>(verifier, VT_PRIMARYUK) &&
           VerifyField<float>(verifier, VT_PRIMARYFE) &&
           VerifyField<uint32_t>(verifier, VT_POWER) &&
           VerifyField<uint32_t>(verifier, VT_MAXHP) &&
           VerifyField<int16_t>(verifier, VT_LEVEL) &&
           VerifyField<int16_t>(verifier, VT_GRADE) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.Verify(skills()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyField<uint16_t>(verifier, VT_TEAM) &&
           VerifyField<uint8_t>(verifier, VT_PARTY) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint32_t>(verifier, VT_TEAMCODE) &&
           VerifyField<uint32_t>(verifier, VT_CURHP) &&
           verifier.EndTable();
  }
  ACTORT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACTORT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACTOR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTORT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACTORBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACTOR::VT_ACTORUK, actorUK, 0);
  }
  void add_actorCategory(uint8_t actorCategory) {
    fbb_.AddElement<uint8_t>(ACTOR::VT_ACTORCATEGORY, actorCategory, 0);
  }
  void add_actorId(flatbuffers::Offset<flatbuffers::String> actorId) {
    fbb_.AddOffset(ACTOR::VT_ACTORID, actorId);
  }
  void add_role(uint8_t role) {
    fbb_.AddElement<uint8_t>(ACTOR::VT_ROLE, role, 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ACTOR::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ACTOR::VT_NICK, nick);
  }
  void add_subNick(flatbuffers::Offset<flatbuffers::String> subNick) {
    fbb_.AddOffset(ACTOR::VT_SUBNICK, subNick);
  }
  void add_ability(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability) {
    fbb_.AddOffset(ACTOR::VT_ABILITY, ability);
  }
  void add_isSummon(bool isSummon) {
    fbb_.AddElement<uint8_t>(ACTOR::VT_ISSUMMON, static_cast<uint8_t>(isSummon), 0);
  }
  void add_primaryUK(uint16_t primaryUK) {
    fbb_.AddElement<uint16_t>(ACTOR::VT_PRIMARYUK, primaryUK, 0);
  }
  void add_primaryFE(float primaryFE) {
    fbb_.AddElement<float>(ACTOR::VT_PRIMARYFE, primaryFE, 0.0f);
  }
  void add_power(uint32_t power) {
    fbb_.AddElement<uint32_t>(ACTOR::VT_POWER, power, 0);
  }
  void add_maxHp(uint32_t maxHp) {
    fbb_.AddElement<uint32_t>(ACTOR::VT_MAXHP, maxHp, 0);
  }
  void add_level(int16_t level) {
    fbb_.AddElement<int16_t>(ACTOR::VT_LEVEL, level, 0);
  }
  void add_grade(int16_t grade) {
    fbb_.AddElement<int16_t>(ACTOR::VT_GRADE, grade, 0);
  }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skills) {
    fbb_.AddOffset(ACTOR::VT_SKILLS, skills);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items) {
    fbb_.AddOffset(ACTOR::VT_ITEMS, items);
  }
  void add_team(uint16_t team) {
    fbb_.AddElement<uint16_t>(ACTOR::VT_TEAM, team, 0);
  }
  void add_party(uint8_t party) {
    fbb_.AddElement<uint8_t>(ACTOR::VT_PARTY, party, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACTOR::VT_SLOT, slot, 0);
  }
  void add_teamCode(uint32_t teamCode) {
    fbb_.AddElement<uint32_t>(ACTOR::VT_TEAMCODE, teamCode, 0);
  }
  void add_curHp(uint32_t curHp) {
    fbb_.AddElement<uint32_t>(ACTOR::VT_CURHP, curHp, 0);
  }
  explicit ACTORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACTORBuilder &operator=(const ACTORBuilder &);
  flatbuffers::Offset<ACTOR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACTOR>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACTOR> CreateACTOR(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint8_t actorCategory = 0,
    flatbuffers::Offset<flatbuffers::String> actorId = 0,
    uint8_t role = 0,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> subNick = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability = 0,
    bool isSummon = false,
    uint16_t primaryUK = 0,
    float primaryFE = 0.0f,
    uint32_t power = 0,
    uint32_t maxHp = 0,
    int16_t level = 0,
    int16_t grade = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skills = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items = 0,
    uint16_t team = 0,
    uint8_t party = 0,
    uint8_t slot = 0,
    uint32_t teamCode = 0,
    uint32_t curHp = 0) {
  ACTORBuilder builder_(_fbb);
  builder_.add_curHp(curHp);
  builder_.add_teamCode(teamCode);
  builder_.add_items(items);
  builder_.add_skills(skills);
  builder_.add_maxHp(maxHp);
  builder_.add_power(power);
  builder_.add_primaryFE(primaryFE);
  builder_.add_ability(ability);
  builder_.add_subNick(subNick);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_actorId(actorId);
  builder_.add_team(team);
  builder_.add_grade(grade);
  builder_.add_level(level);
  builder_.add_primaryUK(primaryUK);
  builder_.add_actorUK(actorUK);
  builder_.add_slot(slot);
  builder_.add_party(party);
  builder_.add_isSummon(isSummon);
  builder_.add_role(role);
  builder_.add_actorCategory(actorCategory);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACTOR> CreateACTORDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint8_t actorCategory = 0,
    const char *actorId = nullptr,
    uint8_t role = 0,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *subNick = nullptr,
    const std::vector<int32_t> *ability = nullptr,
    bool isSummon = false,
    uint16_t primaryUK = 0,
    float primaryFE = 0.0f,
    uint32_t power = 0,
    uint32_t maxHp = 0,
    int16_t level = 0,
    int16_t grade = 0,
    const std::vector<uint8_t> *skills = nullptr,
    const std::vector<flatbuffers::Offset<ITEM>> *items = nullptr,
    uint16_t team = 0,
    uint8_t party = 0,
    uint8_t slot = 0,
    uint32_t teamCode = 0,
    uint32_t curHp = 0) {
  return OVERLORD::RTS::STRUCT::CreateACTOR(
      _fbb,
      actorUK,
      actorCategory,
      actorId ? _fbb.CreateString(actorId) : 0,
      role,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      subNick ? _fbb.CreateString(subNick) : 0,
      ability ? _fbb.CreateVector<int32_t>(*ability) : 0,
      isSummon,
      primaryUK,
      primaryFE,
      power,
      maxHp,
      level,
      grade,
      skills ? _fbb.CreateVector<uint8_t>(*skills) : 0,
      items ? _fbb.CreateVector<flatbuffers::Offset<ITEM>>(*items) : 0,
      team,
      party,
      slot,
      teamCode,
      curHp);
}

flatbuffers::Offset<ACTOR> CreateACTOR(flatbuffers::FlatBufferBuilder &_fbb, const ACTORT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct APPLIERT : public flatbuffers::NativeTable {
  typedef APPLIER TableType;
  uint8_t EF;
  int16_t PE;
  int32_t VA;
  bool removed;
  std::unique_ptr<ACTOR_HIT_UPDATET> hit;
  std::unique_ptr<ACTOR_UPDATET> move;
  std::vector<std::unique_ptr<COOLTIME_UPDATET>> cools;
  APPLIERT()
      : EF(0),
        PE(0),
        VA(0),
        removed(false) {
  }
};

struct APPLIER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef APPLIERT NativeTableType;
  enum {
    VT_EF = 4,
    VT_PE = 6,
    VT_VA = 8,
    VT_REMOVED = 10,
    VT_HIT = 12,
    VT_MOVE = 14,
    VT_COOLS = 16
  };
  uint8_t EF() const {
    return GetField<uint8_t>(VT_EF, 0);
  }
  int16_t PE() const {
    return GetField<int16_t>(VT_PE, 0);
  }
  int32_t VA() const {
    return GetField<int32_t>(VT_VA, 0);
  }
  bool removed() const {
    return GetField<uint8_t>(VT_REMOVED, 0) != 0;
  }
  const ACTOR_HIT_UPDATE *hit() const {
    return GetPointer<const ACTOR_HIT_UPDATE *>(VT_HIT);
  }
  const ACTOR_UPDATE *move() const {
    return GetPointer<const ACTOR_UPDATE *>(VT_MOVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<COOLTIME_UPDATE>> *cools() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<COOLTIME_UPDATE>> *>(VT_COOLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EF) &&
           VerifyField<int16_t>(verifier, VT_PE) &&
           VerifyField<int32_t>(verifier, VT_VA) &&
           VerifyField<uint8_t>(verifier, VT_REMOVED) &&
           VerifyOffset(verifier, VT_HIT) &&
           verifier.VerifyTable(hit()) &&
           VerifyOffset(verifier, VT_MOVE) &&
           verifier.VerifyTable(move()) &&
           VerifyOffset(verifier, VT_COOLS) &&
           verifier.Verify(cools()) &&
           verifier.VerifyVectorOfTables(cools()) &&
           verifier.EndTable();
  }
  APPLIERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(APPLIERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<APPLIER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const APPLIERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct APPLIERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_EF(uint8_t EF) {
    fbb_.AddElement<uint8_t>(APPLIER::VT_EF, EF, 0);
  }
  void add_PE(int16_t PE) {
    fbb_.AddElement<int16_t>(APPLIER::VT_PE, PE, 0);
  }
  void add_VA(int32_t VA) {
    fbb_.AddElement<int32_t>(APPLIER::VT_VA, VA, 0);
  }
  void add_removed(bool removed) {
    fbb_.AddElement<uint8_t>(APPLIER::VT_REMOVED, static_cast<uint8_t>(removed), 0);
  }
  void add_hit(flatbuffers::Offset<ACTOR_HIT_UPDATE> hit) {
    fbb_.AddOffset(APPLIER::VT_HIT, hit);
  }
  void add_move(flatbuffers::Offset<ACTOR_UPDATE> move) {
    fbb_.AddOffset(APPLIER::VT_MOVE, move);
  }
  void add_cools(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<COOLTIME_UPDATE>>> cools) {
    fbb_.AddOffset(APPLIER::VT_COOLS, cools);
  }
  explicit APPLIERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  APPLIERBuilder &operator=(const APPLIERBuilder &);
  flatbuffers::Offset<APPLIER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<APPLIER>(end);
    return o;
  }
};

inline flatbuffers::Offset<APPLIER> CreateAPPLIER(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t EF = 0,
    int16_t PE = 0,
    int32_t VA = 0,
    bool removed = false,
    flatbuffers::Offset<ACTOR_HIT_UPDATE> hit = 0,
    flatbuffers::Offset<ACTOR_UPDATE> move = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<COOLTIME_UPDATE>>> cools = 0) {
  APPLIERBuilder builder_(_fbb);
  builder_.add_cools(cools);
  builder_.add_move(move);
  builder_.add_hit(hit);
  builder_.add_VA(VA);
  builder_.add_PE(PE);
  builder_.add_removed(removed);
  builder_.add_EF(EF);
  return builder_.Finish();
}

inline flatbuffers::Offset<APPLIER> CreateAPPLIERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t EF = 0,
    int16_t PE = 0,
    int32_t VA = 0,
    bool removed = false,
    flatbuffers::Offset<ACTOR_HIT_UPDATE> hit = 0,
    flatbuffers::Offset<ACTOR_UPDATE> move = 0,
    const std::vector<flatbuffers::Offset<COOLTIME_UPDATE>> *cools = nullptr) {
  return OVERLORD::RTS::STRUCT::CreateAPPLIER(
      _fbb,
      EF,
      PE,
      VA,
      removed,
      hit,
      move,
      cools ? _fbb.CreateVector<flatbuffers::Offset<COOLTIME_UPDATE>>(*cools) : 0);
}

flatbuffers::Offset<APPLIER> CreateAPPLIER(flatbuffers::FlatBufferBuilder &_fbb, const APPLIERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SLOTT : public flatbuffers::NativeTable {
  typedef SLOT TableType;
  uint8_t type;
  bool removed;
  SLOTT()
      : type(0),
        removed(false) {
  }
};

struct SLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SLOTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_REMOVED = 6
  };
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  bool removed() const {
    return GetField<uint8_t>(VT_REMOVED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_REMOVED) &&
           verifier.EndTable();
  }
  SLOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SLOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SLOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(SLOT::VT_TYPE, type, 0);
  }
  void add_removed(bool removed) {
    fbb_.AddElement<uint8_t>(SLOT::VT_REMOVED, static_cast<uint8_t>(removed), 0);
  }
  explicit SLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SLOTBuilder &operator=(const SLOTBuilder &);
  flatbuffers::Offset<SLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<SLOT> CreateSLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type = 0,
    bool removed = false) {
  SLOTBuilder builder_(_fbb);
  builder_.add_removed(removed);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<SLOT> CreateSLOT(flatbuffers::FlatBufferBuilder &_fbb, const SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACTOR_UPDATET : public flatbuffers::NativeTable {
  typedef ACTOR_UPDATE TableType;
  uint16_t actorUK;
  bool isStop;
  std::unique_ptr<RTS_VECTORT> location;
  std::unique_ptr<RTS_VECTORT> direction;
  ACTOR_UPDATET()
      : actorUK(0),
        isStop(true) {
  }
};

struct ACTOR_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACTOR_UPDATET NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_ISSTOP = 6,
    VT_LOCATION = 8,
    VT_DIRECTION = 10
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool isStop() const {
    return GetField<uint8_t>(VT_ISSTOP, 1) != 0;
  }
  const RTS_VECTOR *location() const {
    return GetPointer<const RTS_VECTOR *>(VT_LOCATION);
  }
  const RTS_VECTOR *direction() const {
    return GetPointer<const RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_ISSTOP) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  ACTOR_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACTOR_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACTOR_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACTOR_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_isStop(bool isStop) {
    fbb_.AddElement<uint8_t>(ACTOR_UPDATE::VT_ISSTOP, static_cast<uint8_t>(isStop), 1);
  }
  void add_location(flatbuffers::Offset<RTS_VECTOR> location) {
    fbb_.AddOffset(ACTOR_UPDATE::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<RTS_VECTOR> direction) {
    fbb_.AddOffset(ACTOR_UPDATE::VT_DIRECTION, direction);
  }
  explicit ACTOR_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACTOR_UPDATEBuilder &operator=(const ACTOR_UPDATEBuilder &);
  flatbuffers::Offset<ACTOR_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACTOR_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACTOR_UPDATE> CreateACTOR_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    bool isStop = true,
    flatbuffers::Offset<RTS_VECTOR> location = 0,
    flatbuffers::Offset<RTS_VECTOR> direction = 0) {
  ACTOR_UPDATEBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actorUK(actorUK);
  builder_.add_isStop(isStop);
  return builder_.Finish();
}

flatbuffers::Offset<ACTOR_UPDATE> CreateACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACTOR_HIT_UPDATET : public flatbuffers::NativeTable {
  typedef ACTOR_HIT_UPDATE TableType;
  uint16_t actorUK;
  uint32_t curHp;
  uint32_t shield;
  uint8_t type;
  uint32_t damage;
  ACTOR_HIT_UPDATET()
      : actorUK(0),
        curHp(0),
        shield(0),
        type(0),
        damage(0) {
  }
};

struct ACTOR_HIT_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACTOR_HIT_UPDATET NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_CURHP = 6,
    VT_SHIELD = 8,
    VT_TYPE = 10,
    VT_DAMAGE = 12
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint32_t curHp() const {
    return GetField<uint32_t>(VT_CURHP, 0);
  }
  uint32_t shield() const {
    return GetField<uint32_t>(VT_SHIELD, 0);
  }
  uint8_t type() const {
    return GetField<uint8_t>(VT_TYPE, 0);
  }
  uint32_t damage() const {
    return GetField<uint32_t>(VT_DAMAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint32_t>(verifier, VT_CURHP) &&
           VerifyField<uint32_t>(verifier, VT_SHIELD) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_DAMAGE) &&
           verifier.EndTable();
  }
  ACTOR_HIT_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACTOR_HIT_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACTOR_HIT_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_HIT_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACTOR_HIT_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACTOR_HIT_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_curHp(uint32_t curHp) {
    fbb_.AddElement<uint32_t>(ACTOR_HIT_UPDATE::VT_CURHP, curHp, 0);
  }
  void add_shield(uint32_t shield) {
    fbb_.AddElement<uint32_t>(ACTOR_HIT_UPDATE::VT_SHIELD, shield, 0);
  }
  void add_type(uint8_t type) {
    fbb_.AddElement<uint8_t>(ACTOR_HIT_UPDATE::VT_TYPE, type, 0);
  }
  void add_damage(uint32_t damage) {
    fbb_.AddElement<uint32_t>(ACTOR_HIT_UPDATE::VT_DAMAGE, damage, 0);
  }
  explicit ACTOR_HIT_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACTOR_HIT_UPDATEBuilder &operator=(const ACTOR_HIT_UPDATEBuilder &);
  flatbuffers::Offset<ACTOR_HIT_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACTOR_HIT_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACTOR_HIT_UPDATE> CreateACTOR_HIT_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    uint32_t curHp = 0,
    uint32_t shield = 0,
    uint8_t type = 0,
    uint32_t damage = 0) {
  ACTOR_HIT_UPDATEBuilder builder_(_fbb);
  builder_.add_damage(damage);
  builder_.add_shield(shield);
  builder_.add_curHp(curHp);
  builder_.add_actorUK(actorUK);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ACTOR_HIT_UPDATE> CreateACTOR_HIT_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_HIT_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACTOR_SNA_UPDATET : public flatbuffers::NativeTable {
  typedef ACTOR_SNA_UPDATE TableType;
  uint16_t actorUK;
  std::vector<std::unique_ptr<SLOTT>> slots;
  std::vector<std::unique_ptr<APPLIERT>> appliers;
  ACTOR_SNA_UPDATET()
      : actorUK(0) {
  }
};

struct ACTOR_SNA_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACTOR_SNA_UPDATET NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_SLOTS = 6,
    VT_APPLIERS = 8
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SLOT>> *slots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SLOT>> *>(VT_SLOTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<APPLIER>> *appliers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<APPLIER>> *>(VT_APPLIERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_SLOTS) &&
           verifier.Verify(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           VerifyOffset(verifier, VT_APPLIERS) &&
           verifier.Verify(appliers()) &&
           verifier.VerifyVectorOfTables(appliers()) &&
           verifier.EndTable();
  }
  ACTOR_SNA_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACTOR_SNA_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACTOR_SNA_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_SNA_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACTOR_SNA_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACTOR_SNA_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLOT>>> slots) {
    fbb_.AddOffset(ACTOR_SNA_UPDATE::VT_SLOTS, slots);
  }
  void add_appliers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<APPLIER>>> appliers) {
    fbb_.AddOffset(ACTOR_SNA_UPDATE::VT_APPLIERS, appliers);
  }
  explicit ACTOR_SNA_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACTOR_SNA_UPDATEBuilder &operator=(const ACTOR_SNA_UPDATEBuilder &);
  flatbuffers::Offset<ACTOR_SNA_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACTOR_SNA_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACTOR_SNA_UPDATE> CreateACTOR_SNA_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SLOT>>> slots = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<APPLIER>>> appliers = 0) {
  ACTOR_SNA_UPDATEBuilder builder_(_fbb);
  builder_.add_appliers(appliers);
  builder_.add_slots(slots);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACTOR_SNA_UPDATE> CreateACTOR_SNA_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    const std::vector<flatbuffers::Offset<SLOT>> *slots = nullptr,
    const std::vector<flatbuffers::Offset<APPLIER>> *appliers = nullptr) {
  return OVERLORD::RTS::STRUCT::CreateACTOR_SNA_UPDATE(
      _fbb,
      actorUK,
      slots ? _fbb.CreateVector<flatbuffers::Offset<SLOT>>(*slots) : 0,
      appliers ? _fbb.CreateVector<flatbuffers::Offset<APPLIER>>(*appliers) : 0);
}

flatbuffers::Offset<ACTOR_SNA_UPDATE> CreateACTOR_SNA_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_SNA_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COOLTIME_UPDATET : public flatbuffers::NativeTable {
  typedef COOLTIME_UPDATE TableType;
  uint8_t slot;
  int32_t coolbonusMSec;
  COOLTIME_UPDATET()
      : slot(0),
        coolbonusMSec(0) {
  }
};

struct COOLTIME_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COOLTIME_UPDATET NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_COOLBONUSMSEC = 6
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  int32_t coolbonusMSec() const {
    return GetField<int32_t>(VT_COOLBONUSMSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<int32_t>(verifier, VT_COOLBONUSMSEC) &&
           verifier.EndTable();
  }
  COOLTIME_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COOLTIME_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COOLTIME_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COOLTIME_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COOLTIME_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(COOLTIME_UPDATE::VT_SLOT, slot, 0);
  }
  void add_coolbonusMSec(int32_t coolbonusMSec) {
    fbb_.AddElement<int32_t>(COOLTIME_UPDATE::VT_COOLBONUSMSEC, coolbonusMSec, 0);
  }
  explicit COOLTIME_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COOLTIME_UPDATEBuilder &operator=(const COOLTIME_UPDATEBuilder &);
  flatbuffers::Offset<COOLTIME_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COOLTIME_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<COOLTIME_UPDATE> CreateCOOLTIME_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    int32_t coolbonusMSec = 0) {
  COOLTIME_UPDATEBuilder builder_(_fbb);
  builder_.add_coolbonusMSec(coolbonusMSec);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<COOLTIME_UPDATE> CreateCOOLTIME_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const COOLTIME_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SKILL_PIVOTT : public flatbuffers::NativeTable {
  typedef SKILL_PIVOT TableType;
  std::unique_ptr<RTS_VECTORT> startPos;
  uint16_t targetUK;
  std::unique_ptr<RTS_VECTORT> location;
  std::unique_ptr<RTS_VECTORT> direction;
  SKILL_PIVOTT()
      : targetUK(0) {
  }
};

struct SKILL_PIVOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SKILL_PIVOTT NativeTableType;
  enum {
    VT_STARTPOS = 4,
    VT_TARGETUK = 6,
    VT_LOCATION = 8,
    VT_DIRECTION = 10
  };
  const RTS_VECTOR *startPos() const {
    return GetPointer<const RTS_VECTOR *>(VT_STARTPOS);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  const RTS_VECTOR *location() const {
    return GetPointer<const RTS_VECTOR *>(VT_LOCATION);
  }
  const RTS_VECTOR *direction() const {
    return GetPointer<const RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STARTPOS) &&
           verifier.VerifyTable(startPos()) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  SKILL_PIVOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SKILL_PIVOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SKILL_PIVOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SKILL_PIVOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SKILL_PIVOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_startPos(flatbuffers::Offset<RTS_VECTOR> startPos) {
    fbb_.AddOffset(SKILL_PIVOT::VT_STARTPOS, startPos);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(SKILL_PIVOT::VT_TARGETUK, targetUK, 0);
  }
  void add_location(flatbuffers::Offset<RTS_VECTOR> location) {
    fbb_.AddOffset(SKILL_PIVOT::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<RTS_VECTOR> direction) {
    fbb_.AddOffset(SKILL_PIVOT::VT_DIRECTION, direction);
  }
  explicit SKILL_PIVOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SKILL_PIVOTBuilder &operator=(const SKILL_PIVOTBuilder &);
  flatbuffers::Offset<SKILL_PIVOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SKILL_PIVOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<SKILL_PIVOT> CreateSKILL_PIVOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<RTS_VECTOR> startPos = 0,
    uint16_t targetUK = 0,
    flatbuffers::Offset<RTS_VECTOR> location = 0,
    flatbuffers::Offset<RTS_VECTOR> direction = 0) {
  SKILL_PIVOTBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_startPos(startPos);
  builder_.add_targetUK(targetUK);
  return builder_.Finish();
}

flatbuffers::Offset<SKILL_PIVOT> CreateSKILL_PIVOT(flatbuffers::FlatBufferBuilder &_fbb, const SKILL_PIVOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RTS_DECKT : public flatbuffers::NativeTable {
  typedef RTS_DECK TableType;
  uint8_t slot;
  std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT> leader;
  std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT> crew11;
  std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT> crew12;
  std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT> crew21;
  std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT> crew22;
  RTS_DECKT()
      : slot(0) {
  }
};

struct RTS_DECK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RTS_DECKT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_LEADER = 6,
    VT_CREW11 = 8,
    VT_CREW12 = 10,
    VT_CREW21 = 12,
    VT_CREW22 = 14
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  const OVERLORD::STRUCT::EQUIPED_HERO *leader() const {
    return GetPointer<const OVERLORD::STRUCT::EQUIPED_HERO *>(VT_LEADER);
  }
  const OVERLORD::STRUCT::EQUIPED_HERO *crew11() const {
    return GetPointer<const OVERLORD::STRUCT::EQUIPED_HERO *>(VT_CREW11);
  }
  const OVERLORD::STRUCT::EQUIPED_HERO *crew12() const {
    return GetPointer<const OVERLORD::STRUCT::EQUIPED_HERO *>(VT_CREW12);
  }
  const OVERLORD::STRUCT::EQUIPED_HERO *crew21() const {
    return GetPointer<const OVERLORD::STRUCT::EQUIPED_HERO *>(VT_CREW21);
  }
  const OVERLORD::STRUCT::EQUIPED_HERO *crew22() const {
    return GetPointer<const OVERLORD::STRUCT::EQUIPED_HERO *>(VT_CREW22);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_LEADER) &&
           verifier.VerifyTable(leader()) &&
           VerifyOffset(verifier, VT_CREW11) &&
           verifier.VerifyTable(crew11()) &&
           VerifyOffset(verifier, VT_CREW12) &&
           verifier.VerifyTable(crew12()) &&
           VerifyOffset(verifier, VT_CREW21) &&
           verifier.VerifyTable(crew21()) &&
           VerifyOffset(verifier, VT_CREW22) &&
           verifier.VerifyTable(crew22()) &&
           verifier.EndTable();
  }
  RTS_DECKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RTS_DECKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RTS_DECK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_DECKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RTS_DECKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(RTS_DECK::VT_SLOT, slot, 0);
  }
  void add_leader(flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> leader) {
    fbb_.AddOffset(RTS_DECK::VT_LEADER, leader);
  }
  void add_crew11(flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew11) {
    fbb_.AddOffset(RTS_DECK::VT_CREW11, crew11);
  }
  void add_crew12(flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew12) {
    fbb_.AddOffset(RTS_DECK::VT_CREW12, crew12);
  }
  void add_crew21(flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew21) {
    fbb_.AddOffset(RTS_DECK::VT_CREW21, crew21);
  }
  void add_crew22(flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew22) {
    fbb_.AddOffset(RTS_DECK::VT_CREW22, crew22);
  }
  explicit RTS_DECKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RTS_DECKBuilder &operator=(const RTS_DECKBuilder &);
  flatbuffers::Offset<RTS_DECK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RTS_DECK>(end);
    return o;
  }
};

inline flatbuffers::Offset<RTS_DECK> CreateRTS_DECK(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> leader = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew11 = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew12 = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew21 = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO> crew22 = 0) {
  RTS_DECKBuilder builder_(_fbb);
  builder_.add_crew22(crew22);
  builder_.add_crew21(crew21);
  builder_.add_crew12(crew12);
  builder_.add_crew11(crew11);
  builder_.add_leader(leader);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<RTS_DECK> CreateRTS_DECK(flatbuffers::FlatBufferBuilder &_fbb, const RTS_DECKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DICET : public flatbuffers::NativeTable {
  typedef DICE TableType;
  int32_t kId;
  uint16_t dice;
  DICET()
      : kId(0),
        dice(0) {
  }
};

struct DICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DICET NativeTableType;
  enum {
    VT_KID = 4,
    VT_DICE = 6
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  uint16_t dice() const {
    return GetField<uint16_t>(VT_DICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint16_t>(verifier, VT_DICE) &&
           verifier.EndTable();
  }
  DICET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DICET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DICE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DICET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DICEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(DICE::VT_KID, kId, 0);
  }
  void add_dice(uint16_t dice) {
    fbb_.AddElement<uint16_t>(DICE::VT_DICE, dice, 0);
  }
  explicit DICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DICEBuilder &operator=(const DICEBuilder &);
  flatbuffers::Offset<DICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DICE>(end);
    return o;
  }
};

inline flatbuffers::Offset<DICE> CreateDICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    uint16_t dice = 0) {
  DICEBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_dice(dice);
  return builder_.Finish();
}

flatbuffers::Offset<DICE> CreateDICE(flatbuffers::FlatBufferBuilder &_fbb, const DICET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace STRUCT

namespace IC {

struct ROOM_JOINT : public flatbuffers::NativeTable {
  typedef ROOM_JOIN TableType;
  std::string proxyID;
  std::string roomkey;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_DECKT> deck;
  ROOM_JOINT() {
  }
};

struct ROOM_JOIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROOM_JOINT NativeTableType;
  enum {
    VT_PROXYID = 4,
    VT_ROOMKEY = 6,
    VT_PLAYER = 8,
    VT_DECK = 10
  };
  const flatbuffers::String *proxyID() const {
    return GetPointer<const flatbuffers::String *>(VT_PROXYID);
  }
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const OVERLORD::RTS::STRUCT::RTS_DECK *deck() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_DECK *>(VT_DECK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROXYID) &&
           verifier.Verify(proxyID()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_DECK) &&
           verifier.VerifyTable(deck()) &&
           verifier.EndTable();
  }
  ROOM_JOINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROOM_JOINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROOM_JOIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROOM_JOINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proxyID(flatbuffers::Offset<flatbuffers::String> proxyID) {
    fbb_.AddOffset(ROOM_JOIN::VT_PROXYID, proxyID);
  }
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ROOM_JOIN::VT_ROOMKEY, roomkey);
  }
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ROOM_JOIN::VT_PLAYER, player);
  }
  void add_deck(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck) {
    fbb_.AddOffset(ROOM_JOIN::VT_DECK, deck);
  }
  explicit ROOM_JOINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROOM_JOINBuilder &operator=(const ROOM_JOINBuilder &);
  flatbuffers::Offset<ROOM_JOIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROOM_JOIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROOM_JOIN> CreateROOM_JOIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> proxyID = 0,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck = 0) {
  ROOM_JOINBuilder builder_(_fbb);
  builder_.add_deck(deck);
  builder_.add_player(player);
  builder_.add_roomkey(roomkey);
  builder_.add_proxyID(proxyID);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROOM_JOIN> CreateROOM_JOINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *proxyID = nullptr,
    const char *roomkey = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck = 0) {
  return OVERLORD::RTS::IC::CreateROOM_JOIN(
      _fbb,
      proxyID ? _fbb.CreateString(proxyID) : 0,
      roomkey ? _fbb.CreateString(roomkey) : 0,
      player,
      deck);
}

flatbuffers::Offset<ROOM_JOIN> CreateROOM_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROOM_REJOINT : public flatbuffers::NativeTable {
  typedef ROOM_REJOIN TableType;
  std::string proxyID;
  std::string roomkey;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_DECKT> deck;
  ROOM_REJOINT() {
  }
};

struct ROOM_REJOIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROOM_REJOINT NativeTableType;
  enum {
    VT_PROXYID = 4,
    VT_ROOMKEY = 6,
    VT_PLAYER = 8,
    VT_DECK = 10
  };
  const flatbuffers::String *proxyID() const {
    return GetPointer<const flatbuffers::String *>(VT_PROXYID);
  }
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const OVERLORD::RTS::STRUCT::RTS_DECK *deck() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_DECK *>(VT_DECK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROXYID) &&
           verifier.Verify(proxyID()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_DECK) &&
           verifier.VerifyTable(deck()) &&
           verifier.EndTable();
  }
  ROOM_REJOINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROOM_REJOINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROOM_REJOIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_REJOINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROOM_REJOINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proxyID(flatbuffers::Offset<flatbuffers::String> proxyID) {
    fbb_.AddOffset(ROOM_REJOIN::VT_PROXYID, proxyID);
  }
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ROOM_REJOIN::VT_ROOMKEY, roomkey);
  }
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ROOM_REJOIN::VT_PLAYER, player);
  }
  void add_deck(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck) {
    fbb_.AddOffset(ROOM_REJOIN::VT_DECK, deck);
  }
  explicit ROOM_REJOINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROOM_REJOINBuilder &operator=(const ROOM_REJOINBuilder &);
  flatbuffers::Offset<ROOM_REJOIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROOM_REJOIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROOM_REJOIN> CreateROOM_REJOIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> proxyID = 0,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck = 0) {
  ROOM_REJOINBuilder builder_(_fbb);
  builder_.add_deck(deck);
  builder_.add_player(player);
  builder_.add_roomkey(roomkey);
  builder_.add_proxyID(proxyID);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROOM_REJOIN> CreateROOM_REJOINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *proxyID = nullptr,
    const char *roomkey = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_DECK> deck = 0) {
  return OVERLORD::RTS::IC::CreateROOM_REJOIN(
      _fbb,
      proxyID ? _fbb.CreateString(proxyID) : 0,
      roomkey ? _fbb.CreateString(roomkey) : 0,
      player,
      deck);
}

flatbuffers::Offset<ROOM_REJOIN> CreateROOM_REJOIN(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_REJOINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct NPC_HANDLER_JOINT : public flatbuffers::NativeTable {
  typedef NPC_HANDLER_JOIN TableType;
  std::string roomkey;
  NPC_HANDLER_JOINT() {
  }
};

struct NPC_HANDLER_JOIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NPC_HANDLER_JOINT NativeTableType;
  enum {
    VT_ROOMKEY = 4
  };
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           verifier.EndTable();
  }
  NPC_HANDLER_JOINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(NPC_HANDLER_JOINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<NPC_HANDLER_JOIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const NPC_HANDLER_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct NPC_HANDLER_JOINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(NPC_HANDLER_JOIN::VT_ROOMKEY, roomkey);
  }
  explicit NPC_HANDLER_JOINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NPC_HANDLER_JOINBuilder &operator=(const NPC_HANDLER_JOINBuilder &);
  flatbuffers::Offset<NPC_HANDLER_JOIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NPC_HANDLER_JOIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<NPC_HANDLER_JOIN> CreateNPC_HANDLER_JOIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0) {
  NPC_HANDLER_JOINBuilder builder_(_fbb);
  builder_.add_roomkey(roomkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<NPC_HANDLER_JOIN> CreateNPC_HANDLER_JOINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *roomkey = nullptr) {
  return OVERLORD::RTS::IC::CreateNPC_HANDLER_JOIN(
      _fbb,
      roomkey ? _fbb.CreateString(roomkey) : 0);
}

flatbuffers::Offset<NPC_HANDLER_JOIN> CreateNPC_HANDLER_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const NPC_HANDLER_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROOM_PLAYERT : public flatbuffers::NativeTable {
  typedef ROOM_PLAYER TableType;
  std::string proxyID;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>> heros;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ROOM_PLAYERT() {
  }
};

struct ROOM_PLAYER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROOM_PLAYERT NativeTableType;
  enum {
    VT_PROXYID = 4,
    VT_PLAYER = 6,
    VT_HEROS = 8,
    VT_ERROR = 10
  };
  const flatbuffers::String *proxyID() const {
    return GetPointer<const flatbuffers::String *>(VT_PROXYID);
  }
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>> *heros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>> *>(VT_HEROS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROXYID) &&
           verifier.Verify(proxyID()) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_HEROS) &&
           verifier.Verify(heros()) &&
           verifier.VerifyVectorOfTables(heros()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ROOM_PLAYERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROOM_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROOM_PLAYER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROOM_PLAYERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proxyID(flatbuffers::Offset<flatbuffers::String> proxyID) {
    fbb_.AddOffset(ROOM_PLAYER::VT_PROXYID, proxyID);
  }
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ROOM_PLAYER::VT_PLAYER, player);
  }
  void add_heros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>>> heros) {
    fbb_.AddOffset(ROOM_PLAYER::VT_HEROS, heros);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ROOM_PLAYER::VT_ERROR, error);
  }
  explicit ROOM_PLAYERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROOM_PLAYERBuilder &operator=(const ROOM_PLAYERBuilder &);
  flatbuffers::Offset<ROOM_PLAYER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROOM_PLAYER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROOM_PLAYER> CreateROOM_PLAYER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> proxyID = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>>> heros = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ROOM_PLAYERBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_heros(heros);
  builder_.add_player(player);
  builder_.add_proxyID(proxyID);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROOM_PLAYER> CreateROOM_PLAYERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *proxyID = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>> *heros = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::IC::CreateROOM_PLAYER(
      _fbb,
      proxyID ? _fbb.CreateString(proxyID) : 0,
      player,
      heros ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>>(*heros) : 0,
      error);
}

flatbuffers::Offset<ROOM_PLAYER> CreateROOM_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROOM_PLAYER_DISCONNECTEDT : public flatbuffers::NativeTable {
  typedef ROOM_PLAYER_DISCONNECTED TableType;
  std::string roomkey;
  std::string proxyID;
  ROOM_PLAYER_DISCONNECTEDT() {
  }
};

struct ROOM_PLAYER_DISCONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROOM_PLAYER_DISCONNECTEDT NativeTableType;
  enum {
    VT_ROOMKEY = 4,
    VT_PROXYID = 6
  };
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  const flatbuffers::String *proxyID() const {
    return GetPointer<const flatbuffers::String *>(VT_PROXYID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           VerifyOffset(verifier, VT_PROXYID) &&
           verifier.Verify(proxyID()) &&
           verifier.EndTable();
  }
  ROOM_PLAYER_DISCONNECTEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROOM_PLAYER_DISCONNECTEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYER_DISCONNECTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROOM_PLAYER_DISCONNECTEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ROOM_PLAYER_DISCONNECTED::VT_ROOMKEY, roomkey);
  }
  void add_proxyID(flatbuffers::Offset<flatbuffers::String> proxyID) {
    fbb_.AddOffset(ROOM_PLAYER_DISCONNECTED::VT_PROXYID, proxyID);
  }
  explicit ROOM_PLAYER_DISCONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROOM_PLAYER_DISCONNECTEDBuilder &operator=(const ROOM_PLAYER_DISCONNECTEDBuilder &);
  flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> CreateROOM_PLAYER_DISCONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0,
    flatbuffers::Offset<flatbuffers::String> proxyID = 0) {
  ROOM_PLAYER_DISCONNECTEDBuilder builder_(_fbb);
  builder_.add_proxyID(proxyID);
  builder_.add_roomkey(roomkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> CreateROOM_PLAYER_DISCONNECTEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *roomkey = nullptr,
    const char *proxyID = nullptr) {
  return OVERLORD::RTS::IC::CreateROOM_PLAYER_DISCONNECTED(
      _fbb,
      roomkey ? _fbb.CreateString(roomkey) : 0,
      proxyID ? _fbb.CreateString(proxyID) : 0);
}

flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> CreateROOM_PLAYER_DISCONNECTED(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYER_DISCONNECTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROOM_DISPOSET : public flatbuffers::NativeTable {
  typedef ROOM_DISPOSE TableType;
  std::string roomkey;
  ROOM_DISPOSET() {
  }
};

struct ROOM_DISPOSE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROOM_DISPOSET NativeTableType;
  enum {
    VT_ROOMKEY = 4
  };
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           verifier.EndTable();
  }
  ROOM_DISPOSET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROOM_DISPOSET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROOM_DISPOSE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_DISPOSET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROOM_DISPOSEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ROOM_DISPOSE::VT_ROOMKEY, roomkey);
  }
  explicit ROOM_DISPOSEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROOM_DISPOSEBuilder &operator=(const ROOM_DISPOSEBuilder &);
  flatbuffers::Offset<ROOM_DISPOSE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROOM_DISPOSE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROOM_DISPOSE> CreateROOM_DISPOSE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0) {
  ROOM_DISPOSEBuilder builder_(_fbb);
  builder_.add_roomkey(roomkey);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROOM_DISPOSE> CreateROOM_DISPOSEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *roomkey = nullptr) {
  return OVERLORD::RTS::IC::CreateROOM_DISPOSE(
      _fbb,
      roomkey ? _fbb.CreateString(roomkey) : 0);
}

flatbuffers::Offset<ROOM_DISPOSE> CreateROOM_DISPOSE(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_DISPOSET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IC_BT_ACTOR_MOVET : public flatbuffers::NativeTable {
  typedef IC_BT_ACTOR_MOVE TableType;
  uint32_t frame;
  uint16_t actorUK;
  bool isStop;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  std::vector<uint16_t> zone;
  IC_BT_ACTOR_MOVET()
      : frame(0),
        actorUK(0),
        isStop(false) {
  }
};

struct IC_BT_ACTOR_MOVE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IC_BT_ACTOR_MOVET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ISSTOP = 8,
    VT_LOCATION = 10,
    VT_DIRECTION = 12,
    VT_ZONE = 14
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool isStop() const {
    return GetField<uint8_t>(VT_ISSTOP, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  const flatbuffers::Vector<uint16_t> *zone() const {
    return GetPointer<const flatbuffers::Vector<uint16_t> *>(VT_ZONE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_ISSTOP) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           VerifyOffset(verifier, VT_ZONE) &&
           verifier.Verify(zone()) &&
           verifier.EndTable();
  }
  IC_BT_ACTOR_MOVET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IC_BT_ACTOR_MOVET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IC_BT_ACTOR_MOVE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IC_BT_ACTOR_MOVEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(IC_BT_ACTOR_MOVE::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(IC_BT_ACTOR_MOVE::VT_ACTORUK, actorUK, 0);
  }
  void add_isStop(bool isStop) {
    fbb_.AddElement<uint8_t>(IC_BT_ACTOR_MOVE::VT_ISSTOP, static_cast<uint8_t>(isStop), 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(IC_BT_ACTOR_MOVE::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(IC_BT_ACTOR_MOVE::VT_DIRECTION, direction);
  }
  void add_zone(flatbuffers::Offset<flatbuffers::Vector<uint16_t>> zone) {
    fbb_.AddOffset(IC_BT_ACTOR_MOVE::VT_ZONE, zone);
  }
  explicit IC_BT_ACTOR_MOVEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IC_BT_ACTOR_MOVEBuilder &operator=(const IC_BT_ACTOR_MOVEBuilder &);
  flatbuffers::Offset<IC_BT_ACTOR_MOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IC_BT_ACTOR_MOVE>(end);
    return o;
  }
};

inline flatbuffers::Offset<IC_BT_ACTOR_MOVE> CreateIC_BT_ACTOR_MOVE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    bool isStop = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint16_t>> zone = 0) {
  IC_BT_ACTOR_MOVEBuilder builder_(_fbb);
  builder_.add_zone(zone);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_isStop(isStop);
  return builder_.Finish();
}

inline flatbuffers::Offset<IC_BT_ACTOR_MOVE> CreateIC_BT_ACTOR_MOVEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    bool isStop = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0,
    const std::vector<uint16_t> *zone = nullptr) {
  return OVERLORD::RTS::IC::CreateIC_BT_ACTOR_MOVE(
      _fbb,
      frame,
      actorUK,
      isStop,
      location,
      direction,
      zone ? _fbb.CreateVector<uint16_t>(*zone) : 0);
}

flatbuffers::Offset<IC_BT_ACTOR_MOVE> CreateIC_BT_ACTOR_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IC_SPAWN_NPCT : public flatbuffers::NativeTable {
  typedef IC_SPAWN_NPC TableType;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  IC_SPAWN_NPCT()
      : sequence(0) {
  }
};

struct IC_SPAWN_NPC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IC_SPAWN_NPCT NativeTableType;
  enum {
    VT_SEQUENCE = 4,
    VT_ERROR = 6
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  IC_SPAWN_NPCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IC_SPAWN_NPCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IC_SPAWN_NPC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_SPAWN_NPCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IC_SPAWN_NPCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(IC_SPAWN_NPC::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(IC_SPAWN_NPC::VT_ERROR, error);
  }
  explicit IC_SPAWN_NPCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IC_SPAWN_NPCBuilder &operator=(const IC_SPAWN_NPCBuilder &);
  flatbuffers::Offset<IC_SPAWN_NPC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IC_SPAWN_NPC>(end);
    return o;
  }
};

inline flatbuffers::Offset<IC_SPAWN_NPC> CreateIC_SPAWN_NPC(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  IC_SPAWN_NPCBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<IC_SPAWN_NPC> CreateIC_SPAWN_NPC(flatbuffers::FlatBufferBuilder &_fbb, const IC_SPAWN_NPCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IC_BT_ACTOR_RESPAWNT : public flatbuffers::NativeTable {
  typedef IC_BT_ACTOR_RESPAWN TableType;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  IC_BT_ACTOR_RESPAWNT()
      : actorUK(0) {
  }
};

struct IC_BT_ACTOR_RESPAWN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IC_BT_ACTOR_RESPAWNT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_LOCATION = 6,
    VT_DIRECTION = 8
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           verifier.EndTable();
  }
  IC_BT_ACTOR_RESPAWNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IC_BT_ACTOR_RESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_RESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IC_BT_ACTOR_RESPAWNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(IC_BT_ACTOR_RESPAWN::VT_ACTORUK, actorUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(IC_BT_ACTOR_RESPAWN::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(IC_BT_ACTOR_RESPAWN::VT_DIRECTION, direction);
  }
  explicit IC_BT_ACTOR_RESPAWNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IC_BT_ACTOR_RESPAWNBuilder &operator=(const IC_BT_ACTOR_RESPAWNBuilder &);
  flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IC_BT_ACTOR_RESPAWN>(end);
    return o;
  }
};

inline flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> CreateIC_BT_ACTOR_RESPAWN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0) {
  IC_BT_ACTOR_RESPAWNBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> CreateIC_BT_ACTOR_RESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_RESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct IC_NPCHOST_STEP_ONT : public flatbuffers::NativeTable {
  typedef IC_NPCHOST_STEP_ON TableType;
  uint16_t trigger;
  IC_NPCHOST_STEP_ONT()
      : trigger(0) {
  }
};

struct IC_NPCHOST_STEP_ON FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IC_NPCHOST_STEP_ONT NativeTableType;
  enum {
    VT_TRIGGER = 4
  };
  uint16_t trigger() const {
    return GetField<uint16_t>(VT_TRIGGER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_TRIGGER) &&
           verifier.EndTable();
  }
  IC_NPCHOST_STEP_ONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(IC_NPCHOST_STEP_ONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<IC_NPCHOST_STEP_ON> Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_NPCHOST_STEP_ONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct IC_NPCHOST_STEP_ONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trigger(uint16_t trigger) {
    fbb_.AddElement<uint16_t>(IC_NPCHOST_STEP_ON::VT_TRIGGER, trigger, 0);
  }
  explicit IC_NPCHOST_STEP_ONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IC_NPCHOST_STEP_ONBuilder &operator=(const IC_NPCHOST_STEP_ONBuilder &);
  flatbuffers::Offset<IC_NPCHOST_STEP_ON> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IC_NPCHOST_STEP_ON>(end);
    return o;
  }
};

inline flatbuffers::Offset<IC_NPCHOST_STEP_ON> CreateIC_NPCHOST_STEP_ON(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t trigger = 0) {
  IC_NPCHOST_STEP_ONBuilder builder_(_fbb);
  builder_.add_trigger(trigger);
  return builder_.Finish();
}

flatbuffers::Offset<IC_NPCHOST_STEP_ON> CreateIC_NPCHOST_STEP_ON(flatbuffers::FlatBufferBuilder &_fbb, const IC_NPCHOST_STEP_ONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace IC

namespace STRUCT {

inline RTS_ERRORT *RTS_ERROR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RTS_ERRORT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RTS_ERROR::UnPackTo(RTS_ERRORT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = code(); if (_e) _o->code = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = desc(); if (_e) { _o->desc.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->desc[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<RTS_ERROR> RTS_ERROR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_ERRORT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRTS_ERROR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RTS_ERROR> CreateRTS_ERROR(flatbuffers::FlatBufferBuilder &_fbb, const RTS_ERRORT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RTS_ERRORT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _desc = _o->desc.size() ? _fbb.CreateVectorOfStrings(_o->desc) : 0;
  return OVERLORD::RTS::STRUCT::CreateRTS_ERROR(
      _fbb,
      _type,
      _code,
      _name,
      _desc);
}

inline RTS_VECTORT *RTS_VECTOR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RTS_VECTORT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RTS_VECTOR::UnPackTo(RTS_VECTORT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = X(); _o->X = _e; };
  { auto _e = Y(); _o->Y = _e; };
  { auto _e = Z(); _o->Z = _e; };
}

inline flatbuffers::Offset<RTS_VECTOR> RTS_VECTOR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_VECTORT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRTS_VECTOR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RTS_VECTOR> CreateRTS_VECTOR(flatbuffers::FlatBufferBuilder &_fbb, const RTS_VECTORT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RTS_VECTORT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto __X = _o->X;
  auto __Y = _o->Y;
  auto __Z = _o->Z;
  return OVERLORD::RTS::STRUCT::CreateRTS_VECTOR(
      _fbb,
      __X,
      __Y,
      __Z);
}

inline PLAY_RESULTT *PLAY_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PLAY_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PLAY_RESULT::UnPackTo(PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = playResult(); _o->playResult = _e; };
}

inline flatbuffers::Offset<PLAY_RESULT> PLAY_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePLAY_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PLAY_RESULT> CreatePLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PLAY_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _playResult = _o->playResult;
  return OVERLORD::RTS::STRUCT::CreatePLAY_RESULT(
      _fbb,
      _kId,
      _playResult);
}

inline PLAYERT *PLAYER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PLAYERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PLAYER::UnPackTo(PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = elevatedFloor(); _o->elevatedFloor = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = guild_id(); _o->guild_id = _e; };
  { auto _e = ability(); if (_e) { _o->ability.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ability[_i] = _e->Get(_i); } } };
  { auto _e = team(); _o->team = _e; };
  { auto _e = party(); _o->party = _e; };
  { auto _e = slot(); _o->slot = _e; };
}

inline flatbuffers::Offset<PLAYER> PLAYER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePLAYER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PLAYER> CreatePLAYER(flatbuffers::FlatBufferBuilder &_fbb, const PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PLAYERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _elevatedFloor = _o->elevatedFloor;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _guild_id = _o->guild_id;
  auto _ability = _o->ability.size() ? _fbb.CreateVector(_o->ability) : 0;
  auto _team = _o->team;
  auto _party = _o->party;
  auto _slot = _o->slot;
  return OVERLORD::RTS::STRUCT::CreatePLAYER(
      _fbb,
      _kId,
      _nick,
      _level,
      _elevatedFloor,
      _guild,
      _guild_id,
      _ability,
      _team,
      _party,
      _slot);
}

inline PARTY_SLOTT *PARTY_SLOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PARTY_SLOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PARTY_SLOT::UnPackTo(PARTY_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
}

inline flatbuffers::Offset<PARTY_SLOT> PARTY_SLOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PARTY_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePARTY_SLOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PARTY_SLOT> CreatePARTY_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const PARTY_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PARTY_SLOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _kId = _o->kId;
  auto _actorUK = _o->actorUK;
  return OVERLORD::RTS::STRUCT::CreatePARTY_SLOT(
      _fbb,
      _slot,
      _kId,
      _actorUK);
}

inline PARTYT *PARTY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PARTYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PARTY::UnPackTo(PARTYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = party(); _o->party = _e; };
  { auto _e = slots(); if (_e) { _o->slots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slots[_i] = std::unique_ptr<PARTY_SLOTT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<PARTY> PARTY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PARTYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePARTY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PARTY> CreatePARTY(flatbuffers::FlatBufferBuilder &_fbb, const PARTYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PARTYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _party = _o->party;
  auto _slots = _o->slots.size() ? _fbb.CreateVector<flatbuffers::Offset<PARTY_SLOT>> (_o->slots.size(), [](size_t i, _VectorArgs *__va) { return CreatePARTY_SLOT(*__va->__fbb, __va->__o->slots[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RTS::STRUCT::CreatePARTY(
      _fbb,
      _party,
      _slots);
}

inline TEAMT *TEAM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TEAMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TEAM::UnPackTo(TEAMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = team(); _o->team = _e; };
  { auto _e = parties(); if (_e) { _o->parties.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->parties[_i] = std::unique_ptr<PARTYT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TEAM> TEAM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TEAMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTEAM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TEAM> CreateTEAM(flatbuffers::FlatBufferBuilder &_fbb, const TEAMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TEAMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _team = _o->team;
  auto _parties = _o->parties.size() ? _fbb.CreateVector<flatbuffers::Offset<PARTY>> (_o->parties.size(), [](size_t i, _VectorArgs *__va) { return CreatePARTY(*__va->__fbb, __va->__o->parties[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RTS::STRUCT::CreateTEAM(
      _fbb,
      _team,
      _parties);
}

inline PLAYER_SCORET *PLAYER_SCORE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PLAYER_SCORET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PLAYER_SCORE::UnPackTo(PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorCategory(); _o->actorCategory = _e; };
  { auto _e = actorId(); if (_e) _o->actorId = _e->str(); };
  { auto _e = damage(); _o->damage = _e; };
  { auto _e = damageSkill(); _o->damageSkill = _e; };
  { auto _e = heal(); _o->heal = _e; };
  { auto _e = damaged(); _o->damaged = _e; };
  { auto _e = skill(); _o->skill = _e; };
  { auto _e = kill(); _o->kill = _e; };
  { auto _e = death(); _o->death = _e; };
  { auto _e = medal(); _o->medal = _e; };
}

inline flatbuffers::Offset<PLAYER_SCORE> PLAYER_SCORE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePLAYER_SCORE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PLAYER_SCORE> CreatePLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PLAYER_SCORET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _actorUK = _o->actorUK;
  auto _actorCategory = _o->actorCategory;
  auto _actorId = _o->actorId.empty() ? 0 : _fbb.CreateString(_o->actorId);
  auto _damage = _o->damage;
  auto _damageSkill = _o->damageSkill;
  auto _heal = _o->heal;
  auto _damaged = _o->damaged;
  auto _skill = _o->skill;
  auto _kill = _o->kill;
  auto _death = _o->death;
  auto _medal = _o->medal;
  return OVERLORD::RTS::STRUCT::CreatePLAYER_SCORE(
      _fbb,
      _kId,
      _nick,
      _actorUK,
      _actorCategory,
      _actorId,
      _damage,
      _damageSkill,
      _heal,
      _damaged,
      _skill,
      _kill,
      _death,
      _medal);
}

inline ITEM_OPTIONT *ITEM_OPTION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ITEM_OPTIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ITEM_OPTION::UnPackTo(ITEM_OPTIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = option(); if (_e) _o->option = _e->str(); };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<ITEM_OPTION> ITEM_OPTION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateITEM_OPTION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ITEM_OPTIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _option = _o->option.empty() ? 0 : _fbb.CreateString(_o->option);
  auto _value = _o->value;
  return OVERLORD::RTS::STRUCT::CreateITEM_OPTION(
      _fbb,
      _option,
      _value);
}

inline ITEMT *ITEM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ITEMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ITEM::UnPackTo(ITEMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = enchant(); _o->enchant = _e; };
  { auto _e = enchantValue(); _o->enchantValue = _e; };
  { auto _e = options(); if (_e) { _o->options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->options[_i] = std::unique_ptr<ITEM_OPTIONT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = jewels(); if (_e) { _o->jewels.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->jewels[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<ITEM> ITEM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateITEM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ITEM> CreateITEM(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ITEMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _level = _o->level;
  auto _enchant = _o->enchant;
  auto _enchantValue = _o->enchantValue;
  auto _options = _o->options.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM_OPTION>> (_o->options.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM_OPTION(*__va->__fbb, __va->__o->options[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _jewels = _o->jewels.size() ? _fbb.CreateVectorOfStrings(_o->jewels) : 0;
  return OVERLORD::RTS::STRUCT::CreateITEM(
      _fbb,
      _itemId,
      _level,
      _enchant,
      _enchantValue,
      _options,
      _jewels);
}

inline ACTORT *ACTOR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACTORT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACTOR::UnPackTo(ACTORT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorCategory(); _o->actorCategory = _e; };
  { auto _e = actorId(); if (_e) _o->actorId = _e->str(); };
  { auto _e = role(); _o->role = _e; };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = subNick(); if (_e) _o->subNick = _e->str(); };
  { auto _e = ability(); if (_e) { _o->ability.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ability[_i] = _e->Get(_i); } } };
  { auto _e = isSummon(); _o->isSummon = _e; };
  { auto _e = primaryUK(); _o->primaryUK = _e; };
  { auto _e = primaryFE(); _o->primaryFE = _e; };
  { auto _e = power(); _o->power = _e; };
  { auto _e = maxHp(); _o->maxHp = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = skills(); if (_e) { _o->skills.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->skills[_i] = _e->Get(_i); } } };
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<ITEMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = team(); _o->team = _e; };
  { auto _e = party(); _o->party = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = teamCode(); _o->teamCode = _e; };
  { auto _e = curHp(); _o->curHp = _e; };
}

inline flatbuffers::Offset<ACTOR> ACTOR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTORT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACTOR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACTOR> CreateACTOR(flatbuffers::FlatBufferBuilder &_fbb, const ACTORT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACTORT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _actorCategory = _o->actorCategory;
  auto _actorId = _o->actorId.empty() ? 0 : _fbb.CreateString(_o->actorId);
  auto _role = _o->role;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _subNick = _o->subNick.empty() ? 0 : _fbb.CreateString(_o->subNick);
  auto _ability = _o->ability.size() ? _fbb.CreateVector(_o->ability) : 0;
  auto _isSummon = _o->isSummon;
  auto _primaryUK = _o->primaryUK;
  auto _primaryFE = _o->primaryFE;
  auto _power = _o->power;
  auto _maxHp = _o->maxHp;
  auto _level = _o->level;
  auto _grade = _o->grade;
  auto _skills = _o->skills.size() ? _fbb.CreateVector(_o->skills) : 0;
  auto _items = _o->items.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _team = _o->team;
  auto _party = _o->party;
  auto _slot = _o->slot;
  auto _teamCode = _o->teamCode;
  auto _curHp = _o->curHp;
  return OVERLORD::RTS::STRUCT::CreateACTOR(
      _fbb,
      _actorUK,
      _actorCategory,
      _actorId,
      _role,
      _kId,
      _nick,
      _subNick,
      _ability,
      _isSummon,
      _primaryUK,
      _primaryFE,
      _power,
      _maxHp,
      _level,
      _grade,
      _skills,
      _items,
      _team,
      _party,
      _slot,
      _teamCode,
      _curHp);
}

inline APPLIERT *APPLIER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new APPLIERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void APPLIER::UnPackTo(APPLIERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = EF(); _o->EF = _e; };
  { auto _e = PE(); _o->PE = _e; };
  { auto _e = VA(); _o->VA = _e; };
  { auto _e = removed(); _o->removed = _e; };
  { auto _e = hit(); if (_e) _o->hit = std::unique_ptr<ACTOR_HIT_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = move(); if (_e) _o->move = std::unique_ptr<ACTOR_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = cools(); if (_e) { _o->cools.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->cools[_i] = std::unique_ptr<COOLTIME_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<APPLIER> APPLIER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const APPLIERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAPPLIER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<APPLIER> CreateAPPLIER(flatbuffers::FlatBufferBuilder &_fbb, const APPLIERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const APPLIERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _EF = _o->EF;
  auto _PE = _o->PE;
  auto _VA = _o->VA;
  auto _removed = _o->removed;
  auto _hit = _o->hit ? CreateACTOR_HIT_UPDATE(_fbb, _o->hit.get(), _rehasher) : 0;
  auto _move = _o->move ? CreateACTOR_UPDATE(_fbb, _o->move.get(), _rehasher) : 0;
  auto _cools = _o->cools.size() ? _fbb.CreateVector<flatbuffers::Offset<COOLTIME_UPDATE>> (_o->cools.size(), [](size_t i, _VectorArgs *__va) { return CreateCOOLTIME_UPDATE(*__va->__fbb, __va->__o->cools[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RTS::STRUCT::CreateAPPLIER(
      _fbb,
      _EF,
      _PE,
      _VA,
      _removed,
      _hit,
      _move,
      _cools);
}

inline SLOTT *SLOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SLOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SLOT::UnPackTo(SLOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = removed(); _o->removed = _e; };
}

inline flatbuffers::Offset<SLOT> SLOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSLOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SLOT> CreateSLOT(flatbuffers::FlatBufferBuilder &_fbb, const SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SLOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _removed = _o->removed;
  return OVERLORD::RTS::STRUCT::CreateSLOT(
      _fbb,
      _type,
      _removed);
}

inline ACTOR_UPDATET *ACTOR_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACTOR_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACTOR_UPDATE::UnPackTo(ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = isStop(); _o->isStop = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACTOR_UPDATE> ACTOR_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACTOR_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACTOR_UPDATE> CreateACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACTOR_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _isStop = _o->isStop;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::STRUCT::CreateACTOR_UPDATE(
      _fbb,
      _actorUK,
      _isStop,
      _location,
      _direction);
}

inline ACTOR_HIT_UPDATET *ACTOR_HIT_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACTOR_HIT_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACTOR_HIT_UPDATE::UnPackTo(ACTOR_HIT_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = curHp(); _o->curHp = _e; };
  { auto _e = shield(); _o->shield = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = damage(); _o->damage = _e; };
}

inline flatbuffers::Offset<ACTOR_HIT_UPDATE> ACTOR_HIT_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_HIT_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACTOR_HIT_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACTOR_HIT_UPDATE> CreateACTOR_HIT_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_HIT_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACTOR_HIT_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _curHp = _o->curHp;
  auto _shield = _o->shield;
  auto _type = _o->type;
  auto _damage = _o->damage;
  return OVERLORD::RTS::STRUCT::CreateACTOR_HIT_UPDATE(
      _fbb,
      _actorUK,
      _curHp,
      _shield,
      _type,
      _damage);
}

inline ACTOR_SNA_UPDATET *ACTOR_SNA_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACTOR_SNA_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACTOR_SNA_UPDATE::UnPackTo(ACTOR_SNA_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slots(); if (_e) { _o->slots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slots[_i] = std::unique_ptr<SLOTT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = appliers(); if (_e) { _o->appliers.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->appliers[_i] = std::unique_ptr<APPLIERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ACTOR_SNA_UPDATE> ACTOR_SNA_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_SNA_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACTOR_SNA_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACTOR_SNA_UPDATE> CreateACTOR_SNA_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACTOR_SNA_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACTOR_SNA_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _slots = _o->slots.size() ? _fbb.CreateVector<flatbuffers::Offset<SLOT>> (_o->slots.size(), [](size_t i, _VectorArgs *__va) { return CreateSLOT(*__va->__fbb, __va->__o->slots[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _appliers = _o->appliers.size() ? _fbb.CreateVector<flatbuffers::Offset<APPLIER>> (_o->appliers.size(), [](size_t i, _VectorArgs *__va) { return CreateAPPLIER(*__va->__fbb, __va->__o->appliers[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RTS::STRUCT::CreateACTOR_SNA_UPDATE(
      _fbb,
      _actorUK,
      _slots,
      _appliers);
}

inline COOLTIME_UPDATET *COOLTIME_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COOLTIME_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COOLTIME_UPDATE::UnPackTo(COOLTIME_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = coolbonusMSec(); _o->coolbonusMSec = _e; };
}

inline flatbuffers::Offset<COOLTIME_UPDATE> COOLTIME_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COOLTIME_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOOLTIME_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COOLTIME_UPDATE> CreateCOOLTIME_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const COOLTIME_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COOLTIME_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _coolbonusMSec = _o->coolbonusMSec;
  return OVERLORD::RTS::STRUCT::CreateCOOLTIME_UPDATE(
      _fbb,
      _slot,
      _coolbonusMSec);
}

inline SKILL_PIVOTT *SKILL_PIVOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SKILL_PIVOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SKILL_PIVOT::UnPackTo(SKILL_PIVOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = startPos(); if (_e) _o->startPos = std::unique_ptr<RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SKILL_PIVOT> SKILL_PIVOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SKILL_PIVOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSKILL_PIVOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SKILL_PIVOT> CreateSKILL_PIVOT(flatbuffers::FlatBufferBuilder &_fbb, const SKILL_PIVOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SKILL_PIVOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _startPos = _o->startPos ? CreateRTS_VECTOR(_fbb, _o->startPos.get(), _rehasher) : 0;
  auto _targetUK = _o->targetUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::STRUCT::CreateSKILL_PIVOT(
      _fbb,
      _startPos,
      _targetUK,
      _location,
      _direction);
}

inline RTS_DECKT *RTS_DECK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RTS_DECKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RTS_DECK::UnPackTo(RTS_DECKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = leader(); if (_e) _o->leader = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->UnPack(_resolver)); };
  { auto _e = crew11(); if (_e) _o->crew11 = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->UnPack(_resolver)); };
  { auto _e = crew12(); if (_e) _o->crew12 = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->UnPack(_resolver)); };
  { auto _e = crew21(); if (_e) _o->crew21 = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->UnPack(_resolver)); };
  { auto _e = crew22(); if (_e) _o->crew22 = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<RTS_DECK> RTS_DECK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RTS_DECKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRTS_DECK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RTS_DECK> CreateRTS_DECK(flatbuffers::FlatBufferBuilder &_fbb, const RTS_DECKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RTS_DECKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _leader = _o->leader ? CreateEQUIPED_HERO(_fbb, _o->leader.get(), _rehasher) : 0;
  auto _crew11 = _o->crew11 ? CreateEQUIPED_HERO(_fbb, _o->crew11.get(), _rehasher) : 0;
  auto _crew12 = _o->crew12 ? CreateEQUIPED_HERO(_fbb, _o->crew12.get(), _rehasher) : 0;
  auto _crew21 = _o->crew21 ? CreateEQUIPED_HERO(_fbb, _o->crew21.get(), _rehasher) : 0;
  auto _crew22 = _o->crew22 ? CreateEQUIPED_HERO(_fbb, _o->crew22.get(), _rehasher) : 0;
  return OVERLORD::RTS::STRUCT::CreateRTS_DECK(
      _fbb,
      _slot,
      _leader,
      _crew11,
      _crew12,
      _crew21,
      _crew22);
}

inline DICET *DICE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DICET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DICE::UnPackTo(DICET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = dice(); _o->dice = _e; };
}

inline flatbuffers::Offset<DICE> DICE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DICET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDICE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DICE> CreateDICE(flatbuffers::FlatBufferBuilder &_fbb, const DICET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DICET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _dice = _o->dice;
  return OVERLORD::RTS::STRUCT::CreateDICE(
      _fbb,
      _kId,
      _dice);
}

}  // namespace STRUCT

namespace IC {

inline ROOM_JOINT *ROOM_JOIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROOM_JOINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROOM_JOIN::UnPackTo(ROOM_JOINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = proxyID(); if (_e) _o->proxyID = _e->str(); };
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = deck(); if (_e) _o->deck = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_DECKT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ROOM_JOIN> ROOM_JOIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROOM_JOIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROOM_JOIN> CreateROOM_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROOM_JOINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _proxyID = _o->proxyID.empty() ? 0 : _fbb.CreateString(_o->proxyID);
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _deck = _o->deck ? CreateRTS_DECK(_fbb, _o->deck.get(), _rehasher) : 0;
  return OVERLORD::RTS::IC::CreateROOM_JOIN(
      _fbb,
      _proxyID,
      _roomkey,
      _player,
      _deck);
}

inline ROOM_REJOINT *ROOM_REJOIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROOM_REJOINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROOM_REJOIN::UnPackTo(ROOM_REJOINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = proxyID(); if (_e) _o->proxyID = _e->str(); };
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = deck(); if (_e) _o->deck = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_DECKT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ROOM_REJOIN> ROOM_REJOIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_REJOINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROOM_REJOIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROOM_REJOIN> CreateROOM_REJOIN(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_REJOINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROOM_REJOINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _proxyID = _o->proxyID.empty() ? 0 : _fbb.CreateString(_o->proxyID);
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _deck = _o->deck ? CreateRTS_DECK(_fbb, _o->deck.get(), _rehasher) : 0;
  return OVERLORD::RTS::IC::CreateROOM_REJOIN(
      _fbb,
      _proxyID,
      _roomkey,
      _player,
      _deck);
}

inline NPC_HANDLER_JOINT *NPC_HANDLER_JOIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new NPC_HANDLER_JOINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void NPC_HANDLER_JOIN::UnPackTo(NPC_HANDLER_JOINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
}

inline flatbuffers::Offset<NPC_HANDLER_JOIN> NPC_HANDLER_JOIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const NPC_HANDLER_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateNPC_HANDLER_JOIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<NPC_HANDLER_JOIN> CreateNPC_HANDLER_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const NPC_HANDLER_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const NPC_HANDLER_JOINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  return OVERLORD::RTS::IC::CreateNPC_HANDLER_JOIN(
      _fbb,
      _roomkey);
}

inline ROOM_PLAYERT *ROOM_PLAYER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROOM_PLAYERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROOM_PLAYER::UnPackTo(ROOM_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = proxyID(); if (_e) _o->proxyID = _e->str(); };
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = heros(); if (_e) { _o->heros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros[_i] = std::unique_ptr<OVERLORD::STRUCT::EQUIPED_HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ROOM_PLAYER> ROOM_PLAYER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROOM_PLAYER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROOM_PLAYER> CreateROOM_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROOM_PLAYERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _proxyID = _o->proxyID.empty() ? 0 : _fbb.CreateString(_o->proxyID);
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _heros = _o->heros.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::EQUIPED_HERO>> (_o->heros.size(), [](size_t i, _VectorArgs *__va) { return CreateEQUIPED_HERO(*__va->__fbb, __va->__o->heros[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::IC::CreateROOM_PLAYER(
      _fbb,
      _proxyID,
      _player,
      _heros,
      _error);
}

inline ROOM_PLAYER_DISCONNECTEDT *ROOM_PLAYER_DISCONNECTED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROOM_PLAYER_DISCONNECTEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROOM_PLAYER_DISCONNECTED::UnPackTo(ROOM_PLAYER_DISCONNECTEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
  { auto _e = proxyID(); if (_e) _o->proxyID = _e->str(); };
}

inline flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> ROOM_PLAYER_DISCONNECTED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYER_DISCONNECTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROOM_PLAYER_DISCONNECTED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROOM_PLAYER_DISCONNECTED> CreateROOM_PLAYER_DISCONNECTED(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_PLAYER_DISCONNECTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROOM_PLAYER_DISCONNECTEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  auto _proxyID = _o->proxyID.empty() ? 0 : _fbb.CreateString(_o->proxyID);
  return OVERLORD::RTS::IC::CreateROOM_PLAYER_DISCONNECTED(
      _fbb,
      _roomkey,
      _proxyID);
}

inline ROOM_DISPOSET *ROOM_DISPOSE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROOM_DISPOSET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROOM_DISPOSE::UnPackTo(ROOM_DISPOSET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
}

inline flatbuffers::Offset<ROOM_DISPOSE> ROOM_DISPOSE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_DISPOSET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROOM_DISPOSE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROOM_DISPOSE> CreateROOM_DISPOSE(flatbuffers::FlatBufferBuilder &_fbb, const ROOM_DISPOSET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROOM_DISPOSET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  return OVERLORD::RTS::IC::CreateROOM_DISPOSE(
      _fbb,
      _roomkey);
}

inline IC_BT_ACTOR_MOVET *IC_BT_ACTOR_MOVE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IC_BT_ACTOR_MOVET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IC_BT_ACTOR_MOVE::UnPackTo(IC_BT_ACTOR_MOVET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = isStop(); _o->isStop = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = zone(); if (_e) { _o->zone.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->zone[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<IC_BT_ACTOR_MOVE> IC_BT_ACTOR_MOVE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_MOVET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIC_BT_ACTOR_MOVE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IC_BT_ACTOR_MOVE> CreateIC_BT_ACTOR_MOVE(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_MOVET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IC_BT_ACTOR_MOVET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _isStop = _o->isStop;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  auto _zone = _o->zone.size() ? _fbb.CreateVector(_o->zone) : 0;
  return OVERLORD::RTS::IC::CreateIC_BT_ACTOR_MOVE(
      _fbb,
      _frame,
      _actorUK,
      _isStop,
      _location,
      _direction,
      _zone);
}

inline IC_SPAWN_NPCT *IC_SPAWN_NPC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IC_SPAWN_NPCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IC_SPAWN_NPC::UnPackTo(IC_SPAWN_NPCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<IC_SPAWN_NPC> IC_SPAWN_NPC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_SPAWN_NPCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIC_SPAWN_NPC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IC_SPAWN_NPC> CreateIC_SPAWN_NPC(flatbuffers::FlatBufferBuilder &_fbb, const IC_SPAWN_NPCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IC_SPAWN_NPCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::IC::CreateIC_SPAWN_NPC(
      _fbb,
      _sequence,
      _error);
}

inline IC_BT_ACTOR_RESPAWNT *IC_BT_ACTOR_RESPAWN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IC_BT_ACTOR_RESPAWNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IC_BT_ACTOR_RESPAWN::UnPackTo(IC_BT_ACTOR_RESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> IC_BT_ACTOR_RESPAWN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_RESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIC_BT_ACTOR_RESPAWN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IC_BT_ACTOR_RESPAWN> CreateIC_BT_ACTOR_RESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const IC_BT_ACTOR_RESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IC_BT_ACTOR_RESPAWNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  return OVERLORD::RTS::IC::CreateIC_BT_ACTOR_RESPAWN(
      _fbb,
      _actorUK,
      _location,
      _direction);
}

inline IC_NPCHOST_STEP_ONT *IC_NPCHOST_STEP_ON::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new IC_NPCHOST_STEP_ONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void IC_NPCHOST_STEP_ON::UnPackTo(IC_NPCHOST_STEP_ONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = trigger(); _o->trigger = _e; };
}

inline flatbuffers::Offset<IC_NPCHOST_STEP_ON> IC_NPCHOST_STEP_ON::Pack(flatbuffers::FlatBufferBuilder &_fbb, const IC_NPCHOST_STEP_ONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateIC_NPCHOST_STEP_ON(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<IC_NPCHOST_STEP_ON> CreateIC_NPCHOST_STEP_ON(flatbuffers::FlatBufferBuilder &_fbb, const IC_NPCHOST_STEP_ONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const IC_NPCHOST_STEP_ONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _trigger = _o->trigger;
  return OVERLORD::RTS::IC::CreateIC_NPCHOST_STEP_ON(
      _fbb,
      _trigger);
}

}  // namespace IC
}  // namespace RTS
}  // namespace OVERLORD

#endif  // FLATBUFFERS_GENERATED_RTSSTRUCT_OVERLORD_RTS_IC_H_

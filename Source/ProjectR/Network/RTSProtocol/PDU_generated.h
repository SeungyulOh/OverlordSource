// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PDU_OVERLORD_RESPONSE_H_
#define FLATBUFFERS_GENERATED_PDU_OVERLORD_RESPONSE_H_

#include "flatbuffers/flatbuffers.h"

namespace OVERLORD {
namespace STRUCT {

struct DECKS;
struct DECKST;

struct AVATAR;
struct AVATART;

struct HERO;
struct HEROT;

struct HERO_CONFIG;
struct HERO_CONFIGT;

struct ITEM_OPTION;
struct ITEM_OPTIONT;

struct ITEM;
struct ITEMT;

struct REWARD;
struct REWARDT;

struct REWARDSET;
struct REWARDSETT;

struct PLAY_DECK;
struct PLAY_DECKT;

struct EQUIPED_HERO;
struct EQUIPED_HEROT;

struct HERO_SNIPPET;
struct HERO_SNIPPETT;

struct RAID_STAGE;
struct RAID_STAGET;

struct RAID_STAGE_PLAY;
struct RAID_STAGE_PLAYT;

struct EPISODE;
struct EPISODET;

struct CHAPTER;
struct CHAPTERT;

struct ACHIEVE_STATUS;
struct ACHIEVE_STATUST;

struct ACHIEVE_UPDATE;
struct ACHIEVE_UPDATET;

struct ERROR_INFO;
struct ERROR_INFOT;

struct MAIL;
struct MAILT;

struct PD;
struct PDT;

struct PD_CHRONICLE;
struct PD_CHRONICLET;

struct PD_DEFENCE;
struct PD_DEFENCET;

struct PD_SNIPPET;
struct PD_SNIPPETT;

struct PD_MINION;
struct PD_MINIONT;

struct PD_MINION_INVEN;
struct PD_MINION_INVENT;

struct PD_TARGET;
struct PD_TARGETT;

struct PD_TREASURENPC;
struct PD_TREASURENPCT;

struct SHOP_PRODUCT_STATUS;
struct SHOP_PRODUCT_STATUST;

struct SHOP_USER_DATA;
struct SHOP_USER_DATAT;

struct GUILD_INFO;
struct GUILD_INFOT;

struct GUILD_MEMBER;
struct GUILD_MEMBERT;

struct GUILD_AWAITER;
struct GUILD_AWAITERT;

struct GUILD_HISTORY;
struct GUILD_HISTORYT;

struct GUILD_RAID_CHALLENGE;
struct GUILD_RAID_CHALLENGET;

struct GUILD_RAID;
struct GUILD_RAIDT;

struct GUILD_MINE;
struct GUILD_MINET;

struct CHANNEL_EVENT;
struct CHANNEL_EVENTT;

struct CHANNEL_FEATURE;
struct CHANNEL_FEATURET;

struct CHANNEL_GUILD;
struct CHANNEL_GUILDT;

struct CHANNEL_DETAIL;
struct CHANNEL_DETAILT;

struct CHANNEL_INFO;
struct CHANNEL_INFOT;

struct PLAY_CLEAR_GRADE_STATUS;
struct PLAY_CLEAR_GRADE_STATUST;

struct GUILD_RUNE_REQUESTER;
struct GUILD_RUNE_REQUESTERT;

struct CAMPAIGN_QUEST_STATUS;
struct CAMPAIGN_QUEST_STATUST;

struct CAMPAIGN_QUEST;
struct CAMPAIGN_QUESTT;

struct CAMPAIGN_STATUS;
struct CAMPAIGN_STATUST;

struct COMMUNITY_ARTICLE;
struct COMMUNITY_ARTICLET;

struct EVENT_ATTENDANCE;
struct EVENT_ATTENDANCET;

struct INVENTORY;
struct INVENTORYT;

struct INVENTORY_UPDATE;
struct INVENTORY_UPDATET;

struct INVENTORY_CURRENCY;
struct INVENTORY_CURRENCYT;

struct INVENTORY_EQUIPED;
struct INVENTORY_EQUIPEDT;

struct UNLOCK_NOTIFY;
struct UNLOCK_NOTIFYT;

struct UNLOCK_LIST;
struct UNLOCK_LISTT;

struct DAILY_QUEST_STATUS;
struct DAILY_QUEST_STATUST;

struct DAILY_QUEST_UPDATE;
struct DAILY_QUEST_UPDATET;

struct REALTIME_USER_BASIC_INFO;
struct REALTIME_USER_BASIC_INFOT;

struct REALTIME_COLOSSEUM_STATUS;
struct REALTIME_COLOSSEUM_STATUST;

struct HERO_SHOP_PRODUCT;
struct HERO_SHOP_PRODUCTT;

struct HERO_SHOP_PANEL;
struct HERO_SHOP_PANELT;

struct ROA_QUEST;
struct ROA_QUESTT;

struct ROA_CHAPTER_QUESTS;
struct ROA_CHAPTER_QUESTST;

struct ROA_ADVENTURE;
struct ROA_ADVENTURET;

struct BILLING_PREPARE_KAKAOPAY;
struct BILLING_PREPARE_KAKAOPAYT;

struct REALTIME_REWARD;
struct REALTIME_REWARDT;

struct REALTIME_BG_REWARD;
struct REALTIME_BG_REWARDT;

struct ACCOUNT_RECORD;
struct ACCOUNT_RECORDT;

struct HERO_USAGE;
struct HERO_USAGET;

struct HERO_USAGE_TAB;
struct HERO_USAGE_TABT;

struct CRUSADER_HERO_HP;
struct CRUSADER_HERO_HPT;

struct TREASURE;
struct TREASURET;

struct BG_USER;
struct BG_USERT;

struct FLOOR_QUEST_STATUS;
struct FLOOR_QUEST_STATUST;

struct FLOOR_MISSION;
struct FLOOR_MISSIONT;

struct FLOOR_MISSION_STATUS;
struct FLOOR_MISSION_STATUST;

struct TOWER_STATUS;
struct TOWER_STATUST;

struct BATTLE_USER;
struct BATTLE_USERT;

struct ARENA_HISTORY;
struct ARENA_HISTORYT;

struct ARENA_STATUS;
struct ARENA_STATUST;

struct ARENA_RANK_USER;
struct ARENA_RANK_USERT;

struct MIRROR_HERO_HP;
struct MIRROR_HERO_HPT;

struct MIRROR;
struct MIRRORT;

struct MIRROR_STATUS;
struct MIRROR_STATUST;

struct COLOSSEUM_HISTORY;
struct COLOSSEUM_HISTORYT;

struct COLOSSEUM_STATUS;
struct COLOSSEUM_STATUST;

struct COLOSSEUM_RANK_USER;
struct COLOSSEUM_RANK_USERT;

struct SHOP_FLOORSHOP_SLOT;
struct SHOP_FLOORSHOP_SLOTT;

struct SHOP_FLOORSHOP_STATUS;
struct SHOP_FLOORSHOP_STATUST;

struct WORLDBOSS_STATUS;
struct WORLDBOSS_STATUST;

struct SELECTIVE_TUTORIAL;
struct SELECTIVE_TUTORIALT;

struct UPDATE_PACKET;
struct UPDATE_PACKETT;

struct UPDATE_PACKET_SLIM;
struct UPDATE_PACKET_SLIMT;

}  // namespace STRUCT

namespace REQUEST {

struct LOGIN;
struct LOGINT;

struct ACCOUNT_CREATE;
struct ACCOUNT_CREATET;

struct ACCOUNT_REMOVE;
struct ACCOUNT_REMOVET;

struct INIT_CLIENT_KEY;
struct INIT_CLIENT_KEYT;

struct ADD_REFER_PUBLISHER;
struct ADD_REFER_PUBLISHERT;

struct GET_REFER_LIST;
struct GET_REFER_LISTT;

struct ACCOUNT_CHANGE_LANGUAGE;
struct ACCOUNT_CHANGE_LANGUAGET;

struct CLIENT_SDK_ACTION;
struct CLIENT_SDK_ACTIONT;

struct ARENA_STATUS;
struct ARENA_STATUST;

struct ARENA_TARGET_INFO;
struct ARENA_TARGET_INFOT;

struct ARENA_PLAY;
struct ARENA_PLAYT;

struct ARENA_PLAY_DONE;
struct ARENA_PLAY_DONET;

struct ARENA_DEFENSE_REWARD;
struct ARENA_DEFENSE_REWARDT;

struct ARENA_SEASON_DONE;
struct ARENA_SEASON_DONET;

struct ARENA_RANKING_LIST;
struct ARENA_RANKING_LISTT;

struct ARENA_DEFENSE_DECK_SET;
struct ARENA_DEFENSE_DECK_SETT;

struct AVATAR_ABILITY_UP;
struct AVATAR_ABILITY_UPT;

struct AVATAR_ABILITY_RESET;
struct AVATAR_ABILITY_RESETT;

struct AVATAR_ICON_LIST;
struct AVATAR_ICON_LISTT;

struct AVATAR_ICON_SET;
struct AVATAR_ICON_SETT;

struct AVATAR_PROFILE;
struct AVATAR_PROFILET;

struct AVATAR_LOBBY;
struct AVATAR_LOBBYT;

struct AVATAR_GAME_DATA;
struct AVATAR_GAME_DATAT;

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE;
struct AVATAR_SELECTIVE_TUTORIAL_UPDATET;

struct CHANNEL_INFO_LIST;
struct CHANNEL_INFO_LISTT;

struct CHANNEL_DETAIL;
struct CHANNEL_DETAILT;

struct BILLING_TRANSACTION_CREATE;
struct BILLING_TRANSACTION_CREATET;

struct BILLING_TRANSACTION_SUCCESS;
struct BILLING_TRANSACTION_SUCCESST;

struct COLOSSEUM_STATUS;
struct COLOSSEUM_STATUST;

struct COLOSSEUM_PLAY_RESULT;
struct COLOSSEUM_PLAY_RESULTT;

struct COLOSSEUM_SEASON_DONE;
struct COLOSSEUM_SEASON_DONET;

struct COLOSSEUM_RANKING_LIST;
struct COLOSSEUM_RANKING_LISTT;

struct COMMUNITY_ARTICLE_WRITE_HERO;
struct COMMUNITY_ARTICLE_WRITE_HEROT;

struct COMMUNITY_ARTICLE_DELETE_HERO;
struct COMMUNITY_ARTICLE_DELETE_HEROT;

struct COMMUNITY_ARTICLE_LIST_HERO;
struct COMMUNITY_ARTICLE_LIST_HEROT;

struct COMMUNITY_ARTICLE_VOTE_HERO;
struct COMMUNITY_ARTICLE_VOTE_HEROT;

struct CONTENT_RESET_STATUS;
struct CONTENT_RESET_STATUST;

struct CONTENT_RESET;
struct CONTENT_RESETT;

struct ATTENDANCE_GET;
struct ATTENDANCE_GETT;

struct GUILD_CREATE;
struct GUILD_CREATET;

struct GUILD_CLOSE;
struct GUILD_CLOSET;

struct GUILD_GET;
struct GUILD_GETT;

struct GUILD_GET_GUEST;
struct GUILD_GET_GUESTT;

struct GUILD_MEMBER_LIST;
struct GUILD_MEMBER_LISTT;

struct GUILD_AWAITER_LIST;
struct GUILD_AWAITER_LISTT;

struct GUILD_AWAITER_ACCEPT;
struct GUILD_AWAITER_ACCEPTT;

struct GUILD_AWAITER_CANCEL;
struct GUILD_AWAITER_CANCELT;

struct GUILD_FIND_NAME;
struct GUILD_FIND_NAMET;

struct GUILD_CHANGE_NAME;
struct GUILD_CHANGE_NAMET;

struct GUILD_EDIT_DESC;
struct GUILD_EDIT_DESCT;

struct GUILD_EDIT_NOTICE;
struct GUILD_EDIT_NOTICET;

struct GUILD_EDIT_AUTO_GRADE_UP;
struct GUILD_EDIT_AUTO_GRADE_UPT;

struct GUILD_JOIN;
struct GUILD_JOINT;

struct GUILD_JOIN_AUTO;
struct GUILD_JOIN_AUTOT;

struct GUILD_MEMBER_GRADE;
struct GUILD_MEMBER_GRADET;

struct GUILD_MEMBER_KICK;
struct GUILD_MEMBER_KICKT;

struct GUILD_CONTRIBUTION;
struct GUILD_CONTRIBUTIONT;

struct GUILD_CONTRIBUTE_RANKING;
struct GUILD_CONTRIBUTE_RANKINGT;

struct GUILD_CONTRIBUTION_STATUS;
struct GUILD_CONTRIBUTION_STATUST;

struct GUILD_ATTENDANCE_STATUS;
struct GUILD_ATTENDANCE_STATUST;

struct GUILD_ATTENDANCE_DAILY_REWARD;
struct GUILD_ATTENDANCE_DAILY_REWARDT;

struct GUILD_ATTENDANCE_WEEKLY_REWARD;
struct GUILD_ATTENDANCE_WEEKLY_REWARDT;

struct GUILD_RUNE_STATUS;
struct GUILD_RUNE_STATUST;

struct GUILD_RUNE_REQUEST;
struct GUILD_RUNE_REQUESTT;

struct GUILD_RUNE_SUPPORT;
struct GUILD_RUNE_SUPPORTT;

struct GUILD_RUNE_GET;
struct GUILD_RUNE_GETT;

struct GUILD_HISTORY;
struct GUILD_HISTORYT;

struct GUILD_LEVEL_UP;
struct GUILD_LEVEL_UPT;

struct INVENTORY_HERO_UPGRADE;
struct INVENTORY_HERO_UPGRADET;

struct INVENTORY_HERO_LEVELUP;
struct INVENTORY_HERO_LEVELUPT;

struct INVENTORY_HERO_GRIND;
struct INVENTORY_HERO_GRINDT;

struct INVENTORY_HERO_EQUIP;
struct INVENTORY_HERO_EQUIPT;

struct INVENTORY_HERO_UNEQUIP;
struct INVENTORY_HERO_UNEQUIPT;

struct INVENTORY_ITEM_GRIND;
struct INVENTORY_ITEM_GRINDT;

struct INVENTORY_RUNE_EQUIP;
struct INVENTORY_RUNE_EQUIPT;

struct INVENTORY_RUNE_UNEQUIP;
struct INVENTORY_RUNE_UNEQUIPT;

struct INVENTORY_RUNE_MAKE;
struct INVENTORY_RUNE_MAKET;

struct INVENTORY_ITEM_LEVELUP;
struct INVENTORY_ITEM_LEVELUPT;

struct INVENTORY_ITEM_ENCHANT;
struct INVENTORY_ITEM_ENCHANTT;

struct INVENTORY_ITEM_HERO_LOCK;
struct INVENTORY_ITEM_HERO_LOCKT;

struct INVENTORY_HERO_SKILL_LEVELUP;
struct INVENTORY_HERO_SKILL_LEVELUPT;

struct INVENTORY_HERO_ENCHANT_CONSUME;
struct INVENTORY_HERO_ENCHANT_CONSUMET;

struct INVENTORY_HERO_ENCHANT_STAT;
struct INVENTORY_HERO_ENCHANT_STATT;

struct INVENTORY_SELL;
struct INVENTORY_SELLT;

struct INVENTORY_ITEM_UPGRADE;
struct INVENTORY_ITEM_UPGRADET;

struct INVENTORY_ITEM_OPTION_RESET;
struct INVENTORY_ITEM_OPTION_RESETT;

struct INVENTORY_TIMETREASURE_GET;
struct INVENTORY_TIMETREASURE_GETT;

struct INVENTORY_UPGRADE;
struct INVENTORY_UPGRADET;

struct GIFT_LIST;
struct GIFT_LISTT;

struct GIFT_OPEN;
struct GIFT_OPENT;

struct SPECIAL_GIFT_LIST;
struct SPECIAL_GIFT_LISTT;

struct SPECIAL_GIFT_OPEN;
struct SPECIAL_GIFT_OPENT;

struct MIRROR_STATUS;
struct MIRROR_STATUST;

struct MIRROR_PLAY_START;
struct MIRROR_PLAY_STARTT;

struct MIRROR_PLAY_DONE;
struct MIRROR_PLAY_DONET;

struct MIRROR_RESET;
struct MIRROR_RESETT;

struct MIRROR_DEFENSE_DECK_SET;
struct MIRROR_DEFENSE_DECK_SETT;

struct GIVE_ACHIEVE_REWARD;
struct GIVE_ACHIEVE_REWARDT;

struct DAILY_QUEST_STATUS;
struct DAILY_QUEST_STATUST;

struct DAILY_QUEST_REWARD;
struct DAILY_QUEST_REWARDT;

struct SHOP_USER_DATA;
struct SHOP_USER_DATAT;

struct SHOP_BUY;
struct SHOP_BUYT;

struct SHOP_CHARACTER_SUMMON;
struct SHOP_CHARACTER_SUMMONT;

struct SHOP_FLOORSHOP_STATUS;
struct SHOP_FLOORSHOP_STATUST;

struct SHOP_FLOORSHOP_BUY;
struct SHOP_FLOORSHOP_BUYT;

struct SHOP_FLOORSHOP_OPEN_SLOT;
struct SHOP_FLOORSHOP_OPEN_SLOTT;

struct TOWER_STATUS;
struct TOWER_STATUST;

struct TOWER_PLAY_START;
struct TOWER_PLAY_STARTT;

struct TOWER_PLAY_DONE;
struct TOWER_PLAY_DONET;

struct TOWER_TREASURE_BOX;
struct TOWER_TREASURE_BOXT;

struct TOWER_BOSS_PLAY_CHECK;
struct TOWER_BOSS_PLAY_CHECKT;

struct TOWER_BOSS_PLAY_RESULT;
struct TOWER_BOSS_PLAY_RESULTT;

struct TOWER_FLOOR_MISSION_ACTIVE;
struct TOWER_FLOOR_MISSION_ACTIVET;

struct TOWER_FLOOR_MISSION_REWARD;
struct TOWER_FLOOR_MISSION_REWARDT;

struct TREASURE_GET_REWARD;
struct TREASURE_GET_REWARDT;

struct GET_TARGET_SERVER;
struct GET_TARGET_SERVERT;

struct WORLDBOSS_STATUS;
struct WORLDBOSS_STATUST;

struct WORLDBOSS_PLAY_CHECK;
struct WORLDBOSS_PLAY_CHECKT;

struct WORLDBOSS_PLAY_RESULT;
struct WORLDBOSS_PLAY_RESULTT;

}  // namespace REQUEST

namespace RESPONSE {

struct LOGIN_REPLY;
struct LOGIN_REPLYT;

struct ACCOUNT_CREATE_REPLY;
struct ACCOUNT_CREATE_REPLYT;

struct ACCOUNT_REMOVE_REPLY;
struct ACCOUNT_REMOVE_REPLYT;

struct INIT_CLIENT_KEY_REPLY;
struct INIT_CLIENT_KEY_REPLYT;

struct ADD_REFER_PUBLISHER_REPLY;
struct ADD_REFER_PUBLISHER_REPLYT;

struct GET_REFER_LIST_REPLY;
struct GET_REFER_LIST_REPLYT;

struct ACCOUNT_CHANGE_LANGUAGE_REPLY;
struct ACCOUNT_CHANGE_LANGUAGE_REPLYT;

struct CLIENT_SDK_ACTION_REPLY;
struct CLIENT_SDK_ACTION_REPLYT;

struct ARENA_STATUS_REPLY;
struct ARENA_STATUS_REPLYT;

struct ARENA_TARGET_INFO_REPLY;
struct ARENA_TARGET_INFO_REPLYT;

struct ARENA_PLAY_REPLY;
struct ARENA_PLAY_REPLYT;

struct ARENA_PLAY_DONE_REPLY;
struct ARENA_PLAY_DONE_REPLYT;

struct ARENA_DEFENSE_REWARD_REPLY;
struct ARENA_DEFENSE_REWARD_REPLYT;

struct ARENA_SEASON_DONE_REPLY;
struct ARENA_SEASON_DONE_REPLYT;

struct ARENA_RANKING_LIST_REPLY;
struct ARENA_RANKING_LIST_REPLYT;

struct ARENA_DEFENSE_DECK_SET_REPLY;
struct ARENA_DEFENSE_DECK_SET_REPLYT;

struct AVATAR_ABILITY_UP_REPLY;
struct AVATAR_ABILITY_UP_REPLYT;

struct AVATAR_ABILITY_RESET_REPLY;
struct AVATAR_ABILITY_RESET_REPLYT;

struct AVATAR_ICON_LIST_REPLY;
struct AVATAR_ICON_LIST_REPLYT;

struct AVATAR_ICON_SET_REPLY;
struct AVATAR_ICON_SET_REPLYT;

struct AVATAR_PROFILE_REPLY;
struct AVATAR_PROFILE_REPLYT;

struct AVATAR_LOBBY_REPLY;
struct AVATAR_LOBBY_REPLYT;

struct AVATAR_GAME_DATA_REPLY;
struct AVATAR_GAME_DATA_REPLYT;

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY;
struct AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT;

struct CHANNEL_INFO_LIST_REPLY;
struct CHANNEL_INFO_LIST_REPLYT;

struct CHANNEL_DETAIL_REPLY;
struct CHANNEL_DETAIL_REPLYT;

struct BILLING_TRANSACTION_CREATE_REPLY;
struct BILLING_TRANSACTION_CREATE_REPLYT;

struct BILLING_TRANSACTION_SUCCESS_REPLY;
struct BILLING_TRANSACTION_SUCCESS_REPLYT;

struct COLOSSEUM_STATUS_REPLY;
struct COLOSSEUM_STATUS_REPLYT;

struct COLOSSEUM_PLAY_RESULT_REPLY;
struct COLOSSEUM_PLAY_RESULT_REPLYT;

struct COLOSSEUM_SEASON_DONE_REPLY;
struct COLOSSEUM_SEASON_DONE_REPLYT;

struct COLOSSEUM_RANKING_LIST_REPLY;
struct COLOSSEUM_RANKING_LIST_REPLYT;

struct COMMUNITY_ARTICLE_WRITE_HERO_REPLY;
struct COMMUNITY_ARTICLE_WRITE_HERO_REPLYT;

struct COMMUNITY_ARTICLE_DELETE_HERO_REPLY;
struct COMMUNITY_ARTICLE_DELETE_HERO_REPLYT;

struct COMMUNITY_ARTICLE_LIST_HERO_REPLY;
struct COMMUNITY_ARTICLE_LIST_HERO_REPLYT;

struct COMMUNITY_ARTICLE_VOTE_HERO_REPLY;
struct COMMUNITY_ARTICLE_VOTE_HERO_REPLYT;

struct CONTENT_RESET_STATUS_REPLY;
struct CONTENT_RESET_STATUS_REPLYT;

struct CONTENT_RESET_REPLY;
struct CONTENT_RESET_REPLYT;

struct ATTENDANCE_GET_REPLY;
struct ATTENDANCE_GET_REPLYT;

struct GUILD_CREATE_REPLY;
struct GUILD_CREATE_REPLYT;

struct GUILD_CLOSE_REPLY;
struct GUILD_CLOSE_REPLYT;

struct GUILD_GET_REPLY;
struct GUILD_GET_REPLYT;

struct GUILD_GET_GUEST_REPLY;
struct GUILD_GET_GUEST_REPLYT;

struct GUILD_MEMBER_LIST_REPLY;
struct GUILD_MEMBER_LIST_REPLYT;

struct GUILD_AWAITER_LIST_REPLY;
struct GUILD_AWAITER_LIST_REPLYT;

struct GUILD_AWAITER_ACCEPT_REPLY;
struct GUILD_AWAITER_ACCEPT_REPLYT;

struct GUILD_AWAITER_CANCEL_REPLY;
struct GUILD_AWAITER_CANCEL_REPLYT;

struct GUILD_FIND_NAME_REPLY;
struct GUILD_FIND_NAME_REPLYT;

struct GUILD_CHANGE_NAME_REPLY;
struct GUILD_CHANGE_NAME_REPLYT;

struct GUILD_EDIT_DESC_REPLY;
struct GUILD_EDIT_DESC_REPLYT;

struct GUILD_EDIT_NOTICE_REPLY;
struct GUILD_EDIT_NOTICE_REPLYT;

struct GUILD_EDIT_AUTO_GRADE_UP_REPLY;
struct GUILD_EDIT_AUTO_GRADE_UP_REPLYT;

struct GUILD_JOIN_REPLY;
struct GUILD_JOIN_REPLYT;

struct GUILD_JOIN_AUTO_REPLY;
struct GUILD_JOIN_AUTO_REPLYT;

struct GUILD_MEMBER_GRADE_REPLY;
struct GUILD_MEMBER_GRADE_REPLYT;

struct GUILD_MEMBER_KICK_REPLY;
struct GUILD_MEMBER_KICK_REPLYT;

struct GUILD_CONTRIBUTION_REPLY;
struct GUILD_CONTRIBUTION_REPLYT;

struct GUILD_CONTRIBUTE_RANKING_REPLY;
struct GUILD_CONTRIBUTE_RANKING_REPLYT;

struct GUILD_CONTRIBUTION_STATUS_REPLY;
struct GUILD_CONTRIBUTION_STATUS_REPLYT;

struct GUILD_ATTENDANCE_STATUS_REPLY;
struct GUILD_ATTENDANCE_STATUS_REPLYT;

struct GUILD_ATTENDANCE_DAILY_REWARD_REPLY;
struct GUILD_ATTENDANCE_DAILY_REWARD_REPLYT;

struct GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY;
struct GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT;

struct GUILD_RUNE_STATUS_REPLY;
struct GUILD_RUNE_STATUS_REPLYT;

struct GUILD_RUNE_REQUEST_REPLY;
struct GUILD_RUNE_REQUEST_REPLYT;

struct GUILD_RUNE_SUPPORT_REPLY;
struct GUILD_RUNE_SUPPORT_REPLYT;

struct GUILD_RUNE_GET_REPLY;
struct GUILD_RUNE_GET_REPLYT;

struct GUILD_HISTORY_REPLY;
struct GUILD_HISTORY_REPLYT;

struct GUILD_LEVEL_UP_REPLY;
struct GUILD_LEVEL_UP_REPLYT;

struct INVENTORY_HERO_UPGRADE_REPLY;
struct INVENTORY_HERO_UPGRADE_REPLYT;

struct INVENTORY_HERO_LEVELUP_REPLY;
struct INVENTORY_HERO_LEVELUP_REPLYT;

struct INVENTORY_HERO_GRIND_REPLY;
struct INVENTORY_HERO_GRIND_REPLYT;

struct INVENTORY_HERO_EQUIP_REPLY;
struct INVENTORY_HERO_EQUIP_REPLYT;

struct INVENTORY_HERO_UNEQUIP_REPLY;
struct INVENTORY_HERO_UNEQUIP_REPLYT;

struct INVENTORY_ITEM_GRIND_REPLY;
struct INVENTORY_ITEM_GRIND_REPLYT;

struct INVENTORY_RUNE_EQUIP_REPLY;
struct INVENTORY_RUNE_EQUIP_REPLYT;

struct INVENTORY_RUNE_UNEQUIP_REPLY;
struct INVENTORY_RUNE_UNEQUIP_REPLYT;

struct INVENTORY_RUNE_MAKE_REPLY;
struct INVENTORY_RUNE_MAKE_REPLYT;

struct INVENTORY_ITEM_LEVELUP_REPLY;
struct INVENTORY_ITEM_LEVELUP_REPLYT;

struct INVENTORY_ITEM_ENCHANT_REPLY;
struct INVENTORY_ITEM_ENCHANT_REPLYT;

struct INVENTORY_ITEM_HERO_LOCK_REPLY;
struct INVENTORY_ITEM_HERO_LOCK_REPLYT;

struct INVENTORY_HERO_SKILL_LEVELUP_REPLY;
struct INVENTORY_HERO_SKILL_LEVELUP_REPLYT;

struct INVENTORY_HERO_ENCHANT_CONSUME_REPLY;
struct INVENTORY_HERO_ENCHANT_CONSUME_REPLYT;

struct INVENTORY_HERO_ENCHANT_STAT_REPLY;
struct INVENTORY_HERO_ENCHANT_STAT_REPLYT;

struct INVENTORY_SELL_REPLY;
struct INVENTORY_SELL_REPLYT;

struct INVENTORY_ITEM_UPGRADE_REPLY;
struct INVENTORY_ITEM_UPGRADE_REPLYT;

struct INVENTORY_ITEM_OPTION_RESET_REPLY;
struct INVENTORY_ITEM_OPTION_RESET_REPLYT;

struct INVENTORY_TIMETREASURE_GET_REPLY;
struct INVENTORY_TIMETREASURE_GET_REPLYT;

struct INVENTORY_UPGRADE_REPLY;
struct INVENTORY_UPGRADE_REPLYT;

struct GIFT_LIST_REPLY;
struct GIFT_LIST_REPLYT;

struct GIFT_OPEN_REPLY;
struct GIFT_OPEN_REPLYT;

struct SPECIAL_GIFT_LIST_REPLY;
struct SPECIAL_GIFT_LIST_REPLYT;

struct SPECIAL_GIFT_OPEN_REPLY;
struct SPECIAL_GIFT_OPEN_REPLYT;

struct MIRROR_STATUS_REPLY;
struct MIRROR_STATUS_REPLYT;

struct MIRROR_PLAY_START_REPLY;
struct MIRROR_PLAY_START_REPLYT;

struct MIRROR_PLAY_DONE_REPLY;
struct MIRROR_PLAY_DONE_REPLYT;

struct MIRROR_RESET_REPLY;
struct MIRROR_RESET_REPLYT;

struct MIRROR_DEFENSE_DECK_SET_REPLY;
struct MIRROR_DEFENSE_DECK_SET_REPLYT;

struct GIVE_ACHIEVE_REWARD_REPLY;
struct GIVE_ACHIEVE_REWARD_REPLYT;

struct DAILY_QUEST_STATUS_REPLY;
struct DAILY_QUEST_STATUS_REPLYT;

struct DAILY_QUEST_REWARD_REPLY;
struct DAILY_QUEST_REWARD_REPLYT;

struct SHOP_USER_DATA_REPLY;
struct SHOP_USER_DATA_REPLYT;

struct SHOP_BUY_REPLY;
struct SHOP_BUY_REPLYT;

struct SHOP_CHARACTER_SUMMON_REPLY;
struct SHOP_CHARACTER_SUMMON_REPLYT;

struct SHOP_FLOORSHOP_STATUS_REPLY;
struct SHOP_FLOORSHOP_STATUS_REPLYT;

struct SHOP_FLOORSHOP_BUY_REPLY;
struct SHOP_FLOORSHOP_BUY_REPLYT;

struct SHOP_FLOORSHOP_OPEN_SLOT_REPLY;
struct SHOP_FLOORSHOP_OPEN_SLOT_REPLYT;

struct TOWER_STATUS_REPLY;
struct TOWER_STATUS_REPLYT;

struct TOWER_PLAY_START_REPLY;
struct TOWER_PLAY_START_REPLYT;

struct TOWER_PLAY_DONE_REPLY;
struct TOWER_PLAY_DONE_REPLYT;

struct TOWER_TREASURE_BOX_REPLY;
struct TOWER_TREASURE_BOX_REPLYT;

struct TOWER_BOSS_PLAY_CHECK_REPLY;
struct TOWER_BOSS_PLAY_CHECK_REPLYT;

struct TOWER_BOSS_PLAY_RESULT_REPLY;
struct TOWER_BOSS_PLAY_RESULT_REPLYT;

struct TOWER_FLOOR_MISSION_ACTIVE_REPLY;
struct TOWER_FLOOR_MISSION_ACTIVE_REPLYT;

struct TOWER_FLOOR_MISSION_REWARD_REPLY;
struct TOWER_FLOOR_MISSION_REWARD_REPLYT;

struct TREASURE_GET_REWARD_REPLY;
struct TREASURE_GET_REWARD_REPLYT;

struct GET_TARGET_SERVER_REPLY;
struct GET_TARGET_SERVER_REPLYT;

struct WORLDBOSS_STATUS_REPLY;
struct WORLDBOSS_STATUS_REPLYT;

struct WORLDBOSS_PLAY_CHECK_REPLY;
struct WORLDBOSS_PLAY_CHECK_REPLYT;

struct WORLDBOSS_PLAY_RESULT_REPLY;
struct WORLDBOSS_PLAY_RESULT_REPLYT;

}  // namespace RESPONSE

namespace ENUM {

enum CRUD {
  CRUD_CRUD_FAIL = 0,
  CRUD_CRUD_OK = 1,
  CRUD_CRUD_LOGICAL_ERROR = 99,
  CRUD_MIN = CRUD_CRUD_FAIL,
  CRUD_MAX = CRUD_CRUD_LOGICAL_ERROR
};

inline CRUD (&EnumValuesCRUD())[3] {
  static CRUD values[] = {
    CRUD_CRUD_FAIL,
    CRUD_CRUD_OK,
    CRUD_CRUD_LOGICAL_ERROR
  };
  return values;
}

enum PVP {
  PVP_NONE = 0,
  PVP_BG = 1,
  PVP_GR = 2,
  PVP_CS = 3,
  PVP_BF = 4,
  PVP_SR = 5,
  PVP_MR = 6,
  PVP_MIN = PVP_NONE,
  PVP_MAX = PVP_MR
};

inline PVP (&EnumValuesPVP())[7] {
  static PVP values[] = {
    PVP_NONE,
    PVP_BG,
    PVP_GR,
    PVP_CS,
    PVP_BF,
    PVP_SR,
    PVP_MR
  };
  return values;
}

inline const char **EnumNamesPVP() {
  static const char *names[] = {
    "NONE",
    "BG",
    "GR",
    "CS",
    "BF",
    "SR",
    "MR",
    nullptr
  };
  return names;
}

inline const char *EnumNamePVP(PVP e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPVP()[index];
}

enum QUEST {
  QUEST_READY = 0,
  QUEST_DONE = 1,
  QUEST_COMPLETE = 2,
  QUEST_MIN = QUEST_READY,
  QUEST_MAX = QUEST_COMPLETE
};

inline QUEST (&EnumValuesQUEST())[3] {
  static QUEST values[] = {
    QUEST_READY,
    QUEST_DONE,
    QUEST_COMPLETE
  };
  return values;
}

inline const char **EnumNamesQUEST() {
  static const char *names[] = {
    "READY",
    "DONE",
    "COMPLETE",
    nullptr
  };
  return names;
}

inline const char *EnumNameQUEST(QUEST e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQUEST()[index];
}

enum HERO_LEVELUP_MODE {
  HERO_LEVELUP_MODE_NOTHING = 0,
  HERO_LEVELUP_MODE_ONE = 1,
  HERO_LEVELUP_MODE_ALL = 2,
  HERO_LEVELUP_MODE_MIN = HERO_LEVELUP_MODE_NOTHING,
  HERO_LEVELUP_MODE_MAX = HERO_LEVELUP_MODE_ALL
};

inline HERO_LEVELUP_MODE (&EnumValuesHERO_LEVELUP_MODE())[3] {
  static HERO_LEVELUP_MODE values[] = {
    HERO_LEVELUP_MODE_NOTHING,
    HERO_LEVELUP_MODE_ONE,
    HERO_LEVELUP_MODE_ALL
  };
  return values;
}

inline const char **EnumNamesHERO_LEVELUP_MODE() {
  static const char *names[] = {
    "NOTHING",
    "ONE",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameHERO_LEVELUP_MODE(HERO_LEVELUP_MODE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesHERO_LEVELUP_MODE()[index];
}

enum HERO_SKILL_SLOT {
  HERO_SKILL_SLOT_ActiveSkill01 = 0,
  HERO_SKILL_SLOT_ActiveSkill02 = 1,
  HERO_SKILL_SLOT_ActiveSkill03 = 2,
  HERO_SKILL_SLOT_PassiveSkill01 = 3,
  HERO_SKILL_SLOT_PassiveSkill02 = 4,
  HERO_SKILL_SLOT_MIN = HERO_SKILL_SLOT_ActiveSkill01,
  HERO_SKILL_SLOT_MAX = HERO_SKILL_SLOT_PassiveSkill02
};

inline HERO_SKILL_SLOT (&EnumValuesHERO_SKILL_SLOT())[5] {
  static HERO_SKILL_SLOT values[] = {
    HERO_SKILL_SLOT_ActiveSkill01,
    HERO_SKILL_SLOT_ActiveSkill02,
    HERO_SKILL_SLOT_ActiveSkill03,
    HERO_SKILL_SLOT_PassiveSkill01,
    HERO_SKILL_SLOT_PassiveSkill02
  };
  return values;
}

inline const char **EnumNamesHERO_SKILL_SLOT() {
  static const char *names[] = {
    "ActiveSkill01",
    "ActiveSkill02",
    "ActiveSkill03",
    "PassiveSkill01",
    "PassiveSkill02",
    nullptr
  };
  return names;
}

inline const char *EnumNameHERO_SKILL_SLOT(HERO_SKILL_SLOT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesHERO_SKILL_SLOT()[index];
}

enum HERO_ITEM_SLOT {
  HERO_ITEM_SLOT_Weapon = 0,
  HERO_ITEM_SLOT_Armor = 1,
  HERO_ITEM_SLOT_Pants = 2,
  HERO_ITEM_SLOT_Ring = 3,
  HERO_ITEM_SLOT_Necklace = 4,
  HERO_ITEM_SLOT_MIN = HERO_ITEM_SLOT_Weapon,
  HERO_ITEM_SLOT_MAX = HERO_ITEM_SLOT_Necklace
};

inline HERO_ITEM_SLOT (&EnumValuesHERO_ITEM_SLOT())[5] {
  static HERO_ITEM_SLOT values[] = {
    HERO_ITEM_SLOT_Weapon,
    HERO_ITEM_SLOT_Armor,
    HERO_ITEM_SLOT_Pants,
    HERO_ITEM_SLOT_Ring,
    HERO_ITEM_SLOT_Necklace
  };
  return values;
}

inline const char **EnumNamesHERO_ITEM_SLOT() {
  static const char *names[] = {
    "Weapon",
    "Armor",
    "Pants",
    "Ring",
    "Necklace",
    nullptr
  };
  return names;
}

inline const char *EnumNameHERO_ITEM_SLOT(HERO_ITEM_SLOT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesHERO_ITEM_SLOT()[index];
}

enum HERO_ENCHANT_STAT_SLOT {
  HERO_ENCHANT_STAT_SLOT_PhysicalAttackPower = 0,
  HERO_ENCHANT_STAT_SLOT_MagicAttackPower = 1,
  HERO_ENCHANT_STAT_SLOT_Armor = 2,
  HERO_ENCHANT_STAT_SLOT_MagicResistance = 3,
  HERO_ENCHANT_STAT_SLOT_MaxHP = 4,
  HERO_ENCHANT_STAT_SLOT_MIN = HERO_ENCHANT_STAT_SLOT_PhysicalAttackPower,
  HERO_ENCHANT_STAT_SLOT_MAX = HERO_ENCHANT_STAT_SLOT_MaxHP
};

inline HERO_ENCHANT_STAT_SLOT (&EnumValuesHERO_ENCHANT_STAT_SLOT())[5] {
  static HERO_ENCHANT_STAT_SLOT values[] = {
    HERO_ENCHANT_STAT_SLOT_PhysicalAttackPower,
    HERO_ENCHANT_STAT_SLOT_MagicAttackPower,
    HERO_ENCHANT_STAT_SLOT_Armor,
    HERO_ENCHANT_STAT_SLOT_MagicResistance,
    HERO_ENCHANT_STAT_SLOT_MaxHP
  };
  return values;
}

inline const char **EnumNamesHERO_ENCHANT_STAT_SLOT() {
  static const char *names[] = {
    "PhysicalAttackPower",
    "MagicAttackPower",
    "Armor",
    "MagicResistance",
    "MaxHP",
    nullptr
  };
  return names;
}

inline const char *EnumNameHERO_ENCHANT_STAT_SLOT(HERO_ENCHANT_STAT_SLOT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesHERO_ENCHANT_STAT_SLOT()[index];
}

enum PLAY_LOD {
  PLAY_LOD_NOTHING = 0,
  PLAY_LOD_CAMP_NORMAL = 10,
  PLAY_LOD_CAMP_HARD = 11,
  PLAY_LOD_RAID_NORMAL = 20,
  PLAY_LOD_RAID_HARD = 21,
  PLAY_LOD_RAID_NIGHTMARE = 22,
  PLAY_LOD_RAID_HELL = 23,
  PLAY_LOD_ARENA = 30,
  PLAY_LOD_ARENA_BAT = 31,
  PLAY_LOD_MIN = PLAY_LOD_NOTHING,
  PLAY_LOD_MAX = PLAY_LOD_ARENA_BAT
};

inline PLAY_LOD (&EnumValuesPLAY_LOD())[9] {
  static PLAY_LOD values[] = {
    PLAY_LOD_NOTHING,
    PLAY_LOD_CAMP_NORMAL,
    PLAY_LOD_CAMP_HARD,
    PLAY_LOD_RAID_NORMAL,
    PLAY_LOD_RAID_HARD,
    PLAY_LOD_RAID_NIGHTMARE,
    PLAY_LOD_RAID_HELL,
    PLAY_LOD_ARENA,
    PLAY_LOD_ARENA_BAT
  };
  return values;
}

inline const char **EnumNamesPLAY_LOD() {
  static const char *names[] = {
    "NOTHING",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "CAMP_NORMAL",
    "CAMP_HARD",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "RAID_NORMAL",
    "RAID_HARD",
    "RAID_NIGHTMARE",
    "RAID_HELL",
    "",
    "",
    "",
    "",
    "",
    "",
    "ARENA",
    "ARENA_BAT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAY_LOD(PLAY_LOD e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPLAY_LOD()[index];
}

enum PLAY_CAMP_TAB {
  PLAY_CAMP_TAB_NOTHING = 0,
  PLAY_CAMP_TAB_CAMP = 10,
  PLAY_CAMP_TAB_HERO = 20,
  PLAY_CAMP_TAB_CHALL = 30,
  PLAY_CAMP_TAB_MIN = PLAY_CAMP_TAB_NOTHING,
  PLAY_CAMP_TAB_MAX = PLAY_CAMP_TAB_CHALL
};

inline PLAY_CAMP_TAB (&EnumValuesPLAY_CAMP_TAB())[4] {
  static PLAY_CAMP_TAB values[] = {
    PLAY_CAMP_TAB_NOTHING,
    PLAY_CAMP_TAB_CAMP,
    PLAY_CAMP_TAB_HERO,
    PLAY_CAMP_TAB_CHALL
  };
  return values;
}

enum PLAY_CAMP_REWARD_MODE {
  PLAY_CAMP_REWARD_MODE_NOTHING = 0,
  PLAY_CAMP_REWARD_MODE_CHAPTER_STAR = 10,
  PLAY_CAMP_REWARD_MODE_CHAPTER_CLEAR = 15,
  PLAY_CAMP_REWARD_MODE_EPISODE_STAR = 20,
  PLAY_CAMP_REWARD_MODE_EPISODE_CLEAR = 35,
  PLAY_CAMP_REWARD_MODE_MIN = PLAY_CAMP_REWARD_MODE_NOTHING,
  PLAY_CAMP_REWARD_MODE_MAX = PLAY_CAMP_REWARD_MODE_EPISODE_CLEAR
};

inline PLAY_CAMP_REWARD_MODE (&EnumValuesPLAY_CAMP_REWARD_MODE())[5] {
  static PLAY_CAMP_REWARD_MODE values[] = {
    PLAY_CAMP_REWARD_MODE_NOTHING,
    PLAY_CAMP_REWARD_MODE_CHAPTER_STAR,
    PLAY_CAMP_REWARD_MODE_CHAPTER_CLEAR,
    PLAY_CAMP_REWARD_MODE_EPISODE_STAR,
    PLAY_CAMP_REWARD_MODE_EPISODE_CLEAR
  };
  return values;
}

enum PLAY_CAMP_CONFIG {
  PLAY_CAMP_CONFIG_NOTHING = 0,
  PLAY_CAMP_CONFIG_CHAPTER_STAR = 10,
  PLAY_CAMP_CONFIG_CHAPTER_CLEAR = 15,
  PLAY_CAMP_CONFIG_EPISODE_STAR = 20,
  PLAY_CAMP_CONFIG_EPISODE_CLEAR = 35,
  PLAY_CAMP_CONFIG_MIN = PLAY_CAMP_CONFIG_NOTHING,
  PLAY_CAMP_CONFIG_MAX = PLAY_CAMP_CONFIG_EPISODE_CLEAR
};

inline PLAY_CAMP_CONFIG (&EnumValuesPLAY_CAMP_CONFIG())[5] {
  static PLAY_CAMP_CONFIG values[] = {
    PLAY_CAMP_CONFIG_NOTHING,
    PLAY_CAMP_CONFIG_CHAPTER_STAR,
    PLAY_CAMP_CONFIG_CHAPTER_CLEAR,
    PLAY_CAMP_CONFIG_EPISODE_STAR,
    PLAY_CAMP_CONFIG_EPISODE_CLEAR
  };
  return values;
}

enum PLAY_CLEAR_GRADE {
  PLAY_CLEAR_GRADE_CLEAR_FAILED = 0,
  PLAY_CLEAR_GRADE_CLEAR_STAR_ONE = 1,
  PLAY_CLEAR_GRADE_CLEAR_STAR_TWO = 2,
  PLAY_CLEAR_GRADE_CLEAR_STAR_THR = 3,
  PLAY_CLEAR_GRADE_MIN = PLAY_CLEAR_GRADE_CLEAR_FAILED,
  PLAY_CLEAR_GRADE_MAX = PLAY_CLEAR_GRADE_CLEAR_STAR_THR
};

inline PLAY_CLEAR_GRADE (&EnumValuesPLAY_CLEAR_GRADE())[4] {
  static PLAY_CLEAR_GRADE values[] = {
    PLAY_CLEAR_GRADE_CLEAR_FAILED,
    PLAY_CLEAR_GRADE_CLEAR_STAR_ONE,
    PLAY_CLEAR_GRADE_CLEAR_STAR_TWO,
    PLAY_CLEAR_GRADE_CLEAR_STAR_THR
  };
  return values;
}

inline const char **EnumNamesPLAY_CLEAR_GRADE() {
  static const char *names[] = {
    "CLEAR_FAILED",
    "CLEAR_STAR_ONE",
    "CLEAR_STAR_TWO",
    "CLEAR_STAR_THR",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAY_CLEAR_GRADE(PLAY_CLEAR_GRADE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPLAY_CLEAR_GRADE()[index];
}

enum PLAY_DECK_TYPE {
  PLAY_DECK_TYPE_DECK1 = 0,
  PLAY_DECK_TYPE_DECK2 = 1,
  PLAY_DECK_TYPE_DECK3 = 2,
  PLAY_DECK_TYPE_DECK4 = 3,
  PLAY_DECK_TYPE_MIN = PLAY_DECK_TYPE_DECK1,
  PLAY_DECK_TYPE_MAX = PLAY_DECK_TYPE_DECK4
};

inline PLAY_DECK_TYPE (&EnumValuesPLAY_DECK_TYPE())[4] {
  static PLAY_DECK_TYPE values[] = {
    PLAY_DECK_TYPE_DECK1,
    PLAY_DECK_TYPE_DECK2,
    PLAY_DECK_TYPE_DECK3,
    PLAY_DECK_TYPE_DECK4
  };
  return values;
}

inline const char **EnumNamesPLAY_DECK_TYPE() {
  static const char *names[] = {
    "DECK1",
    "DECK2",
    "DECK3",
    "DECK4",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAY_DECK_TYPE(PLAY_DECK_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPLAY_DECK_TYPE()[index];
}

enum PLAY_DECK_FORMATION {
  PLAY_DECK_FORMATION_OFFENSE = 0,
  PLAY_DECK_FORMATION_BALANCE = 1,
  PLAY_DECK_FORMATION_DEFENCE = 2,
  PLAY_DECK_FORMATION_NONE = 99,
  PLAY_DECK_FORMATION_MIN = PLAY_DECK_FORMATION_OFFENSE,
  PLAY_DECK_FORMATION_MAX = PLAY_DECK_FORMATION_NONE
};

inline PLAY_DECK_FORMATION (&EnumValuesPLAY_DECK_FORMATION())[4] {
  static PLAY_DECK_FORMATION values[] = {
    PLAY_DECK_FORMATION_OFFENSE,
    PLAY_DECK_FORMATION_BALANCE,
    PLAY_DECK_FORMATION_DEFENCE,
    PLAY_DECK_FORMATION_NONE
  };
  return values;
}

enum REWARD_TYPE {
  REWARD_TYPE_NONE = 0,
  REWARD_TYPE_ITEM = 1,
  REWARD_TYPE_HERO = 2,
  REWARD_TYPE_AVATAR_EXP = 3,
  REWARD_TYPE_ARENA_POINT = 4,
  REWARD_TYPE_PACK = 5,
  REWARD_TYPE_COLOSSEUM_POINT = 6,
  REWARD_TYPE_BSG = 7,
  REWARD_TYPE_TREASURE_MAP = 8,
  REWARD_TYPE_TREASURE_KEY = 9,
  REWARD_TYPE_WALLET = 10,
  REWARD_TYPE_HERO_EXP = 11,
  REWARD_TYPE_MIN = REWARD_TYPE_NONE,
  REWARD_TYPE_MAX = REWARD_TYPE_HERO_EXP
};

inline REWARD_TYPE (&EnumValuesREWARD_TYPE())[12] {
  static REWARD_TYPE values[] = {
    REWARD_TYPE_NONE,
    REWARD_TYPE_ITEM,
    REWARD_TYPE_HERO,
    REWARD_TYPE_AVATAR_EXP,
    REWARD_TYPE_ARENA_POINT,
    REWARD_TYPE_PACK,
    REWARD_TYPE_COLOSSEUM_POINT,
    REWARD_TYPE_BSG,
    REWARD_TYPE_TREASURE_MAP,
    REWARD_TYPE_TREASURE_KEY,
    REWARD_TYPE_WALLET,
    REWARD_TYPE_HERO_EXP
  };
  return values;
}

inline const char **EnumNamesREWARD_TYPE() {
  static const char *names[] = {
    "NONE",
    "ITEM",
    "HERO",
    "AVATAR_EXP",
    "ARENA_POINT",
    "PACK",
    "COLOSSEUM_POINT",
    "BSG",
    "TREASURE_MAP",
    "TREASURE_KEY",
    "WALLET",
    "HERO_EXP",
    nullptr
  };
  return names;
}

inline const char *EnumNameREWARD_TYPE(REWARD_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesREWARD_TYPE()[index];
}

enum ACHIEVE_TYPE {
  ACHIEVE_TYPE_NOTHING = 0,
  ACHIEVE_TYPE_AVATAR_LEVEL = 1,
  ACHIEVE_TYPE_HERO_GRADE_AGATHON = 2,
  ACHIEVE_TYPE_HERO_GRADE_RAYNA = 3,
  ACHIEVE_TYPE_HERO_GRADE_THAN = 4,
  ACHIEVE_TYPE_HERO_GRADE_SIRIA = 5,
  ACHIEVE_TYPE_HERO_GRADE_GRANT = 6,
  ACHIEVE_TYPE_HERO_GRADE_ZAGAN = 7,
  ACHIEVE_TYPE_HERO_GRADE_FLAME = 8,
  ACHIEVE_TYPE_HERO_GRADE_BARTOR = 9,
  ACHIEVE_TYPE_HERO_GRADE_YOSEPH = 10,
  ACHIEVE_TYPE_HERO_GRADE_AMON = 11,
  ACHIEVE_TYPE_HERO_GRADE_MOMENT = 12,
  ACHIEVE_TYPE_HERO_GRADE_BALT = 13,
  ACHIEVE_TYPE_HERO_GRADE_LUCY = 14,
  ACHIEVE_TYPE_HERO_GRADE_SOPHIA = 15,
  ACHIEVE_TYPE_HERO_GRADE_RHEA = 16,
  ACHIEVE_TYPE_HERO_GRADE_SCARLET = 17,
  ACHIEVE_TYPE_HERO_GRADE_JIN = 18,
  ACHIEVE_TYPE_HERO_GRADE_PANG = 19,
  ACHIEVE_TYPE_HERO_GRADE_TIERA = 20,
  ACHIEVE_TYPE_HERO_GRADE_BONNIE = 21,
  ACHIEVE_TYPE_HERO_GRADE_IOLA = 22,
  ACHIEVE_TYPE_HERO_GRADE_DOROTHY = 23,
  ACHIEVE_TYPE_HERO_GRADE_BANTONIO = 24,
  ACHIEVE_TYPE_HERO_GRADE_SHARON = 25,
  ACHIEVE_TYPE_HERO_GRADE_BARD = 26,
  ACHIEVE_TYPE_HERO_GRADE_BUDDY = 27,
  ACHIEVE_TYPE_HERO_GRADE_BELITA = 28,
  ACHIEVE_TYPE_HERO_GRADE_MURMUR = 29,
  ACHIEVE_TYPE_GET_HERO_CNT = 30,
  ACHIEVE_TYPE_GET_HERO_GRADE7_CNT = 31,
  ACHIEVE_TYPE_GET_HERO_GRADE8_CNT = 32,
  ACHIEVE_TYPE_GET_HERO_GRADE9_CNT = 33,
  ACHIEVE_TYPE_GET_HERO_GRADE10_CNT = 34,
  ACHIEVE_TYPE_GET_SPIRIT_CNT = 35,
  ACHIEVE_TYPE_FLOOR_ARRIVE = 36,
  ACHIEVE_TYPE_ITEM_RARE_CNT = 37,
  ACHIEVE_TYPE_ITEM_EPIC_CNT = 38,
  ACHIEVE_TYPE_ITEM_UNIQUE_CNT = 39,
  ACHIEVE_TYPE_ITEM_TOWER_CNT = 40,
  ACHIEVE_TYPE_ITEM_ENCHANT_CNT = 41,
  ACHIEVE_TYPE_ITEM_ENCHANT_SUCCESS = 42,
  ACHIEVE_TYPE_ITEM_ENCHANT_FAIL = 43,
  ACHIEVE_TYPE_ITEM_ENCHANT_LEVEL = 44,
  ACHIEVE_TYPE_ITEM_LEVEL_UP = 45,
  ACHIEVE_TYPE_ITEM_LEVEL_MAX_CNT = 46,
  ACHIEVE_TYPE_INVEN_GRIND_ITEM_CNT = 47,
  ACHIEVE_TYPE_TRY_COLOSSEUM = 48,
  ACHIEVE_TYPE_COLOSSEUM_WIN_CNT = 49,
  ACHIEVE_TYPE_COLOSSEUM_LOSE_CNT = 50,
  ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND1 = 51,
  ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND2 = 52,
  ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND3 = 53,
  ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND4 = 54,
  ACHIEVE_TYPE_COLOSSEUM_GRADE_MASTER = 55,
  ACHIEVE_TYPE_TRY_ARENA = 56,
  ACHIEVE_TYPE_ARENA_WIN_CNT = 57,
  ACHIEVE_TYPE_ARENA_LOSE_CNT = 58,
  ACHIEVE_TYPE_ARENA_TOP_RANK_RATE = 59,
  ACHIEVE_TYPE_ARENA_TOP_RANK = 60,
  ACHIEVE_TYPE_ARENA_DEFENCE_CNT = 61,
  ACHIEVE_TYPE_JOIN_TO_GUILD = 62,
  ACHIEVE_TYPE_CREATE_GUILD = 63,
  ACHIEVE_TYPE_HERO_GRIND_CNT = 64,
  ACHIEVE_TYPE_ITEM_UPGRADE_CNT = 65,
  ACHIEVE_TYPE_PROPERTY_GOLD_VALUE = 66,
  ACHIEVE_TYPE_HERO_ENCHANT_CNT = 67,
  ACHIEVE_TYPE_HERO_ENCHANT_SUCCESS_CNT = 68,
  ACHIEVE_TYPE_HERO_ENCHANT_FAIL_CNT = 69,
  ACHIEVE_TYPE_SPIRIT_GRIND_CNT = 70,
  ACHIEVE_TYPE_MIN = ACHIEVE_TYPE_NOTHING,
  ACHIEVE_TYPE_MAX = ACHIEVE_TYPE_SPIRIT_GRIND_CNT
};

inline ACHIEVE_TYPE (&EnumValuesACHIEVE_TYPE())[71] {
  static ACHIEVE_TYPE values[] = {
    ACHIEVE_TYPE_NOTHING,
    ACHIEVE_TYPE_AVATAR_LEVEL,
    ACHIEVE_TYPE_HERO_GRADE_AGATHON,
    ACHIEVE_TYPE_HERO_GRADE_RAYNA,
    ACHIEVE_TYPE_HERO_GRADE_THAN,
    ACHIEVE_TYPE_HERO_GRADE_SIRIA,
    ACHIEVE_TYPE_HERO_GRADE_GRANT,
    ACHIEVE_TYPE_HERO_GRADE_ZAGAN,
    ACHIEVE_TYPE_HERO_GRADE_FLAME,
    ACHIEVE_TYPE_HERO_GRADE_BARTOR,
    ACHIEVE_TYPE_HERO_GRADE_YOSEPH,
    ACHIEVE_TYPE_HERO_GRADE_AMON,
    ACHIEVE_TYPE_HERO_GRADE_MOMENT,
    ACHIEVE_TYPE_HERO_GRADE_BALT,
    ACHIEVE_TYPE_HERO_GRADE_LUCY,
    ACHIEVE_TYPE_HERO_GRADE_SOPHIA,
    ACHIEVE_TYPE_HERO_GRADE_RHEA,
    ACHIEVE_TYPE_HERO_GRADE_SCARLET,
    ACHIEVE_TYPE_HERO_GRADE_JIN,
    ACHIEVE_TYPE_HERO_GRADE_PANG,
    ACHIEVE_TYPE_HERO_GRADE_TIERA,
    ACHIEVE_TYPE_HERO_GRADE_BONNIE,
    ACHIEVE_TYPE_HERO_GRADE_IOLA,
    ACHIEVE_TYPE_HERO_GRADE_DOROTHY,
    ACHIEVE_TYPE_HERO_GRADE_BANTONIO,
    ACHIEVE_TYPE_HERO_GRADE_SHARON,
    ACHIEVE_TYPE_HERO_GRADE_BARD,
    ACHIEVE_TYPE_HERO_GRADE_BUDDY,
    ACHIEVE_TYPE_HERO_GRADE_BELITA,
    ACHIEVE_TYPE_HERO_GRADE_MURMUR,
    ACHIEVE_TYPE_GET_HERO_CNT,
    ACHIEVE_TYPE_GET_HERO_GRADE7_CNT,
    ACHIEVE_TYPE_GET_HERO_GRADE8_CNT,
    ACHIEVE_TYPE_GET_HERO_GRADE9_CNT,
    ACHIEVE_TYPE_GET_HERO_GRADE10_CNT,
    ACHIEVE_TYPE_GET_SPIRIT_CNT,
    ACHIEVE_TYPE_FLOOR_ARRIVE,
    ACHIEVE_TYPE_ITEM_RARE_CNT,
    ACHIEVE_TYPE_ITEM_EPIC_CNT,
    ACHIEVE_TYPE_ITEM_UNIQUE_CNT,
    ACHIEVE_TYPE_ITEM_TOWER_CNT,
    ACHIEVE_TYPE_ITEM_ENCHANT_CNT,
    ACHIEVE_TYPE_ITEM_ENCHANT_SUCCESS,
    ACHIEVE_TYPE_ITEM_ENCHANT_FAIL,
    ACHIEVE_TYPE_ITEM_ENCHANT_LEVEL,
    ACHIEVE_TYPE_ITEM_LEVEL_UP,
    ACHIEVE_TYPE_ITEM_LEVEL_MAX_CNT,
    ACHIEVE_TYPE_INVEN_GRIND_ITEM_CNT,
    ACHIEVE_TYPE_TRY_COLOSSEUM,
    ACHIEVE_TYPE_COLOSSEUM_WIN_CNT,
    ACHIEVE_TYPE_COLOSSEUM_LOSE_CNT,
    ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND1,
    ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND2,
    ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND3,
    ACHIEVE_TYPE_COLOSSEUM_GRADE_DIAMOND4,
    ACHIEVE_TYPE_COLOSSEUM_GRADE_MASTER,
    ACHIEVE_TYPE_TRY_ARENA,
    ACHIEVE_TYPE_ARENA_WIN_CNT,
    ACHIEVE_TYPE_ARENA_LOSE_CNT,
    ACHIEVE_TYPE_ARENA_TOP_RANK_RATE,
    ACHIEVE_TYPE_ARENA_TOP_RANK,
    ACHIEVE_TYPE_ARENA_DEFENCE_CNT,
    ACHIEVE_TYPE_JOIN_TO_GUILD,
    ACHIEVE_TYPE_CREATE_GUILD,
    ACHIEVE_TYPE_HERO_GRIND_CNT,
    ACHIEVE_TYPE_ITEM_UPGRADE_CNT,
    ACHIEVE_TYPE_PROPERTY_GOLD_VALUE,
    ACHIEVE_TYPE_HERO_ENCHANT_CNT,
    ACHIEVE_TYPE_HERO_ENCHANT_SUCCESS_CNT,
    ACHIEVE_TYPE_HERO_ENCHANT_FAIL_CNT,
    ACHIEVE_TYPE_SPIRIT_GRIND_CNT
  };
  return values;
}

inline const char **EnumNamesACHIEVE_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "AVATAR_LEVEL",
    "HERO_GRADE_AGATHON",
    "HERO_GRADE_RAYNA",
    "HERO_GRADE_THAN",
    "HERO_GRADE_SIRIA",
    "HERO_GRADE_GRANT",
    "HERO_GRADE_ZAGAN",
    "HERO_GRADE_FLAME",
    "HERO_GRADE_BARTOR",
    "HERO_GRADE_YOSEPH",
    "HERO_GRADE_AMON",
    "HERO_GRADE_MOMENT",
    "HERO_GRADE_BALT",
    "HERO_GRADE_LUCY",
    "HERO_GRADE_SOPHIA",
    "HERO_GRADE_RHEA",
    "HERO_GRADE_SCARLET",
    "HERO_GRADE_JIN",
    "HERO_GRADE_PANG",
    "HERO_GRADE_TIERA",
    "HERO_GRADE_BONNIE",
    "HERO_GRADE_IOLA",
    "HERO_GRADE_DOROTHY",
    "HERO_GRADE_BANTONIO",
    "HERO_GRADE_SHARON",
    "HERO_GRADE_BARD",
    "HERO_GRADE_BUDDY",
    "HERO_GRADE_BELITA",
    "HERO_GRADE_MURMUR",
    "GET_HERO_CNT",
    "GET_HERO_GRADE7_CNT",
    "GET_HERO_GRADE8_CNT",
    "GET_HERO_GRADE9_CNT",
    "GET_HERO_GRADE10_CNT",
    "GET_SPIRIT_CNT",
    "FLOOR_ARRIVE",
    "ITEM_RARE_CNT",
    "ITEM_EPIC_CNT",
    "ITEM_UNIQUE_CNT",
    "ITEM_TOWER_CNT",
    "ITEM_ENCHANT_CNT",
    "ITEM_ENCHANT_SUCCESS",
    "ITEM_ENCHANT_FAIL",
    "ITEM_ENCHANT_LEVEL",
    "ITEM_LEVEL_UP",
    "ITEM_LEVEL_MAX_CNT",
    "INVEN_GRIND_ITEM_CNT",
    "TRY_COLOSSEUM",
    "COLOSSEUM_WIN_CNT",
    "COLOSSEUM_LOSE_CNT",
    "COLOSSEUM_GRADE_DIAMOND1",
    "COLOSSEUM_GRADE_DIAMOND2",
    "COLOSSEUM_GRADE_DIAMOND3",
    "COLOSSEUM_GRADE_DIAMOND4",
    "COLOSSEUM_GRADE_MASTER",
    "TRY_ARENA",
    "ARENA_WIN_CNT",
    "ARENA_LOSE_CNT",
    "ARENA_TOP_RANK_RATE",
    "ARENA_TOP_RANK",
    "ARENA_DEFENCE_CNT",
    "JOIN_TO_GUILD",
    "CREATE_GUILD",
    "HERO_GRIND_CNT",
    "ITEM_UPGRADE_CNT",
    "PROPERTY_GOLD_VALUE",
    "HERO_ENCHANT_CNT",
    "HERO_ENCHANT_SUCCESS_CNT",
    "HERO_ENCHANT_FAIL_CNT",
    "SPIRIT_GRIND_CNT",
    nullptr
  };
  return names;
}

inline const char *EnumNameACHIEVE_TYPE(ACHIEVE_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesACHIEVE_TYPE()[index];
}

enum IS_CHECKED {
  IS_CHECKED_UNCHECKED = 0,
  IS_CHECKED_CHECKED = 1,
  IS_CHECKED_MIN = IS_CHECKED_UNCHECKED,
  IS_CHECKED_MAX = IS_CHECKED_CHECKED
};

inline IS_CHECKED (&EnumValuesIS_CHECKED())[2] {
  static IS_CHECKED values[] = {
    IS_CHECKED_UNCHECKED,
    IS_CHECKED_CHECKED
  };
  return values;
}

inline const char **EnumNamesIS_CHECKED() {
  static const char *names[] = {
    "UNCHECKED",
    "CHECKED",
    nullptr
  };
  return names;
}

inline const char *EnumNameIS_CHECKED(IS_CHECKED e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesIS_CHECKED()[index];
}

enum SHOP_PRODUCT_TYPE {
  SHOP_PRODUCT_TYPE_NOTHING = 0,
  SHOP_PRODUCT_TYPE_ITEM = 10,
  SHOP_PRODUCT_TYPE_GACHA = 20,
  SHOP_PRODUCT_TYPE_PACK = 30,
  SHOP_PRODUCT_TYPE_GACHA10 = 40,
  SHOP_PRODUCT_TYPE_MIN = SHOP_PRODUCT_TYPE_NOTHING,
  SHOP_PRODUCT_TYPE_MAX = SHOP_PRODUCT_TYPE_GACHA10
};

inline SHOP_PRODUCT_TYPE (&EnumValuesSHOP_PRODUCT_TYPE())[5] {
  static SHOP_PRODUCT_TYPE values[] = {
    SHOP_PRODUCT_TYPE_NOTHING,
    SHOP_PRODUCT_TYPE_ITEM,
    SHOP_PRODUCT_TYPE_GACHA,
    SHOP_PRODUCT_TYPE_PACK,
    SHOP_PRODUCT_TYPE_GACHA10
  };
  return values;
}

enum SHOP_ACCESS_TYPE {
  SHOP_ACCESS_TYPE_EVERYONE = 0,
  SHOP_ACCESS_TYPE_VIP = 10,
  SHOP_ACCESS_TYPE_LEVEL = 20,
  SHOP_ACCESS_TYPE_MIN = SHOP_ACCESS_TYPE_EVERYONE,
  SHOP_ACCESS_TYPE_MAX = SHOP_ACCESS_TYPE_LEVEL
};

inline SHOP_ACCESS_TYPE (&EnumValuesSHOP_ACCESS_TYPE())[3] {
  static SHOP_ACCESS_TYPE values[] = {
    SHOP_ACCESS_TYPE_EVERYONE,
    SHOP_ACCESS_TYPE_VIP,
    SHOP_ACCESS_TYPE_LEVEL
  };
  return values;
}

enum COLOSSEUM_CLASS_VAL {
  COLOSSEUM_CLASS_VAL_BRONZE_C = 0,
  COLOSSEUM_CLASS_VAL_BRONZE_B = 1,
  COLOSSEUM_CLASS_VAL_BRONZE_A = 2,
  COLOSSEUM_CLASS_VAL_BRONZE_S = 3,
  COLOSSEUM_CLASS_VAL_SILVER_C = 4,
  COLOSSEUM_CLASS_VAL_SILVER_B = 5,
  COLOSSEUM_CLASS_VAL_SILVER_A = 6,
  COLOSSEUM_CLASS_VAL_SILVER_S = 7,
  COLOSSEUM_CLASS_VAL_GOLD_C = 8,
  COLOSSEUM_CLASS_VAL_GOLD_B = 9,
  COLOSSEUM_CLASS_VAL_GOLD_A = 10,
  COLOSSEUM_CLASS_VAL_GOLD_S = 11,
  COLOSSEUM_CLASS_VAL_DIAMOND_C = 12,
  COLOSSEUM_CLASS_VAL_DIAMOND_B = 13,
  COLOSSEUM_CLASS_VAL_DIAMOND_A = 14,
  COLOSSEUM_CLASS_VAL_DIAMOND_S = 15,
  COLOSSEUM_CLASS_VAL_PLATINUM_S = 16,
  COLOSSEUM_CLASS_VAL_MIN = COLOSSEUM_CLASS_VAL_BRONZE_C,
  COLOSSEUM_CLASS_VAL_MAX = COLOSSEUM_CLASS_VAL_PLATINUM_S
};

inline COLOSSEUM_CLASS_VAL (&EnumValuesCOLOSSEUM_CLASS_VAL())[17] {
  static COLOSSEUM_CLASS_VAL values[] = {
    COLOSSEUM_CLASS_VAL_BRONZE_C,
    COLOSSEUM_CLASS_VAL_BRONZE_B,
    COLOSSEUM_CLASS_VAL_BRONZE_A,
    COLOSSEUM_CLASS_VAL_BRONZE_S,
    COLOSSEUM_CLASS_VAL_SILVER_C,
    COLOSSEUM_CLASS_VAL_SILVER_B,
    COLOSSEUM_CLASS_VAL_SILVER_A,
    COLOSSEUM_CLASS_VAL_SILVER_S,
    COLOSSEUM_CLASS_VAL_GOLD_C,
    COLOSSEUM_CLASS_VAL_GOLD_B,
    COLOSSEUM_CLASS_VAL_GOLD_A,
    COLOSSEUM_CLASS_VAL_GOLD_S,
    COLOSSEUM_CLASS_VAL_DIAMOND_C,
    COLOSSEUM_CLASS_VAL_DIAMOND_B,
    COLOSSEUM_CLASS_VAL_DIAMOND_A,
    COLOSSEUM_CLASS_VAL_DIAMOND_S,
    COLOSSEUM_CLASS_VAL_PLATINUM_S
  };
  return values;
}

inline const char **EnumNamesCOLOSSEUM_CLASS_VAL() {
  static const char *names[] = {
    "BRONZE_C",
    "BRONZE_B",
    "BRONZE_A",
    "BRONZE_S",
    "SILVER_C",
    "SILVER_B",
    "SILVER_A",
    "SILVER_S",
    "GOLD_C",
    "GOLD_B",
    "GOLD_A",
    "GOLD_S",
    "DIAMOND_C",
    "DIAMOND_B",
    "DIAMOND_A",
    "DIAMOND_S",
    "PLATINUM_S",
    nullptr
  };
  return names;
}

inline const char *EnumNameCOLOSSEUM_CLASS_VAL(COLOSSEUM_CLASS_VAL e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCOLOSSEUM_CLASS_VAL()[index];
}

enum COLOSSEUM_PLAY_TYPE {
  COLOSSEUM_PLAY_TYPE_NONE = 0,
  COLOSSEUM_PLAY_TYPE_LEADER = 1,
  COLOSSEUM_PLAY_TYPE_CREW = 2,
  COLOSSEUM_PLAY_TYPE_AI = 3,
  COLOSSEUM_PLAY_TYPE_MIN = COLOSSEUM_PLAY_TYPE_NONE,
  COLOSSEUM_PLAY_TYPE_MAX = COLOSSEUM_PLAY_TYPE_AI
};

inline COLOSSEUM_PLAY_TYPE (&EnumValuesCOLOSSEUM_PLAY_TYPE())[4] {
  static COLOSSEUM_PLAY_TYPE values[] = {
    COLOSSEUM_PLAY_TYPE_NONE,
    COLOSSEUM_PLAY_TYPE_LEADER,
    COLOSSEUM_PLAY_TYPE_CREW,
    COLOSSEUM_PLAY_TYPE_AI
  };
  return values;
}

inline const char **EnumNamesCOLOSSEUM_PLAY_TYPE() {
  static const char *names[] = {
    "NONE",
    "LEADER",
    "CREW",
    "AI",
    nullptr
  };
  return names;
}

inline const char *EnumNameCOLOSSEUM_PLAY_TYPE(COLOSSEUM_PLAY_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCOLOSSEUM_PLAY_TYPE()[index];
}

enum PD_TYPE {
  PD_TYPE_NOTHING = 0,
  PD_TYPE_NORMAL = 1,
  PD_TYPE_SYSBOT = 2,
  PD_TYPE_RESOURCE = 3,
  PD_TYPE_EVTBOT = 4,
  PD_TYPE_MIN = PD_TYPE_NOTHING,
  PD_TYPE_MAX = PD_TYPE_EVTBOT
};

inline PD_TYPE (&EnumValuesPD_TYPE())[5] {
  static PD_TYPE values[] = {
    PD_TYPE_NOTHING,
    PD_TYPE_NORMAL,
    PD_TYPE_SYSBOT,
    PD_TYPE_RESOURCE,
    PD_TYPE_EVTBOT
  };
  return values;
}

inline const char **EnumNamesPD_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "NORMAL",
    "SYSBOT",
    "RESOURCE",
    "EVTBOT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePD_TYPE(PD_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPD_TYPE()[index];
}

enum PD_LOCK_TYPE {
  PD_LOCK_TYPE_NONE = 0,
  PD_LOCK_TYPE_SOFT = 1,
  PD_LOCK_TYPE_HARD = 2,
  PD_LOCK_TYPE_MIN = PD_LOCK_TYPE_NONE,
  PD_LOCK_TYPE_MAX = PD_LOCK_TYPE_HARD
};

inline PD_LOCK_TYPE (&EnumValuesPD_LOCK_TYPE())[3] {
  static PD_LOCK_TYPE values[] = {
    PD_LOCK_TYPE_NONE,
    PD_LOCK_TYPE_SOFT,
    PD_LOCK_TYPE_HARD
  };
  return values;
}

inline const char **EnumNamesPD_LOCK_TYPE() {
  static const char *names[] = {
    "NONE",
    "SOFT",
    "HARD",
    nullptr
  };
  return names;
}

inline const char *EnumNamePD_LOCK_TYPE(PD_LOCK_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPD_LOCK_TYPE()[index];
}

enum PD_NPC {
  PD_NPC_NONE = 0,
  PD_NPC_SAVE = 1,
  PD_NPC_KILL = 2,
  PD_NPC_MIN = PD_NPC_NONE,
  PD_NPC_MAX = PD_NPC_KILL
};

inline PD_NPC (&EnumValuesPD_NPC())[3] {
  static PD_NPC values[] = {
    PD_NPC_NONE,
    PD_NPC_SAVE,
    PD_NPC_KILL
  };
  return values;
}

inline const char **EnumNamesPD_NPC() {
  static const char *names[] = {
    "NONE",
    "SAVE",
    "KILL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePD_NPC(PD_NPC e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPD_NPC()[index];
}

enum PD_NPC_TYPE {
  PD_NPC_TYPE_Nothing = 0,
  PD_NPC_TYPE_GoblinGold = 1,
  PD_NPC_TYPE_GoblinGem = 2,
  PD_NPC_TYPE_GoblinSweeper = 3,
  PD_NPC_TYPE_GoblinTitan = 4,
  PD_NPC_TYPE_GoblinStamina = 5,
  PD_NPC_TYPE_MIN = PD_NPC_TYPE_Nothing,
  PD_NPC_TYPE_MAX = PD_NPC_TYPE_GoblinStamina
};

inline PD_NPC_TYPE (&EnumValuesPD_NPC_TYPE())[6] {
  static PD_NPC_TYPE values[] = {
    PD_NPC_TYPE_Nothing,
    PD_NPC_TYPE_GoblinGold,
    PD_NPC_TYPE_GoblinGem,
    PD_NPC_TYPE_GoblinSweeper,
    PD_NPC_TYPE_GoblinTitan,
    PD_NPC_TYPE_GoblinStamina
  };
  return values;
}

inline const char **EnumNamesPD_NPC_TYPE() {
  static const char *names[] = {
    "Nothing",
    "GoblinGold",
    "GoblinGem",
    "GoblinSweeper",
    "GoblinTitan",
    "GoblinStamina",
    nullptr
  };
  return names;
}

inline const char *EnumNamePD_NPC_TYPE(PD_NPC_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPD_NPC_TYPE()[index];
}

enum PD_MINION_TYPE {
  PD_MINION_TYPE_SYSTEM = 0,
  PD_MINION_TYPE_SUPPLIED = 1,
  PD_MINION_TYPE_PURCHASED = 2,
  PD_MINION_TYPE_MIN = PD_MINION_TYPE_SYSTEM,
  PD_MINION_TYPE_MAX = PD_MINION_TYPE_PURCHASED
};

inline PD_MINION_TYPE (&EnumValuesPD_MINION_TYPE())[3] {
  static PD_MINION_TYPE values[] = {
    PD_MINION_TYPE_SYSTEM,
    PD_MINION_TYPE_SUPPLIED,
    PD_MINION_TYPE_PURCHASED
  };
  return values;
}

inline const char **EnumNamesPD_MINION_TYPE() {
  static const char *names[] = {
    "SYSTEM",
    "SUPPLIED",
    "PURCHASED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePD_MINION_TYPE(PD_MINION_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPD_MINION_TYPE()[index];
}

enum AVATAR_SKILL {
  AVATAR_SKILL_NONE = 0,
  AVATAR_SKILL_PD_HERO_3 = 1,
  AVATAR_SKILL_PD_HERO_5 = 2,
  AVATAR_SKILL_MIN = AVATAR_SKILL_NONE,
  AVATAR_SKILL_MAX = AVATAR_SKILL_PD_HERO_5
};

inline AVATAR_SKILL (&EnumValuesAVATAR_SKILL())[3] {
  static AVATAR_SKILL values[] = {
    AVATAR_SKILL_NONE,
    AVATAR_SKILL_PD_HERO_3,
    AVATAR_SKILL_PD_HERO_5
  };
  return values;
}

inline const char **EnumNamesAVATAR_SKILL() {
  static const char *names[] = {
    "NONE",
    "PD_HERO_3",
    "PD_HERO_5",
    nullptr
  };
  return names;
}

inline const char *EnumNameAVATAR_SKILL(AVATAR_SKILL e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAVATAR_SKILL()[index];
}

enum OVERLORD {
  OVERLORD_NOTHING = 0,
  OVERLORD_TUTORIAL = 1,
  OVERLORD_CAMPAIGN = 2,
  OVERLORD_CHALLENGE = 3,
  OVERLORD_ARENA = 4,
  OVERLORD_RAID = 5,
  OVERLORD_COLOSSEUM = 6,
  OVERLORD_BATTLEFIELD = 7,
  OVERLORD_MAIL = 8,
  OVERLORD_ITEM_ENCHANT = 9,
  OVERLORD_ITEM_MANUFACTURE = 10,
  OVERLORD_ITEM_GRIND = 11,
  OVERLORD_ITEM_SALE = 12,
  OVERLORD_SHOP = 13,
  OVERLORD_GUILD = 14,
  OVERLORD_HERO_EPISODE = 15,
  OVERLORD_BATTLEGROUND_20 = 16,
  OVERLORD_BATTLEGROUND_30 = 17,
  OVERLORD_BATTLEGROUND_50 = 18,
  OVERLORD_ACCOUNT_ABILITY = 19,
  OVERLORD_CRUSADER = 20,
  OVERLORD_MIN = OVERLORD_NOTHING,
  OVERLORD_MAX = OVERLORD_CRUSADER
};

inline OVERLORD (&EnumValuesOVERLORD())[21] {
  static OVERLORD values[] = {
    OVERLORD_NOTHING,
    OVERLORD_TUTORIAL,
    OVERLORD_CAMPAIGN,
    OVERLORD_CHALLENGE,
    OVERLORD_ARENA,
    OVERLORD_RAID,
    OVERLORD_COLOSSEUM,
    OVERLORD_BATTLEFIELD,
    OVERLORD_MAIL,
    OVERLORD_ITEM_ENCHANT,
    OVERLORD_ITEM_MANUFACTURE,
    OVERLORD_ITEM_GRIND,
    OVERLORD_ITEM_SALE,
    OVERLORD_SHOP,
    OVERLORD_GUILD,
    OVERLORD_HERO_EPISODE,
    OVERLORD_BATTLEGROUND_20,
    OVERLORD_BATTLEGROUND_30,
    OVERLORD_BATTLEGROUND_50,
    OVERLORD_ACCOUNT_ABILITY,
    OVERLORD_CRUSADER
  };
  return values;
}

inline const char **EnumNamesOVERLORD() {
  static const char *names[] = {
    "NOTHING",
    "TUTORIAL",
    "CAMPAIGN",
    "CHALLENGE",
    "ARENA",
    "RAID",
    "COLOSSEUM",
    "BATTLEFIELD",
    "MAIL",
    "ITEM_ENCHANT",
    "ITEM_MANUFACTURE",
    "ITEM_GRIND",
    "ITEM_SALE",
    "SHOP",
    "GUILD",
    "HERO_EPISODE",
    "BATTLEGROUND_20",
    "BATTLEGROUND_30",
    "BATTLEGROUND_50",
    "ACCOUNT_ABILITY",
    "CRUSADER",
    nullptr
  };
  return names;
}

inline const char *EnumNameOVERLORD(OVERLORD e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesOVERLORD()[index];
}

enum GUILD_GRADE {
  GUILD_GRADE_NOTHING = 0,
  GUILD_GRADE_MEMBER = 5,
  GUILD_GRADE_ELDER = 7,
  GUILD_GRADE_MASTER = 10,
  GUILD_GRADE_MIN = GUILD_GRADE_NOTHING,
  GUILD_GRADE_MAX = GUILD_GRADE_MASTER
};

inline GUILD_GRADE (&EnumValuesGUILD_GRADE())[4] {
  static GUILD_GRADE values[] = {
    GUILD_GRADE_NOTHING,
    GUILD_GRADE_MEMBER,
    GUILD_GRADE_ELDER,
    GUILD_GRADE_MASTER
  };
  return values;
}

inline const char **EnumNamesGUILD_GRADE() {
  static const char *names[] = {
    "NOTHING",
    "",
    "",
    "",
    "",
    "MEMBER",
    "",
    "ELDER",
    "",
    "",
    "MASTER",
    nullptr
  };
  return names;
}

inline const char *EnumNameGUILD_GRADE(GUILD_GRADE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGUILD_GRADE()[index];
}

enum GUILD_CONTRIBUTION_TYPE {
  GUILD_CONTRIBUTION_TYPE_NOTHING = 0,
  GUILD_CONTRIBUTION_TYPE_TYPE1 = 1,
  GUILD_CONTRIBUTION_TYPE_TYPE2 = 2,
  GUILD_CONTRIBUTION_TYPE_TYPE3 = 3,
  GUILD_CONTRIBUTION_TYPE_MIN = GUILD_CONTRIBUTION_TYPE_NOTHING,
  GUILD_CONTRIBUTION_TYPE_MAX = GUILD_CONTRIBUTION_TYPE_TYPE3
};

inline GUILD_CONTRIBUTION_TYPE (&EnumValuesGUILD_CONTRIBUTION_TYPE())[4] {
  static GUILD_CONTRIBUTION_TYPE values[] = {
    GUILD_CONTRIBUTION_TYPE_NOTHING,
    GUILD_CONTRIBUTION_TYPE_TYPE1,
    GUILD_CONTRIBUTION_TYPE_TYPE2,
    GUILD_CONTRIBUTION_TYPE_TYPE3
  };
  return values;
}

inline const char **EnumNamesGUILD_CONTRIBUTION_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "TYPE1",
    "TYPE2",
    "TYPE3",
    nullptr
  };
  return names;
}

inline const char *EnumNameGUILD_CONTRIBUTION_TYPE(GUILD_CONTRIBUTION_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGUILD_CONTRIBUTION_TYPE()[index];
}

enum GUILD_HISTORY_TYPE {
  GUILD_HISTORY_TYPE_NOTHING = 0,
  GUILD_HISTORY_TYPE_JOIN = 1,
  GUILD_HISTORY_TYPE_GRADE_UP = 2,
  GUILD_HISTORY_TYPE_GRADE_DOWN = 3,
  GUILD_HISTORY_TYPE_KICK = 4,
  GUILD_HISTORY_TYPE_QUIT = 5,
  GUILD_HISTORY_TYPE_CHANGE_NAME = 6,
  GUILD_HISTORY_TYPE_CHANGE_INFO = 7,
  GUILD_HISTORY_TYPE_LEVEL_UP = 8,
  GUILD_HISTORY_TYPE_BOSS_SPAWN = 9,
  GUILD_HISTORY_TYPE_MIN = GUILD_HISTORY_TYPE_NOTHING,
  GUILD_HISTORY_TYPE_MAX = GUILD_HISTORY_TYPE_BOSS_SPAWN
};

inline GUILD_HISTORY_TYPE (&EnumValuesGUILD_HISTORY_TYPE())[10] {
  static GUILD_HISTORY_TYPE values[] = {
    GUILD_HISTORY_TYPE_NOTHING,
    GUILD_HISTORY_TYPE_JOIN,
    GUILD_HISTORY_TYPE_GRADE_UP,
    GUILD_HISTORY_TYPE_GRADE_DOWN,
    GUILD_HISTORY_TYPE_KICK,
    GUILD_HISTORY_TYPE_QUIT,
    GUILD_HISTORY_TYPE_CHANGE_NAME,
    GUILD_HISTORY_TYPE_CHANGE_INFO,
    GUILD_HISTORY_TYPE_LEVEL_UP,
    GUILD_HISTORY_TYPE_BOSS_SPAWN
  };
  return values;
}

inline const char **EnumNamesGUILD_HISTORY_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "JOIN",
    "GRADE_UP",
    "GRADE_DOWN",
    "KICK",
    "QUIT",
    "CHANGE_NAME",
    "CHANGE_INFO",
    "LEVEL_UP",
    "BOSS_SPAWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameGUILD_HISTORY_TYPE(GUILD_HISTORY_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGUILD_HISTORY_TYPE()[index];
}

enum REWARDABLE_STATUS {
  REWARDABLE_STATUS_NOT_READY = 0,
  REWARDABLE_STATUS_READY = 1,
  REWARDABLE_STATUS_REWARDED = 2,
  REWARDABLE_STATUS_MIN = REWARDABLE_STATUS_NOT_READY,
  REWARDABLE_STATUS_MAX = REWARDABLE_STATUS_REWARDED
};

inline REWARDABLE_STATUS (&EnumValuesREWARDABLE_STATUS())[3] {
  static REWARDABLE_STATUS values[] = {
    REWARDABLE_STATUS_NOT_READY,
    REWARDABLE_STATUS_READY,
    REWARDABLE_STATUS_REWARDED
  };
  return values;
}

inline const char **EnumNamesREWARDABLE_STATUS() {
  static const char *names[] = {
    "NOT_READY",
    "READY",
    "REWARDED",
    nullptr
  };
  return names;
}

inline const char *EnumNameREWARDABLE_STATUS(REWARDABLE_STATUS e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesREWARDABLE_STATUS()[index];
}

enum ENCHANT_RESULT {
  ENCHANT_RESULT_FAIL = 0,
  ENCHANT_RESULT_SUCCESS = 1,
  ENCHANT_RESULT_DESTRUCTION = 2,
  ENCHANT_RESULT_MIN = ENCHANT_RESULT_FAIL,
  ENCHANT_RESULT_MAX = ENCHANT_RESULT_DESTRUCTION
};

inline ENCHANT_RESULT (&EnumValuesENCHANT_RESULT())[3] {
  static ENCHANT_RESULT values[] = {
    ENCHANT_RESULT_FAIL,
    ENCHANT_RESULT_SUCCESS,
    ENCHANT_RESULT_DESTRUCTION
  };
  return values;
}

inline const char **EnumNamesENCHANT_RESULT() {
  static const char *names[] = {
    "FAIL",
    "SUCCESS",
    "DESTRUCTION",
    nullptr
  };
  return names;
}

inline const char *EnumNameENCHANT_RESULT(ENCHANT_RESULT e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesENCHANT_RESULT()[index];
}

enum CHANNEL_EVENT_TYPE {
  CHANNEL_EVENT_TYPE_NOTHING = 0,
  CHANNEL_EVENT_TYPE_PVE = 1,
  CHANNEL_EVENT_TYPE_PVP = 2,
  CHANNEL_EVENT_TYPE_GVPVP = 3,
  CHANNEL_EVENT_TYPE_GVG = 4,
  CHANNEL_EVENT_TYPE_BOSS_SPAWN = 5,
  CHANNEL_EVENT_TYPE_GOLD = 6,
  CHANNEL_EVENT_TYPE_AVATAR_EXP = 7,
  CHANNEL_EVENT_TYPE_HERO_EXP = 8,
  CHANNEL_EVENT_TYPE_GEM = 9,
  CHANNEL_EVENT_TYPE_MIN = CHANNEL_EVENT_TYPE_NOTHING,
  CHANNEL_EVENT_TYPE_MAX = CHANNEL_EVENT_TYPE_GEM
};

inline CHANNEL_EVENT_TYPE (&EnumValuesCHANNEL_EVENT_TYPE())[10] {
  static CHANNEL_EVENT_TYPE values[] = {
    CHANNEL_EVENT_TYPE_NOTHING,
    CHANNEL_EVENT_TYPE_PVE,
    CHANNEL_EVENT_TYPE_PVP,
    CHANNEL_EVENT_TYPE_GVPVP,
    CHANNEL_EVENT_TYPE_GVG,
    CHANNEL_EVENT_TYPE_BOSS_SPAWN,
    CHANNEL_EVENT_TYPE_GOLD,
    CHANNEL_EVENT_TYPE_AVATAR_EXP,
    CHANNEL_EVENT_TYPE_HERO_EXP,
    CHANNEL_EVENT_TYPE_GEM
  };
  return values;
}

inline const char **EnumNamesCHANNEL_EVENT_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "PVE",
    "PVP",
    "GVPVP",
    "GVG",
    "BOSS_SPAWN",
    "GOLD",
    "AVATAR_EXP",
    "HERO_EXP",
    "GEM",
    nullptr
  };
  return names;
}

inline const char *EnumNameCHANNEL_EVENT_TYPE(CHANNEL_EVENT_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCHANNEL_EVENT_TYPE()[index];
}

enum COMMUNITY_SORT_TYPE {
  COMMUNITY_SORT_TYPE_RECENT = 0,
  COMMUNITY_SORT_TYPE_VOTE = 1,
  COMMUNITY_SORT_TYPE_BEST = 2,
  COMMUNITY_SORT_TYPE_MINE = 3,
  COMMUNITY_SORT_TYPE_MIN = COMMUNITY_SORT_TYPE_RECENT,
  COMMUNITY_SORT_TYPE_MAX = COMMUNITY_SORT_TYPE_MINE
};

inline COMMUNITY_SORT_TYPE (&EnumValuesCOMMUNITY_SORT_TYPE())[4] {
  static COMMUNITY_SORT_TYPE values[] = {
    COMMUNITY_SORT_TYPE_RECENT,
    COMMUNITY_SORT_TYPE_VOTE,
    COMMUNITY_SORT_TYPE_BEST,
    COMMUNITY_SORT_TYPE_MINE
  };
  return values;
}

inline const char **EnumNamesCOMMUNITY_SORT_TYPE() {
  static const char *names[] = {
    "RECENT",
    "VOTE",
    "BEST",
    "MINE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCOMMUNITY_SORT_TYPE(COMMUNITY_SORT_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCOMMUNITY_SORT_TYPE()[index];
}

enum ACCOUNT_LANGUAGE {
  ACCOUNT_LANGUAGE_VE_KOR = 0,
  ACCOUNT_LANGUAGE_VE_ENG = 1,
  ACCOUNT_LANGUAGE_VE_CHN = 2,
  ACCOUNT_LANGUAGE_VE_TWN = 3,
  ACCOUNT_LANGUAGE_MIN = ACCOUNT_LANGUAGE_VE_KOR,
  ACCOUNT_LANGUAGE_MAX = ACCOUNT_LANGUAGE_VE_TWN
};

inline ACCOUNT_LANGUAGE (&EnumValuesACCOUNT_LANGUAGE())[4] {
  static ACCOUNT_LANGUAGE values[] = {
    ACCOUNT_LANGUAGE_VE_KOR,
    ACCOUNT_LANGUAGE_VE_ENG,
    ACCOUNT_LANGUAGE_VE_CHN,
    ACCOUNT_LANGUAGE_VE_TWN
  };
  return values;
}

inline const char **EnumNamesACCOUNT_LANGUAGE() {
  static const char *names[] = {
    "VE_KOR",
    "VE_ENG",
    "VE_CHN",
    "VE_TWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameACCOUNT_LANGUAGE(ACCOUNT_LANGUAGE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesACCOUNT_LANGUAGE()[index];
}

enum CLIENT_SDK_FLAG {
  CLIENT_SDK_FLAG_NONE = 0,
  CLIENT_SDK_FLAG_KAKAO_MESSAGE_GET = 1,
  CLIENT_SDK_FLAG_MIN = CLIENT_SDK_FLAG_NONE,
  CLIENT_SDK_FLAG_MAX = CLIENT_SDK_FLAG_KAKAO_MESSAGE_GET
};

inline CLIENT_SDK_FLAG (&EnumValuesCLIENT_SDK_FLAG())[2] {
  static CLIENT_SDK_FLAG values[] = {
    CLIENT_SDK_FLAG_NONE,
    CLIENT_SDK_FLAG_KAKAO_MESSAGE_GET
  };
  return values;
}

inline const char **EnumNamesCLIENT_SDK_FLAG() {
  static const char *names[] = {
    "NONE",
    "KAKAO_MESSAGE_GET",
    nullptr
  };
  return names;
}

inline const char *EnumNameCLIENT_SDK_FLAG(CLIENT_SDK_FLAG e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCLIENT_SDK_FLAG()[index];
}

enum CONTENTS_TYPE {
  CONTENTS_TYPE_NOTHING = 0,
  CONTENTS_TYPE_CAMPAIGN = 1,
  CONTENTS_TYPE_HERO_EPISODE = 2,
  CONTENTS_TYPE_RAID = 3,
  CONTENTS_TYPE_CRUSADER = 4,
  CONTENTS_TYPE_WEEK_DUNGEON = 5,
  CONTENTS_TYPE_COLOSSEUM = 6,
  CONTENTS_TYPE_MIN = CONTENTS_TYPE_NOTHING,
  CONTENTS_TYPE_MAX = CONTENTS_TYPE_COLOSSEUM
};

inline CONTENTS_TYPE (&EnumValuesCONTENTS_TYPE())[7] {
  static CONTENTS_TYPE values[] = {
    CONTENTS_TYPE_NOTHING,
    CONTENTS_TYPE_CAMPAIGN,
    CONTENTS_TYPE_HERO_EPISODE,
    CONTENTS_TYPE_RAID,
    CONTENTS_TYPE_CRUSADER,
    CONTENTS_TYPE_WEEK_DUNGEON,
    CONTENTS_TYPE_COLOSSEUM
  };
  return values;
}

inline const char **EnumNamesCONTENTS_TYPE() {
  static const char *names[] = {
    "NOTHING",
    "CAMPAIGN",
    "HERO_EPISODE",
    "RAID",
    "CRUSADER",
    "WEEK_DUNGEON",
    "COLOSSEUM",
    nullptr
  };
  return names;
}

inline const char *EnumNameCONTENTS_TYPE(CONTENTS_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCONTENTS_TYPE()[index];
}

enum PREFER_TARGET_TYPE {
  PREFER_TARGET_TYPE_NONE = 0,
  PREFER_TARGET_TYPE_TANKER = 1,
  PREFER_TARGET_TYPE_MELEE_DEALER = 2,
  PREFER_TARGET_TYPE_RANGE_DEALER = 3,
  PREFER_TARGET_TYPE_MAGIC_DEALER = 4,
  PREFER_TARGET_TYPE_SUPPORTER = 5,
  PREFER_TARGET_TYPE_MIN = PREFER_TARGET_TYPE_NONE,
  PREFER_TARGET_TYPE_MAX = PREFER_TARGET_TYPE_SUPPORTER
};

inline PREFER_TARGET_TYPE (&EnumValuesPREFER_TARGET_TYPE())[6] {
  static PREFER_TARGET_TYPE values[] = {
    PREFER_TARGET_TYPE_NONE,
    PREFER_TARGET_TYPE_TANKER,
    PREFER_TARGET_TYPE_MELEE_DEALER,
    PREFER_TARGET_TYPE_RANGE_DEALER,
    PREFER_TARGET_TYPE_MAGIC_DEALER,
    PREFER_TARGET_TYPE_SUPPORTER
  };
  return values;
}

inline const char **EnumNamesPREFER_TARGET_TYPE() {
  static const char *names[] = {
    "NONE",
    "TANKER",
    "MELEE_DEALER",
    "RANGE_DEALER",
    "MAGIC_DEALER",
    "SUPPORTER",
    nullptr
  };
  return names;
}

inline const char *EnumNamePREFER_TARGET_TYPE(PREFER_TARGET_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPREFER_TARGET_TYPE()[index];
}

enum MIRROR_TYPE {
  MIRROR_TYPE_PAST = 0,
  MIRROR_TYPE_PRESENT = 1,
  MIRROR_TYPE_FUTURE = 2,
  MIRROR_TYPE_MIN = MIRROR_TYPE_PAST,
  MIRROR_TYPE_MAX = MIRROR_TYPE_FUTURE
};

inline MIRROR_TYPE (&EnumValuesMIRROR_TYPE())[3] {
  static MIRROR_TYPE values[] = {
    MIRROR_TYPE_PAST,
    MIRROR_TYPE_PRESENT,
    MIRROR_TYPE_FUTURE
  };
  return values;
}

inline const char **EnumNamesMIRROR_TYPE() {
  static const char *names[] = {
    "PAST",
    "PRESENT",
    "FUTURE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMIRROR_TYPE(MIRROR_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMIRROR_TYPE()[index];
}

enum SHOP_FLOORSHOP_SLOT_STATE {
  SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT = 0,
  SHOP_FLOORSHOP_SLOT_STATE_ENABLED_BUY = 1,
  SHOP_FLOORSHOP_SLOT_STATE_ENABLED_OPEN = 2,
  SHOP_FLOORSHOP_SLOT_STATE_DISABLED_FLOOR = 3,
  SHOP_FLOORSHOP_SLOT_STATE_DISABLED_OPEN = 4,
  SHOP_FLOORSHOP_SLOT_STATE_MIN = SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT,
  SHOP_FLOORSHOP_SLOT_STATE_MAX = SHOP_FLOORSHOP_SLOT_STATE_DISABLED_OPEN
};

inline SHOP_FLOORSHOP_SLOT_STATE (&EnumValuesSHOP_FLOORSHOP_SLOT_STATE())[5] {
  static SHOP_FLOORSHOP_SLOT_STATE values[] = {
    SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT,
    SHOP_FLOORSHOP_SLOT_STATE_ENABLED_BUY,
    SHOP_FLOORSHOP_SLOT_STATE_ENABLED_OPEN,
    SHOP_FLOORSHOP_SLOT_STATE_DISABLED_FLOOR,
    SHOP_FLOORSHOP_SLOT_STATE_DISABLED_OPEN
  };
  return values;
}

inline const char **EnumNamesSHOP_FLOORSHOP_SLOT_STATE() {
  static const char *names[] = {
    "SOLDOUT",
    "ENABLED_BUY",
    "ENABLED_OPEN",
    "DISABLED_FLOOR",
    "DISABLED_OPEN",
    nullptr
  };
  return names;
}

inline const char *EnumNameSHOP_FLOORSHOP_SLOT_STATE(SHOP_FLOORSHOP_SLOT_STATE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesSHOP_FLOORSHOP_SLOT_STATE()[index];
}

enum INVENTORY_UPGRADE_TYPE {
  INVENTORY_UPGRADE_TYPE_ITEM = 0,
  INVENTORY_UPGRADE_TYPE_HERO = 1,
  INVENTORY_UPGRADE_TYPE_MIN = INVENTORY_UPGRADE_TYPE_ITEM,
  INVENTORY_UPGRADE_TYPE_MAX = INVENTORY_UPGRADE_TYPE_HERO
};

inline INVENTORY_UPGRADE_TYPE (&EnumValuesINVENTORY_UPGRADE_TYPE())[2] {
  static INVENTORY_UPGRADE_TYPE values[] = {
    INVENTORY_UPGRADE_TYPE_ITEM,
    INVENTORY_UPGRADE_TYPE_HERO
  };
  return values;
}

inline const char **EnumNamesINVENTORY_UPGRADE_TYPE() {
  static const char *names[] = {
    "ITEM",
    "HERO",
    nullptr
  };
  return names;
}

inline const char *EnumNameINVENTORY_UPGRADE_TYPE(INVENTORY_UPGRADE_TYPE e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesINVENTORY_UPGRADE_TYPE()[index];
}

enum FLOOR_MISSION_CLASS_CONDITION_TYPE {
  FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER = 0,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_MELEEDEALER = 1,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_RANGEDEALER = 2,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_SUPPORTER = 5,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_MAGICDEALER = 6,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_NONE = 99,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_MIN = FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER,
  FLOOR_MISSION_CLASS_CONDITION_TYPE_MAX = FLOOR_MISSION_CLASS_CONDITION_TYPE_NONE
};

inline FLOOR_MISSION_CLASS_CONDITION_TYPE (&EnumValuesFLOOR_MISSION_CLASS_CONDITION_TYPE())[6] {
  static FLOOR_MISSION_CLASS_CONDITION_TYPE values[] = {
    FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER,
    FLOOR_MISSION_CLASS_CONDITION_TYPE_MELEEDEALER,
    FLOOR_MISSION_CLASS_CONDITION_TYPE_RANGEDEALER,
    FLOOR_MISSION_CLASS_CONDITION_TYPE_SUPPORTER,
    FLOOR_MISSION_CLASS_CONDITION_TYPE_MAGICDEALER,
    FLOOR_MISSION_CLASS_CONDITION_TYPE_NONE
  };
  return values;
}

enum WALLET_TYPE1 {
  WALLET_TYPE1_NONE = 0,
  WALLET_TYPE1_GOLD = 1,
  WALLET_TYPE1_GEM = 2,
  WALLET_TYPE1_MILEAGE = 3,
  WALLET_TYPE1_SPIRIT_STONE = 4,
  WALLET_TYPE1_HERO_RUNE = 5,
  WALLET_TYPE1_GUILD_RAID_POINT = 6,
  WALLET_TYPE1_REDSTONE = 7,
  WALLET_TYPE1_PVPTOKEN = 8,
  WALLET_TYPE1_BGT1 = 9,
  WALLET_TYPE1_BGT2 = 10,
  WALLET_TYPE1_BGT3 = 11,
  WALLET_TYPE1_STAMINA = 12,
  WALLET_TYPE1_STAMINA_PVP = 13,
  WALLET_TYPE1_ENCHANTSCROLL_WEAPON01 = 14,
  WALLET_TYPE1_ENCHANTSCROLL_WEAPON02 = 15,
  WALLET_TYPE1_ENCHANTSCROLL_ARMOR01 = 16,
  WALLET_TYPE1_ENCHANTSCROLL_ARMOR02 = 17,
  WALLET_TYPE1_ENCHANTSCROLL_ACCESSARY01 = 18,
  WALLET_TYPE1_ENCHANTSCROLL_ACCESSARY02 = 19,
  WALLET_TYPE1_ESSENCE_IELO = 20,
  WALLET_TYPE1_TITANSTONE01 = 21,
  WALLET_TYPE1_TITANSTONE02 = 22,
  WALLET_TYPE1_TITANSTONE03 = 23,
  WALLET_TYPE1_TITANSTONE04 = 24,
  WALLET_TYPE1_TITANSTONE05 = 25,
  WALLET_TYPE1_EXP_WEAPON01 = 26,
  WALLET_TYPE1_EXP_ARMOR01 = 27,
  WALLET_TYPE1_EXP_PANTS01 = 28,
  WALLET_TYPE1_EXP_ACCESSARY01 = 29,
  WALLET_TYPE1_TITAN_STONE = 30,
  WALLET_TYPE1_SWEEP_TICKET = 31,
  WALLET_TYPE1_HERO_UPGRADEMATERIAL = 32,
  WALLET_TYPE1_ITEM_OPTIONRESETMATERIAL = 33,
  WALLET_TYPE1_ITEM_UPGRADEMATERIAL = 34,
  WALLET_TYPE1_SUMMONTICKET01 = 35,
  WALLET_TYPE1_SUMMONTICKET02 = 36,
  WALLET_TYPE1_FLOORCOIN05 = 37,
  WALLET_TYPE1_FLOORCOIN06 = 38,
  WALLET_TYPE1_FLOORCOIN07 = 39,
  WALLET_TYPE1_FLOORCOIN08 = 40,
  WALLET_TYPE1_FLOORCOIN09 = 41,
  WALLET_TYPE1_FLOORCOIN10 = 42,
  WALLET_TYPE1_FLOORCOIN11 = 43,
  WALLET_TYPE1_FLOORCOIN12 = 44,
  WALLET_TYPE1_FLOORCOIN13 = 45,
  WALLET_TYPE1_FLOORCOIN14 = 46,
  WALLET_TYPE1_FLOORCOIN15 = 47,
  WALLET_TYPE1_FLOORCOIN16 = 48,
  WALLET_TYPE1_FLOORCOIN17 = 49,
  WALLET_TYPE1_FLOORCOIN18 = 50,
  WALLET_TYPE1_FLOORCOIN19 = 51,
  WALLET_TYPE1_FLOORCOIN20 = 52,
  WALLET_TYPE1_FLOORCOIN21 = 53,
  WALLET_TYPE1_FLOORCOIN22 = 54,
  WALLET_TYPE1_FLOORCOIN23 = 55,
  WALLET_TYPE1_FLOORCOIN24 = 56,
  WALLET_TYPE1_FLOORSTORETICKET = 57,
  WALLET_TYPE1_MISSION_ADD_SCROLL = 58,
  WALLET_TYPE1_MISSION_ADD_SCROLL_FREE = 59,
  WALLET_TYPE1_ITEM_UPGRADEMATERIAL02 = 60,
  WALLET_TYPE1_MIN = WALLET_TYPE1_NONE,
  WALLET_TYPE1_MAX = WALLET_TYPE1_ITEM_UPGRADEMATERIAL02
};

inline WALLET_TYPE1 (&EnumValuesWALLET_TYPE1())[61] {
  static WALLET_TYPE1 values[] = {
    WALLET_TYPE1_NONE,
    WALLET_TYPE1_GOLD,
    WALLET_TYPE1_GEM,
    WALLET_TYPE1_MILEAGE,
    WALLET_TYPE1_SPIRIT_STONE,
    WALLET_TYPE1_HERO_RUNE,
    WALLET_TYPE1_GUILD_RAID_POINT,
    WALLET_TYPE1_REDSTONE,
    WALLET_TYPE1_PVPTOKEN,
    WALLET_TYPE1_BGT1,
    WALLET_TYPE1_BGT2,
    WALLET_TYPE1_BGT3,
    WALLET_TYPE1_STAMINA,
    WALLET_TYPE1_STAMINA_PVP,
    WALLET_TYPE1_ENCHANTSCROLL_WEAPON01,
    WALLET_TYPE1_ENCHANTSCROLL_WEAPON02,
    WALLET_TYPE1_ENCHANTSCROLL_ARMOR01,
    WALLET_TYPE1_ENCHANTSCROLL_ARMOR02,
    WALLET_TYPE1_ENCHANTSCROLL_ACCESSARY01,
    WALLET_TYPE1_ENCHANTSCROLL_ACCESSARY02,
    WALLET_TYPE1_ESSENCE_IELO,
    WALLET_TYPE1_TITANSTONE01,
    WALLET_TYPE1_TITANSTONE02,
    WALLET_TYPE1_TITANSTONE03,
    WALLET_TYPE1_TITANSTONE04,
    WALLET_TYPE1_TITANSTONE05,
    WALLET_TYPE1_EXP_WEAPON01,
    WALLET_TYPE1_EXP_ARMOR01,
    WALLET_TYPE1_EXP_PANTS01,
    WALLET_TYPE1_EXP_ACCESSARY01,
    WALLET_TYPE1_TITAN_STONE,
    WALLET_TYPE1_SWEEP_TICKET,
    WALLET_TYPE1_HERO_UPGRADEMATERIAL,
    WALLET_TYPE1_ITEM_OPTIONRESETMATERIAL,
    WALLET_TYPE1_ITEM_UPGRADEMATERIAL,
    WALLET_TYPE1_SUMMONTICKET01,
    WALLET_TYPE1_SUMMONTICKET02,
    WALLET_TYPE1_FLOORCOIN05,
    WALLET_TYPE1_FLOORCOIN06,
    WALLET_TYPE1_FLOORCOIN07,
    WALLET_TYPE1_FLOORCOIN08,
    WALLET_TYPE1_FLOORCOIN09,
    WALLET_TYPE1_FLOORCOIN10,
    WALLET_TYPE1_FLOORCOIN11,
    WALLET_TYPE1_FLOORCOIN12,
    WALLET_TYPE1_FLOORCOIN13,
    WALLET_TYPE1_FLOORCOIN14,
    WALLET_TYPE1_FLOORCOIN15,
    WALLET_TYPE1_FLOORCOIN16,
    WALLET_TYPE1_FLOORCOIN17,
    WALLET_TYPE1_FLOORCOIN18,
    WALLET_TYPE1_FLOORCOIN19,
    WALLET_TYPE1_FLOORCOIN20,
    WALLET_TYPE1_FLOORCOIN21,
    WALLET_TYPE1_FLOORCOIN22,
    WALLET_TYPE1_FLOORCOIN23,
    WALLET_TYPE1_FLOORCOIN24,
    WALLET_TYPE1_FLOORSTORETICKET,
    WALLET_TYPE1_MISSION_ADD_SCROLL,
    WALLET_TYPE1_MISSION_ADD_SCROLL_FREE,
    WALLET_TYPE1_ITEM_UPGRADEMATERIAL02
  };
  return values;
}

inline const char **EnumNamesWALLET_TYPE1() {
  static const char *names[] = {
    "NONE",
    "GOLD",
    "GEM",
    "MILEAGE",
    "SPIRIT_STONE",
    "HERO_RUNE",
    "GUILD_RAID_POINT",
    "REDSTONE",
    "PVPTOKEN",
    "BGT1",
    "BGT2",
    "BGT3",
    "STAMINA",
    "STAMINA_PVP",
    "ENCHANTSCROLL_WEAPON01",
    "ENCHANTSCROLL_WEAPON02",
    "ENCHANTSCROLL_ARMOR01",
    "ENCHANTSCROLL_ARMOR02",
    "ENCHANTSCROLL_ACCESSARY01",
    "ENCHANTSCROLL_ACCESSARY02",
    "ESSENCE_IELO",
    "TITANSTONE01",
    "TITANSTONE02",
    "TITANSTONE03",
    "TITANSTONE04",
    "TITANSTONE05",
    "EXP_WEAPON01",
    "EXP_ARMOR01",
    "EXP_PANTS01",
    "EXP_ACCESSARY01",
    "TITAN_STONE",
    "SWEEP_TICKET",
    "HERO_UPGRADEMATERIAL",
    "ITEM_OPTIONRESETMATERIAL",
    "ITEM_UPGRADEMATERIAL",
    "SUMMONTICKET01",
    "SUMMONTICKET02",
    "FLOORCOIN05",
    "FLOORCOIN06",
    "FLOORCOIN07",
    "FLOORCOIN08",
    "FLOORCOIN09",
    "FLOORCOIN10",
    "FLOORCOIN11",
    "FLOORCOIN12",
    "FLOORCOIN13",
    "FLOORCOIN14",
    "FLOORCOIN15",
    "FLOORCOIN16",
    "FLOORCOIN17",
    "FLOORCOIN18",
    "FLOORCOIN19",
    "FLOORCOIN20",
    "FLOORCOIN21",
    "FLOORCOIN22",
    "FLOORCOIN23",
    "FLOORCOIN24",
    "FLOORSTORETICKET",
    "MISSION_ADD_SCROLL",
    "MISSION_ADD_SCROLL_FREE",
    "ITEM_UPGRADEMATERIAL02",
    nullptr
  };
  return names;
}

inline const char *EnumNameWALLET_TYPE1(WALLET_TYPE1 e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWALLET_TYPE1()[index];
}

enum WALLET_TYPE2 {
  WALLET_TYPE2_ARENA_DAILYBONUSTOKEN = 0,
  WALLET_TYPE2_ARENA_DEFENDERRESETTOKEN = 1,
  WALLET_TYPE2_MIRROR_DEFENDERRESET_FREE = 2,
  WALLET_TYPE2_MIRROR_ENTRANCE = 3,
  WALLET_TYPE2_FLOORSTORE_RESETTOKEN = 4,
  WALLET_TYPE2_FLOORSTORE_RESETTOKEN_GEM = 5,
  WALLET_TYPE2_TIMETREASURE_GOLD = 6,
  WALLET_TYPE2_TIMETREASURE_HERORUNE = 7,
  WALLET_TYPE2_TIMETREASURE_AVATAR_EXP = 8,
  WALLET_TYPE2_TIMETREASURE_EQUIP = 9,
  WALLET_TYPE2_TIMETREASURE_RUNE = 10,
  WALLET_TYPE2_ITEM_INVENTORY_SLOT_TOKEN = 11,
  WALLET_TYPE2_HERO_INVENTORY_SLOT_TOKEN = 12,
  WALLET_TYPE2_S_AKHAN_EASY = 13,
  WALLET_TYPE2_S_AKHAN_NORMAL = 14,
  WALLET_TYPE2_S_AKHAN_HARD = 15,
  WALLET_TYPE2_S_AKHAN_VERYHARD = 16,
  WALLET_TYPE2_S_GIGANT_EASY = 17,
  WALLET_TYPE2_S_GIGANT_NORMAL = 18,
  WALLET_TYPE2_S_GIGANT_HARD = 19,
  WALLET_TYPE2_S_GIGANT_VERYHARD = 20,
  WALLET_TYPE2_S_MORS_EASY = 21,
  WALLET_TYPE2_S_MORS_NORMAL = 22,
  WALLET_TYPE2_S_MORS_HARD = 23,
  WALLET_TYPE2_S_MORS_VERYHARD = 24,
  WALLET_TYPE2_S_TOWERBOSS_F1 = 25,
  WALLET_TYPE2_S_TOWERBOSS_F2 = 26,
  WALLET_TYPE2_S_TOWERBOSS_F3 = 27,
  WALLET_TYPE2_S_TOWERBOSS_F4 = 28,
  WALLET_TYPE2_S_TOWERBOSS_F5 = 29,
  WALLET_TYPE2_S_TOWERBOSS_F6 = 30,
  WALLET_TYPE2_S_TOWERBOSS_F7 = 31,
  WALLET_TYPE2_S_TOWERBOSS_F8 = 32,
  WALLET_TYPE2_S_TOWERBOSS_F9 = 33,
  WALLET_TYPE2_S_TOWERBOSS_F10 = 34,
  WALLET_TYPE2_S_TOWERBOSS_F11 = 35,
  WALLET_TYPE2_S_TOWERBOSS_F12 = 36,
  WALLET_TYPE2_S_TOWERBOSS_F13 = 37,
  WALLET_TYPE2_S_TOWERBOSS_F14 = 38,
  WALLET_TYPE2_S_TOWERBOSS_F15 = 39,
  WALLET_TYPE2_S_TOWERBOSS_F16 = 40,
  WALLET_TYPE2_S_TOWERBOSS_F17 = 41,
  WALLET_TYPE2_S_TOWERBOSS_F18 = 42,
  WALLET_TYPE2_S_TOWERBOSS_F19 = 43,
  WALLET_TYPE2_S_TOWERBOSS_F20 = 44,
  WALLET_TYPE2_S_TOWERBOSS_F21 = 45,
  WALLET_TYPE2_S_TOWERBOSS_F22 = 46,
  WALLET_TYPE2_S_TOWERBOSS_F23 = 47,
  WALLET_TYPE2_S_TOWERBOSS_F24 = 48,
  WALLET_TYPE2_S_TOWERBOSS_F25 = 49,
  WALLET_TYPE2_MIN = WALLET_TYPE2_ARENA_DAILYBONUSTOKEN,
  WALLET_TYPE2_MAX = WALLET_TYPE2_S_TOWERBOSS_F25
};

inline WALLET_TYPE2 (&EnumValuesWALLET_TYPE2())[50] {
  static WALLET_TYPE2 values[] = {
    WALLET_TYPE2_ARENA_DAILYBONUSTOKEN,
    WALLET_TYPE2_ARENA_DEFENDERRESETTOKEN,
    WALLET_TYPE2_MIRROR_DEFENDERRESET_FREE,
    WALLET_TYPE2_MIRROR_ENTRANCE,
    WALLET_TYPE2_FLOORSTORE_RESETTOKEN,
    WALLET_TYPE2_FLOORSTORE_RESETTOKEN_GEM,
    WALLET_TYPE2_TIMETREASURE_GOLD,
    WALLET_TYPE2_TIMETREASURE_HERORUNE,
    WALLET_TYPE2_TIMETREASURE_AVATAR_EXP,
    WALLET_TYPE2_TIMETREASURE_EQUIP,
    WALLET_TYPE2_TIMETREASURE_RUNE,
    WALLET_TYPE2_ITEM_INVENTORY_SLOT_TOKEN,
    WALLET_TYPE2_HERO_INVENTORY_SLOT_TOKEN,
    WALLET_TYPE2_S_AKHAN_EASY,
    WALLET_TYPE2_S_AKHAN_NORMAL,
    WALLET_TYPE2_S_AKHAN_HARD,
    WALLET_TYPE2_S_AKHAN_VERYHARD,
    WALLET_TYPE2_S_GIGANT_EASY,
    WALLET_TYPE2_S_GIGANT_NORMAL,
    WALLET_TYPE2_S_GIGANT_HARD,
    WALLET_TYPE2_S_GIGANT_VERYHARD,
    WALLET_TYPE2_S_MORS_EASY,
    WALLET_TYPE2_S_MORS_NORMAL,
    WALLET_TYPE2_S_MORS_HARD,
    WALLET_TYPE2_S_MORS_VERYHARD,
    WALLET_TYPE2_S_TOWERBOSS_F1,
    WALLET_TYPE2_S_TOWERBOSS_F2,
    WALLET_TYPE2_S_TOWERBOSS_F3,
    WALLET_TYPE2_S_TOWERBOSS_F4,
    WALLET_TYPE2_S_TOWERBOSS_F5,
    WALLET_TYPE2_S_TOWERBOSS_F6,
    WALLET_TYPE2_S_TOWERBOSS_F7,
    WALLET_TYPE2_S_TOWERBOSS_F8,
    WALLET_TYPE2_S_TOWERBOSS_F9,
    WALLET_TYPE2_S_TOWERBOSS_F10,
    WALLET_TYPE2_S_TOWERBOSS_F11,
    WALLET_TYPE2_S_TOWERBOSS_F12,
    WALLET_TYPE2_S_TOWERBOSS_F13,
    WALLET_TYPE2_S_TOWERBOSS_F14,
    WALLET_TYPE2_S_TOWERBOSS_F15,
    WALLET_TYPE2_S_TOWERBOSS_F16,
    WALLET_TYPE2_S_TOWERBOSS_F17,
    WALLET_TYPE2_S_TOWERBOSS_F18,
    WALLET_TYPE2_S_TOWERBOSS_F19,
    WALLET_TYPE2_S_TOWERBOSS_F20,
    WALLET_TYPE2_S_TOWERBOSS_F21,
    WALLET_TYPE2_S_TOWERBOSS_F22,
    WALLET_TYPE2_S_TOWERBOSS_F23,
    WALLET_TYPE2_S_TOWERBOSS_F24,
    WALLET_TYPE2_S_TOWERBOSS_F25
  };
  return values;
}

inline const char **EnumNamesWALLET_TYPE2() {
  static const char *names[] = {
    "ARENA_DAILYBONUSTOKEN",
    "ARENA_DEFENDERRESETTOKEN",
    "MIRROR_DEFENDERRESET_FREE",
    "MIRROR_ENTRANCE",
    "FLOORSTORE_RESETTOKEN",
    "FLOORSTORE_RESETTOKEN_GEM",
    "TIMETREASURE_GOLD",
    "TIMETREASURE_HERORUNE",
    "TIMETREASURE_AVATAR_EXP",
    "TIMETREASURE_EQUIP",
    "TIMETREASURE_RUNE",
    "ITEM_INVENTORY_SLOT_TOKEN",
    "HERO_INVENTORY_SLOT_TOKEN",
    "S_AKHAN_EASY",
    "S_AKHAN_NORMAL",
    "S_AKHAN_HARD",
    "S_AKHAN_VERYHARD",
    "S_GIGANT_EASY",
    "S_GIGANT_NORMAL",
    "S_GIGANT_HARD",
    "S_GIGANT_VERYHARD",
    "S_MORS_EASY",
    "S_MORS_NORMAL",
    "S_MORS_HARD",
    "S_MORS_VERYHARD",
    "S_TOWERBOSS_F1",
    "S_TOWERBOSS_F2",
    "S_TOWERBOSS_F3",
    "S_TOWERBOSS_F4",
    "S_TOWERBOSS_F5",
    "S_TOWERBOSS_F6",
    "S_TOWERBOSS_F7",
    "S_TOWERBOSS_F8",
    "S_TOWERBOSS_F9",
    "S_TOWERBOSS_F10",
    "S_TOWERBOSS_F11",
    "S_TOWERBOSS_F12",
    "S_TOWERBOSS_F13",
    "S_TOWERBOSS_F14",
    "S_TOWERBOSS_F15",
    "S_TOWERBOSS_F16",
    "S_TOWERBOSS_F17",
    "S_TOWERBOSS_F18",
    "S_TOWERBOSS_F19",
    "S_TOWERBOSS_F20",
    "S_TOWERBOSS_F21",
    "S_TOWERBOSS_F22",
    "S_TOWERBOSS_F23",
    "S_TOWERBOSS_F24",
    "S_TOWERBOSS_F25",
    nullptr
  };
  return names;
}

inline const char *EnumNameWALLET_TYPE2(WALLET_TYPE2 e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWALLET_TYPE2()[index];
}

enum WALLET_TYPE3 {
  WALLET_TYPE3_RUNE001 = 0,
  WALLET_TYPE3_RUNE002 = 1,
  WALLET_TYPE3_RUNE003 = 2,
  WALLET_TYPE3_RUNE004 = 3,
  WALLET_TYPE3_RUNE005 = 4,
  WALLET_TYPE3_RUNE006 = 5,
  WALLET_TYPE3_RUNE007 = 6,
  WALLET_TYPE3_RUNE008 = 7,
  WALLET_TYPE3_RUNE009 = 8,
  WALLET_TYPE3_RUNE010 = 9,
  WALLET_TYPE3_RUNE011 = 10,
  WALLET_TYPE3_RUNE012 = 11,
  WALLET_TYPE3_RUNE013 = 12,
  WALLET_TYPE3_RUNE014 = 13,
  WALLET_TYPE3_RUNE015 = 14,
  WALLET_TYPE3_RUNE016 = 15,
  WALLET_TYPE3_RUNE017 = 16,
  WALLET_TYPE3_RUNE018 = 17,
  WALLET_TYPE3_RUNE019 = 18,
  WALLET_TYPE3_RUNE020 = 19,
  WALLET_TYPE3_POTION = 20,
  WALLET_TYPE3_BOOSTER = 21,
  WALLET_TYPE3_HEROPIECE_AGATHON03 = 22,
  WALLET_TYPE3_HEROPIECE_AGATHON04 = 23,
  WALLET_TYPE3_HEROPIECE_AGATHON05 = 24,
  WALLET_TYPE3_HEROPIECE_RAYNA03 = 25,
  WALLET_TYPE3_HEROPIECE_RAYNA04 = 26,
  WALLET_TYPE3_HEROPIECE_RAYNA05 = 27,
  WALLET_TYPE3_HEROPIECE_YOSEPH03 = 28,
  WALLET_TYPE3_HEROPIECE_YOSEPH04 = 29,
  WALLET_TYPE3_HEROPIECE_YOSEPH05 = 30,
  WALLET_TYPE3_HEROPIECE_THAN03 = 31,
  WALLET_TYPE3_HEROPIECE_THAN04 = 32,
  WALLET_TYPE3_HEROPIECE_THAN05 = 33,
  WALLET_TYPE3_HEROPIECE_AMON03 = 34,
  WALLET_TYPE3_HEROPIECE_AMON04 = 35,
  WALLET_TYPE3_HEROPIECE_AMON05 = 36,
  WALLET_TYPE3_HEROPIECE_MOMENT03 = 37,
  WALLET_TYPE3_HEROPIECE_MOMENT04 = 38,
  WALLET_TYPE3_HEROPIECE_MOMENT05 = 39,
  WALLET_TYPE3_HEROPIECE_SIRIA03 = 40,
  WALLET_TYPE3_HEROPIECE_SIRIA04 = 41,
  WALLET_TYPE3_HEROPIECE_SIRIA05 = 42,
  WALLET_TYPE3_HEROPIECE_BALT03 = 43,
  WALLET_TYPE3_HEROPIECE_BALT04 = 44,
  WALLET_TYPE3_HEROPIECE_BALT05 = 45,
  WALLET_TYPE3_HEROPIECE_GRANT03 = 46,
  WALLET_TYPE3_HEROPIECE_GRANT04 = 47,
  WALLET_TYPE3_HEROPIECE_GRANT05 = 48,
  WALLET_TYPE3_HEROPIECE_FLAME03 = 49,
  WALLET_TYPE3_HEROPIECE_FLAME04 = 50,
  WALLET_TYPE3_HEROPIECE_FLAME05 = 51,
  WALLET_TYPE3_HEROPIECE_LUCY03 = 52,
  WALLET_TYPE3_HEROPIECE_LUCY04 = 53,
  WALLET_TYPE3_HEROPIECE_LUCY05 = 54,
  WALLET_TYPE3_HEROPIECE_SOPHIA03 = 55,
  WALLET_TYPE3_HEROPIECE_SOPHIA04 = 56,
  WALLET_TYPE3_HEROPIECE_SOPHIA05 = 57,
  WALLET_TYPE3_HEROPIECE_BARTOR03 = 58,
  WALLET_TYPE3_HEROPIECE_BARTOR04 = 59,
  WALLET_TYPE3_HEROPIECE_BARTOR05 = 60,
  WALLET_TYPE3_HEROPIECE_RHEA03 = 61,
  WALLET_TYPE3_HEROPIECE_RHEA04 = 62,
  WALLET_TYPE3_HEROPIECE_RHEA05 = 63,
  WALLET_TYPE3_HEROPIECE_DOROTHY03 = 64,
  WALLET_TYPE3_HEROPIECE_DOROTHY04 = 65,
  WALLET_TYPE3_HEROPIECE_DOROTHY05 = 66,
  WALLET_TYPE3_HEROPIECE_SCARLET03 = 67,
  WALLET_TYPE3_HEROPIECE_SCARLET04 = 68,
  WALLET_TYPE3_HEROPIECE_SCARLET05 = 69,
  WALLET_TYPE3_HEROPIECE_JIN03 = 70,
  WALLET_TYPE3_HEROPIECE_JIN04 = 71,
  WALLET_TYPE3_HEROPIECE_JIN05 = 72,
  WALLET_TYPE3_HEROPIECE_BANTONIO03 = 73,
  WALLET_TYPE3_HEROPIECE_BANTONIO04 = 74,
  WALLET_TYPE3_HEROPIECE_BANTONIO05 = 75,
  WALLET_TYPE3_HEROPIECE_KRATOS03 = 76,
  WALLET_TYPE3_HEROPIECE_KRATOS04 = 77,
  WALLET_TYPE3_HEROPIECE_KRATOS05 = 78,
  WALLET_TYPE3_HEROPIECE_PANG03 = 79,
  WALLET_TYPE3_HEROPIECE_PANG04 = 80,
  WALLET_TYPE3_HEROPIECE_PANG05 = 81,
  WALLET_TYPE3_HEROPIECE_SHARON03 = 82,
  WALLET_TYPE3_HEROPIECE_SHARON04 = 83,
  WALLET_TYPE3_HEROPIECE_SHARON05 = 84,
  WALLET_TYPE3_HEROPIECE_BARD03 = 85,
  WALLET_TYPE3_HEROPIECE_BARD04 = 86,
  WALLET_TYPE3_HEROPIECE_BARD05 = 87,
  WALLET_TYPE3_HEROPIECE_BUDDY03 = 88,
  WALLET_TYPE3_HEROPIECE_BUDDY04 = 89,
  WALLET_TYPE3_HEROPIECE_BUDDY05 = 90,
  WALLET_TYPE3_HEROPIECE_TIERA03 = 91,
  WALLET_TYPE3_HEROPIECE_TIERA04 = 92,
  WALLET_TYPE3_HEROPIECE_TIERA05 = 93,
  WALLET_TYPE3_HEROPIECE_ZAGAN03 = 94,
  WALLET_TYPE3_HEROPIECE_ZAGAN04 = 95,
  WALLET_TYPE3_HEROPIECE_ZAGAN05 = 96,
  WALLET_TYPE3_HEROPIECE_BELITA03 = 97,
  WALLET_TYPE3_HEROPIECE_BELITA04 = 98,
  WALLET_TYPE3_HEROPIECE_BELITA05 = 99,
  WALLET_TYPE3_HEROPIECE_BONNIE03 = 100,
  WALLET_TYPE3_HEROPIECE_BONNIE04 = 101,
  WALLET_TYPE3_HEROPIECE_BONNIE05 = 102,
  WALLET_TYPE3_HEROPIECE_IOLA03 = 103,
  WALLET_TYPE3_HEROPIECE_IOLA04 = 104,
  WALLET_TYPE3_HEROPIECE_IOLA05 = 105,
  WALLET_TYPE3_HEROPIECE_MURMUR03 = 106,
  WALLET_TYPE3_HEROPIECE_MURMUR04 = 107,
  WALLET_TYPE3_HEROPIECE_MURMUR05 = 108,
  WALLET_TYPE3_HEROPIECE_RANDOM_ALL = 109,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER03 = 110,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER04 = 111,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER05 = 112,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER03 = 113,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER04 = 114,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER05 = 115,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER03 = 116,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER04 = 117,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER05 = 118,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER03 = 119,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER04 = 120,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER05 = 121,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER03 = 122,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER04 = 123,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER05 = 124,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX03 = 125,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX04 = 126,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX05 = 127,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA03 = 128,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA04 = 129,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA05 = 130,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA03 = 131,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA04 = 132,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA05 = 133,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX03 = 134,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX04 = 135,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX05 = 136,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_TANKER = 137,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_MELEEDEALER = 138,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_RANGEDEALER = 139,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_MAGICDEALER = 140,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_SUPPORTER = 141,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_TANKER = 142,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_MELEEDEALER = 143,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_RANGEDEALER = 144,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_MAGICDEALER = 145,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_SUPPORTER = 146,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_TANKER = 147,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_MELEEDEALER = 148,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_RANGEDEALER = 149,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_MAGICDEALER = 150,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_SUPPORTER = 151,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_TANKER = 152,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_MELEEDEALER = 153,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_RANGEDEALER = 154,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_MAGICDEALER = 155,
  WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_SUPPORTER = 156,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_TANKER = 157,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_MELEEDEALER = 158,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_RANGEDEALER = 159,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_MAGICDEALER = 160,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_SUPPORTER = 161,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_03 = 162,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_04 = 163,
  WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_05 = 164,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_LUX = 165,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_SOLONA = 166,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_LUNA = 167,
  WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_NOX = 168,
  WALLET_TYPE3_MIN = WALLET_TYPE3_RUNE001,
  WALLET_TYPE3_MAX = WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_NOX
};

inline WALLET_TYPE3 (&EnumValuesWALLET_TYPE3())[169] {
  static WALLET_TYPE3 values[] = {
    WALLET_TYPE3_RUNE001,
    WALLET_TYPE3_RUNE002,
    WALLET_TYPE3_RUNE003,
    WALLET_TYPE3_RUNE004,
    WALLET_TYPE3_RUNE005,
    WALLET_TYPE3_RUNE006,
    WALLET_TYPE3_RUNE007,
    WALLET_TYPE3_RUNE008,
    WALLET_TYPE3_RUNE009,
    WALLET_TYPE3_RUNE010,
    WALLET_TYPE3_RUNE011,
    WALLET_TYPE3_RUNE012,
    WALLET_TYPE3_RUNE013,
    WALLET_TYPE3_RUNE014,
    WALLET_TYPE3_RUNE015,
    WALLET_TYPE3_RUNE016,
    WALLET_TYPE3_RUNE017,
    WALLET_TYPE3_RUNE018,
    WALLET_TYPE3_RUNE019,
    WALLET_TYPE3_RUNE020,
    WALLET_TYPE3_POTION,
    WALLET_TYPE3_BOOSTER,
    WALLET_TYPE3_HEROPIECE_AGATHON03,
    WALLET_TYPE3_HEROPIECE_AGATHON04,
    WALLET_TYPE3_HEROPIECE_AGATHON05,
    WALLET_TYPE3_HEROPIECE_RAYNA03,
    WALLET_TYPE3_HEROPIECE_RAYNA04,
    WALLET_TYPE3_HEROPIECE_RAYNA05,
    WALLET_TYPE3_HEROPIECE_YOSEPH03,
    WALLET_TYPE3_HEROPIECE_YOSEPH04,
    WALLET_TYPE3_HEROPIECE_YOSEPH05,
    WALLET_TYPE3_HEROPIECE_THAN03,
    WALLET_TYPE3_HEROPIECE_THAN04,
    WALLET_TYPE3_HEROPIECE_THAN05,
    WALLET_TYPE3_HEROPIECE_AMON03,
    WALLET_TYPE3_HEROPIECE_AMON04,
    WALLET_TYPE3_HEROPIECE_AMON05,
    WALLET_TYPE3_HEROPIECE_MOMENT03,
    WALLET_TYPE3_HEROPIECE_MOMENT04,
    WALLET_TYPE3_HEROPIECE_MOMENT05,
    WALLET_TYPE3_HEROPIECE_SIRIA03,
    WALLET_TYPE3_HEROPIECE_SIRIA04,
    WALLET_TYPE3_HEROPIECE_SIRIA05,
    WALLET_TYPE3_HEROPIECE_BALT03,
    WALLET_TYPE3_HEROPIECE_BALT04,
    WALLET_TYPE3_HEROPIECE_BALT05,
    WALLET_TYPE3_HEROPIECE_GRANT03,
    WALLET_TYPE3_HEROPIECE_GRANT04,
    WALLET_TYPE3_HEROPIECE_GRANT05,
    WALLET_TYPE3_HEROPIECE_FLAME03,
    WALLET_TYPE3_HEROPIECE_FLAME04,
    WALLET_TYPE3_HEROPIECE_FLAME05,
    WALLET_TYPE3_HEROPIECE_LUCY03,
    WALLET_TYPE3_HEROPIECE_LUCY04,
    WALLET_TYPE3_HEROPIECE_LUCY05,
    WALLET_TYPE3_HEROPIECE_SOPHIA03,
    WALLET_TYPE3_HEROPIECE_SOPHIA04,
    WALLET_TYPE3_HEROPIECE_SOPHIA05,
    WALLET_TYPE3_HEROPIECE_BARTOR03,
    WALLET_TYPE3_HEROPIECE_BARTOR04,
    WALLET_TYPE3_HEROPIECE_BARTOR05,
    WALLET_TYPE3_HEROPIECE_RHEA03,
    WALLET_TYPE3_HEROPIECE_RHEA04,
    WALLET_TYPE3_HEROPIECE_RHEA05,
    WALLET_TYPE3_HEROPIECE_DOROTHY03,
    WALLET_TYPE3_HEROPIECE_DOROTHY04,
    WALLET_TYPE3_HEROPIECE_DOROTHY05,
    WALLET_TYPE3_HEROPIECE_SCARLET03,
    WALLET_TYPE3_HEROPIECE_SCARLET04,
    WALLET_TYPE3_HEROPIECE_SCARLET05,
    WALLET_TYPE3_HEROPIECE_JIN03,
    WALLET_TYPE3_HEROPIECE_JIN04,
    WALLET_TYPE3_HEROPIECE_JIN05,
    WALLET_TYPE3_HEROPIECE_BANTONIO03,
    WALLET_TYPE3_HEROPIECE_BANTONIO04,
    WALLET_TYPE3_HEROPIECE_BANTONIO05,
    WALLET_TYPE3_HEROPIECE_KRATOS03,
    WALLET_TYPE3_HEROPIECE_KRATOS04,
    WALLET_TYPE3_HEROPIECE_KRATOS05,
    WALLET_TYPE3_HEROPIECE_PANG03,
    WALLET_TYPE3_HEROPIECE_PANG04,
    WALLET_TYPE3_HEROPIECE_PANG05,
    WALLET_TYPE3_HEROPIECE_SHARON03,
    WALLET_TYPE3_HEROPIECE_SHARON04,
    WALLET_TYPE3_HEROPIECE_SHARON05,
    WALLET_TYPE3_HEROPIECE_BARD03,
    WALLET_TYPE3_HEROPIECE_BARD04,
    WALLET_TYPE3_HEROPIECE_BARD05,
    WALLET_TYPE3_HEROPIECE_BUDDY03,
    WALLET_TYPE3_HEROPIECE_BUDDY04,
    WALLET_TYPE3_HEROPIECE_BUDDY05,
    WALLET_TYPE3_HEROPIECE_TIERA03,
    WALLET_TYPE3_HEROPIECE_TIERA04,
    WALLET_TYPE3_HEROPIECE_TIERA05,
    WALLET_TYPE3_HEROPIECE_ZAGAN03,
    WALLET_TYPE3_HEROPIECE_ZAGAN04,
    WALLET_TYPE3_HEROPIECE_ZAGAN05,
    WALLET_TYPE3_HEROPIECE_BELITA03,
    WALLET_TYPE3_HEROPIECE_BELITA04,
    WALLET_TYPE3_HEROPIECE_BELITA05,
    WALLET_TYPE3_HEROPIECE_BONNIE03,
    WALLET_TYPE3_HEROPIECE_BONNIE04,
    WALLET_TYPE3_HEROPIECE_BONNIE05,
    WALLET_TYPE3_HEROPIECE_IOLA03,
    WALLET_TYPE3_HEROPIECE_IOLA04,
    WALLET_TYPE3_HEROPIECE_IOLA05,
    WALLET_TYPE3_HEROPIECE_MURMUR03,
    WALLET_TYPE3_HEROPIECE_MURMUR04,
    WALLET_TYPE3_HEROPIECE_MURMUR05,
    WALLET_TYPE3_HEROPIECE_RANDOM_ALL,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_TANKER05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MELEEDEALER05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_RANGEDEALER05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_MAGICDEALER05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTINENT_SUPPORTER05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUX05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_SOLONA05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_LUNA05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASS_NOX05,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_TANKER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_MELEEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_RANGEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_MAGICDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUX_SUPPORTER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_TANKER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_MELEEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_RANGEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_MAGICDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_SOLONA_SUPPORTER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_TANKER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_MELEEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_RANGEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_MAGICDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_LUNA_SUPPORTER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_TANKER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_MELEEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_RANGEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_MAGICDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_GRADE_NOX_SUPPORTER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_TANKER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_MELEEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_RANGEDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_MAGICDEALER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTIGRADE_SUPPORTER,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_03,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_04,
    WALLET_TYPE3_HEROPIECE_RANDOM_CONTICLASS_05,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_LUX,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_SOLONA,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_LUNA,
    WALLET_TYPE3_HEROPIECE_RANDOM_CLASSGRADE_NOX
  };
  return values;
}

inline const char **EnumNamesWALLET_TYPE3() {
  static const char *names[] = {
    "RUNE001",
    "RUNE002",
    "RUNE003",
    "RUNE004",
    "RUNE005",
    "RUNE006",
    "RUNE007",
    "RUNE008",
    "RUNE009",
    "RUNE010",
    "RUNE011",
    "RUNE012",
    "RUNE013",
    "RUNE014",
    "RUNE015",
    "RUNE016",
    "RUNE017",
    "RUNE018",
    "RUNE019",
    "RUNE020",
    "POTION",
    "BOOSTER",
    "HEROPIECE_AGATHON03",
    "HEROPIECE_AGATHON04",
    "HEROPIECE_AGATHON05",
    "HEROPIECE_RAYNA03",
    "HEROPIECE_RAYNA04",
    "HEROPIECE_RAYNA05",
    "HEROPIECE_YOSEPH03",
    "HEROPIECE_YOSEPH04",
    "HEROPIECE_YOSEPH05",
    "HEROPIECE_THAN03",
    "HEROPIECE_THAN04",
    "HEROPIECE_THAN05",
    "HEROPIECE_AMON03",
    "HEROPIECE_AMON04",
    "HEROPIECE_AMON05",
    "HEROPIECE_MOMENT03",
    "HEROPIECE_MOMENT04",
    "HEROPIECE_MOMENT05",
    "HEROPIECE_SIRIA03",
    "HEROPIECE_SIRIA04",
    "HEROPIECE_SIRIA05",
    "HEROPIECE_BALT03",
    "HEROPIECE_BALT04",
    "HEROPIECE_BALT05",
    "HEROPIECE_GRANT03",
    "HEROPIECE_GRANT04",
    "HEROPIECE_GRANT05",
    "HEROPIECE_FLAME03",
    "HEROPIECE_FLAME04",
    "HEROPIECE_FLAME05",
    "HEROPIECE_LUCY03",
    "HEROPIECE_LUCY04",
    "HEROPIECE_LUCY05",
    "HEROPIECE_SOPHIA03",
    "HEROPIECE_SOPHIA04",
    "HEROPIECE_SOPHIA05",
    "HEROPIECE_BARTOR03",
    "HEROPIECE_BARTOR04",
    "HEROPIECE_BARTOR05",
    "HEROPIECE_RHEA03",
    "HEROPIECE_RHEA04",
    "HEROPIECE_RHEA05",
    "HEROPIECE_DOROTHY03",
    "HEROPIECE_DOROTHY04",
    "HEROPIECE_DOROTHY05",
    "HEROPIECE_SCARLET03",
    "HEROPIECE_SCARLET04",
    "HEROPIECE_SCARLET05",
    "HEROPIECE_JIN03",
    "HEROPIECE_JIN04",
    "HEROPIECE_JIN05",
    "HEROPIECE_BANTONIO03",
    "HEROPIECE_BANTONIO04",
    "HEROPIECE_BANTONIO05",
    "HEROPIECE_KRATOS03",
    "HEROPIECE_KRATOS04",
    "HEROPIECE_KRATOS05",
    "HEROPIECE_PANG03",
    "HEROPIECE_PANG04",
    "HEROPIECE_PANG05",
    "HEROPIECE_SHARON03",
    "HEROPIECE_SHARON04",
    "HEROPIECE_SHARON05",
    "HEROPIECE_BARD03",
    "HEROPIECE_BARD04",
    "HEROPIECE_BARD05",
    "HEROPIECE_BUDDY03",
    "HEROPIECE_BUDDY04",
    "HEROPIECE_BUDDY05",
    "HEROPIECE_TIERA03",
    "HEROPIECE_TIERA04",
    "HEROPIECE_TIERA05",
    "HEROPIECE_ZAGAN03",
    "HEROPIECE_ZAGAN04",
    "HEROPIECE_ZAGAN05",
    "HEROPIECE_BELITA03",
    "HEROPIECE_BELITA04",
    "HEROPIECE_BELITA05",
    "HEROPIECE_BONNIE03",
    "HEROPIECE_BONNIE04",
    "HEROPIECE_BONNIE05",
    "HEROPIECE_IOLA03",
    "HEROPIECE_IOLA04",
    "HEROPIECE_IOLA05",
    "HEROPIECE_MURMUR03",
    "HEROPIECE_MURMUR04",
    "HEROPIECE_MURMUR05",
    "HEROPIECE_RANDOM_ALL",
    "HEROPIECE_RANDOM_CONTINENT_TANKER03",
    "HEROPIECE_RANDOM_CONTINENT_TANKER04",
    "HEROPIECE_RANDOM_CONTINENT_TANKER05",
    "HEROPIECE_RANDOM_CONTINENT_MELEEDEALER03",
    "HEROPIECE_RANDOM_CONTINENT_MELEEDEALER04",
    "HEROPIECE_RANDOM_CONTINENT_MELEEDEALER05",
    "HEROPIECE_RANDOM_CONTINENT_RANGEDEALER03",
    "HEROPIECE_RANDOM_CONTINENT_RANGEDEALER04",
    "HEROPIECE_RANDOM_CONTINENT_RANGEDEALER05",
    "HEROPIECE_RANDOM_CONTINENT_MAGICDEALER03",
    "HEROPIECE_RANDOM_CONTINENT_MAGICDEALER04",
    "HEROPIECE_RANDOM_CONTINENT_MAGICDEALER05",
    "HEROPIECE_RANDOM_CONTINENT_SUPPORTER03",
    "HEROPIECE_RANDOM_CONTINENT_SUPPORTER04",
    "HEROPIECE_RANDOM_CONTINENT_SUPPORTER05",
    "HEROPIECE_RANDOM_CLASS_LUX03",
    "HEROPIECE_RANDOM_CLASS_LUX04",
    "HEROPIECE_RANDOM_CLASS_LUX05",
    "HEROPIECE_RANDOM_CLASS_SOLONA03",
    "HEROPIECE_RANDOM_CLASS_SOLONA04",
    "HEROPIECE_RANDOM_CLASS_SOLONA05",
    "HEROPIECE_RANDOM_CLASS_LUNA03",
    "HEROPIECE_RANDOM_CLASS_LUNA04",
    "HEROPIECE_RANDOM_CLASS_LUNA05",
    "HEROPIECE_RANDOM_CLASS_NOX03",
    "HEROPIECE_RANDOM_CLASS_NOX04",
    "HEROPIECE_RANDOM_CLASS_NOX05",
    "HEROPIECE_RANDOM_GRADE_LUX_TANKER",
    "HEROPIECE_RANDOM_GRADE_LUX_MELEEDEALER",
    "HEROPIECE_RANDOM_GRADE_LUX_RANGEDEALER",
    "HEROPIECE_RANDOM_GRADE_LUX_MAGICDEALER",
    "HEROPIECE_RANDOM_GRADE_LUX_SUPPORTER",
    "HEROPIECE_RANDOM_GRADE_SOLONA_TANKER",
    "HEROPIECE_RANDOM_GRADE_SOLONA_MELEEDEALER",
    "HEROPIECE_RANDOM_GRADE_SOLONA_RANGEDEALER",
    "HEROPIECE_RANDOM_GRADE_SOLONA_MAGICDEALER",
    "HEROPIECE_RANDOM_GRADE_SOLONA_SUPPORTER",
    "HEROPIECE_RANDOM_GRADE_LUNA_TANKER",
    "HEROPIECE_RANDOM_GRADE_LUNA_MELEEDEALER",
    "HEROPIECE_RANDOM_GRADE_LUNA_RANGEDEALER",
    "HEROPIECE_RANDOM_GRADE_LUNA_MAGICDEALER",
    "HEROPIECE_RANDOM_GRADE_LUNA_SUPPORTER",
    "HEROPIECE_RANDOM_GRADE_NOX_TANKER",
    "HEROPIECE_RANDOM_GRADE_NOX_MELEEDEALER",
    "HEROPIECE_RANDOM_GRADE_NOX_RANGEDEALER",
    "HEROPIECE_RANDOM_GRADE_NOX_MAGICDEALER",
    "HEROPIECE_RANDOM_GRADE_NOX_SUPPORTER",
    "HEROPIECE_RANDOM_CONTIGRADE_TANKER",
    "HEROPIECE_RANDOM_CONTIGRADE_MELEEDEALER",
    "HEROPIECE_RANDOM_CONTIGRADE_RANGEDEALER",
    "HEROPIECE_RANDOM_CONTIGRADE_MAGICDEALER",
    "HEROPIECE_RANDOM_CONTIGRADE_SUPPORTER",
    "HEROPIECE_RANDOM_CONTICLASS_03",
    "HEROPIECE_RANDOM_CONTICLASS_04",
    "HEROPIECE_RANDOM_CONTICLASS_05",
    "HEROPIECE_RANDOM_CLASSGRADE_LUX",
    "HEROPIECE_RANDOM_CLASSGRADE_SOLONA",
    "HEROPIECE_RANDOM_CLASSGRADE_LUNA",
    "HEROPIECE_RANDOM_CLASSGRADE_NOX",
    nullptr
  };
  return names;
}

inline const char *EnumNameWALLET_TYPE3(WALLET_TYPE3 e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesWALLET_TYPE3()[index];
}

}  // namespace ENUM

namespace STRUCT {

struct DECKST : public flatbuffers::NativeTable {
  typedef DECKS TableType;
  std::vector<std::string> campaignThree;
  std::vector<std::string> campaignOne;
  std::vector<std::string> mirror;
  std::vector<std::string> arena;
  std::vector<std::string> defense;
  DECKST() {
  }
};

struct DECKS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DECKST NativeTableType;
  enum {
    VT_CAMPAIGNTHREE = 4,
    VT_CAMPAIGNONE = 6,
    VT_MIRROR = 8,
    VT_ARENA = 10,
    VT_DEFENSE = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *campaignThree() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CAMPAIGNTHREE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *campaignOne() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_CAMPAIGNONE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mirror() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MIRROR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *arena() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARENA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *defense() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEFENSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CAMPAIGNTHREE) &&
           verifier.Verify(campaignThree()) &&
           verifier.VerifyVectorOfStrings(campaignThree()) &&
           VerifyOffset(verifier, VT_CAMPAIGNONE) &&
           verifier.Verify(campaignOne()) &&
           verifier.VerifyVectorOfStrings(campaignOne()) &&
           VerifyOffset(verifier, VT_MIRROR) &&
           verifier.Verify(mirror()) &&
           verifier.VerifyVectorOfStrings(mirror()) &&
           VerifyOffset(verifier, VT_ARENA) &&
           verifier.Verify(arena()) &&
           verifier.VerifyVectorOfStrings(arena()) &&
           VerifyOffset(verifier, VT_DEFENSE) &&
           verifier.Verify(defense()) &&
           verifier.VerifyVectorOfStrings(defense()) &&
           verifier.EndTable();
  }
  DECKST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DECKST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DECKS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DECKST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DECKSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_campaignThree(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> campaignThree) {
    fbb_.AddOffset(DECKS::VT_CAMPAIGNTHREE, campaignThree);
  }
  void add_campaignOne(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> campaignOne) {
    fbb_.AddOffset(DECKS::VT_CAMPAIGNONE, campaignOne);
  }
  void add_mirror(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mirror) {
    fbb_.AddOffset(DECKS::VT_MIRROR, mirror);
  }
  void add_arena(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arena) {
    fbb_.AddOffset(DECKS::VT_ARENA, arena);
  }
  void add_defense(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense) {
    fbb_.AddOffset(DECKS::VT_DEFENSE, defense);
  }
  explicit DECKSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DECKSBuilder &operator=(const DECKSBuilder &);
  flatbuffers::Offset<DECKS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DECKS>(end);
    return o;
  }
};

inline flatbuffers::Offset<DECKS> CreateDECKS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> campaignThree = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> campaignOne = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mirror = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> arena = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense = 0) {
  DECKSBuilder builder_(_fbb);
  builder_.add_defense(defense);
  builder_.add_arena(arena);
  builder_.add_mirror(mirror);
  builder_.add_campaignOne(campaignOne);
  builder_.add_campaignThree(campaignThree);
  return builder_.Finish();
}

inline flatbuffers::Offset<DECKS> CreateDECKSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *campaignThree = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *campaignOne = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *mirror = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *arena = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *defense = nullptr) {
  return OVERLORD::STRUCT::CreateDECKS(
      _fbb,
      campaignThree ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*campaignThree) : 0,
      campaignOne ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*campaignOne) : 0,
      mirror ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*mirror) : 0,
      arena ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*arena) : 0,
      defense ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*defense) : 0);
}

flatbuffers::Offset<DECKS> CreateDECKS(flatbuffers::FlatBufferBuilder &_fbb, const DECKST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATART : public flatbuffers::NativeTable {
  typedef AVATAR TableType;
  int32_t kId;
  std::string nick;
  int32_t level;
  int32_t exp;
  std::string now;
  std::vector<int32_t> ability;
  int32_t icon;
  AVATART()
      : kId(0),
        level(0),
        exp(0),
        icon(1) {
  }
};

struct AVATAR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATART NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_NOW = 12,
    VT_ABILITY = 14,
    VT_ICON = 16
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::String *now() const {
    return GetPointer<const flatbuffers::String *>(VT_NOW);
  }
  const flatbuffers::Vector<int32_t> *ability() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ABILITY);
  }
  int32_t icon() const {
    return GetField<int32_t>(VT_ICON, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_NOW) &&
           verifier.Verify(now()) &&
           VerifyOffset(verifier, VT_ABILITY) &&
           verifier.Verify(ability()) &&
           VerifyField<int32_t>(verifier, VT_ICON) &&
           verifier.EndTable();
  }
  AVATART *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATART *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATART* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATARBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(AVATAR::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(AVATAR::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(AVATAR::VT_LEVEL, level, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(AVATAR::VT_EXP, exp, 0);
  }
  void add_now(flatbuffers::Offset<flatbuffers::String> now) {
    fbb_.AddOffset(AVATAR::VT_NOW, now);
  }
  void add_ability(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability) {
    fbb_.AddOffset(AVATAR::VT_ABILITY, ability);
  }
  void add_icon(int32_t icon) {
    fbb_.AddElement<int32_t>(AVATAR::VT_ICON, icon, 1);
  }
  explicit AVATARBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATARBuilder &operator=(const AVATARBuilder &);
  flatbuffers::Offset<AVATAR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR> CreateAVATAR(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::String> now = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability = 0,
    int32_t icon = 1) {
  AVATARBuilder builder_(_fbb);
  builder_.add_icon(icon);
  builder_.add_ability(ability);
  builder_.add_now(now);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR> CreateAVATARDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t level = 0,
    int32_t exp = 0,
    const char *now = nullptr,
    const std::vector<int32_t> *ability = nullptr,
    int32_t icon = 1) {
  return OVERLORD::STRUCT::CreateAVATAR(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      exp,
      now ? _fbb.CreateString(now) : 0,
      ability ? _fbb.CreateVector<int32_t>(*ability) : 0,
      icon);
}

flatbuffers::Offset<AVATAR> CreateAVATAR(flatbuffers::FlatBufferBuilder &_fbb, const AVATART *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HEROT : public flatbuffers::NativeTable {
  typedef HERO TableType;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  int32_t exp;
  std::vector<std::string> equipedItemUDs;
  std::vector<int32_t> skills;
  std::vector<int32_t> enchantStat;
  int32_t enchantPoint;
  bool locked;
  HEROT()
      : level(1),
        exp(0),
        enchantPoint(0),
        locked(false) {
  }
};

struct HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HEROT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_HEROID = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_EQUIPEDITEMUDS = 12,
    VT_SKILLS = 14,
    VT_ENCHANTSTAT = 16,
    VT_ENCHANTPOINT = 18,
    VT_LOCKED = 20
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *equipedItemUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EQUIPEDITEMUDS);
  }
  const flatbuffers::Vector<int32_t> *skills() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKILLS);
  }
  const flatbuffers::Vector<int32_t> *enchantStat() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENCHANTSTAT);
  }
  int32_t enchantPoint() const {
    return GetField<int32_t>(VT_ENCHANTPOINT, 0);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_EQUIPEDITEMUDS) &&
           verifier.Verify(equipedItemUDs()) &&
           verifier.VerifyVectorOfStrings(equipedItemUDs()) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.Verify(skills()) &&
           VerifyOffset(verifier, VT_ENCHANTSTAT) &&
           verifier.Verify(enchantStat()) &&
           VerifyField<int32_t>(verifier, VT_ENCHANTPOINT) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           verifier.EndTable();
  }
  HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(HERO::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(HERO::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(HERO::VT_LEVEL, level, 1);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(HERO::VT_EXP, exp, 0);
  }
  void add_equipedItemUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> equipedItemUDs) {
    fbb_.AddOffset(HERO::VT_EQUIPEDITEMUDS, equipedItemUDs);
  }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skills) {
    fbb_.AddOffset(HERO::VT_SKILLS, skills);
  }
  void add_enchantStat(flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat) {
    fbb_.AddOffset(HERO::VT_ENCHANTSTAT, enchantStat);
  }
  void add_enchantPoint(int32_t enchantPoint) {
    fbb_.AddElement<int32_t>(HERO::VT_ENCHANTPOINT, enchantPoint, 0);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(HERO::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  explicit HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HEROBuilder &operator=(const HEROBuilder &);
  flatbuffers::Offset<HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO> CreateHERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> equipedItemUDs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> skills = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat = 0,
    int32_t enchantPoint = 0,
    bool locked = false) {
  HEROBuilder builder_(_fbb);
  builder_.add_enchantPoint(enchantPoint);
  builder_.add_enchantStat(enchantStat);
  builder_.add_skills(skills);
  builder_.add_equipedItemUDs(equipedItemUDs);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  builder_.add_locked(locked);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO> CreateHERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1,
    int32_t exp = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *equipedItemUDs = nullptr,
    const std::vector<int32_t> *skills = nullptr,
    const std::vector<int32_t> *enchantStat = nullptr,
    int32_t enchantPoint = 0,
    bool locked = false) {
  return OVERLORD::STRUCT::CreateHERO(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level,
      exp,
      equipedItemUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*equipedItemUDs) : 0,
      skills ? _fbb.CreateVector<int32_t>(*skills) : 0,
      enchantStat ? _fbb.CreateVector<int32_t>(*enchantStat) : 0,
      enchantPoint,
      locked);
}

flatbuffers::Offset<HERO> CreateHERO(flatbuffers::FlatBufferBuilder &_fbb, const HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_CONFIGT : public flatbuffers::NativeTable {
  typedef HERO_CONFIG TableType;
  std::string heroUD;
  OVERLORD::ENUM::CONTENTS_TYPE contents;
  OVERLORD::ENUM::PREFER_TARGET_TYPE preferTarget;
  std::vector<bool> skills;
  HERO_CONFIGT()
      : contents(OVERLORD::ENUM::CONTENTS_TYPE_NOTHING),
        preferTarget(OVERLORD::ENUM::PREFER_TARGET_TYPE_NONE) {
  }
};

struct HERO_CONFIG FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_CONFIGT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_CONTENTS = 6,
    VT_PREFERTARGET = 8,
    VT_SKILLS = 10
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  OVERLORD::ENUM::CONTENTS_TYPE contents() const {
    return static_cast<OVERLORD::ENUM::CONTENTS_TYPE>(GetField<int8_t>(VT_CONTENTS, 0));
  }
  OVERLORD::ENUM::PREFER_TARGET_TYPE preferTarget() const {
    return static_cast<OVERLORD::ENUM::PREFER_TARGET_TYPE>(GetField<int8_t>(VT_PREFERTARGET, 0));
  }
  const flatbuffers::Vector<uint8_t> *skills() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SKILLS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyField<int8_t>(verifier, VT_CONTENTS) &&
           VerifyField<int8_t>(verifier, VT_PREFERTARGET) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.Verify(skills()) &&
           verifier.EndTable();
  }
  HERO_CONFIGT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_CONFIGT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_CONFIG> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_CONFIGT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_CONFIGBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(HERO_CONFIG::VT_HEROUD, heroUD);
  }
  void add_contents(OVERLORD::ENUM::CONTENTS_TYPE contents) {
    fbb_.AddElement<int8_t>(HERO_CONFIG::VT_CONTENTS, static_cast<int8_t>(contents), 0);
  }
  void add_preferTarget(OVERLORD::ENUM::PREFER_TARGET_TYPE preferTarget) {
    fbb_.AddElement<int8_t>(HERO_CONFIG::VT_PREFERTARGET, static_cast<int8_t>(preferTarget), 0);
  }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skills) {
    fbb_.AddOffset(HERO_CONFIG::VT_SKILLS, skills);
  }
  explicit HERO_CONFIGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_CONFIGBuilder &operator=(const HERO_CONFIGBuilder &);
  flatbuffers::Offset<HERO_CONFIG> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_CONFIG>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_CONFIG> CreateHERO_CONFIG(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    OVERLORD::ENUM::CONTENTS_TYPE contents = OVERLORD::ENUM::CONTENTS_TYPE_NOTHING,
    OVERLORD::ENUM::PREFER_TARGET_TYPE preferTarget = OVERLORD::ENUM::PREFER_TARGET_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> skills = 0) {
  HERO_CONFIGBuilder builder_(_fbb);
  builder_.add_skills(skills);
  builder_.add_heroUD(heroUD);
  builder_.add_preferTarget(preferTarget);
  builder_.add_contents(contents);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_CONFIG> CreateHERO_CONFIGDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    OVERLORD::ENUM::CONTENTS_TYPE contents = OVERLORD::ENUM::CONTENTS_TYPE_NOTHING,
    OVERLORD::ENUM::PREFER_TARGET_TYPE preferTarget = OVERLORD::ENUM::PREFER_TARGET_TYPE_NONE,
    const std::vector<uint8_t> *skills = nullptr) {
  return OVERLORD::STRUCT::CreateHERO_CONFIG(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      contents,
      preferTarget,
      skills ? _fbb.CreateVector<uint8_t>(*skills) : 0);
}

flatbuffers::Offset<HERO_CONFIG> CreateHERO_CONFIG(flatbuffers::FlatBufferBuilder &_fbb, const HERO_CONFIGT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ITEM_OPTIONT : public flatbuffers::NativeTable {
  typedef ITEM_OPTION TableType;
  int32_t idx;
  float factor;
  ITEM_OPTIONT()
      : idx(0),
        factor(0.0f) {
  }
};

struct ITEM_OPTION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ITEM_OPTIONT NativeTableType;
  enum {
    VT_IDX = 4,
    VT_FACTOR = 6
  };
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  float factor() const {
    return GetField<float>(VT_FACTOR, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           VerifyField<float>(verifier, VT_FACTOR) &&
           verifier.EndTable();
  }
  ITEM_OPTIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ITEM_OPTIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ITEM_OPTION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ITEM_OPTIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(ITEM_OPTION::VT_IDX, idx, 0);
  }
  void add_factor(float factor) {
    fbb_.AddElement<float>(ITEM_OPTION::VT_FACTOR, factor, 0.0f);
  }
  explicit ITEM_OPTIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ITEM_OPTIONBuilder &operator=(const ITEM_OPTIONBuilder &);
  flatbuffers::Offset<ITEM_OPTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ITEM_OPTION>(end);
    return o;
  }
};

inline flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t idx = 0,
    float factor = 0.0f) {
  ITEM_OPTIONBuilder builder_(_fbb);
  builder_.add_factor(factor);
  builder_.add_idx(idx);
  return builder_.Finish();
}

flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ITEMT : public flatbuffers::NativeTable {
  typedef ITEM TableType;
  std::string itemUD;
  std::string itemId;
  int32_t enchant;
  bool enchantLocked;
  int32_t level;
  int32_t exp;
  std::vector<std::unique_ptr<ITEM_OPTIONT>> options;
  std::vector<std::string> runes;
  std::string equipedHeroUD;
  bool locked;
  ITEMT()
      : enchant(0),
        enchantLocked(false),
        level(1),
        exp(0),
        locked(false) {
  }
};

struct ITEM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ITEMT NativeTableType;
  enum {
    VT_ITEMUD = 4,
    VT_ITEMID = 6,
    VT_ENCHANT = 8,
    VT_ENCHANTLOCKED = 10,
    VT_LEVEL = 12,
    VT_EXP = 14,
    VT_OPTIONS = 16,
    VT_RUNES = 18,
    VT_EQUIPEDHEROUD = 20,
    VT_LOCKED = 22
  };
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  int32_t enchant() const {
    return GetField<int32_t>(VT_ENCHANT, 0);
  }
  bool enchantLocked() const {
    return GetField<uint8_t>(VT_ENCHANTLOCKED, 0) != 0;
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>> *options() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>> *>(VT_OPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *runes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_RUNES);
  }
  const flatbuffers::String *equipedHeroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_EQUIPEDHEROUD);
  }
  bool locked() const {
    return GetField<uint8_t>(VT_LOCKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyField<int32_t>(verifier, VT_ENCHANT) &&
           VerifyField<uint8_t>(verifier, VT_ENCHANTLOCKED) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyOffset(verifier, VT_OPTIONS) &&
           verifier.Verify(options()) &&
           verifier.VerifyVectorOfTables(options()) &&
           VerifyOffset(verifier, VT_RUNES) &&
           verifier.Verify(runes()) &&
           verifier.VerifyVectorOfStrings(runes()) &&
           VerifyOffset(verifier, VT_EQUIPEDHEROUD) &&
           verifier.Verify(equipedHeroUD()) &&
           VerifyField<uint8_t>(verifier, VT_LOCKED) &&
           verifier.EndTable();
  }
  ITEMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ITEMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ITEM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ITEMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(ITEM::VT_ITEMUD, itemUD);
  }
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ITEM::VT_ITEMID, itemId);
  }
  void add_enchant(int32_t enchant) {
    fbb_.AddElement<int32_t>(ITEM::VT_ENCHANT, enchant, 0);
  }
  void add_enchantLocked(bool enchantLocked) {
    fbb_.AddElement<uint8_t>(ITEM::VT_ENCHANTLOCKED, static_cast<uint8_t>(enchantLocked), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ITEM::VT_LEVEL, level, 1);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(ITEM::VT_EXP, exp, 0);
  }
  void add_options(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>>> options) {
    fbb_.AddOffset(ITEM::VT_OPTIONS, options);
  }
  void add_runes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> runes) {
    fbb_.AddOffset(ITEM::VT_RUNES, runes);
  }
  void add_equipedHeroUD(flatbuffers::Offset<flatbuffers::String> equipedHeroUD) {
    fbb_.AddOffset(ITEM::VT_EQUIPEDHEROUD, equipedHeroUD);
  }
  void add_locked(bool locked) {
    fbb_.AddElement<uint8_t>(ITEM::VT_LOCKED, static_cast<uint8_t>(locked), 0);
  }
  explicit ITEMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ITEMBuilder &operator=(const ITEMBuilder &);
  flatbuffers::Offset<ITEM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ITEM>(end);
    return o;
  }
};

inline flatbuffers::Offset<ITEM> CreateITEM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    int32_t enchant = 0,
    bool enchantLocked = false,
    int32_t level = 1,
    int32_t exp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM_OPTION>>> options = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> runes = 0,
    flatbuffers::Offset<flatbuffers::String> equipedHeroUD = 0,
    bool locked = false) {
  ITEMBuilder builder_(_fbb);
  builder_.add_equipedHeroUD(equipedHeroUD);
  builder_.add_runes(runes);
  builder_.add_options(options);
  builder_.add_exp(exp);
  builder_.add_level(level);
  builder_.add_enchant(enchant);
  builder_.add_itemId(itemId);
  builder_.add_itemUD(itemUD);
  builder_.add_locked(locked);
  builder_.add_enchantLocked(enchantLocked);
  return builder_.Finish();
}

inline flatbuffers::Offset<ITEM> CreateITEMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *itemUD = nullptr,
    const char *itemId = nullptr,
    int32_t enchant = 0,
    bool enchantLocked = false,
    int32_t level = 1,
    int32_t exp = 0,
    const std::vector<flatbuffers::Offset<ITEM_OPTION>> *options = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *runes = nullptr,
    const char *equipedHeroUD = nullptr,
    bool locked = false) {
  return OVERLORD::STRUCT::CreateITEM(
      _fbb,
      itemUD ? _fbb.CreateString(itemUD) : 0,
      itemId ? _fbb.CreateString(itemId) : 0,
      enchant,
      enchantLocked,
      level,
      exp,
      options ? _fbb.CreateVector<flatbuffers::Offset<ITEM_OPTION>>(*options) : 0,
      runes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*runes) : 0,
      equipedHeroUD ? _fbb.CreateString(equipedHeroUD) : 0,
      locked);
}

flatbuffers::Offset<ITEM> CreateITEM(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REWARDT : public flatbuffers::NativeTable {
  typedef REWARD TableType;
  OVERLORD::ENUM::REWARD_TYPE type;
  std::string rewardId;
  int32_t amt;
  int32_t prob;
  REWARDT()
      : type(OVERLORD::ENUM::REWARD_TYPE_NONE),
        amt(0),
        prob(100) {
  }
};

struct REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_REWARDID = 6,
    VT_AMT = 8,
    VT_PROB = 10
  };
  OVERLORD::ENUM::REWARD_TYPE type() const {
    return static_cast<OVERLORD::ENUM::REWARD_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *rewardId() const {
    return GetPointer<const flatbuffers::String *>(VT_REWARDID);
  }
  int32_t amt() const {
    return GetField<int32_t>(VT_AMT, 0);
  }
  int32_t prob() const {
    return GetField<int32_t>(VT_PROB, 100);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_REWARDID) &&
           verifier.Verify(rewardId()) &&
           VerifyField<int32_t>(verifier, VT_AMT) &&
           VerifyField<int32_t>(verifier, VT_PROB) &&
           verifier.EndTable();
  }
  REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(OVERLORD::ENUM::REWARD_TYPE type) {
    fbb_.AddElement<int8_t>(REWARD::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_rewardId(flatbuffers::Offset<flatbuffers::String> rewardId) {
    fbb_.AddOffset(REWARD::VT_REWARDID, rewardId);
  }
  void add_amt(int32_t amt) {
    fbb_.AddElement<int32_t>(REWARD::VT_AMT, amt, 0);
  }
  void add_prob(int32_t prob) {
    fbb_.AddElement<int32_t>(REWARD::VT_PROB, prob, 100);
  }
  explicit REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REWARDBuilder &operator=(const REWARDBuilder &);
  flatbuffers::Offset<REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<REWARD> CreateREWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::REWARD_TYPE type = OVERLORD::ENUM::REWARD_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> rewardId = 0,
    int32_t amt = 0,
    int32_t prob = 100) {
  REWARDBuilder builder_(_fbb);
  builder_.add_prob(prob);
  builder_.add_amt(amt);
  builder_.add_rewardId(rewardId);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<REWARD> CreateREWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::REWARD_TYPE type = OVERLORD::ENUM::REWARD_TYPE_NONE,
    const char *rewardId = nullptr,
    int32_t amt = 0,
    int32_t prob = 100) {
  return OVERLORD::STRUCT::CreateREWARD(
      _fbb,
      type,
      rewardId ? _fbb.CreateString(rewardId) : 0,
      amt,
      prob);
}

flatbuffers::Offset<REWARD> CreateREWARD(flatbuffers::FlatBufferBuilder &_fbb, const REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REWARDSETT : public flatbuffers::NativeTable {
  typedef REWARDSET TableType;
  std::vector<std::unique_ptr<REWARDT>> rewards;
  REWARDSETT() {
  }
};

struct REWARDSET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REWARDSETT NativeTableType;
  enum {
    VT_REWARDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  REWARDSETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REWARDSETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REWARDSET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REWARDSETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REWARDSETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards) {
    fbb_.AddOffset(REWARDSET::VT_REWARDS, rewards);
  }
  explicit REWARDSETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REWARDSETBuilder &operator=(const REWARDSETBuilder &);
  flatbuffers::Offset<REWARDSET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REWARDSET>(end);
    return o;
  }
};

inline flatbuffers::Offset<REWARDSET> CreateREWARDSET(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards = 0) {
  REWARDSETBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  return builder_.Finish();
}

inline flatbuffers::Offset<REWARDSET> CreateREWARDSETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<REWARD>> *rewards = nullptr) {
  return OVERLORD::STRUCT::CreateREWARDSET(
      _fbb,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<REWARDSET> CreateREWARDSET(flatbuffers::FlatBufferBuilder &_fbb, const REWARDSETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PLAY_DECKT : public flatbuffers::NativeTable {
  typedef PLAY_DECK TableType;
  std::string deckUD;
  OVERLORD::ENUM::PLAY_DECK_TYPE pno;
  OVERLORD::ENUM::PLAY_DECK_FORMATION formation;
  std::vector<std::string> heroUDs;
  int32_t power;
  PLAY_DECKT()
      : pno(OVERLORD::ENUM::PLAY_DECK_TYPE_DECK1),
        formation(OVERLORD::ENUM::PLAY_DECK_FORMATION_OFFENSE),
        power(0) {
  }
};

struct PLAY_DECK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PLAY_DECKT NativeTableType;
  enum {
    VT_DECKUD = 4,
    VT_PNO = 6,
    VT_FORMATION = 8,
    VT_HEROUDS = 10,
    VT_POWER = 12
  };
  const flatbuffers::String *deckUD() const {
    return GetPointer<const flatbuffers::String *>(VT_DECKUD);
  }
  OVERLORD::ENUM::PLAY_DECK_TYPE pno() const {
    return static_cast<OVERLORD::ENUM::PLAY_DECK_TYPE>(GetField<int8_t>(VT_PNO, 0));
  }
  OVERLORD::ENUM::PLAY_DECK_FORMATION formation() const {
    return static_cast<OVERLORD::ENUM::PLAY_DECK_FORMATION>(GetField<int8_t>(VT_FORMATION, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DECKUD) &&
           verifier.Verify(deckUD()) &&
           VerifyField<int8_t>(verifier, VT_PNO) &&
           VerifyField<int8_t>(verifier, VT_FORMATION) &&
           VerifyOffset(verifier, VT_HEROUDS) &&
           verifier.Verify(heroUDs()) &&
           verifier.VerifyVectorOfStrings(heroUDs()) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           verifier.EndTable();
  }
  PLAY_DECKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PLAY_DECKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PLAY_DECK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_DECKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PLAY_DECKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deckUD(flatbuffers::Offset<flatbuffers::String> deckUD) {
    fbb_.AddOffset(PLAY_DECK::VT_DECKUD, deckUD);
  }
  void add_pno(OVERLORD::ENUM::PLAY_DECK_TYPE pno) {
    fbb_.AddElement<int8_t>(PLAY_DECK::VT_PNO, static_cast<int8_t>(pno), 0);
  }
  void add_formation(OVERLORD::ENUM::PLAY_DECK_FORMATION formation) {
    fbb_.AddElement<int8_t>(PLAY_DECK::VT_FORMATION, static_cast<int8_t>(formation), 0);
  }
  void add_heroUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs) {
    fbb_.AddOffset(PLAY_DECK::VT_HEROUDS, heroUDs);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(PLAY_DECK::VT_POWER, power, 0);
  }
  explicit PLAY_DECKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PLAY_DECKBuilder &operator=(const PLAY_DECKBuilder &);
  flatbuffers::Offset<PLAY_DECK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PLAY_DECK>(end);
    return o;
  }
};

inline flatbuffers::Offset<PLAY_DECK> CreatePLAY_DECK(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> deckUD = 0,
    OVERLORD::ENUM::PLAY_DECK_TYPE pno = OVERLORD::ENUM::PLAY_DECK_TYPE_DECK1,
    OVERLORD::ENUM::PLAY_DECK_FORMATION formation = OVERLORD::ENUM::PLAY_DECK_FORMATION_OFFENSE,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs = 0,
    int32_t power = 0) {
  PLAY_DECKBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_heroUDs(heroUDs);
  builder_.add_deckUD(deckUD);
  builder_.add_formation(formation);
  builder_.add_pno(pno);
  return builder_.Finish();
}

inline flatbuffers::Offset<PLAY_DECK> CreatePLAY_DECKDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *deckUD = nullptr,
    OVERLORD::ENUM::PLAY_DECK_TYPE pno = OVERLORD::ENUM::PLAY_DECK_TYPE_DECK1,
    OVERLORD::ENUM::PLAY_DECK_FORMATION formation = OVERLORD::ENUM::PLAY_DECK_FORMATION_OFFENSE,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs = nullptr,
    int32_t power = 0) {
  return OVERLORD::STRUCT::CreatePLAY_DECK(
      _fbb,
      deckUD ? _fbb.CreateString(deckUD) : 0,
      pno,
      formation,
      heroUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs) : 0,
      power);
}

flatbuffers::Offset<PLAY_DECK> CreatePLAY_DECK(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_DECKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EQUIPED_HEROT : public flatbuffers::NativeTable {
  typedef EQUIPED_HERO TableType;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  std::vector<std::unique_ptr<ITEMT>> equipedItems;
  std::vector<int32_t> skills;
  std::vector<int32_t> enchantStat;
  EQUIPED_HEROT()
      : level(1) {
  }
};

struct EQUIPED_HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EQUIPED_HEROT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_HEROID = 6,
    VT_LEVEL = 8,
    VT_EQUIPEDITEMS = 10,
    VT_SKILLS = 12,
    VT_ENCHANTSTAT = 14
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *equipedItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *>(VT_EQUIPEDITEMS);
  }
  const flatbuffers::Vector<int32_t> *skills() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SKILLS);
  }
  const flatbuffers::Vector<int32_t> *enchantStat() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENCHANTSTAT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_EQUIPEDITEMS) &&
           verifier.Verify(equipedItems()) &&
           verifier.VerifyVectorOfTables(equipedItems()) &&
           VerifyOffset(verifier, VT_SKILLS) &&
           verifier.Verify(skills()) &&
           VerifyOffset(verifier, VT_ENCHANTSTAT) &&
           verifier.Verify(enchantStat()) &&
           verifier.EndTable();
  }
  EQUIPED_HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EQUIPED_HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EQUIPED_HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EQUIPED_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EQUIPED_HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(EQUIPED_HERO::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(EQUIPED_HERO::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(EQUIPED_HERO::VT_LEVEL, level, 1);
  }
  void add_equipedItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> equipedItems) {
    fbb_.AddOffset(EQUIPED_HERO::VT_EQUIPEDITEMS, equipedItems);
  }
  void add_skills(flatbuffers::Offset<flatbuffers::Vector<int32_t>> skills) {
    fbb_.AddOffset(EQUIPED_HERO::VT_SKILLS, skills);
  }
  void add_enchantStat(flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat) {
    fbb_.AddOffset(EQUIPED_HERO::VT_ENCHANTSTAT, enchantStat);
  }
  explicit EQUIPED_HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EQUIPED_HEROBuilder &operator=(const EQUIPED_HEROBuilder &);
  flatbuffers::Offset<EQUIPED_HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EQUIPED_HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<EQUIPED_HERO> CreateEQUIPED_HERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> equipedItems = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> skills = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat = 0) {
  EQUIPED_HEROBuilder builder_(_fbb);
  builder_.add_enchantStat(enchantStat);
  builder_.add_skills(skills);
  builder_.add_equipedItems(equipedItems);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  return builder_.Finish();
}

inline flatbuffers::Offset<EQUIPED_HERO> CreateEQUIPED_HERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1,
    const std::vector<flatbuffers::Offset<ITEM>> *equipedItems = nullptr,
    const std::vector<int32_t> *skills = nullptr,
    const std::vector<int32_t> *enchantStat = nullptr) {
  return OVERLORD::STRUCT::CreateEQUIPED_HERO(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level,
      equipedItems ? _fbb.CreateVector<flatbuffers::Offset<ITEM>>(*equipedItems) : 0,
      skills ? _fbb.CreateVector<int32_t>(*skills) : 0,
      enchantStat ? _fbb.CreateVector<int32_t>(*enchantStat) : 0);
}

flatbuffers::Offset<EQUIPED_HERO> CreateEQUIPED_HERO(flatbuffers::FlatBufferBuilder &_fbb, const EQUIPED_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_SNIPPETT : public flatbuffers::NativeTable {
  typedef HERO_SNIPPET TableType;
  std::string heroUD;
  std::string heroId;
  int32_t grade;
  int32_t level;
  HERO_SNIPPETT()
      : grade(1),
        level(1) {
  }
};

struct HERO_SNIPPET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_SNIPPETT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_HEROID = 6,
    VT_GRADE = 8,
    VT_LEVEL = 10
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t grade() const {
    return GetField<int32_t>(VT_GRADE, 1);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  HERO_SNIPPETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_SNIPPETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_SNIPPET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SNIPPETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_SNIPPETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(HERO_SNIPPET::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(HERO_SNIPPET::VT_HEROID, heroId);
  }
  void add_grade(int32_t grade) {
    fbb_.AddElement<int32_t>(HERO_SNIPPET::VT_GRADE, grade, 1);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(HERO_SNIPPET::VT_LEVEL, level, 1);
  }
  explicit HERO_SNIPPETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_SNIPPETBuilder &operator=(const HERO_SNIPPETBuilder &);
  flatbuffers::Offset<HERO_SNIPPET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_SNIPPET>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_SNIPPET> CreateHERO_SNIPPET(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t grade = 1,
    int32_t level = 1) {
  HERO_SNIPPETBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_grade(grade);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_SNIPPET> CreateHERO_SNIPPETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t grade = 1,
    int32_t level = 1) {
  return OVERLORD::STRUCT::CreateHERO_SNIPPET(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      grade,
      level);
}

flatbuffers::Offset<HERO_SNIPPET> CreateHERO_SNIPPET(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SNIPPETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RAID_STAGET : public flatbuffers::NativeTable {
  typedef RAID_STAGE TableType;
  std::string boss;
  std::string stageId;
  std::vector<int32_t> modes;
  int32_t left;
  std::vector<int32_t> ds;
  std::vector<int32_t> de;
  RAID_STAGET()
      : left(0) {
  }
};

struct RAID_STAGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RAID_STAGET NativeTableType;
  enum {
    VT_BOSS = 4,
    VT_STAGEID = 6,
    VT_MODES = 8,
    VT_LEFT = 10,
    VT_DS = 12,
    VT_DE = 14
  };
  const flatbuffers::String *boss() const {
    return GetPointer<const flatbuffers::String *>(VT_BOSS);
  }
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  const flatbuffers::Vector<int32_t> *modes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MODES);
  }
  int32_t left() const {
    return GetField<int32_t>(VT_LEFT, 0);
  }
  const flatbuffers::Vector<int32_t> *ds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DS);
  }
  const flatbuffers::Vector<int32_t> *de() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BOSS) &&
           verifier.Verify(boss()) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           VerifyOffset(verifier, VT_MODES) &&
           verifier.Verify(modes()) &&
           VerifyField<int32_t>(verifier, VT_LEFT) &&
           VerifyOffset(verifier, VT_DS) &&
           verifier.Verify(ds()) &&
           VerifyOffset(verifier, VT_DE) &&
           verifier.Verify(de()) &&
           verifier.EndTable();
  }
  RAID_STAGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RAID_STAGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RAID_STAGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RAID_STAGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_boss(flatbuffers::Offset<flatbuffers::String> boss) {
    fbb_.AddOffset(RAID_STAGE::VT_BOSS, boss);
  }
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(RAID_STAGE::VT_STAGEID, stageId);
  }
  void add_modes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> modes) {
    fbb_.AddOffset(RAID_STAGE::VT_MODES, modes);
  }
  void add_left(int32_t left) {
    fbb_.AddElement<int32_t>(RAID_STAGE::VT_LEFT, left, 0);
  }
  void add_ds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ds) {
    fbb_.AddOffset(RAID_STAGE::VT_DS, ds);
  }
  void add_de(flatbuffers::Offset<flatbuffers::Vector<int32_t>> de) {
    fbb_.AddOffset(RAID_STAGE::VT_DE, de);
  }
  explicit RAID_STAGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RAID_STAGEBuilder &operator=(const RAID_STAGEBuilder &);
  flatbuffers::Offset<RAID_STAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RAID_STAGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<RAID_STAGE> CreateRAID_STAGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> boss = 0,
    flatbuffers::Offset<flatbuffers::String> stageId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> modes = 0,
    int32_t left = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ds = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> de = 0) {
  RAID_STAGEBuilder builder_(_fbb);
  builder_.add_de(de);
  builder_.add_ds(ds);
  builder_.add_left(left);
  builder_.add_modes(modes);
  builder_.add_stageId(stageId);
  builder_.add_boss(boss);
  return builder_.Finish();
}

inline flatbuffers::Offset<RAID_STAGE> CreateRAID_STAGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *boss = nullptr,
    const char *stageId = nullptr,
    const std::vector<int32_t> *modes = nullptr,
    int32_t left = 0,
    const std::vector<int32_t> *ds = nullptr,
    const std::vector<int32_t> *de = nullptr) {
  return OVERLORD::STRUCT::CreateRAID_STAGE(
      _fbb,
      boss ? _fbb.CreateString(boss) : 0,
      stageId ? _fbb.CreateString(stageId) : 0,
      modes ? _fbb.CreateVector<int32_t>(*modes) : 0,
      left,
      ds ? _fbb.CreateVector<int32_t>(*ds) : 0,
      de ? _fbb.CreateVector<int32_t>(*de) : 0);
}

flatbuffers::Offset<RAID_STAGE> CreateRAID_STAGE(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RAID_STAGE_PLAYT : public flatbuffers::NativeTable {
  typedef RAID_STAGE_PLAY TableType;
  std::string stageId;
  int32_t c;
  int32_t m;
  RAID_STAGE_PLAYT()
      : c(0),
        m(0) {
  }
};

struct RAID_STAGE_PLAY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RAID_STAGE_PLAYT NativeTableType;
  enum {
    VT_STAGEID = 4,
    VT_C = 6,
    VT_M = 8
  };
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  int32_t c() const {
    return GetField<int32_t>(VT_C, 0);
  }
  int32_t m() const {
    return GetField<int32_t>(VT_M, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           VerifyField<int32_t>(verifier, VT_C) &&
           VerifyField<int32_t>(verifier, VT_M) &&
           verifier.EndTable();
  }
  RAID_STAGE_PLAYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RAID_STAGE_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RAID_STAGE_PLAY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGE_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RAID_STAGE_PLAYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(RAID_STAGE_PLAY::VT_STAGEID, stageId);
  }
  void add_c(int32_t c) {
    fbb_.AddElement<int32_t>(RAID_STAGE_PLAY::VT_C, c, 0);
  }
  void add_m(int32_t m) {
    fbb_.AddElement<int32_t>(RAID_STAGE_PLAY::VT_M, m, 0);
  }
  explicit RAID_STAGE_PLAYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RAID_STAGE_PLAYBuilder &operator=(const RAID_STAGE_PLAYBuilder &);
  flatbuffers::Offset<RAID_STAGE_PLAY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RAID_STAGE_PLAY>(end);
    return o;
  }
};

inline flatbuffers::Offset<RAID_STAGE_PLAY> CreateRAID_STAGE_PLAY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> stageId = 0,
    int32_t c = 0,
    int32_t m = 0) {
  RAID_STAGE_PLAYBuilder builder_(_fbb);
  builder_.add_m(m);
  builder_.add_c(c);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

inline flatbuffers::Offset<RAID_STAGE_PLAY> CreateRAID_STAGE_PLAYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *stageId = nullptr,
    int32_t c = 0,
    int32_t m = 0) {
  return OVERLORD::STRUCT::CreateRAID_STAGE_PLAY(
      _fbb,
      stageId ? _fbb.CreateString(stageId) : 0,
      c,
      m);
}

flatbuffers::Offset<RAID_STAGE_PLAY> CreateRAID_STAGE_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGE_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EPISODET : public flatbuffers::NativeTable {
  typedef EPISODE TableType;
  std::string episodeId;
  int32_t max;
  int32_t trial;
  std::vector<int32_t> stages;
  EPISODET()
      : max(0),
        trial(0) {
  }
};

struct EPISODE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EPISODET NativeTableType;
  enum {
    VT_EPISODEID = 4,
    VT_MAX = 6,
    VT_TRIAL = 8,
    VT_STAGES = 10
  };
  const flatbuffers::String *episodeId() const {
    return GetPointer<const flatbuffers::String *>(VT_EPISODEID);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  int32_t trial() const {
    return GetField<int32_t>(VT_TRIAL, 0);
  }
  const flatbuffers::Vector<int32_t> *stages() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EPISODEID) &&
           verifier.Verify(episodeId()) &&
           VerifyField<int32_t>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_TRIAL) &&
           VerifyOffset(verifier, VT_STAGES) &&
           verifier.Verify(stages()) &&
           verifier.EndTable();
  }
  EPISODET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EPISODET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EPISODE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EPISODET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EPISODEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_episodeId(flatbuffers::Offset<flatbuffers::String> episodeId) {
    fbb_.AddOffset(EPISODE::VT_EPISODEID, episodeId);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(EPISODE::VT_MAX, max, 0);
  }
  void add_trial(int32_t trial) {
    fbb_.AddElement<int32_t>(EPISODE::VT_TRIAL, trial, 0);
  }
  void add_stages(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stages) {
    fbb_.AddOffset(EPISODE::VT_STAGES, stages);
  }
  explicit EPISODEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EPISODEBuilder &operator=(const EPISODEBuilder &);
  flatbuffers::Offset<EPISODE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EPISODE>(end);
    return o;
  }
};

inline flatbuffers::Offset<EPISODE> CreateEPISODE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> episodeId = 0,
    int32_t max = 0,
    int32_t trial = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stages = 0) {
  EPISODEBuilder builder_(_fbb);
  builder_.add_stages(stages);
  builder_.add_trial(trial);
  builder_.add_max(max);
  builder_.add_episodeId(episodeId);
  return builder_.Finish();
}

inline flatbuffers::Offset<EPISODE> CreateEPISODEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *episodeId = nullptr,
    int32_t max = 0,
    int32_t trial = 0,
    const std::vector<int32_t> *stages = nullptr) {
  return OVERLORD::STRUCT::CreateEPISODE(
      _fbb,
      episodeId ? _fbb.CreateString(episodeId) : 0,
      max,
      trial,
      stages ? _fbb.CreateVector<int32_t>(*stages) : 0);
}

flatbuffers::Offset<EPISODE> CreateEPISODE(flatbuffers::FlatBufferBuilder &_fbb, const EPISODET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAPTERT : public flatbuffers::NativeTable {
  typedef CHAPTER TableType;
  std::string chapterId;
  int32_t stars;
  int32_t clears;
  std::vector<std::unique_ptr<EPISODET>> episodes;
  CHAPTERT()
      : stars(0),
        clears(0) {
  }
};

struct CHAPTER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAPTERT NativeTableType;
  enum {
    VT_CHAPTERID = 4,
    VT_STARS = 6,
    VT_CLEARS = 8,
    VT_EPISODES = 10
  };
  const flatbuffers::String *chapterId() const {
    return GetPointer<const flatbuffers::String *>(VT_CHAPTERID);
  }
  int32_t stars() const {
    return GetField<int32_t>(VT_STARS, 0);
  }
  int32_t clears() const {
    return GetField<int32_t>(VT_CLEARS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EPISODE>> *episodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EPISODE>> *>(VT_EPISODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHAPTERID) &&
           verifier.Verify(chapterId()) &&
           VerifyField<int32_t>(verifier, VT_STARS) &&
           VerifyField<int32_t>(verifier, VT_CLEARS) &&
           VerifyOffset(verifier, VT_EPISODES) &&
           verifier.Verify(episodes()) &&
           verifier.VerifyVectorOfTables(episodes()) &&
           verifier.EndTable();
  }
  CHAPTERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAPTERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAPTER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAPTERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAPTERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapterId(flatbuffers::Offset<flatbuffers::String> chapterId) {
    fbb_.AddOffset(CHAPTER::VT_CHAPTERID, chapterId);
  }
  void add_stars(int32_t stars) {
    fbb_.AddElement<int32_t>(CHAPTER::VT_STARS, stars, 0);
  }
  void add_clears(int32_t clears) {
    fbb_.AddElement<int32_t>(CHAPTER::VT_CLEARS, clears, 0);
  }
  void add_episodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EPISODE>>> episodes) {
    fbb_.AddOffset(CHAPTER::VT_EPISODES, episodes);
  }
  explicit CHAPTERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAPTERBuilder &operator=(const CHAPTERBuilder &);
  flatbuffers::Offset<CHAPTER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAPTER>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAPTER> CreateCHAPTER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> chapterId = 0,
    int32_t stars = 0,
    int32_t clears = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EPISODE>>> episodes = 0) {
  CHAPTERBuilder builder_(_fbb);
  builder_.add_episodes(episodes);
  builder_.add_clears(clears);
  builder_.add_stars(stars);
  builder_.add_chapterId(chapterId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAPTER> CreateCHAPTERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *chapterId = nullptr,
    int32_t stars = 0,
    int32_t clears = 0,
    const std::vector<flatbuffers::Offset<EPISODE>> *episodes = nullptr) {
  return OVERLORD::STRUCT::CreateCHAPTER(
      _fbb,
      chapterId ? _fbb.CreateString(chapterId) : 0,
      stars,
      clears,
      episodes ? _fbb.CreateVector<flatbuffers::Offset<EPISODE>>(*episodes) : 0);
}

flatbuffers::Offset<CHAPTER> CreateCHAPTER(flatbuffers::FlatBufferBuilder &_fbb, const CHAPTERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACHIEVE_STATUST : public flatbuffers::NativeTable {
  typedef ACHIEVE_STATUS TableType;
  OVERLORD::ENUM::ACHIEVE_TYPE type;
  int32_t srl;
  int32_t amt;
  int32_t passed_level;
  bool unlocked;
  ACHIEVE_STATUST()
      : type(OVERLORD::ENUM::ACHIEVE_TYPE_NOTHING),
        srl(0),
        amt(0),
        passed_level(0),
        unlocked(false) {
  }
};

struct ACHIEVE_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACHIEVE_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_SRL = 6,
    VT_AMT = 8,
    VT_PASSED_LEVEL = 10,
    VT_UNLOCKED = 12
  };
  OVERLORD::ENUM::ACHIEVE_TYPE type() const {
    return static_cast<OVERLORD::ENUM::ACHIEVE_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t srl() const {
    return GetField<int32_t>(VT_SRL, 0);
  }
  int32_t amt() const {
    return GetField<int32_t>(VT_AMT, 0);
  }
  int32_t passed_level() const {
    return GetField<int32_t>(VT_PASSED_LEVEL, 0);
  }
  bool unlocked() const {
    return GetField<uint8_t>(VT_UNLOCKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SRL) &&
           VerifyField<int32_t>(verifier, VT_AMT) &&
           VerifyField<int32_t>(verifier, VT_PASSED_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_UNLOCKED) &&
           verifier.EndTable();
  }
  ACHIEVE_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACHIEVE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACHIEVE_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACHIEVE_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(OVERLORD::ENUM::ACHIEVE_TYPE type) {
    fbb_.AddElement<int8_t>(ACHIEVE_STATUS::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_srl(int32_t srl) {
    fbb_.AddElement<int32_t>(ACHIEVE_STATUS::VT_SRL, srl, 0);
  }
  void add_amt(int32_t amt) {
    fbb_.AddElement<int32_t>(ACHIEVE_STATUS::VT_AMT, amt, 0);
  }
  void add_passed_level(int32_t passed_level) {
    fbb_.AddElement<int32_t>(ACHIEVE_STATUS::VT_PASSED_LEVEL, passed_level, 0);
  }
  void add_unlocked(bool unlocked) {
    fbb_.AddElement<uint8_t>(ACHIEVE_STATUS::VT_UNLOCKED, static_cast<uint8_t>(unlocked), 0);
  }
  explicit ACHIEVE_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACHIEVE_STATUSBuilder &operator=(const ACHIEVE_STATUSBuilder &);
  flatbuffers::Offset<ACHIEVE_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACHIEVE_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACHIEVE_STATUS> CreateACHIEVE_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::ACHIEVE_TYPE type = OVERLORD::ENUM::ACHIEVE_TYPE_NOTHING,
    int32_t srl = 0,
    int32_t amt = 0,
    int32_t passed_level = 0,
    bool unlocked = false) {
  ACHIEVE_STATUSBuilder builder_(_fbb);
  builder_.add_passed_level(passed_level);
  builder_.add_amt(amt);
  builder_.add_srl(srl);
  builder_.add_unlocked(unlocked);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ACHIEVE_STATUS> CreateACHIEVE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACHIEVE_UPDATET : public flatbuffers::NativeTable {
  typedef ACHIEVE_UPDATE TableType;
  OVERLORD::ENUM::ACHIEVE_TYPE type;
  int32_t srl;
  int32_t amt;
  int32_t passed_level;
  bool unlocked;
  ACHIEVE_UPDATET()
      : type(OVERLORD::ENUM::ACHIEVE_TYPE_NOTHING),
        srl(0),
        amt(0),
        passed_level(0),
        unlocked(false) {
  }
};

struct ACHIEVE_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACHIEVE_UPDATET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_SRL = 6,
    VT_AMT = 8,
    VT_PASSED_LEVEL = 10,
    VT_UNLOCKED = 12
  };
  OVERLORD::ENUM::ACHIEVE_TYPE type() const {
    return static_cast<OVERLORD::ENUM::ACHIEVE_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t srl() const {
    return GetField<int32_t>(VT_SRL, 0);
  }
  int32_t amt() const {
    return GetField<int32_t>(VT_AMT, 0);
  }
  int32_t passed_level() const {
    return GetField<int32_t>(VT_PASSED_LEVEL, 0);
  }
  bool unlocked() const {
    return GetField<uint8_t>(VT_UNLOCKED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SRL) &&
           VerifyField<int32_t>(verifier, VT_AMT) &&
           VerifyField<int32_t>(verifier, VT_PASSED_LEVEL) &&
           VerifyField<uint8_t>(verifier, VT_UNLOCKED) &&
           verifier.EndTable();
  }
  ACHIEVE_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACHIEVE_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACHIEVE_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACHIEVE_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(OVERLORD::ENUM::ACHIEVE_TYPE type) {
    fbb_.AddElement<int8_t>(ACHIEVE_UPDATE::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_srl(int32_t srl) {
    fbb_.AddElement<int32_t>(ACHIEVE_UPDATE::VT_SRL, srl, 0);
  }
  void add_amt(int32_t amt) {
    fbb_.AddElement<int32_t>(ACHIEVE_UPDATE::VT_AMT, amt, 0);
  }
  void add_passed_level(int32_t passed_level) {
    fbb_.AddElement<int32_t>(ACHIEVE_UPDATE::VT_PASSED_LEVEL, passed_level, 0);
  }
  void add_unlocked(bool unlocked) {
    fbb_.AddElement<uint8_t>(ACHIEVE_UPDATE::VT_UNLOCKED, static_cast<uint8_t>(unlocked), 0);
  }
  explicit ACHIEVE_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACHIEVE_UPDATEBuilder &operator=(const ACHIEVE_UPDATEBuilder &);
  flatbuffers::Offset<ACHIEVE_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACHIEVE_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACHIEVE_UPDATE> CreateACHIEVE_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::ACHIEVE_TYPE type = OVERLORD::ENUM::ACHIEVE_TYPE_NOTHING,
    int32_t srl = 0,
    int32_t amt = 0,
    int32_t passed_level = 0,
    bool unlocked = false) {
  ACHIEVE_UPDATEBuilder builder_(_fbb);
  builder_.add_passed_level(passed_level);
  builder_.add_amt(amt);
  builder_.add_srl(srl);
  builder_.add_unlocked(unlocked);
  builder_.add_type(type);
  return builder_.Finish();
}

flatbuffers::Offset<ACHIEVE_UPDATE> CreateACHIEVE_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ERROR_INFOT : public flatbuffers::NativeTable {
  typedef ERROR_INFO TableType;
  std::string code;
  std::string name;
  std::vector<std::string> desc;
  ERROR_INFOT() {
  }
};

struct ERROR_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ERROR_INFOT NativeTableType;
  enum {
    VT_CODE = 4,
    VT_NAME = 6,
    VT_DESC = 8
  };
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *desc() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DESC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           verifier.VerifyVectorOfStrings(desc()) &&
           verifier.EndTable();
  }
  ERROR_INFOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ERROR_INFOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ERROR_INFO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ERROR_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ERROR_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(ERROR_INFO::VT_CODE, code);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ERROR_INFO::VT_NAME, name);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> desc) {
    fbb_.AddOffset(ERROR_INFO::VT_DESC, desc);
  }
  explicit ERROR_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ERROR_INFOBuilder &operator=(const ERROR_INFOBuilder &);
  flatbuffers::Offset<ERROR_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ERROR_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ERROR_INFO> CreateERROR_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> desc = 0) {
  ERROR_INFOBuilder builder_(_fbb);
  builder_.add_desc(desc);
  builder_.add_name(name);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<ERROR_INFO> CreateERROR_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *code = nullptr,
    const char *name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *desc = nullptr) {
  return OVERLORD::STRUCT::CreateERROR_INFO(
      _fbb,
      code ? _fbb.CreateString(code) : 0,
      name ? _fbb.CreateString(name) : 0,
      desc ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*desc) : 0);
}

flatbuffers::Offset<ERROR_INFO> CreateERROR_INFO(flatbuffers::FlatBufferBuilder &_fbb, const ERROR_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MAILT : public flatbuffers::NativeTable {
  typedef MAIL TableType;
  std::string mailUD;
  int32_t kId;
  std::string from;
  std::string subject;
  std::string desc;
  std::string created;
  std::string expire;
  std::vector<std::unique_ptr<REWARDT>> attach;
  bool isNew;
  MAILT()
      : kId(0),
        isNew(true) {
  }
};

struct MAIL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MAILT NativeTableType;
  enum {
    VT_MAILUD = 4,
    VT_KID = 6,
    VT_FROM = 8,
    VT_SUBJECT = 10,
    VT_DESC = 12,
    VT_CREATED = 14,
    VT_EXPIRE = 16,
    VT_ATTACH = 18,
    VT_ISNEW = 20
  };
  const flatbuffers::String *mailUD() const {
    return GetPointer<const flatbuffers::String *>(VT_MAILUD);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *from() const {
    return GetPointer<const flatbuffers::String *>(VT_FROM);
  }
  const flatbuffers::String *subject() const {
    return GetPointer<const flatbuffers::String *>(VT_SUBJECT);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::String *created() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATED);
  }
  const flatbuffers::String *expire() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPIRE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *attach() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_ATTACH);
  }
  bool isNew() const {
    return GetField<uint8_t>(VT_ISNEW, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MAILUD) &&
           verifier.Verify(mailUD()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_FROM) &&
           verifier.Verify(from()) &&
           VerifyOffset(verifier, VT_SUBJECT) &&
           verifier.Verify(subject()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           VerifyOffset(verifier, VT_CREATED) &&
           verifier.Verify(created()) &&
           VerifyOffset(verifier, VT_EXPIRE) &&
           verifier.Verify(expire()) &&
           VerifyOffset(verifier, VT_ATTACH) &&
           verifier.Verify(attach()) &&
           verifier.VerifyVectorOfTables(attach()) &&
           VerifyField<uint8_t>(verifier, VT_ISNEW) &&
           verifier.EndTable();
  }
  MAILT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MAILT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MAIL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MAILT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MAILBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mailUD(flatbuffers::Offset<flatbuffers::String> mailUD) {
    fbb_.AddOffset(MAIL::VT_MAILUD, mailUD);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(MAIL::VT_KID, kId, 0);
  }
  void add_from(flatbuffers::Offset<flatbuffers::String> from) {
    fbb_.AddOffset(MAIL::VT_FROM, from);
  }
  void add_subject(flatbuffers::Offset<flatbuffers::String> subject) {
    fbb_.AddOffset(MAIL::VT_SUBJECT, subject);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(MAIL::VT_DESC, desc);
  }
  void add_created(flatbuffers::Offset<flatbuffers::String> created) {
    fbb_.AddOffset(MAIL::VT_CREATED, created);
  }
  void add_expire(flatbuffers::Offset<flatbuffers::String> expire) {
    fbb_.AddOffset(MAIL::VT_EXPIRE, expire);
  }
  void add_attach(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> attach) {
    fbb_.AddOffset(MAIL::VT_ATTACH, attach);
  }
  void add_isNew(bool isNew) {
    fbb_.AddElement<uint8_t>(MAIL::VT_ISNEW, static_cast<uint8_t>(isNew), 1);
  }
  explicit MAILBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MAILBuilder &operator=(const MAILBuilder &);
  flatbuffers::Offset<MAIL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MAIL>(end);
    return o;
  }
};

inline flatbuffers::Offset<MAIL> CreateMAIL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mailUD = 0,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> from = 0,
    flatbuffers::Offset<flatbuffers::String> subject = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::String> created = 0,
    flatbuffers::Offset<flatbuffers::String> expire = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> attach = 0,
    bool isNew = true) {
  MAILBuilder builder_(_fbb);
  builder_.add_attach(attach);
  builder_.add_expire(expire);
  builder_.add_created(created);
  builder_.add_desc(desc);
  builder_.add_subject(subject);
  builder_.add_from(from);
  builder_.add_kId(kId);
  builder_.add_mailUD(mailUD);
  builder_.add_isNew(isNew);
  return builder_.Finish();
}

inline flatbuffers::Offset<MAIL> CreateMAILDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mailUD = nullptr,
    int32_t kId = 0,
    const char *from = nullptr,
    const char *subject = nullptr,
    const char *desc = nullptr,
    const char *created = nullptr,
    const char *expire = nullptr,
    const std::vector<flatbuffers::Offset<REWARD>> *attach = nullptr,
    bool isNew = true) {
  return OVERLORD::STRUCT::CreateMAIL(
      _fbb,
      mailUD ? _fbb.CreateString(mailUD) : 0,
      kId,
      from ? _fbb.CreateString(from) : 0,
      subject ? _fbb.CreateString(subject) : 0,
      desc ? _fbb.CreateString(desc) : 0,
      created ? _fbb.CreateString(created) : 0,
      expire ? _fbb.CreateString(expire) : 0,
      attach ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*attach) : 0,
      isNew);
}

flatbuffers::Offset<MAIL> CreateMAIL(flatbuffers::FlatBufferBuilder &_fbb, const MAILT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PDT : public flatbuffers::NativeTable {
  typedef PD TableType;
  int32_t kId;
  std::string name;
  int32_t level;
  int32_t sublevel;
  int32_t exp;
  OVERLORD::ENUM::PD_TYPE type;
  int32_t shards;
  int32_t ticket;
  int32_t chip;
  int32_t gp;
  int32_t cp;
  int32_t ap;
  int32_t dp;
  int32_t defWin;
  int32_t defCnt;
  OVERLORD::ENUM::PD_LOCK_TYPE lock;
  PDT()
      : kId(0),
        level(0),
        sublevel(0),
        exp(0),
        type(OVERLORD::ENUM::PD_TYPE_NOTHING),
        shards(0),
        ticket(0),
        chip(0),
        gp(0),
        cp(0),
        ap(0),
        dp(0),
        defWin(0),
        defCnt(0),
        lock(OVERLORD::ENUM::PD_LOCK_TYPE_NONE) {
  }
};

struct PD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PDT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_SUBLEVEL = 10,
    VT_EXP = 12,
    VT_TYPE = 14,
    VT_SHARDS = 16,
    VT_TICKET = 18,
    VT_CHIP = 20,
    VT_GP = 22,
    VT_CP = 24,
    VT_AP = 26,
    VT_DP = 28,
    VT_DEFWIN = 30,
    VT_DEFCNT = 32,
    VT_LOCK = 34
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t sublevel() const {
    return GetField<int32_t>(VT_SUBLEVEL, 0);
  }
  int32_t exp() const {
    return GetField<int32_t>(VT_EXP, 0);
  }
  OVERLORD::ENUM::PD_TYPE type() const {
    return static_cast<OVERLORD::ENUM::PD_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t shards() const {
    return GetField<int32_t>(VT_SHARDS, 0);
  }
  int32_t ticket() const {
    return GetField<int32_t>(VT_TICKET, 0);
  }
  int32_t chip() const {
    return GetField<int32_t>(VT_CHIP, 0);
  }
  int32_t gp() const {
    return GetField<int32_t>(VT_GP, 0);
  }
  int32_t cp() const {
    return GetField<int32_t>(VT_CP, 0);
  }
  int32_t ap() const {
    return GetField<int32_t>(VT_AP, 0);
  }
  int32_t dp() const {
    return GetField<int32_t>(VT_DP, 0);
  }
  int32_t defWin() const {
    return GetField<int32_t>(VT_DEFWIN, 0);
  }
  int32_t defCnt() const {
    return GetField<int32_t>(VT_DEFCNT, 0);
  }
  OVERLORD::ENUM::PD_LOCK_TYPE lock() const {
    return static_cast<OVERLORD::ENUM::PD_LOCK_TYPE>(GetField<int8_t>(VT_LOCK, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_SUBLEVEL) &&
           VerifyField<int32_t>(verifier, VT_EXP) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_SHARDS) &&
           VerifyField<int32_t>(verifier, VT_TICKET) &&
           VerifyField<int32_t>(verifier, VT_CHIP) &&
           VerifyField<int32_t>(verifier, VT_GP) &&
           VerifyField<int32_t>(verifier, VT_CP) &&
           VerifyField<int32_t>(verifier, VT_AP) &&
           VerifyField<int32_t>(verifier, VT_DP) &&
           VerifyField<int32_t>(verifier, VT_DEFWIN) &&
           VerifyField<int32_t>(verifier, VT_DEFCNT) &&
           VerifyField<int8_t>(verifier, VT_LOCK) &&
           verifier.EndTable();
  }
  PDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PD::VT_KID, kId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PD::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PD::VT_LEVEL, level, 0);
  }
  void add_sublevel(int32_t sublevel) {
    fbb_.AddElement<int32_t>(PD::VT_SUBLEVEL, sublevel, 0);
  }
  void add_exp(int32_t exp) {
    fbb_.AddElement<int32_t>(PD::VT_EXP, exp, 0);
  }
  void add_type(OVERLORD::ENUM::PD_TYPE type) {
    fbb_.AddElement<int8_t>(PD::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_shards(int32_t shards) {
    fbb_.AddElement<int32_t>(PD::VT_SHARDS, shards, 0);
  }
  void add_ticket(int32_t ticket) {
    fbb_.AddElement<int32_t>(PD::VT_TICKET, ticket, 0);
  }
  void add_chip(int32_t chip) {
    fbb_.AddElement<int32_t>(PD::VT_CHIP, chip, 0);
  }
  void add_gp(int32_t gp) {
    fbb_.AddElement<int32_t>(PD::VT_GP, gp, 0);
  }
  void add_cp(int32_t cp) {
    fbb_.AddElement<int32_t>(PD::VT_CP, cp, 0);
  }
  void add_ap(int32_t ap) {
    fbb_.AddElement<int32_t>(PD::VT_AP, ap, 0);
  }
  void add_dp(int32_t dp) {
    fbb_.AddElement<int32_t>(PD::VT_DP, dp, 0);
  }
  void add_defWin(int32_t defWin) {
    fbb_.AddElement<int32_t>(PD::VT_DEFWIN, defWin, 0);
  }
  void add_defCnt(int32_t defCnt) {
    fbb_.AddElement<int32_t>(PD::VT_DEFCNT, defCnt, 0);
  }
  void add_lock(OVERLORD::ENUM::PD_LOCK_TYPE lock) {
    fbb_.AddElement<int8_t>(PD::VT_LOCK, static_cast<int8_t>(lock), 0);
  }
  explicit PDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PDBuilder &operator=(const PDBuilder &);
  flatbuffers::Offset<PD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD> CreatePD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    int32_t sublevel = 0,
    int32_t exp = 0,
    OVERLORD::ENUM::PD_TYPE type = OVERLORD::ENUM::PD_TYPE_NOTHING,
    int32_t shards = 0,
    int32_t ticket = 0,
    int32_t chip = 0,
    int32_t gp = 0,
    int32_t cp = 0,
    int32_t ap = 0,
    int32_t dp = 0,
    int32_t defWin = 0,
    int32_t defCnt = 0,
    OVERLORD::ENUM::PD_LOCK_TYPE lock = OVERLORD::ENUM::PD_LOCK_TYPE_NONE) {
  PDBuilder builder_(_fbb);
  builder_.add_defCnt(defCnt);
  builder_.add_defWin(defWin);
  builder_.add_dp(dp);
  builder_.add_ap(ap);
  builder_.add_cp(cp);
  builder_.add_gp(gp);
  builder_.add_chip(chip);
  builder_.add_ticket(ticket);
  builder_.add_shards(shards);
  builder_.add_exp(exp);
  builder_.add_sublevel(sublevel);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_kId(kId);
  builder_.add_lock(lock);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD> CreatePDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *name = nullptr,
    int32_t level = 0,
    int32_t sublevel = 0,
    int32_t exp = 0,
    OVERLORD::ENUM::PD_TYPE type = OVERLORD::ENUM::PD_TYPE_NOTHING,
    int32_t shards = 0,
    int32_t ticket = 0,
    int32_t chip = 0,
    int32_t gp = 0,
    int32_t cp = 0,
    int32_t ap = 0,
    int32_t dp = 0,
    int32_t defWin = 0,
    int32_t defCnt = 0,
    OVERLORD::ENUM::PD_LOCK_TYPE lock = OVERLORD::ENUM::PD_LOCK_TYPE_NONE) {
  return OVERLORD::STRUCT::CreatePD(
      _fbb,
      kId,
      name ? _fbb.CreateString(name) : 0,
      level,
      sublevel,
      exp,
      type,
      shards,
      ticket,
      chip,
      gp,
      cp,
      ap,
      dp,
      defWin,
      defCnt,
      lock);
}

flatbuffers::Offset<PD> CreatePD(flatbuffers::FlatBufferBuilder &_fbb, const PDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_CHRONICLET : public flatbuffers::NativeTable {
  typedef PD_CHRONICLE TableType;
  std::string when;
  std::string msg;
  PD_CHRONICLET() {
  }
};

struct PD_CHRONICLE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_CHRONICLET NativeTableType;
  enum {
    VT_WHEN = 4,
    VT_MSG = 6
  };
  const flatbuffers::String *when() const {
    return GetPointer<const flatbuffers::String *>(VT_WHEN);
  }
  const flatbuffers::String *msg() const {
    return GetPointer<const flatbuffers::String *>(VT_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WHEN) &&
           verifier.Verify(when()) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.Verify(msg()) &&
           verifier.EndTable();
  }
  PD_CHRONICLET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_CHRONICLET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_CHRONICLE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_CHRONICLET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_CHRONICLEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_when(flatbuffers::Offset<flatbuffers::String> when) {
    fbb_.AddOffset(PD_CHRONICLE::VT_WHEN, when);
  }
  void add_msg(flatbuffers::Offset<flatbuffers::String> msg) {
    fbb_.AddOffset(PD_CHRONICLE::VT_MSG, msg);
  }
  explicit PD_CHRONICLEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_CHRONICLEBuilder &operator=(const PD_CHRONICLEBuilder &);
  flatbuffers::Offset<PD_CHRONICLE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_CHRONICLE>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_CHRONICLE> CreatePD_CHRONICLE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> when = 0,
    flatbuffers::Offset<flatbuffers::String> msg = 0) {
  PD_CHRONICLEBuilder builder_(_fbb);
  builder_.add_msg(msg);
  builder_.add_when(when);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_CHRONICLE> CreatePD_CHRONICLEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *when = nullptr,
    const char *msg = nullptr) {
  return OVERLORD::STRUCT::CreatePD_CHRONICLE(
      _fbb,
      when ? _fbb.CreateString(when) : 0,
      msg ? _fbb.CreateString(msg) : 0);
}

flatbuffers::Offset<PD_CHRONICLE> CreatePD_CHRONICLE(flatbuffers::FlatBufferBuilder &_fbb, const PD_CHRONICLET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_DEFENCET : public flatbuffers::NativeTable {
  typedef PD_DEFENCE TableType;
  bool defeated;
  int32_t level;
  std::string nick;
  std::string guild;
  int32_t chip;
  int32_t gp;
  int32_t dp;
  std::vector<std::string> deadHeros;
  PD_DEFENCET()
      : defeated(false),
        level(0),
        chip(0),
        gp(0),
        dp(0) {
  }
};

struct PD_DEFENCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_DEFENCET NativeTableType;
  enum {
    VT_DEFEATED = 4,
    VT_LEVEL = 6,
    VT_NICK = 8,
    VT_GUILD = 10,
    VT_CHIP = 12,
    VT_GP = 14,
    VT_DP = 16,
    VT_DEADHEROS = 18
  };
  bool defeated() const {
    return GetField<uint8_t>(VT_DEFEATED, 0) != 0;
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t chip() const {
    return GetField<int32_t>(VT_CHIP, 0);
  }
  int32_t gp() const {
    return GetField<int32_t>(VT_GP, 0);
  }
  int32_t dp() const {
    return GetField<int32_t>(VT_DP, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *deadHeros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEADHEROS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DEFEATED) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_CHIP) &&
           VerifyField<int32_t>(verifier, VT_GP) &&
           VerifyField<int32_t>(verifier, VT_DP) &&
           VerifyOffset(verifier, VT_DEADHEROS) &&
           verifier.Verify(deadHeros()) &&
           verifier.VerifyVectorOfStrings(deadHeros()) &&
           verifier.EndTable();
  }
  PD_DEFENCET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_DEFENCET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_DEFENCE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_DEFENCET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_DEFENCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_defeated(bool defeated) {
    fbb_.AddElement<uint8_t>(PD_DEFENCE::VT_DEFEATED, static_cast<uint8_t>(defeated), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PD_DEFENCE::VT_LEVEL, level, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(PD_DEFENCE::VT_NICK, nick);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(PD_DEFENCE::VT_GUILD, guild);
  }
  void add_chip(int32_t chip) {
    fbb_.AddElement<int32_t>(PD_DEFENCE::VT_CHIP, chip, 0);
  }
  void add_gp(int32_t gp) {
    fbb_.AddElement<int32_t>(PD_DEFENCE::VT_GP, gp, 0);
  }
  void add_dp(int32_t dp) {
    fbb_.AddElement<int32_t>(PD_DEFENCE::VT_DP, dp, 0);
  }
  void add_deadHeros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deadHeros) {
    fbb_.AddOffset(PD_DEFENCE::VT_DEADHEROS, deadHeros);
  }
  explicit PD_DEFENCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_DEFENCEBuilder &operator=(const PD_DEFENCEBuilder &);
  flatbuffers::Offset<PD_DEFENCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_DEFENCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_DEFENCE> CreatePD_DEFENCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool defeated = false,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t chip = 0,
    int32_t gp = 0,
    int32_t dp = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> deadHeros = 0) {
  PD_DEFENCEBuilder builder_(_fbb);
  builder_.add_deadHeros(deadHeros);
  builder_.add_dp(dp);
  builder_.add_gp(gp);
  builder_.add_chip(chip);
  builder_.add_guild(guild);
  builder_.add_nick(nick);
  builder_.add_level(level);
  builder_.add_defeated(defeated);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_DEFENCE> CreatePD_DEFENCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool defeated = false,
    int32_t level = 0,
    const char *nick = nullptr,
    const char *guild = nullptr,
    int32_t chip = 0,
    int32_t gp = 0,
    int32_t dp = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *deadHeros = nullptr) {
  return OVERLORD::STRUCT::CreatePD_DEFENCE(
      _fbb,
      defeated,
      level,
      nick ? _fbb.CreateString(nick) : 0,
      guild ? _fbb.CreateString(guild) : 0,
      chip,
      gp,
      dp,
      deadHeros ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*deadHeros) : 0);
}

flatbuffers::Offset<PD_DEFENCE> CreatePD_DEFENCE(flatbuffers::FlatBufferBuilder &_fbb, const PD_DEFENCET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_SNIPPETT : public flatbuffers::NativeTable {
  typedef PD_SNIPPET TableType;
  int32_t kId;
  std::string name;
  int32_t level;
  std::string guild;
  int32_t defWin;
  int32_t defCnt;
  int32_t rank;
  PD_SNIPPETT()
      : kId(0),
        level(0),
        defWin(0),
        defCnt(0),
        rank(0) {
  }
};

struct PD_SNIPPET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_SNIPPETT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_GUILD = 10,
    VT_DEFWIN = 12,
    VT_DEFCNT = 14,
    VT_RANK = 16
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t defWin() const {
    return GetField<int32_t>(VT_DEFWIN, 0);
  }
  int32_t defCnt() const {
    return GetField<int32_t>(VT_DEFCNT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_DEFWIN) &&
           VerifyField<int32_t>(verifier, VT_DEFCNT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           verifier.EndTable();
  }
  PD_SNIPPETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_SNIPPETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_SNIPPET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_SNIPPETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_SNIPPETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PD_SNIPPET::VT_KID, kId, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PD_SNIPPET::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PD_SNIPPET::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(PD_SNIPPET::VT_GUILD, guild);
  }
  void add_defWin(int32_t defWin) {
    fbb_.AddElement<int32_t>(PD_SNIPPET::VT_DEFWIN, defWin, 0);
  }
  void add_defCnt(int32_t defCnt) {
    fbb_.AddElement<int32_t>(PD_SNIPPET::VT_DEFCNT, defCnt, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(PD_SNIPPET::VT_RANK, rank, 0);
  }
  explicit PD_SNIPPETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_SNIPPETBuilder &operator=(const PD_SNIPPETBuilder &);
  flatbuffers::Offset<PD_SNIPPET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_SNIPPET>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_SNIPPET> CreatePD_SNIPPET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t defWin = 0,
    int32_t defCnt = 0,
    int32_t rank = 0) {
  PD_SNIPPETBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_defCnt(defCnt);
  builder_.add_defWin(defWin);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_SNIPPET> CreatePD_SNIPPETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *name = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    int32_t defWin = 0,
    int32_t defCnt = 0,
    int32_t rank = 0) {
  return OVERLORD::STRUCT::CreatePD_SNIPPET(
      _fbb,
      kId,
      name ? _fbb.CreateString(name) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      defWin,
      defCnt,
      rank);
}

flatbuffers::Offset<PD_SNIPPET> CreatePD_SNIPPET(flatbuffers::FlatBufferBuilder &_fbb, const PD_SNIPPETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_MINIONT : public flatbuffers::NativeTable {
  typedef PD_MINION TableType;
  std::string UD;
  std::string mId;
  OVERLORD::ENUM::PD_MINION_TYPE mType;
  int32_t level;
  int32_t left;
  PD_MINIONT()
      : mType(OVERLORD::ENUM::PD_MINION_TYPE_SYSTEM),
        level(0),
        left(0) {
  }
};

struct PD_MINION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_MINIONT NativeTableType;
  enum {
    VT_UD = 4,
    VT_MID = 6,
    VT_MTYPE = 8,
    VT_LEVEL = 10,
    VT_LEFT = 12
  };
  const flatbuffers::String *UD() const {
    return GetPointer<const flatbuffers::String *>(VT_UD);
  }
  const flatbuffers::String *mId() const {
    return GetPointer<const flatbuffers::String *>(VT_MID);
  }
  OVERLORD::ENUM::PD_MINION_TYPE mType() const {
    return static_cast<OVERLORD::ENUM::PD_MINION_TYPE>(GetField<int8_t>(VT_MTYPE, 0));
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t left() const {
    return GetField<int32_t>(VT_LEFT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UD) &&
           verifier.Verify(UD()) &&
           VerifyOffset(verifier, VT_MID) &&
           verifier.Verify(mId()) &&
           VerifyField<int8_t>(verifier, VT_MTYPE) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_LEFT) &&
           verifier.EndTable();
  }
  PD_MINIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_MINIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_MINION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_MINIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_UD(flatbuffers::Offset<flatbuffers::String> UD) {
    fbb_.AddOffset(PD_MINION::VT_UD, UD);
  }
  void add_mId(flatbuffers::Offset<flatbuffers::String> mId) {
    fbb_.AddOffset(PD_MINION::VT_MID, mId);
  }
  void add_mType(OVERLORD::ENUM::PD_MINION_TYPE mType) {
    fbb_.AddElement<int8_t>(PD_MINION::VT_MTYPE, static_cast<int8_t>(mType), 0);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(PD_MINION::VT_LEVEL, level, 0);
  }
  void add_left(int32_t left) {
    fbb_.AddElement<int32_t>(PD_MINION::VT_LEFT, left, 0);
  }
  explicit PD_MINIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_MINIONBuilder &operator=(const PD_MINIONBuilder &);
  flatbuffers::Offset<PD_MINION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_MINION>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_MINION> CreatePD_MINION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> UD = 0,
    flatbuffers::Offset<flatbuffers::String> mId = 0,
    OVERLORD::ENUM::PD_MINION_TYPE mType = OVERLORD::ENUM::PD_MINION_TYPE_SYSTEM,
    int32_t level = 0,
    int32_t left = 0) {
  PD_MINIONBuilder builder_(_fbb);
  builder_.add_left(left);
  builder_.add_level(level);
  builder_.add_mId(mId);
  builder_.add_UD(UD);
  builder_.add_mType(mType);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_MINION> CreatePD_MINIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *UD = nullptr,
    const char *mId = nullptr,
    OVERLORD::ENUM::PD_MINION_TYPE mType = OVERLORD::ENUM::PD_MINION_TYPE_SYSTEM,
    int32_t level = 0,
    int32_t left = 0) {
  return OVERLORD::STRUCT::CreatePD_MINION(
      _fbb,
      UD ? _fbb.CreateString(UD) : 0,
      mId ? _fbb.CreateString(mId) : 0,
      mType,
      level,
      left);
}

flatbuffers::Offset<PD_MINION> CreatePD_MINION(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_MINION_INVENT : public flatbuffers::NativeTable {
  typedef PD_MINION_INVEN TableType;
  std::vector<std::unique_ptr<PD_MINIONT>> supplied;
  std::vector<std::unique_ptr<PD_MINIONT>> purchased;
  PD_MINION_INVENT() {
  }
};

struct PD_MINION_INVEN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_MINION_INVENT NativeTableType;
  enum {
    VT_SUPPLIED = 4,
    VT_PURCHASED = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<PD_MINION>> *supplied() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PD_MINION>> *>(VT_SUPPLIED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PD_MINION>> *purchased() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PD_MINION>> *>(VT_PURCHASED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUPPLIED) &&
           verifier.Verify(supplied()) &&
           verifier.VerifyVectorOfTables(supplied()) &&
           VerifyOffset(verifier, VT_PURCHASED) &&
           verifier.Verify(purchased()) &&
           verifier.VerifyVectorOfTables(purchased()) &&
           verifier.EndTable();
  }
  PD_MINION_INVENT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_MINION_INVENT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_MINION_INVEN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINION_INVENT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_MINION_INVENBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_supplied(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PD_MINION>>> supplied) {
    fbb_.AddOffset(PD_MINION_INVEN::VT_SUPPLIED, supplied);
  }
  void add_purchased(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PD_MINION>>> purchased) {
    fbb_.AddOffset(PD_MINION_INVEN::VT_PURCHASED, purchased);
  }
  explicit PD_MINION_INVENBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_MINION_INVENBuilder &operator=(const PD_MINION_INVENBuilder &);
  flatbuffers::Offset<PD_MINION_INVEN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_MINION_INVEN>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_MINION_INVEN> CreatePD_MINION_INVEN(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PD_MINION>>> supplied = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PD_MINION>>> purchased = 0) {
  PD_MINION_INVENBuilder builder_(_fbb);
  builder_.add_purchased(purchased);
  builder_.add_supplied(supplied);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_MINION_INVEN> CreatePD_MINION_INVENDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<PD_MINION>> *supplied = nullptr,
    const std::vector<flatbuffers::Offset<PD_MINION>> *purchased = nullptr) {
  return OVERLORD::STRUCT::CreatePD_MINION_INVEN(
      _fbb,
      supplied ? _fbb.CreateVector<flatbuffers::Offset<PD_MINION>>(*supplied) : 0,
      purchased ? _fbb.CreateVector<flatbuffers::Offset<PD_MINION>>(*purchased) : 0);
}

flatbuffers::Offset<PD_MINION_INVEN> CreatePD_MINION_INVEN(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINION_INVENT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_TARGETT : public flatbuffers::NativeTable {
  typedef PD_TARGET TableType;
  int32_t kId;
  std::unique_ptr<AVATART> avatar;
  std::vector<std::unique_ptr<EQUIPED_HEROT>> heros;
  std::unique_ptr<PD_MINION_INVENT> minions;
  PD_TARGETT()
      : kId(0) {
  }
};

struct PD_TARGET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_TARGETT NativeTableType;
  enum {
    VT_KID = 4,
    VT_AVATAR = 6,
    VT_HEROS = 8,
    VT_MINIONS = 10
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const AVATAR *avatar() const {
    return GetPointer<const AVATAR *>(VT_AVATAR);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>> *heros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>> *>(VT_HEROS);
  }
  const PD_MINION_INVEN *minions() const {
    return GetPointer<const PD_MINION_INVEN *>(VT_MINIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.VerifyTable(avatar()) &&
           VerifyOffset(verifier, VT_HEROS) &&
           verifier.Verify(heros()) &&
           verifier.VerifyVectorOfTables(heros()) &&
           VerifyOffset(verifier, VT_MINIONS) &&
           verifier.VerifyTable(minions()) &&
           verifier.EndTable();
  }
  PD_TARGETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_TARGETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_TARGET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_TARGETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_TARGETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(PD_TARGET::VT_KID, kId, 0);
  }
  void add_avatar(flatbuffers::Offset<AVATAR> avatar) {
    fbb_.AddOffset(PD_TARGET::VT_AVATAR, avatar);
  }
  void add_heros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>>> heros) {
    fbb_.AddOffset(PD_TARGET::VT_HEROS, heros);
  }
  void add_minions(flatbuffers::Offset<PD_MINION_INVEN> minions) {
    fbb_.AddOffset(PD_TARGET::VT_MINIONS, minions);
  }
  explicit PD_TARGETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_TARGETBuilder &operator=(const PD_TARGETBuilder &);
  flatbuffers::Offset<PD_TARGET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_TARGET>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_TARGET> CreatePD_TARGET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<AVATAR> avatar = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>>> heros = 0,
    flatbuffers::Offset<PD_MINION_INVEN> minions = 0) {
  PD_TARGETBuilder builder_(_fbb);
  builder_.add_minions(minions);
  builder_.add_heros(heros);
  builder_.add_avatar(avatar);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_TARGET> CreatePD_TARGETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<AVATAR> avatar = 0,
    const std::vector<flatbuffers::Offset<EQUIPED_HERO>> *heros = nullptr,
    flatbuffers::Offset<PD_MINION_INVEN> minions = 0) {
  return OVERLORD::STRUCT::CreatePD_TARGET(
      _fbb,
      kId,
      avatar,
      heros ? _fbb.CreateVector<flatbuffers::Offset<EQUIPED_HERO>>(*heros) : 0,
      minions);
}

flatbuffers::Offset<PD_TARGET> CreatePD_TARGET(flatbuffers::FlatBufferBuilder &_fbb, const PD_TARGETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PD_TREASURENPCT : public flatbuffers::NativeTable {
  typedef PD_TREASURENPC TableType;
  std::string mId;
  int32_t room;
  PD_TREASURENPCT()
      : room(0) {
  }
};

struct PD_TREASURENPC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PD_TREASURENPCT NativeTableType;
  enum {
    VT_MID = 4,
    VT_ROOM = 6
  };
  const flatbuffers::String *mId() const {
    return GetPointer<const flatbuffers::String *>(VT_MID);
  }
  int32_t room() const {
    return GetField<int32_t>(VT_ROOM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MID) &&
           verifier.Verify(mId()) &&
           VerifyField<int32_t>(verifier, VT_ROOM) &&
           verifier.EndTable();
  }
  PD_TREASURENPCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PD_TREASURENPCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PD_TREASURENPC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_TREASURENPCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PD_TREASURENPCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mId(flatbuffers::Offset<flatbuffers::String> mId) {
    fbb_.AddOffset(PD_TREASURENPC::VT_MID, mId);
  }
  void add_room(int32_t room) {
    fbb_.AddElement<int32_t>(PD_TREASURENPC::VT_ROOM, room, 0);
  }
  explicit PD_TREASURENPCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PD_TREASURENPCBuilder &operator=(const PD_TREASURENPCBuilder &);
  flatbuffers::Offset<PD_TREASURENPC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PD_TREASURENPC>(end);
    return o;
  }
};

inline flatbuffers::Offset<PD_TREASURENPC> CreatePD_TREASURENPC(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mId = 0,
    int32_t room = 0) {
  PD_TREASURENPCBuilder builder_(_fbb);
  builder_.add_room(room);
  builder_.add_mId(mId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PD_TREASURENPC> CreatePD_TREASURENPCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mId = nullptr,
    int32_t room = 0) {
  return OVERLORD::STRUCT::CreatePD_TREASURENPC(
      _fbb,
      mId ? _fbb.CreateString(mId) : 0,
      room);
}

flatbuffers::Offset<PD_TREASURENPC> CreatePD_TREASURENPC(flatbuffers::FlatBufferBuilder &_fbb, const PD_TREASURENPCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_PRODUCT_STATUST : public flatbuffers::NativeTable {
  typedef SHOP_PRODUCT_STATUS TableType;
  std::string productId;
  int32_t buyCount;
  int32_t coolTime;
  SHOP_PRODUCT_STATUST()
      : buyCount(0),
        coolTime(0) {
  }
};

struct SHOP_PRODUCT_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_PRODUCT_STATUST NativeTableType;
  enum {
    VT_PRODUCTID = 4,
    VT_BUYCOUNT = 6,
    VT_COOLTIME = 8
  };
  const flatbuffers::String *productId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCTID);
  }
  int32_t buyCount() const {
    return GetField<int32_t>(VT_BUYCOUNT, 0);
  }
  int32_t coolTime() const {
    return GetField<int32_t>(VT_COOLTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRODUCTID) &&
           verifier.Verify(productId()) &&
           VerifyField<int32_t>(verifier, VT_BUYCOUNT) &&
           VerifyField<int32_t>(verifier, VT_COOLTIME) &&
           verifier.EndTable();
  }
  SHOP_PRODUCT_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_PRODUCT_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_PRODUCT_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_PRODUCT_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_PRODUCT_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(flatbuffers::Offset<flatbuffers::String> productId) {
    fbb_.AddOffset(SHOP_PRODUCT_STATUS::VT_PRODUCTID, productId);
  }
  void add_buyCount(int32_t buyCount) {
    fbb_.AddElement<int32_t>(SHOP_PRODUCT_STATUS::VT_BUYCOUNT, buyCount, 0);
  }
  void add_coolTime(int32_t coolTime) {
    fbb_.AddElement<int32_t>(SHOP_PRODUCT_STATUS::VT_COOLTIME, coolTime, 0);
  }
  explicit SHOP_PRODUCT_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_PRODUCT_STATUSBuilder &operator=(const SHOP_PRODUCT_STATUSBuilder &);
  flatbuffers::Offset<SHOP_PRODUCT_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_PRODUCT_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_PRODUCT_STATUS> CreateSHOP_PRODUCT_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> productId = 0,
    int32_t buyCount = 0,
    int32_t coolTime = 0) {
  SHOP_PRODUCT_STATUSBuilder builder_(_fbb);
  builder_.add_coolTime(coolTime);
  builder_.add_buyCount(buyCount);
  builder_.add_productId(productId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_PRODUCT_STATUS> CreateSHOP_PRODUCT_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *productId = nullptr,
    int32_t buyCount = 0,
    int32_t coolTime = 0) {
  return OVERLORD::STRUCT::CreateSHOP_PRODUCT_STATUS(
      _fbb,
      productId ? _fbb.CreateString(productId) : 0,
      buyCount,
      coolTime);
}

flatbuffers::Offset<SHOP_PRODUCT_STATUS> CreateSHOP_PRODUCT_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_PRODUCT_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_USER_DATAT : public flatbuffers::NativeTable {
  typedef SHOP_USER_DATA TableType;
  int32_t kId;
  std::vector<std::unique_ptr<SHOP_PRODUCT_STATUST>> productStatus;
  SHOP_USER_DATAT()
      : kId(0) {
  }
};

struct SHOP_USER_DATA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_USER_DATAT NativeTableType;
  enum {
    VT_KID = 4,
    VT_PRODUCTSTATUS = 6
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>> *productStatus() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>> *>(VT_PRODUCTSTATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_PRODUCTSTATUS) &&
           verifier.Verify(productStatus()) &&
           verifier.VerifyVectorOfTables(productStatus()) &&
           verifier.EndTable();
  }
  SHOP_USER_DATAT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_USER_DATAT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_USER_DATA> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_USER_DATABuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(SHOP_USER_DATA::VT_KID, kId, 0);
  }
  void add_productStatus(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>>> productStatus) {
    fbb_.AddOffset(SHOP_USER_DATA::VT_PRODUCTSTATUS, productStatus);
  }
  explicit SHOP_USER_DATABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_USER_DATABuilder &operator=(const SHOP_USER_DATABuilder &);
  flatbuffers::Offset<SHOP_USER_DATA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_USER_DATA>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>>> productStatus = 0) {
  SHOP_USER_DATABuilder builder_(_fbb);
  builder_.add_productStatus(productStatus);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const std::vector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>> *productStatus = nullptr) {
  return OVERLORD::STRUCT::CreateSHOP_USER_DATA(
      _fbb,
      kId,
      productStatus ? _fbb.CreateVector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>>(*productStatus) : 0);
}

flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_INFOT : public flatbuffers::NativeTable {
  typedef GUILD_INFO TableType;
  int32_t guild_id;
  std::string name;
  int32_t level;
  int32_t point;
  int32_t point_rank;
  int32_t gold;
  std::string desc;
  std::string notice;
  std::string create_date;
  int32_t member_count;
  int32_t member_limit;
  bool auto_grade_up;
  GUILD_INFOT()
      : guild_id(0),
        level(1),
        point(0),
        point_rank(0),
        gold(0),
        member_count(0),
        member_limit(10),
        auto_grade_up(false) {
  }
};

struct GUILD_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_INFOT NativeTableType;
  enum {
    VT_GUILD_ID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_POINT = 10,
    VT_POINT_RANK = 12,
    VT_GOLD = 14,
    VT_DESC = 16,
    VT_NOTICE = 18,
    VT_CREATE_DATE = 20,
    VT_MEMBER_COUNT = 22,
    VT_MEMBER_LIMIT = 24,
    VT_AUTO_GRADE_UP = 26
  };
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t point_rank() const {
    return GetField<int32_t>(VT_POINT_RANK, 0);
  }
  int32_t gold() const {
    return GetField<int32_t>(VT_GOLD, 0);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::String *notice() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICE);
  }
  const flatbuffers::String *create_date() const {
    return GetPointer<const flatbuffers::String *>(VT_CREATE_DATE);
  }
  int32_t member_count() const {
    return GetField<int32_t>(VT_MEMBER_COUNT, 0);
  }
  int32_t member_limit() const {
    return GetField<int32_t>(VT_MEMBER_LIMIT, 10);
  }
  bool auto_grade_up() const {
    return GetField<uint8_t>(VT_AUTO_GRADE_UP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_POINT_RANK) &&
           VerifyField<int32_t>(verifier, VT_GOLD) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           VerifyOffset(verifier, VT_NOTICE) &&
           verifier.Verify(notice()) &&
           VerifyOffset(verifier, VT_CREATE_DATE) &&
           verifier.Verify(create_date()) &&
           VerifyField<int32_t>(verifier, VT_MEMBER_COUNT) &&
           VerifyField<int32_t>(verifier, VT_MEMBER_LIMIT) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_GRADE_UP) &&
           verifier.EndTable();
  }
  GUILD_INFOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_INFOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_INFO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_GUILD_ID, guild_id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GUILD_INFO::VT_NAME, name);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_LEVEL, level, 1);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_POINT, point, 0);
  }
  void add_point_rank(int32_t point_rank) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_POINT_RANK, point_rank, 0);
  }
  void add_gold(int32_t gold) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_GOLD, gold, 0);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(GUILD_INFO::VT_DESC, desc);
  }
  void add_notice(flatbuffers::Offset<flatbuffers::String> notice) {
    fbb_.AddOffset(GUILD_INFO::VT_NOTICE, notice);
  }
  void add_create_date(flatbuffers::Offset<flatbuffers::String> create_date) {
    fbb_.AddOffset(GUILD_INFO::VT_CREATE_DATE, create_date);
  }
  void add_member_count(int32_t member_count) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_MEMBER_COUNT, member_count, 0);
  }
  void add_member_limit(int32_t member_limit) {
    fbb_.AddElement<int32_t>(GUILD_INFO::VT_MEMBER_LIMIT, member_limit, 10);
  }
  void add_auto_grade_up(bool auto_grade_up) {
    fbb_.AddElement<uint8_t>(GUILD_INFO::VT_AUTO_GRADE_UP, static_cast<uint8_t>(auto_grade_up), 0);
  }
  explicit GUILD_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_INFOBuilder &operator=(const GUILD_INFOBuilder &);
  flatbuffers::Offset<GUILD_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_INFO> CreateGUILD_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guild_id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t level = 1,
    int32_t point = 0,
    int32_t point_rank = 0,
    int32_t gold = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::String> notice = 0,
    flatbuffers::Offset<flatbuffers::String> create_date = 0,
    int32_t member_count = 0,
    int32_t member_limit = 10,
    bool auto_grade_up = false) {
  GUILD_INFOBuilder builder_(_fbb);
  builder_.add_member_limit(member_limit);
  builder_.add_member_count(member_count);
  builder_.add_create_date(create_date);
  builder_.add_notice(notice);
  builder_.add_desc(desc);
  builder_.add_gold(gold);
  builder_.add_point_rank(point_rank);
  builder_.add_point(point);
  builder_.add_level(level);
  builder_.add_name(name);
  builder_.add_guild_id(guild_id);
  builder_.add_auto_grade_up(auto_grade_up);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_INFO> CreateGUILD_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t guild_id = 0,
    const char *name = nullptr,
    int32_t level = 1,
    int32_t point = 0,
    int32_t point_rank = 0,
    int32_t gold = 0,
    const char *desc = nullptr,
    const char *notice = nullptr,
    const char *create_date = nullptr,
    int32_t member_count = 0,
    int32_t member_limit = 10,
    bool auto_grade_up = false) {
  return OVERLORD::STRUCT::CreateGUILD_INFO(
      _fbb,
      guild_id,
      name ? _fbb.CreateString(name) : 0,
      level,
      point,
      point_rank,
      gold,
      desc ? _fbb.CreateString(desc) : 0,
      notice ? _fbb.CreateString(notice) : 0,
      create_date ? _fbb.CreateString(create_date) : 0,
      member_count,
      member_limit,
      auto_grade_up);
}

flatbuffers::Offset<GUILD_INFO> CreateGUILD_INFO(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBERT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER TableType;
  int32_t kId;
  int32_t guild_id;
  OVERLORD::ENUM::GUILD_GRADE grade;
  int32_t point;
  std::string join_date;
  std::string nick;
  int32_t level;
  int32_t last_update;
  GUILD_MEMBERT()
      : kId(0),
        guild_id(0),
        grade(OVERLORD::ENUM::GUILD_GRADE_NOTHING),
        point(0),
        level(0),
        last_update(0) {
  }
};

struct GUILD_MEMBER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_GUILD_ID = 6,
    VT_GRADE = 8,
    VT_POINT = 10,
    VT_JOIN_DATE = 12,
    VT_NICK = 14,
    VT_LEVEL = 16,
    VT_LAST_UPDATE = 18
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  OVERLORD::ENUM::GUILD_GRADE grade() const {
    return static_cast<OVERLORD::ENUM::GUILD_GRADE>(GetField<int8_t>(VT_GRADE, 0));
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  const flatbuffers::String *join_date() const {
    return GetPointer<const flatbuffers::String *>(VT_JOIN_DATE);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t last_update() const {
    return GetField<int32_t>(VT_LAST_UPDATE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyOffset(verifier, VT_JOIN_DATE) &&
           verifier.Verify(join_date()) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_LAST_UPDATE) &&
           verifier.EndTable();
  }
  GUILD_MEMBERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER::VT_KID, kId, 0);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER::VT_GUILD_ID, guild_id, 0);
  }
  void add_grade(OVERLORD::ENUM::GUILD_GRADE grade) {
    fbb_.AddElement<int8_t>(GUILD_MEMBER::VT_GRADE, static_cast<int8_t>(grade), 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER::VT_POINT, point, 0);
  }
  void add_join_date(flatbuffers::Offset<flatbuffers::String> join_date) {
    fbb_.AddOffset(GUILD_MEMBER::VT_JOIN_DATE, join_date);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(GUILD_MEMBER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER::VT_LEVEL, level, 0);
  }
  void add_last_update(int32_t last_update) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER::VT_LAST_UPDATE, last_update, 0);
  }
  explicit GUILD_MEMBERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBERBuilder &operator=(const GUILD_MEMBERBuilder &);
  flatbuffers::Offset<GUILD_MEMBER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER> CreateGUILD_MEMBER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t guild_id = 0,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    int32_t point = 0,
    flatbuffers::Offset<flatbuffers::String> join_date = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    int32_t last_update = 0) {
  GUILD_MEMBERBuilder builder_(_fbb);
  builder_.add_last_update(last_update);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_join_date(join_date);
  builder_.add_point(point);
  builder_.add_guild_id(guild_id);
  builder_.add_kId(kId);
  builder_.add_grade(grade);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_MEMBER> CreateGUILD_MEMBERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t guild_id = 0,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    int32_t point = 0,
    const char *join_date = nullptr,
    const char *nick = nullptr,
    int32_t level = 0,
    int32_t last_update = 0) {
  return OVERLORD::STRUCT::CreateGUILD_MEMBER(
      _fbb,
      kId,
      guild_id,
      grade,
      point,
      join_date ? _fbb.CreateString(join_date) : 0,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      last_update);
}

flatbuffers::Offset<GUILD_MEMBER> CreateGUILD_MEMBER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITERT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER TableType;
  int32_t kId;
  int32_t elapsedSec;
  std::string nick;
  int32_t level;
  GUILD_AWAITERT()
      : kId(0),
        elapsedSec(0),
        level(0) {
  }
};

struct GUILD_AWAITER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_ELAPSEDSEC = 6,
    VT_NICK = 8,
    VT_LEVEL = 10
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  int32_t elapsedSec() const {
    return GetField<int32_t>(VT_ELAPSEDSEC, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<int32_t>(verifier, VT_ELAPSEDSEC) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  GUILD_AWAITERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER::VT_KID, kId, 0);
  }
  void add_elapsedSec(int32_t elapsedSec) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER::VT_ELAPSEDSEC, elapsedSec, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(GUILD_AWAITER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER::VT_LEVEL, level, 0);
  }
  explicit GUILD_AWAITERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITERBuilder &operator=(const GUILD_AWAITERBuilder &);
  flatbuffers::Offset<GUILD_AWAITER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER> CreateGUILD_AWAITER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t elapsedSec = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0) {
  GUILD_AWAITERBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_elapsedSec(elapsedSec);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_AWAITER> CreateGUILD_AWAITERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t elapsedSec = 0,
    const char *nick = nullptr,
    int32_t level = 0) {
  return OVERLORD::STRUCT::CreateGUILD_AWAITER(
      _fbb,
      kId,
      elapsedSec,
      nick ? _fbb.CreateString(nick) : 0,
      level);
}

flatbuffers::Offset<GUILD_AWAITER> CreateGUILD_AWAITER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_HISTORYT : public flatbuffers::NativeTable {
  typedef GUILD_HISTORY TableType;
  OVERLORD::ENUM::GUILD_HISTORY_TYPE type;
  int32_t kId;
  std::string nick;
  int32_t target_kId;
  std::string target_nick;
  OVERLORD::ENUM::GUILD_GRADE grade;
  std::string time;
  GUILD_HISTORYT()
      : type(OVERLORD::ENUM::GUILD_HISTORY_TYPE_NOTHING),
        kId(0),
        target_kId(0),
        grade(OVERLORD::ENUM::GUILD_GRADE_NOTHING) {
  }
};

struct GUILD_HISTORY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_HISTORYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_KID = 6,
    VT_NICK = 8,
    VT_TARGET_KID = 10,
    VT_TARGET_NICK = 12,
    VT_GRADE = 14,
    VT_TIME = 16
  };
  OVERLORD::ENUM::GUILD_HISTORY_TYPE type() const {
    return static_cast<OVERLORD::ENUM::GUILD_HISTORY_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  const flatbuffers::String *target_nick() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGET_NICK);
  }
  OVERLORD::ENUM::GUILD_GRADE grade() const {
    return static_cast<OVERLORD::ENUM::GUILD_GRADE>(GetField<int8_t>(VT_GRADE, 0));
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           VerifyOffset(verifier, VT_TARGET_NICK) &&
           verifier.Verify(target_nick()) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           verifier.EndTable();
  }
  GUILD_HISTORYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_HISTORY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_HISTORYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(OVERLORD::ENUM::GUILD_HISTORY_TYPE type) {
    fbb_.AddElement<int8_t>(GUILD_HISTORY::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_HISTORY::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(GUILD_HISTORY::VT_NICK, nick);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_HISTORY::VT_TARGET_KID, target_kId, 0);
  }
  void add_target_nick(flatbuffers::Offset<flatbuffers::String> target_nick) {
    fbb_.AddOffset(GUILD_HISTORY::VT_TARGET_NICK, target_nick);
  }
  void add_grade(OVERLORD::ENUM::GUILD_GRADE grade) {
    fbb_.AddElement<int8_t>(GUILD_HISTORY::VT_GRADE, static_cast<int8_t>(grade), 0);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(GUILD_HISTORY::VT_TIME, time);
  }
  explicit GUILD_HISTORYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_HISTORYBuilder &operator=(const GUILD_HISTORYBuilder &);
  flatbuffers::Offset<GUILD_HISTORY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_HISTORY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::GUILD_HISTORY_TYPE type = OVERLORD::ENUM::GUILD_HISTORY_TYPE_NOTHING,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t target_kId = 0,
    flatbuffers::Offset<flatbuffers::String> target_nick = 0,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    flatbuffers::Offset<flatbuffers::String> time = 0) {
  GUILD_HISTORYBuilder builder_(_fbb);
  builder_.add_time(time);
  builder_.add_target_nick(target_nick);
  builder_.add_target_kId(target_kId);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_grade(grade);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::GUILD_HISTORY_TYPE type = OVERLORD::ENUM::GUILD_HISTORY_TYPE_NOTHING,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t target_kId = 0,
    const char *target_nick = nullptr,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    const char *time = nullptr) {
  return OVERLORD::STRUCT::CreateGUILD_HISTORY(
      _fbb,
      type,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      target_kId,
      target_nick ? _fbb.CreateString(target_nick) : 0,
      grade,
      time ? _fbb.CreateString(time) : 0);
}

flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RAID_CHALLENGET : public flatbuffers::NativeTable {
  typedef GUILD_RAID_CHALLENGE TableType;
  int32_t kId;
  std::string nick;
  int32_t trial;
  int32_t spawn;
  int32_t leftSec;
  GUILD_RAID_CHALLENGET()
      : kId(0),
        trial(0),
        spawn(0),
        leftSec(0) {
  }
};

struct GUILD_RAID_CHALLENGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RAID_CHALLENGET NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_TRIAL = 8,
    VT_SPAWN = 10,
    VT_LEFTSEC = 12
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t trial() const {
    return GetField<int32_t>(VT_TRIAL, 0);
  }
  int32_t spawn() const {
    return GetField<int32_t>(VT_SPAWN, 0);
  }
  int32_t leftSec() const {
    return GetField<int32_t>(VT_LEFTSEC, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_TRIAL) &&
           VerifyField<int32_t>(verifier, VT_SPAWN) &&
           VerifyField<int32_t>(verifier, VT_LEFTSEC) &&
           verifier.EndTable();
  }
  GUILD_RAID_CHALLENGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RAID_CHALLENGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RAID_CHALLENGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAID_CHALLENGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RAID_CHALLENGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_RAID_CHALLENGE::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(GUILD_RAID_CHALLENGE::VT_NICK, nick);
  }
  void add_trial(int32_t trial) {
    fbb_.AddElement<int32_t>(GUILD_RAID_CHALLENGE::VT_TRIAL, trial, 0);
  }
  void add_spawn(int32_t spawn) {
    fbb_.AddElement<int32_t>(GUILD_RAID_CHALLENGE::VT_SPAWN, spawn, 0);
  }
  void add_leftSec(int32_t leftSec) {
    fbb_.AddElement<int32_t>(GUILD_RAID_CHALLENGE::VT_LEFTSEC, leftSec, 0);
  }
  explicit GUILD_RAID_CHALLENGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RAID_CHALLENGEBuilder &operator=(const GUILD_RAID_CHALLENGEBuilder &);
  flatbuffers::Offset<GUILD_RAID_CHALLENGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RAID_CHALLENGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RAID_CHALLENGE> CreateGUILD_RAID_CHALLENGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t trial = 0,
    int32_t spawn = 0,
    int32_t leftSec = 0) {
  GUILD_RAID_CHALLENGEBuilder builder_(_fbb);
  builder_.add_leftSec(leftSec);
  builder_.add_spawn(spawn);
  builder_.add_trial(trial);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RAID_CHALLENGE> CreateGUILD_RAID_CHALLENGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t trial = 0,
    int32_t spawn = 0,
    int32_t leftSec = 0) {
  return OVERLORD::STRUCT::CreateGUILD_RAID_CHALLENGE(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      trial,
      spawn,
      leftSec);
}

flatbuffers::Offset<GUILD_RAID_CHALLENGE> CreateGUILD_RAID_CHALLENGE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAID_CHALLENGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RAIDT : public flatbuffers::NativeTable {
  typedef GUILD_RAID TableType;
  std::string modId;
  int32_t grade;
  bool isOpen;
  int32_t left;
  std::string captain;
  int32_t members;
  std::vector<std::string> boss;
  GUILD_RAIDT()
      : grade(0),
        isOpen(false),
        left(-1),
        members(0) {
  }
};

struct GUILD_RAID FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RAIDT NativeTableType;
  enum {
    VT_MODID = 4,
    VT_GRADE = 6,
    VT_ISOPEN = 8,
    VT_LEFT = 10,
    VT_CAPTAIN = 12,
    VT_MEMBERS = 14,
    VT_BOSS = 16
  };
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  int32_t grade() const {
    return GetField<int32_t>(VT_GRADE, 0);
  }
  bool isOpen() const {
    return GetField<uint8_t>(VT_ISOPEN, 0) != 0;
  }
  int32_t left() const {
    return GetField<int32_t>(VT_LEFT, -1);
  }
  const flatbuffers::String *captain() const {
    return GetPointer<const flatbuffers::String *>(VT_CAPTAIN);
  }
  int32_t members() const {
    return GetField<int32_t>(VT_MEMBERS, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *boss() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_BOSS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyField<int32_t>(verifier, VT_GRADE) &&
           VerifyField<uint8_t>(verifier, VT_ISOPEN) &&
           VerifyField<int32_t>(verifier, VT_LEFT) &&
           VerifyOffset(verifier, VT_CAPTAIN) &&
           verifier.Verify(captain()) &&
           VerifyField<int32_t>(verifier, VT_MEMBERS) &&
           VerifyOffset(verifier, VT_BOSS) &&
           verifier.Verify(boss()) &&
           verifier.VerifyVectorOfStrings(boss()) &&
           verifier.EndTable();
  }
  GUILD_RAIDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RAIDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RAID> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAIDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RAIDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(GUILD_RAID::VT_MODID, modId);
  }
  void add_grade(int32_t grade) {
    fbb_.AddElement<int32_t>(GUILD_RAID::VT_GRADE, grade, 0);
  }
  void add_isOpen(bool isOpen) {
    fbb_.AddElement<uint8_t>(GUILD_RAID::VT_ISOPEN, static_cast<uint8_t>(isOpen), 0);
  }
  void add_left(int32_t left) {
    fbb_.AddElement<int32_t>(GUILD_RAID::VT_LEFT, left, -1);
  }
  void add_captain(flatbuffers::Offset<flatbuffers::String> captain) {
    fbb_.AddOffset(GUILD_RAID::VT_CAPTAIN, captain);
  }
  void add_members(int32_t members) {
    fbb_.AddElement<int32_t>(GUILD_RAID::VT_MEMBERS, members, 0);
  }
  void add_boss(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> boss) {
    fbb_.AddOffset(GUILD_RAID::VT_BOSS, boss);
  }
  explicit GUILD_RAIDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RAIDBuilder &operator=(const GUILD_RAIDBuilder &);
  flatbuffers::Offset<GUILD_RAID> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RAID>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RAID> CreateGUILD_RAID(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    int32_t grade = 0,
    bool isOpen = false,
    int32_t left = -1,
    flatbuffers::Offset<flatbuffers::String> captain = 0,
    int32_t members = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> boss = 0) {
  GUILD_RAIDBuilder builder_(_fbb);
  builder_.add_boss(boss);
  builder_.add_members(members);
  builder_.add_captain(captain);
  builder_.add_left(left);
  builder_.add_grade(grade);
  builder_.add_modId(modId);
  builder_.add_isOpen(isOpen);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RAID> CreateGUILD_RAIDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *modId = nullptr,
    int32_t grade = 0,
    bool isOpen = false,
    int32_t left = -1,
    const char *captain = nullptr,
    int32_t members = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *boss = nullptr) {
  return OVERLORD::STRUCT::CreateGUILD_RAID(
      _fbb,
      modId ? _fbb.CreateString(modId) : 0,
      grade,
      isOpen,
      left,
      captain ? _fbb.CreateString(captain) : 0,
      members,
      boss ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*boss) : 0);
}

flatbuffers::Offset<GUILD_RAID> CreateGUILD_RAID(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAIDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MINET : public flatbuffers::NativeTable {
  typedef GUILD_MINE TableType;
  std::unique_ptr<GUILD_INFOT> guild_info;
  std::unique_ptr<GUILD_MEMBERT> guild_member;
  std::unique_ptr<GUILD_MEMBERT> guild_master;
  bool guild_exist;
  bool isActiveAttendance;
  bool isActiveContribute;
  GUILD_MINET()
      : guild_exist(false),
        isActiveAttendance(false),
        isActiveContribute(false) {
  }
};

struct GUILD_MINE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MINET NativeTableType;
  enum {
    VT_GUILD_INFO = 4,
    VT_GUILD_MEMBER = 6,
    VT_GUILD_MASTER = 8,
    VT_GUILD_EXIST = 10,
    VT_ISACTIVEATTENDANCE = 12,
    VT_ISACTIVECONTRIBUTE = 14
  };
  const GUILD_INFO *guild_info() const {
    return GetPointer<const GUILD_INFO *>(VT_GUILD_INFO);
  }
  const GUILD_MEMBER *guild_member() const {
    return GetPointer<const GUILD_MEMBER *>(VT_GUILD_MEMBER);
  }
  const GUILD_MEMBER *guild_master() const {
    return GetPointer<const GUILD_MEMBER *>(VT_GUILD_MASTER);
  }
  bool guild_exist() const {
    return GetField<uint8_t>(VT_GUILD_EXIST, 0) != 0;
  }
  bool isActiveAttendance() const {
    return GetField<uint8_t>(VT_ISACTIVEATTENDANCE, 0) != 0;
  }
  bool isActiveContribute() const {
    return GetField<uint8_t>(VT_ISACTIVECONTRIBUTE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           VerifyOffset(verifier, VT_GUILD_MEMBER) &&
           verifier.VerifyTable(guild_member()) &&
           VerifyOffset(verifier, VT_GUILD_MASTER) &&
           verifier.VerifyTable(guild_master()) &&
           VerifyField<uint8_t>(verifier, VT_GUILD_EXIST) &&
           VerifyField<uint8_t>(verifier, VT_ISACTIVEATTENDANCE) &&
           VerifyField<uint8_t>(verifier, VT_ISACTIVECONTRIBUTE) &&
           verifier.EndTable();
  }
  GUILD_MINET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MINET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MINE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MINET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MINEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_guild_info(flatbuffers::Offset<GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_MINE::VT_GUILD_INFO, guild_info);
  }
  void add_guild_member(flatbuffers::Offset<GUILD_MEMBER> guild_member) {
    fbb_.AddOffset(GUILD_MINE::VT_GUILD_MEMBER, guild_member);
  }
  void add_guild_master(flatbuffers::Offset<GUILD_MEMBER> guild_master) {
    fbb_.AddOffset(GUILD_MINE::VT_GUILD_MASTER, guild_master);
  }
  void add_guild_exist(bool guild_exist) {
    fbb_.AddElement<uint8_t>(GUILD_MINE::VT_GUILD_EXIST, static_cast<uint8_t>(guild_exist), 0);
  }
  void add_isActiveAttendance(bool isActiveAttendance) {
    fbb_.AddElement<uint8_t>(GUILD_MINE::VT_ISACTIVEATTENDANCE, static_cast<uint8_t>(isActiveAttendance), 0);
  }
  void add_isActiveContribute(bool isActiveContribute) {
    fbb_.AddElement<uint8_t>(GUILD_MINE::VT_ISACTIVECONTRIBUTE, static_cast<uint8_t>(isActiveContribute), 0);
  }
  explicit GUILD_MINEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MINEBuilder &operator=(const GUILD_MINEBuilder &);
  flatbuffers::Offset<GUILD_MINE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MINE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MINE> CreateGUILD_MINE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<GUILD_INFO> guild_info = 0,
    flatbuffers::Offset<GUILD_MEMBER> guild_member = 0,
    flatbuffers::Offset<GUILD_MEMBER> guild_master = 0,
    bool guild_exist = false,
    bool isActiveAttendance = false,
    bool isActiveContribute = false) {
  GUILD_MINEBuilder builder_(_fbb);
  builder_.add_guild_master(guild_master);
  builder_.add_guild_member(guild_member);
  builder_.add_guild_info(guild_info);
  builder_.add_isActiveContribute(isActiveContribute);
  builder_.add_isActiveAttendance(isActiveAttendance);
  builder_.add_guild_exist(guild_exist);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_MINE> CreateGUILD_MINE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MINET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_EVENTT : public flatbuffers::NativeTable {
  typedef CHANNEL_EVENT TableType;
  OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType;
  int32_t value;
  std::string open;
  std::string close;
  CHANNEL_EVENTT()
      : eventType(OVERLORD::ENUM::CHANNEL_EVENT_TYPE_NOTHING),
        value(0) {
  }
};

struct CHANNEL_EVENT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_EVENTT NativeTableType;
  enum {
    VT_EVENTTYPE = 4,
    VT_VALUE = 6,
    VT_OPEN = 8,
    VT_CLOSE = 10
  };
  OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType() const {
    return static_cast<OVERLORD::ENUM::CHANNEL_EVENT_TYPE>(GetField<int8_t>(VT_EVENTTYPE, 0));
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  const flatbuffers::String *open() const {
    return GetPointer<const flatbuffers::String *>(VT_OPEN);
  }
  const flatbuffers::String *close() const {
    return GetPointer<const flatbuffers::String *>(VT_CLOSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_EVENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyOffset(verifier, VT_OPEN) &&
           verifier.Verify(open()) &&
           VerifyOffset(verifier, VT_CLOSE) &&
           verifier.Verify(close()) &&
           verifier.EndTable();
  }
  CHANNEL_EVENTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_EVENT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_EVENTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType) {
    fbb_.AddElement<int8_t>(CHANNEL_EVENT::VT_EVENTTYPE, static_cast<int8_t>(eventType), 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CHANNEL_EVENT::VT_VALUE, value, 0);
  }
  void add_open(flatbuffers::Offset<flatbuffers::String> open) {
    fbb_.AddOffset(CHANNEL_EVENT::VT_OPEN, open);
  }
  void add_close(flatbuffers::Offset<flatbuffers::String> close) {
    fbb_.AddOffset(CHANNEL_EVENT::VT_CLOSE, close);
  }
  explicit CHANNEL_EVENTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_EVENTBuilder &operator=(const CHANNEL_EVENTBuilder &);
  flatbuffers::Offset<CHANNEL_EVENT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_EVENT>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_EVENT> CreateCHANNEL_EVENT(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType = OVERLORD::ENUM::CHANNEL_EVENT_TYPE_NOTHING,
    int32_t value = 0,
    flatbuffers::Offset<flatbuffers::String> open = 0,
    flatbuffers::Offset<flatbuffers::String> close = 0) {
  CHANNEL_EVENTBuilder builder_(_fbb);
  builder_.add_close(close);
  builder_.add_open(open);
  builder_.add_value(value);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_EVENT> CreateCHANNEL_EVENTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType = OVERLORD::ENUM::CHANNEL_EVENT_TYPE_NOTHING,
    int32_t value = 0,
    const char *open = nullptr,
    const char *close = nullptr) {
  return OVERLORD::STRUCT::CreateCHANNEL_EVENT(
      _fbb,
      eventType,
      value,
      open ? _fbb.CreateString(open) : 0,
      close ? _fbb.CreateString(close) : 0);
}

flatbuffers::Offset<CHANNEL_EVENT> CreateCHANNEL_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_FEATURET : public flatbuffers::NativeTable {
  typedef CHANNEL_FEATURE TableType;
  OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType;
  int32_t value;
  CHANNEL_FEATURET()
      : eventType(OVERLORD::ENUM::CHANNEL_EVENT_TYPE_NOTHING),
        value(0) {
  }
};

struct CHANNEL_FEATURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_FEATURET NativeTableType;
  enum {
    VT_EVENTTYPE = 4,
    VT_VALUE = 6
  };
  OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType() const {
    return static_cast<OVERLORD::ENUM::CHANNEL_EVENT_TYPE>(GetField<int8_t>(VT_EVENTTYPE, 0));
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_EVENTTYPE) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  CHANNEL_FEATURET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_FEATURET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_FEATURE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_FEATURET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_FEATUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eventType(OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType) {
    fbb_.AddElement<int8_t>(CHANNEL_FEATURE::VT_EVENTTYPE, static_cast<int8_t>(eventType), 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CHANNEL_FEATURE::VT_VALUE, value, 0);
  }
  explicit CHANNEL_FEATUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_FEATUREBuilder &operator=(const CHANNEL_FEATUREBuilder &);
  flatbuffers::Offset<CHANNEL_FEATURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_FEATURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_FEATURE> CreateCHANNEL_FEATURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    OVERLORD::ENUM::CHANNEL_EVENT_TYPE eventType = OVERLORD::ENUM::CHANNEL_EVENT_TYPE_NOTHING,
    int32_t value = 0) {
  CHANNEL_FEATUREBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_eventType(eventType);
  return builder_.Finish();
}

flatbuffers::Offset<CHANNEL_FEATURE> CreateCHANNEL_FEATURE(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_FEATURET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_GUILDT : public flatbuffers::NativeTable {
  typedef CHANNEL_GUILD TableType;
  std::string name;
  int32_t count;
  CHANNEL_GUILDT()
      : count(0) {
  }
};

struct CHANNEL_GUILD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_GUILDT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_COUNT = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  CHANNEL_GUILDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_GUILDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_GUILD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_GUILDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_GUILDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CHANNEL_GUILD::VT_NAME, name);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(CHANNEL_GUILD::VT_COUNT, count, 0);
  }
  explicit CHANNEL_GUILDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_GUILDBuilder &operator=(const CHANNEL_GUILDBuilder &);
  flatbuffers::Offset<CHANNEL_GUILD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_GUILD>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_GUILD> CreateCHANNEL_GUILD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t count = 0) {
  CHANNEL_GUILDBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_GUILD> CreateCHANNEL_GUILDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t count = 0) {
  return OVERLORD::STRUCT::CreateCHANNEL_GUILD(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      count);
}

flatbuffers::Offset<CHANNEL_GUILD> CreateCHANNEL_GUILD(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_GUILDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_DETAILT : public flatbuffers::NativeTable {
  typedef CHANNEL_DETAIL TableType;
  int32_t limit_lv;
  bool guild_only;
  std::string owner_guild;
  int32_t count_current;
  int32_t count_max;
  std::vector<std::unique_ptr<CHANNEL_GUILDT>> guildList;
  std::string desc;
  std::vector<std::unique_ptr<CHANNEL_FEATURET>> feature;
  std::vector<std::unique_ptr<CHANNEL_EVENTT>> event;
  std::string map_name;
  CHANNEL_DETAILT()
      : limit_lv(0),
        guild_only(false),
        count_current(0),
        count_max(50) {
  }
};

struct CHANNEL_DETAIL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_DETAILT NativeTableType;
  enum {
    VT_LIMIT_LV = 4,
    VT_GUILD_ONLY = 6,
    VT_OWNER_GUILD = 8,
    VT_COUNT_CURRENT = 10,
    VT_COUNT_MAX = 12,
    VT_GUILDLIST = 14,
    VT_DESC = 16,
    VT_FEATURE = 18,
    VT_EVENT = 20,
    VT_MAP_NAME = 22
  };
  int32_t limit_lv() const {
    return GetField<int32_t>(VT_LIMIT_LV, 0);
  }
  bool guild_only() const {
    return GetField<uint8_t>(VT_GUILD_ONLY, 0) != 0;
  }
  const flatbuffers::String *owner_guild() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNER_GUILD);
  }
  int32_t count_current() const {
    return GetField<int32_t>(VT_COUNT_CURRENT, 0);
  }
  int32_t count_max() const {
    return GetField<int32_t>(VT_COUNT_MAX, 50);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_GUILD>> *guildList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_GUILD>> *>(VT_GUILDLIST);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_FEATURE>> *feature() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_FEATURE>> *>(VT_FEATURE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>> *event() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>> *>(VT_EVENT);
  }
  const flatbuffers::String *map_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MAP_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LIMIT_LV) &&
           VerifyField<uint8_t>(verifier, VT_GUILD_ONLY) &&
           VerifyOffset(verifier, VT_OWNER_GUILD) &&
           verifier.Verify(owner_guild()) &&
           VerifyField<int32_t>(verifier, VT_COUNT_CURRENT) &&
           VerifyField<int32_t>(verifier, VT_COUNT_MAX) &&
           VerifyOffset(verifier, VT_GUILDLIST) &&
           verifier.Verify(guildList()) &&
           verifier.VerifyVectorOfTables(guildList()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           VerifyOffset(verifier, VT_FEATURE) &&
           verifier.Verify(feature()) &&
           verifier.VerifyVectorOfTables(feature()) &&
           VerifyOffset(verifier, VT_EVENT) &&
           verifier.Verify(event()) &&
           verifier.VerifyVectorOfTables(event()) &&
           VerifyOffset(verifier, VT_MAP_NAME) &&
           verifier.Verify(map_name()) &&
           verifier.EndTable();
  }
  CHANNEL_DETAILT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_DETAILT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_DETAIL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_DETAILBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_limit_lv(int32_t limit_lv) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL::VT_LIMIT_LV, limit_lv, 0);
  }
  void add_guild_only(bool guild_only) {
    fbb_.AddElement<uint8_t>(CHANNEL_DETAIL::VT_GUILD_ONLY, static_cast<uint8_t>(guild_only), 0);
  }
  void add_owner_guild(flatbuffers::Offset<flatbuffers::String> owner_guild) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_OWNER_GUILD, owner_guild);
  }
  void add_count_current(int32_t count_current) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL::VT_COUNT_CURRENT, count_current, 0);
  }
  void add_count_max(int32_t count_max) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL::VT_COUNT_MAX, count_max, 50);
  }
  void add_guildList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_GUILD>>> guildList) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_GUILDLIST, guildList);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_DESC, desc);
  }
  void add_feature(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_FEATURE>>> feature) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_FEATURE, feature);
  }
  void add_event(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>>> event) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_EVENT, event);
  }
  void add_map_name(flatbuffers::Offset<flatbuffers::String> map_name) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_MAP_NAME, map_name);
  }
  explicit CHANNEL_DETAILBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_DETAILBuilder &operator=(const CHANNEL_DETAILBuilder &);
  flatbuffers::Offset<CHANNEL_DETAIL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_DETAIL>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t limit_lv = 0,
    bool guild_only = false,
    flatbuffers::Offset<flatbuffers::String> owner_guild = 0,
    int32_t count_current = 0,
    int32_t count_max = 50,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_GUILD>>> guildList = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_FEATURE>>> feature = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>>> event = 0,
    flatbuffers::Offset<flatbuffers::String> map_name = 0) {
  CHANNEL_DETAILBuilder builder_(_fbb);
  builder_.add_map_name(map_name);
  builder_.add_event(event);
  builder_.add_feature(feature);
  builder_.add_desc(desc);
  builder_.add_guildList(guildList);
  builder_.add_count_max(count_max);
  builder_.add_count_current(count_current);
  builder_.add_owner_guild(owner_guild);
  builder_.add_limit_lv(limit_lv);
  builder_.add_guild_only(guild_only);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAILDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t limit_lv = 0,
    bool guild_only = false,
    const char *owner_guild = nullptr,
    int32_t count_current = 0,
    int32_t count_max = 50,
    const std::vector<flatbuffers::Offset<CHANNEL_GUILD>> *guildList = nullptr,
    const char *desc = nullptr,
    const std::vector<flatbuffers::Offset<CHANNEL_FEATURE>> *feature = nullptr,
    const std::vector<flatbuffers::Offset<CHANNEL_EVENT>> *event = nullptr,
    const char *map_name = nullptr) {
  return OVERLORD::STRUCT::CreateCHANNEL_DETAIL(
      _fbb,
      limit_lv,
      guild_only,
      owner_guild ? _fbb.CreateString(owner_guild) : 0,
      count_current,
      count_max,
      guildList ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_GUILD>>(*guildList) : 0,
      desc ? _fbb.CreateString(desc) : 0,
      feature ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_FEATURE>>(*feature) : 0,
      event ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_EVENT>>(*event) : 0,
      map_name ? _fbb.CreateString(map_name) : 0);
}

flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_INFOT : public flatbuffers::NativeTable {
  typedef CHANNEL_INFO TableType;
  int32_t no;
  std::string ip;
  int32_t port;
  int32_t enter_current;
  int32_t enter_max;
  std::string owner_guild_name;
  std::vector<std::unique_ptr<CHANNEL_EVENTT>> event_current;
  CHANNEL_INFOT()
      : no(0),
        port(0),
        enter_current(0),
        enter_max(50) {
  }
};

struct CHANNEL_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_INFOT NativeTableType;
  enum {
    VT_NO = 4,
    VT_IP = 6,
    VT_PORT = 8,
    VT_ENTER_CURRENT = 10,
    VT_ENTER_MAX = 12,
    VT_OWNER_GUILD_NAME = 14,
    VT_EVENT_CURRENT = 16
  };
  int32_t no() const {
    return GetField<int32_t>(VT_NO, 0);
  }
  const flatbuffers::String *ip() const {
    return GetPointer<const flatbuffers::String *>(VT_IP);
  }
  int32_t port() const {
    return GetField<int32_t>(VT_PORT, 0);
  }
  int32_t enter_current() const {
    return GetField<int32_t>(VT_ENTER_CURRENT, 0);
  }
  int32_t enter_max() const {
    return GetField<int32_t>(VT_ENTER_MAX, 50);
  }
  const flatbuffers::String *owner_guild_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNER_GUILD_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>> *event_current() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>> *>(VT_EVENT_CURRENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NO) &&
           VerifyOffset(verifier, VT_IP) &&
           verifier.Verify(ip()) &&
           VerifyField<int32_t>(verifier, VT_PORT) &&
           VerifyField<int32_t>(verifier, VT_ENTER_CURRENT) &&
           VerifyField<int32_t>(verifier, VT_ENTER_MAX) &&
           VerifyOffset(verifier, VT_OWNER_GUILD_NAME) &&
           verifier.Verify(owner_guild_name()) &&
           VerifyOffset(verifier, VT_EVENT_CURRENT) &&
           verifier.Verify(event_current()) &&
           verifier.VerifyVectorOfTables(event_current()) &&
           verifier.EndTable();
  }
  CHANNEL_INFOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_INFOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_INFO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_no(int32_t no) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO::VT_NO, no, 0);
  }
  void add_ip(flatbuffers::Offset<flatbuffers::String> ip) {
    fbb_.AddOffset(CHANNEL_INFO::VT_IP, ip);
  }
  void add_port(int32_t port) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO::VT_PORT, port, 0);
  }
  void add_enter_current(int32_t enter_current) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO::VT_ENTER_CURRENT, enter_current, 0);
  }
  void add_enter_max(int32_t enter_max) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO::VT_ENTER_MAX, enter_max, 50);
  }
  void add_owner_guild_name(flatbuffers::Offset<flatbuffers::String> owner_guild_name) {
    fbb_.AddOffset(CHANNEL_INFO::VT_OWNER_GUILD_NAME, owner_guild_name);
  }
  void add_event_current(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>>> event_current) {
    fbb_.AddOffset(CHANNEL_INFO::VT_EVENT_CURRENT, event_current);
  }
  explicit CHANNEL_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_INFOBuilder &operator=(const CHANNEL_INFOBuilder &);
  flatbuffers::Offset<CHANNEL_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_INFO> CreateCHANNEL_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t no = 0,
    flatbuffers::Offset<flatbuffers::String> ip = 0,
    int32_t port = 0,
    int32_t enter_current = 0,
    int32_t enter_max = 50,
    flatbuffers::Offset<flatbuffers::String> owner_guild_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CHANNEL_EVENT>>> event_current = 0) {
  CHANNEL_INFOBuilder builder_(_fbb);
  builder_.add_event_current(event_current);
  builder_.add_owner_guild_name(owner_guild_name);
  builder_.add_enter_max(enter_max);
  builder_.add_enter_current(enter_current);
  builder_.add_port(port);
  builder_.add_ip(ip);
  builder_.add_no(no);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_INFO> CreateCHANNEL_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t no = 0,
    const char *ip = nullptr,
    int32_t port = 0,
    int32_t enter_current = 0,
    int32_t enter_max = 50,
    const char *owner_guild_name = nullptr,
    const std::vector<flatbuffers::Offset<CHANNEL_EVENT>> *event_current = nullptr) {
  return OVERLORD::STRUCT::CreateCHANNEL_INFO(
      _fbb,
      no,
      ip ? _fbb.CreateString(ip) : 0,
      port,
      enter_current,
      enter_max,
      owner_guild_name ? _fbb.CreateString(owner_guild_name) : 0,
      event_current ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_EVENT>>(*event_current) : 0);
}

flatbuffers::Offset<CHANNEL_INFO> CreateCHANNEL_INFO(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PLAY_CLEAR_GRADE_STATUST : public flatbuffers::NativeTable {
  typedef PLAY_CLEAR_GRADE_STATUS TableType;
  std::string stageId;
  int32_t clearGrade;
  PLAY_CLEAR_GRADE_STATUST()
      : clearGrade(0) {
  }
};

struct PLAY_CLEAR_GRADE_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PLAY_CLEAR_GRADE_STATUST NativeTableType;
  enum {
    VT_STAGEID = 4,
    VT_CLEARGRADE = 6
  };
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  int32_t clearGrade() const {
    return GetField<int32_t>(VT_CLEARGRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           VerifyField<int32_t>(verifier, VT_CLEARGRADE) &&
           verifier.EndTable();
  }
  PLAY_CLEAR_GRADE_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PLAY_CLEAR_GRADE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_CLEAR_GRADE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PLAY_CLEAR_GRADE_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(PLAY_CLEAR_GRADE_STATUS::VT_STAGEID, stageId);
  }
  void add_clearGrade(int32_t clearGrade) {
    fbb_.AddElement<int32_t>(PLAY_CLEAR_GRADE_STATUS::VT_CLEARGRADE, clearGrade, 0);
  }
  explicit PLAY_CLEAR_GRADE_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PLAY_CLEAR_GRADE_STATUSBuilder &operator=(const PLAY_CLEAR_GRADE_STATUSBuilder &);
  flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> CreatePLAY_CLEAR_GRADE_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> stageId = 0,
    int32_t clearGrade = 0) {
  PLAY_CLEAR_GRADE_STATUSBuilder builder_(_fbb);
  builder_.add_clearGrade(clearGrade);
  builder_.add_stageId(stageId);
  return builder_.Finish();
}

inline flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> CreatePLAY_CLEAR_GRADE_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *stageId = nullptr,
    int32_t clearGrade = 0) {
  return OVERLORD::STRUCT::CreatePLAY_CLEAR_GRADE_STATUS(
      _fbb,
      stageId ? _fbb.CreateString(stageId) : 0,
      clearGrade);
}

flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> CreatePLAY_CLEAR_GRADE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_CLEAR_GRADE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_REQUESTERT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_REQUESTER TableType;
  int32_t kId;
  std::string nick;
  int32_t timeLeft;
  OVERLORD::ENUM::GUILD_GRADE grade;
  std::string heroId;
  int32_t maxAmount;
  int32_t currentAmount;
  bool gettable;
  GUILD_RUNE_REQUESTERT()
      : kId(0),
        timeLeft(0),
        grade(OVERLORD::ENUM::GUILD_GRADE_NOTHING),
        maxAmount(2),
        currentAmount(0),
        gettable(false) {
  }
};

struct GUILD_RUNE_REQUESTER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_REQUESTERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_TIMELEFT = 8,
    VT_GRADE = 10,
    VT_HEROID = 12,
    VT_MAXAMOUNT = 14,
    VT_CURRENTAMOUNT = 16,
    VT_GETTABLE = 18
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t timeLeft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  OVERLORD::ENUM::GUILD_GRADE grade() const {
    return static_cast<OVERLORD::ENUM::GUILD_GRADE>(GetField<int8_t>(VT_GRADE, 0));
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t maxAmount() const {
    return GetField<int32_t>(VT_MAXAMOUNT, 2);
  }
  int32_t currentAmount() const {
    return GetField<int32_t>(VT_CURRENTAMOUNT, 0);
  }
  bool gettable() const {
    return GetField<uint8_t>(VT_GETTABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           VerifyField<int8_t>(verifier, VT_GRADE) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_MAXAMOUNT) &&
           VerifyField<int32_t>(verifier, VT_CURRENTAMOUNT) &&
           VerifyField<uint8_t>(verifier, VT_GETTABLE) &&
           verifier.EndTable();
  }
  GUILD_RUNE_REQUESTERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_REQUESTERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_REQUESTER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_REQUESTERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUESTER::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(GUILD_RUNE_REQUESTER::VT_NICK, nick);
  }
  void add_timeLeft(int32_t timeLeft) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUESTER::VT_TIMELEFT, timeLeft, 0);
  }
  void add_grade(OVERLORD::ENUM::GUILD_GRADE grade) {
    fbb_.AddElement<int8_t>(GUILD_RUNE_REQUESTER::VT_GRADE, static_cast<int8_t>(grade), 0);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(GUILD_RUNE_REQUESTER::VT_HEROID, heroId);
  }
  void add_maxAmount(int32_t maxAmount) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUESTER::VT_MAXAMOUNT, maxAmount, 2);
  }
  void add_currentAmount(int32_t currentAmount) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUESTER::VT_CURRENTAMOUNT, currentAmount, 0);
  }
  void add_gettable(bool gettable) {
    fbb_.AddElement<uint8_t>(GUILD_RUNE_REQUESTER::VT_GETTABLE, static_cast<uint8_t>(gettable), 0);
  }
  explicit GUILD_RUNE_REQUESTERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_REQUESTERBuilder &operator=(const GUILD_RUNE_REQUESTERBuilder &);
  flatbuffers::Offset<GUILD_RUNE_REQUESTER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_REQUESTER>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_REQUESTER> CreateGUILD_RUNE_REQUESTER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t timeLeft = 0,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t maxAmount = 2,
    int32_t currentAmount = 0,
    bool gettable = false) {
  GUILD_RUNE_REQUESTERBuilder builder_(_fbb);
  builder_.add_currentAmount(currentAmount);
  builder_.add_maxAmount(maxAmount);
  builder_.add_heroId(heroId);
  builder_.add_timeLeft(timeLeft);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_gettable(gettable);
  builder_.add_grade(grade);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_REQUESTER> CreateGUILD_RUNE_REQUESTERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t timeLeft = 0,
    OVERLORD::ENUM::GUILD_GRADE grade = OVERLORD::ENUM::GUILD_GRADE_NOTHING,
    const char *heroId = nullptr,
    int32_t maxAmount = 2,
    int32_t currentAmount = 0,
    bool gettable = false) {
  return OVERLORD::STRUCT::CreateGUILD_RUNE_REQUESTER(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      timeLeft,
      grade,
      heroId ? _fbb.CreateString(heroId) : 0,
      maxAmount,
      currentAmount,
      gettable);
}

flatbuffers::Offset<GUILD_RUNE_REQUESTER> CreateGUILD_RUNE_REQUESTER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CAMPAIGN_QUEST_STATUST : public flatbuffers::NativeTable {
  typedef CAMPAIGN_QUEST_STATUS TableType;
  std::string questId;
  std::string stageId;
  int32_t value;
  int32_t trial;
  CAMPAIGN_QUEST_STATUST()
      : value(0),
        trial(0) {
  }
};

struct CAMPAIGN_QUEST_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CAMPAIGN_QUEST_STATUST NativeTableType;
  enum {
    VT_QUESTID = 4,
    VT_STAGEID = 6,
    VT_VALUE = 8,
    VT_TRIAL = 10
  };
  const flatbuffers::String *questId() const {
    return GetPointer<const flatbuffers::String *>(VT_QUESTID);
  }
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t trial() const {
    return GetField<int32_t>(VT_TRIAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QUESTID) &&
           verifier.Verify(questId()) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<int32_t>(verifier, VT_TRIAL) &&
           verifier.EndTable();
  }
  CAMPAIGN_QUEST_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CAMPAIGN_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CAMPAIGN_QUEST_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(flatbuffers::Offset<flatbuffers::String> questId) {
    fbb_.AddOffset(CAMPAIGN_QUEST_STATUS::VT_QUESTID, questId);
  }
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(CAMPAIGN_QUEST_STATUS::VT_STAGEID, stageId);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(CAMPAIGN_QUEST_STATUS::VT_VALUE, value, 0);
  }
  void add_trial(int32_t trial) {
    fbb_.AddElement<int32_t>(CAMPAIGN_QUEST_STATUS::VT_TRIAL, trial, 0);
  }
  explicit CAMPAIGN_QUEST_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CAMPAIGN_QUEST_STATUSBuilder &operator=(const CAMPAIGN_QUEST_STATUSBuilder &);
  flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> CreateCAMPAIGN_QUEST_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> questId = 0,
    flatbuffers::Offset<flatbuffers::String> stageId = 0,
    int32_t value = 0,
    int32_t trial = 0) {
  CAMPAIGN_QUEST_STATUSBuilder builder_(_fbb);
  builder_.add_trial(trial);
  builder_.add_value(value);
  builder_.add_stageId(stageId);
  builder_.add_questId(questId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> CreateCAMPAIGN_QUEST_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *questId = nullptr,
    const char *stageId = nullptr,
    int32_t value = 0,
    int32_t trial = 0) {
  return OVERLORD::STRUCT::CreateCAMPAIGN_QUEST_STATUS(
      _fbb,
      questId ? _fbb.CreateString(questId) : 0,
      stageId ? _fbb.CreateString(stageId) : 0,
      value,
      trial);
}

flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> CreateCAMPAIGN_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CAMPAIGN_QUESTT : public flatbuffers::NativeTable {
  typedef CAMPAIGN_QUEST TableType;
  std::vector<std::unique_ptr<CAMPAIGN_QUEST_STATUST>> list;
  OVERLORD::ENUM::REWARDABLE_STATUS rewardable;
  std::string rewardKey;
  CAMPAIGN_QUESTT()
      : rewardable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  }
};

struct CAMPAIGN_QUEST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CAMPAIGN_QUESTT NativeTableType;
  enum {
    VT_LIST = 4,
    VT_REWARDABLE = 6,
    VT_REWARDKEY = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>> *list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>> *>(VT_LIST);
  }
  OVERLORD::ENUM::REWARDABLE_STATUS rewardable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_REWARDABLE, 0));
  }
  const flatbuffers::String *rewardKey() const {
    return GetPointer<const flatbuffers::String *>(VT_REWARDKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.VerifyVectorOfTables(list()) &&
           VerifyField<int8_t>(verifier, VT_REWARDABLE) &&
           VerifyOffset(verifier, VT_REWARDKEY) &&
           verifier.Verify(rewardKey()) &&
           verifier.EndTable();
  }
  CAMPAIGN_QUESTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CAMPAIGN_QUESTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CAMPAIGN_QUEST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CAMPAIGN_QUESTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>>> list) {
    fbb_.AddOffset(CAMPAIGN_QUEST::VT_LIST, list);
  }
  void add_rewardable(OVERLORD::ENUM::REWARDABLE_STATUS rewardable) {
    fbb_.AddElement<int8_t>(CAMPAIGN_QUEST::VT_REWARDABLE, static_cast<int8_t>(rewardable), 0);
  }
  void add_rewardKey(flatbuffers::Offset<flatbuffers::String> rewardKey) {
    fbb_.AddOffset(CAMPAIGN_QUEST::VT_REWARDKEY, rewardKey);
  }
  explicit CAMPAIGN_QUESTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CAMPAIGN_QUESTBuilder &operator=(const CAMPAIGN_QUESTBuilder &);
  flatbuffers::Offset<CAMPAIGN_QUEST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CAMPAIGN_QUEST>(end);
    return o;
  }
};

inline flatbuffers::Offset<CAMPAIGN_QUEST> CreateCAMPAIGN_QUEST(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>>> list = 0,
    OVERLORD::ENUM::REWARDABLE_STATUS rewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY,
    flatbuffers::Offset<flatbuffers::String> rewardKey = 0) {
  CAMPAIGN_QUESTBuilder builder_(_fbb);
  builder_.add_rewardKey(rewardKey);
  builder_.add_list(list);
  builder_.add_rewardable(rewardable);
  return builder_.Finish();
}

inline flatbuffers::Offset<CAMPAIGN_QUEST> CreateCAMPAIGN_QUESTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>> *list = nullptr,
    OVERLORD::ENUM::REWARDABLE_STATUS rewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY,
    const char *rewardKey = nullptr) {
  return OVERLORD::STRUCT::CreateCAMPAIGN_QUEST(
      _fbb,
      list ? _fbb.CreateVector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>>(*list) : 0,
      rewardable,
      rewardKey ? _fbb.CreateString(rewardKey) : 0);
}

flatbuffers::Offset<CAMPAIGN_QUEST> CreateCAMPAIGN_QUEST(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CAMPAIGN_STATUST : public flatbuffers::NativeTable {
  typedef CAMPAIGN_STATUS TableType;
  std::vector<int32_t> clearGrades;
  std::vector<int32_t> episodeRewardStatus;
  std::vector<int32_t> dailyClearGrades;
  std::vector<int32_t> dailyTicket;
  std::vector<std::string> dailyOpenCards;
  std::unique_ptr<CAMPAIGN_QUESTT> Elite_1;
  CAMPAIGN_STATUST() {
  }
};

struct CAMPAIGN_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CAMPAIGN_STATUST NativeTableType;
  enum {
    VT_CLEARGRADES = 4,
    VT_EPISODEREWARDSTATUS = 6,
    VT_DAILYCLEARGRADES = 8,
    VT_DAILYTICKET = 10,
    VT_DAILYOPENCARDS = 12,
    VT_ELITE_1 = 14
  };
  const flatbuffers::Vector<int32_t> *clearGrades() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLEARGRADES);
  }
  const flatbuffers::Vector<int32_t> *episodeRewardStatus() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EPISODEREWARDSTATUS);
  }
  const flatbuffers::Vector<int32_t> *dailyClearGrades() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DAILYCLEARGRADES);
  }
  const flatbuffers::Vector<int32_t> *dailyTicket() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DAILYTICKET);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *dailyOpenCards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DAILYOPENCARDS);
  }
  const CAMPAIGN_QUEST *Elite_1() const {
    return GetPointer<const CAMPAIGN_QUEST *>(VT_ELITE_1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLEARGRADES) &&
           verifier.Verify(clearGrades()) &&
           VerifyOffset(verifier, VT_EPISODEREWARDSTATUS) &&
           verifier.Verify(episodeRewardStatus()) &&
           VerifyOffset(verifier, VT_DAILYCLEARGRADES) &&
           verifier.Verify(dailyClearGrades()) &&
           VerifyOffset(verifier, VT_DAILYTICKET) &&
           verifier.Verify(dailyTicket()) &&
           VerifyOffset(verifier, VT_DAILYOPENCARDS) &&
           verifier.Verify(dailyOpenCards()) &&
           verifier.VerifyVectorOfStrings(dailyOpenCards()) &&
           VerifyOffset(verifier, VT_ELITE_1) &&
           verifier.VerifyTable(Elite_1()) &&
           verifier.EndTable();
  }
  CAMPAIGN_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CAMPAIGN_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CAMPAIGN_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CAMPAIGN_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clearGrades(flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_CLEARGRADES, clearGrades);
  }
  void add_episodeRewardStatus(flatbuffers::Offset<flatbuffers::Vector<int32_t>> episodeRewardStatus) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_EPISODEREWARDSTATUS, episodeRewardStatus);
  }
  void add_dailyClearGrades(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dailyClearGrades) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_DAILYCLEARGRADES, dailyClearGrades);
  }
  void add_dailyTicket(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dailyTicket) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_DAILYTICKET, dailyTicket);
  }
  void add_dailyOpenCards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dailyOpenCards) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_DAILYOPENCARDS, dailyOpenCards);
  }
  void add_Elite_1(flatbuffers::Offset<CAMPAIGN_QUEST> Elite_1) {
    fbb_.AddOffset(CAMPAIGN_STATUS::VT_ELITE_1, Elite_1);
  }
  explicit CAMPAIGN_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CAMPAIGN_STATUSBuilder &operator=(const CAMPAIGN_STATUSBuilder &);
  flatbuffers::Offset<CAMPAIGN_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CAMPAIGN_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<CAMPAIGN_STATUS> CreateCAMPAIGN_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> episodeRewardStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dailyClearGrades = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dailyTicket = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> dailyOpenCards = 0,
    flatbuffers::Offset<CAMPAIGN_QUEST> Elite_1 = 0) {
  CAMPAIGN_STATUSBuilder builder_(_fbb);
  builder_.add_Elite_1(Elite_1);
  builder_.add_dailyOpenCards(dailyOpenCards);
  builder_.add_dailyTicket(dailyTicket);
  builder_.add_dailyClearGrades(dailyClearGrades);
  builder_.add_episodeRewardStatus(episodeRewardStatus);
  builder_.add_clearGrades(clearGrades);
  return builder_.Finish();
}

inline flatbuffers::Offset<CAMPAIGN_STATUS> CreateCAMPAIGN_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *clearGrades = nullptr,
    const std::vector<int32_t> *episodeRewardStatus = nullptr,
    const std::vector<int32_t> *dailyClearGrades = nullptr,
    const std::vector<int32_t> *dailyTicket = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *dailyOpenCards = nullptr,
    flatbuffers::Offset<CAMPAIGN_QUEST> Elite_1 = 0) {
  return OVERLORD::STRUCT::CreateCAMPAIGN_STATUS(
      _fbb,
      clearGrades ? _fbb.CreateVector<int32_t>(*clearGrades) : 0,
      episodeRewardStatus ? _fbb.CreateVector<int32_t>(*episodeRewardStatus) : 0,
      dailyClearGrades ? _fbb.CreateVector<int32_t>(*dailyClearGrades) : 0,
      dailyTicket ? _fbb.CreateVector<int32_t>(*dailyTicket) : 0,
      dailyOpenCards ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*dailyOpenCards) : 0,
      Elite_1);
}

flatbuffers::Offset<CAMPAIGN_STATUS> CreateCAMPAIGN_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLET : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE TableType;
  std::string articleId;
  std::string category;
  std::string contents;
  int32_t kId;
  std::string nick;
  std::string time;
  int32_t up;
  int32_t down;
  int32_t point;
  COMMUNITY_ARTICLET()
      : kId(0),
        up(0),
        down(0),
        point(0) {
  }
};

struct COMMUNITY_ARTICLE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLET NativeTableType;
  enum {
    VT_ARTICLEID = 4,
    VT_CATEGORY = 6,
    VT_CONTENTS = 8,
    VT_KID = 10,
    VT_NICK = 12,
    VT_TIME = 14,
    VT_UP = 16,
    VT_DOWN = 18,
    VT_POINT = 20
  };
  const flatbuffers::String *articleId() const {
    return GetPointer<const flatbuffers::String *>(VT_ARTICLEID);
  }
  const flatbuffers::String *category() const {
    return GetPointer<const flatbuffers::String *>(VT_CATEGORY);
  }
  const flatbuffers::String *contents() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENTS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *time() const {
    return GetPointer<const flatbuffers::String *>(VT_TIME);
  }
  int32_t up() const {
    return GetField<int32_t>(VT_UP, 0);
  }
  int32_t down() const {
    return GetField<int32_t>(VT_DOWN, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARTICLEID) &&
           verifier.Verify(articleId()) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.Verify(category()) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.Verify(contents()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_TIME) &&
           verifier.Verify(time()) &&
           VerifyField<int32_t>(verifier, VT_UP) &&
           VerifyField<int32_t>(verifier, VT_DOWN) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_articleId(flatbuffers::Offset<flatbuffers::String> articleId) {
    fbb_.AddOffset(COMMUNITY_ARTICLE::VT_ARTICLEID, articleId);
  }
  void add_category(flatbuffers::Offset<flatbuffers::String> category) {
    fbb_.AddOffset(COMMUNITY_ARTICLE::VT_CATEGORY, category);
  }
  void add_contents(flatbuffers::Offset<flatbuffers::String> contents) {
    fbb_.AddOffset(COMMUNITY_ARTICLE::VT_CONTENTS, contents);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(COMMUNITY_ARTICLE::VT_NICK, nick);
  }
  void add_time(flatbuffers::Offset<flatbuffers::String> time) {
    fbb_.AddOffset(COMMUNITY_ARTICLE::VT_TIME, time);
  }
  void add_up(int32_t up) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE::VT_UP, up, 0);
  }
  void add_down(int32_t down) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE::VT_DOWN, down, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE::VT_POINT, point, 0);
  }
  explicit COMMUNITY_ARTICLEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLEBuilder &operator=(const COMMUNITY_ARTICLEBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE> CreateCOMMUNITY_ARTICLE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> articleId = 0,
    flatbuffers::Offset<flatbuffers::String> category = 0,
    flatbuffers::Offset<flatbuffers::String> contents = 0,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> time = 0,
    int32_t up = 0,
    int32_t down = 0,
    int32_t point = 0) {
  COMMUNITY_ARTICLEBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_down(down);
  builder_.add_up(up);
  builder_.add_time(time);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_contents(contents);
  builder_.add_category(category);
  builder_.add_articleId(articleId);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE> CreateCOMMUNITY_ARTICLEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *articleId = nullptr,
    const char *category = nullptr,
    const char *contents = nullptr,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *time = nullptr,
    int32_t up = 0,
    int32_t down = 0,
    int32_t point = 0) {
  return OVERLORD::STRUCT::CreateCOMMUNITY_ARTICLE(
      _fbb,
      articleId ? _fbb.CreateString(articleId) : 0,
      category ? _fbb.CreateString(category) : 0,
      contents ? _fbb.CreateString(contents) : 0,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      time ? _fbb.CreateString(time) : 0,
      up,
      down,
      point);
}

flatbuffers::Offset<COMMUNITY_ARTICLE> CreateCOMMUNITY_ARTICLE(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EVENT_ATTENDANCET : public flatbuffers::NativeTable {
  typedef EVENT_ATTENDANCE TableType;
  std::string attId;
  std::vector<int32_t> days;
  int32_t stamp;
  EVENT_ATTENDANCET()
      : stamp(0) {
  }
};

struct EVENT_ATTENDANCE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EVENT_ATTENDANCET NativeTableType;
  enum {
    VT_ATTID = 4,
    VT_DAYS = 6,
    VT_STAMP = 8
  };
  const flatbuffers::String *attId() const {
    return GetPointer<const flatbuffers::String *>(VT_ATTID);
  }
  const flatbuffers::Vector<int32_t> *days() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DAYS);
  }
  int32_t stamp() const {
    return GetField<int32_t>(VT_STAMP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ATTID) &&
           verifier.Verify(attId()) &&
           VerifyOffset(verifier, VT_DAYS) &&
           verifier.Verify(days()) &&
           VerifyField<int32_t>(verifier, VT_STAMP) &&
           verifier.EndTable();
  }
  EVENT_ATTENDANCET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EVENT_ATTENDANCET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EVENT_ATTENDANCE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EVENT_ATTENDANCET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EVENT_ATTENDANCEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_attId(flatbuffers::Offset<flatbuffers::String> attId) {
    fbb_.AddOffset(EVENT_ATTENDANCE::VT_ATTID, attId);
  }
  void add_days(flatbuffers::Offset<flatbuffers::Vector<int32_t>> days) {
    fbb_.AddOffset(EVENT_ATTENDANCE::VT_DAYS, days);
  }
  void add_stamp(int32_t stamp) {
    fbb_.AddElement<int32_t>(EVENT_ATTENDANCE::VT_STAMP, stamp, 0);
  }
  explicit EVENT_ATTENDANCEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EVENT_ATTENDANCEBuilder &operator=(const EVENT_ATTENDANCEBuilder &);
  flatbuffers::Offset<EVENT_ATTENDANCE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EVENT_ATTENDANCE>(end);
    return o;
  }
};

inline flatbuffers::Offset<EVENT_ATTENDANCE> CreateEVENT_ATTENDANCE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> attId = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> days = 0,
    int32_t stamp = 0) {
  EVENT_ATTENDANCEBuilder builder_(_fbb);
  builder_.add_stamp(stamp);
  builder_.add_days(days);
  builder_.add_attId(attId);
  return builder_.Finish();
}

inline flatbuffers::Offset<EVENT_ATTENDANCE> CreateEVENT_ATTENDANCEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *attId = nullptr,
    const std::vector<int32_t> *days = nullptr,
    int32_t stamp = 0) {
  return OVERLORD::STRUCT::CreateEVENT_ATTENDANCE(
      _fbb,
      attId ? _fbb.CreateString(attId) : 0,
      days ? _fbb.CreateVector<int32_t>(*days) : 0,
      stamp);
}

flatbuffers::Offset<EVENT_ATTENDANCE> CreateEVENT_ATTENDANCE(flatbuffers::FlatBufferBuilder &_fbb, const EVENT_ATTENDANCET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORYT : public flatbuffers::NativeTable {
  typedef INVENTORY TableType;
  std::vector<int32_t> currency1;
  std::vector<int32_t> currency2;
  std::vector<int32_t> currency3;
  std::vector<std::unique_ptr<ITEMT>> items;
  std::vector<std::unique_ptr<HEROT>> heros;
  int32_t mailN;
  int32_t mailTag;
  std::unique_ptr<DECKST> decks;
  int32_t tut;
  std::vector<int32_t> size;
  INVENTORYT()
      : mailN(0),
        mailTag(0),
        tut(0) {
  }
};

struct INVENTORY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORYT NativeTableType;
  enum {
    VT_CURRENCY1 = 4,
    VT_CURRENCY2 = 6,
    VT_CURRENCY3 = 8,
    VT_ITEMS = 10,
    VT_HEROS = 12,
    VT_MAILN = 14,
    VT_MAILTAG = 16,
    VT_DECKS = 18,
    VT_TUT = 20,
    VT_SIZE = 22
  };
  const flatbuffers::Vector<int32_t> *currency1() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY1);
  }
  const flatbuffers::Vector<int32_t> *currency2() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY2);
  }
  const flatbuffers::Vector<int32_t> *currency3() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY3);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HERO>> *heros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HERO>> *>(VT_HEROS);
  }
  int32_t mailN() const {
    return GetField<int32_t>(VT_MAILN, 0);
  }
  int32_t mailTag() const {
    return GetField<int32_t>(VT_MAILTAG, 0);
  }
  const DECKS *decks() const {
    return GetPointer<const DECKS *>(VT_DECKS);
  }
  int32_t tut() const {
    return GetField<int32_t>(VT_TUT, 0);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENCY1) &&
           verifier.Verify(currency1()) &&
           VerifyOffset(verifier, VT_CURRENCY2) &&
           verifier.Verify(currency2()) &&
           VerifyOffset(verifier, VT_CURRENCY3) &&
           verifier.Verify(currency3()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_HEROS) &&
           verifier.Verify(heros()) &&
           verifier.VerifyVectorOfTables(heros()) &&
           VerifyField<int32_t>(verifier, VT_MAILN) &&
           VerifyField<int32_t>(verifier, VT_MAILTAG) &&
           VerifyOffset(verifier, VT_DECKS) &&
           verifier.VerifyTable(decks()) &&
           VerifyField<int32_t>(verifier, VT_TUT) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.Verify(size()) &&
           verifier.EndTable();
  }
  INVENTORYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency1(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1) {
    fbb_.AddOffset(INVENTORY::VT_CURRENCY1, currency1);
  }
  void add_currency2(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency2) {
    fbb_.AddOffset(INVENTORY::VT_CURRENCY2, currency2);
  }
  void add_currency3(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency3) {
    fbb_.AddOffset(INVENTORY::VT_CURRENCY3, currency3);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items) {
    fbb_.AddOffset(INVENTORY::VT_ITEMS, items);
  }
  void add_heros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros) {
    fbb_.AddOffset(INVENTORY::VT_HEROS, heros);
  }
  void add_mailN(int32_t mailN) {
    fbb_.AddElement<int32_t>(INVENTORY::VT_MAILN, mailN, 0);
  }
  void add_mailTag(int32_t mailTag) {
    fbb_.AddElement<int32_t>(INVENTORY::VT_MAILTAG, mailTag, 0);
  }
  void add_decks(flatbuffers::Offset<DECKS> decks) {
    fbb_.AddOffset(INVENTORY::VT_DECKS, decks);
  }
  void add_tut(int32_t tut) {
    fbb_.AddElement<int32_t>(INVENTORY::VT_TUT, tut, 0);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(INVENTORY::VT_SIZE, size);
  }
  explicit INVENTORYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORYBuilder &operator=(const INVENTORYBuilder &);
  flatbuffers::Offset<INVENTORY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY> CreateINVENTORY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros = 0,
    int32_t mailN = 0,
    int32_t mailTag = 0,
    flatbuffers::Offset<DECKS> decks = 0,
    int32_t tut = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0) {
  INVENTORYBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_tut(tut);
  builder_.add_decks(decks);
  builder_.add_mailTag(mailTag);
  builder_.add_mailN(mailN);
  builder_.add_heros(heros);
  builder_.add_items(items);
  builder_.add_currency3(currency3);
  builder_.add_currency2(currency2);
  builder_.add_currency1(currency1);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY> CreateINVENTORYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *currency1 = nullptr,
    const std::vector<int32_t> *currency2 = nullptr,
    const std::vector<int32_t> *currency3 = nullptr,
    const std::vector<flatbuffers::Offset<ITEM>> *items = nullptr,
    const std::vector<flatbuffers::Offset<HERO>> *heros = nullptr,
    int32_t mailN = 0,
    int32_t mailTag = 0,
    flatbuffers::Offset<DECKS> decks = 0,
    int32_t tut = 0,
    const std::vector<int32_t> *size = nullptr) {
  return OVERLORD::STRUCT::CreateINVENTORY(
      _fbb,
      currency1 ? _fbb.CreateVector<int32_t>(*currency1) : 0,
      currency2 ? _fbb.CreateVector<int32_t>(*currency2) : 0,
      currency3 ? _fbb.CreateVector<int32_t>(*currency3) : 0,
      items ? _fbb.CreateVector<flatbuffers::Offset<ITEM>>(*items) : 0,
      heros ? _fbb.CreateVector<flatbuffers::Offset<HERO>>(*heros) : 0,
      mailN,
      mailTag,
      decks,
      tut,
      size ? _fbb.CreateVector<int32_t>(*size) : 0);
}

flatbuffers::Offset<INVENTORY> CreateINVENTORY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_UPDATET : public flatbuffers::NativeTable {
  typedef INVENTORY_UPDATE TableType;
  std::vector<int32_t> currency1;
  std::vector<int32_t> currency2;
  std::vector<int32_t> currency3;
  std::vector<std::unique_ptr<ITEMT>> items_update;
  std::vector<std::string> items_delete;
  std::vector<std::unique_ptr<HEROT>> heros_update;
  std::vector<std::string> heros_delete;
  int32_t mailN;
  int32_t mailTag;
  std::unique_ptr<DECKST> decks;
  int32_t tut;
  std::vector<int32_t> size;
  INVENTORY_UPDATET()
      : mailN(0),
        mailTag(0),
        tut(0) {
  }
};

struct INVENTORY_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_UPDATET NativeTableType;
  enum {
    VT_CURRENCY1 = 4,
    VT_CURRENCY2 = 6,
    VT_CURRENCY3 = 8,
    VT_ITEMS_UPDATE = 10,
    VT_ITEMS_DELETE = 12,
    VT_HEROS_UPDATE = 14,
    VT_HEROS_DELETE = 16,
    VT_MAILN = 18,
    VT_MAILTAG = 20,
    VT_DECKS = 22,
    VT_TUT = 24,
    VT_SIZE = 26
  };
  const flatbuffers::Vector<int32_t> *currency1() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY1);
  }
  const flatbuffers::Vector<int32_t> *currency2() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY2);
  }
  const flatbuffers::Vector<int32_t> *currency3() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY3);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *items_update() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *>(VT_ITEMS_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *items_delete() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ITEMS_DELETE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HERO>> *heros_update() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HERO>> *>(VT_HEROS_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heros_delete() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROS_DELETE);
  }
  int32_t mailN() const {
    return GetField<int32_t>(VT_MAILN, 0);
  }
  int32_t mailTag() const {
    return GetField<int32_t>(VT_MAILTAG, 0);
  }
  const DECKS *decks() const {
    return GetPointer<const DECKS *>(VT_DECKS);
  }
  int32_t tut() const {
    return GetField<int32_t>(VT_TUT, 0);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENCY1) &&
           verifier.Verify(currency1()) &&
           VerifyOffset(verifier, VT_CURRENCY2) &&
           verifier.Verify(currency2()) &&
           VerifyOffset(verifier, VT_CURRENCY3) &&
           verifier.Verify(currency3()) &&
           VerifyOffset(verifier, VT_ITEMS_UPDATE) &&
           verifier.Verify(items_update()) &&
           verifier.VerifyVectorOfTables(items_update()) &&
           VerifyOffset(verifier, VT_ITEMS_DELETE) &&
           verifier.Verify(items_delete()) &&
           verifier.VerifyVectorOfStrings(items_delete()) &&
           VerifyOffset(verifier, VT_HEROS_UPDATE) &&
           verifier.Verify(heros_update()) &&
           verifier.VerifyVectorOfTables(heros_update()) &&
           VerifyOffset(verifier, VT_HEROS_DELETE) &&
           verifier.Verify(heros_delete()) &&
           verifier.VerifyVectorOfStrings(heros_delete()) &&
           VerifyField<int32_t>(verifier, VT_MAILN) &&
           VerifyField<int32_t>(verifier, VT_MAILTAG) &&
           VerifyOffset(verifier, VT_DECKS) &&
           verifier.VerifyTable(decks()) &&
           VerifyField<int32_t>(verifier, VT_TUT) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.Verify(size()) &&
           verifier.EndTable();
  }
  INVENTORY_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency1(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_CURRENCY1, currency1);
  }
  void add_currency2(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency2) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_CURRENCY2, currency2);
  }
  void add_currency3(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency3) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_CURRENCY3, currency3);
  }
  void add_items_update(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items_update) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_ITEMS_UPDATE, items_update);
  }
  void add_items_delete(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> items_delete) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_ITEMS_DELETE, items_delete);
  }
  void add_heros_update(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros_update) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_HEROS_UPDATE, heros_update);
  }
  void add_heros_delete(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heros_delete) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_HEROS_DELETE, heros_delete);
  }
  void add_mailN(int32_t mailN) {
    fbb_.AddElement<int32_t>(INVENTORY_UPDATE::VT_MAILN, mailN, 0);
  }
  void add_mailTag(int32_t mailTag) {
    fbb_.AddElement<int32_t>(INVENTORY_UPDATE::VT_MAILTAG, mailTag, 0);
  }
  void add_decks(flatbuffers::Offset<DECKS> decks) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_DECKS, decks);
  }
  void add_tut(int32_t tut) {
    fbb_.AddElement<int32_t>(INVENTORY_UPDATE::VT_TUT, tut, 0);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(INVENTORY_UPDATE::VT_SIZE, size);
  }
  explicit INVENTORY_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_UPDATEBuilder &operator=(const INVENTORY_UPDATEBuilder &);
  flatbuffers::Offset<INVENTORY_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_UPDATE> CreateINVENTORY_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items_update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> items_delete = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros_update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heros_delete = 0,
    int32_t mailN = 0,
    int32_t mailTag = 0,
    flatbuffers::Offset<DECKS> decks = 0,
    int32_t tut = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0) {
  INVENTORY_UPDATEBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_tut(tut);
  builder_.add_decks(decks);
  builder_.add_mailTag(mailTag);
  builder_.add_mailN(mailN);
  builder_.add_heros_delete(heros_delete);
  builder_.add_heros_update(heros_update);
  builder_.add_items_delete(items_delete);
  builder_.add_items_update(items_update);
  builder_.add_currency3(currency3);
  builder_.add_currency2(currency2);
  builder_.add_currency1(currency1);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_UPDATE> CreateINVENTORY_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *currency1 = nullptr,
    const std::vector<int32_t> *currency2 = nullptr,
    const std::vector<int32_t> *currency3 = nullptr,
    const std::vector<flatbuffers::Offset<ITEM>> *items_update = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *items_delete = nullptr,
    const std::vector<flatbuffers::Offset<HERO>> *heros_update = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heros_delete = nullptr,
    int32_t mailN = 0,
    int32_t mailTag = 0,
    flatbuffers::Offset<DECKS> decks = 0,
    int32_t tut = 0,
    const std::vector<int32_t> *size = nullptr) {
  return OVERLORD::STRUCT::CreateINVENTORY_UPDATE(
      _fbb,
      currency1 ? _fbb.CreateVector<int32_t>(*currency1) : 0,
      currency2 ? _fbb.CreateVector<int32_t>(*currency2) : 0,
      currency3 ? _fbb.CreateVector<int32_t>(*currency3) : 0,
      items_update ? _fbb.CreateVector<flatbuffers::Offset<ITEM>>(*items_update) : 0,
      items_delete ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*items_delete) : 0,
      heros_update ? _fbb.CreateVector<flatbuffers::Offset<HERO>>(*heros_update) : 0,
      heros_delete ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heros_delete) : 0,
      mailN,
      mailTag,
      decks,
      tut,
      size ? _fbb.CreateVector<int32_t>(*size) : 0);
}

flatbuffers::Offset<INVENTORY_UPDATE> CreateINVENTORY_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_CURRENCYT : public flatbuffers::NativeTable {
  typedef INVENTORY_CURRENCY TableType;
  std::vector<int32_t> currency1;
  INVENTORY_CURRENCYT() {
  }
};

struct INVENTORY_CURRENCY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_CURRENCYT NativeTableType;
  enum {
    VT_CURRENCY1 = 4
  };
  const flatbuffers::Vector<int32_t> *currency1() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CURRENCY1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENCY1) &&
           verifier.Verify(currency1()) &&
           verifier.EndTable();
  }
  INVENTORY_CURRENCYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_CURRENCYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_CURRENCY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_CURRENCYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_CURRENCYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currency1(flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1) {
    fbb_.AddOffset(INVENTORY_CURRENCY::VT_CURRENCY1, currency1);
  }
  explicit INVENTORY_CURRENCYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_CURRENCYBuilder &operator=(const INVENTORY_CURRENCYBuilder &);
  flatbuffers::Offset<INVENTORY_CURRENCY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_CURRENCY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_CURRENCY> CreateINVENTORY_CURRENCY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> currency1 = 0) {
  INVENTORY_CURRENCYBuilder builder_(_fbb);
  builder_.add_currency1(currency1);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_CURRENCY> CreateINVENTORY_CURRENCYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *currency1 = nullptr) {
  return OVERLORD::STRUCT::CreateINVENTORY_CURRENCY(
      _fbb,
      currency1 ? _fbb.CreateVector<int32_t>(*currency1) : 0);
}

flatbuffers::Offset<INVENTORY_CURRENCY> CreateINVENTORY_CURRENCY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_CURRENCYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_EQUIPEDT : public flatbuffers::NativeTable {
  typedef INVENTORY_EQUIPED TableType;
  std::vector<std::unique_ptr<ITEMT>> items;
  std::vector<std::unique_ptr<HEROT>> heros;
  std::unique_ptr<DECKST> decks;
  INVENTORY_EQUIPEDT() {
  }
};

struct INVENTORY_EQUIPED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_EQUIPEDT NativeTableType;
  enum {
    VT_ITEMS = 4,
    VT_HEROS = 6,
    VT_DECKS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ITEM>> *>(VT_ITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HERO>> *heros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HERO>> *>(VT_HEROS);
  }
  const DECKS *decks() const {
    return GetPointer<const DECKS *>(VT_DECKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.Verify(items()) &&
           verifier.VerifyVectorOfTables(items()) &&
           VerifyOffset(verifier, VT_HEROS) &&
           verifier.Verify(heros()) &&
           verifier.VerifyVectorOfTables(heros()) &&
           VerifyOffset(verifier, VT_DECKS) &&
           verifier.VerifyTable(decks()) &&
           verifier.EndTable();
  }
  INVENTORY_EQUIPEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_EQUIPEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_EQUIPED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_EQUIPEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_EQUIPEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items) {
    fbb_.AddOffset(INVENTORY_EQUIPED::VT_ITEMS, items);
  }
  void add_heros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros) {
    fbb_.AddOffset(INVENTORY_EQUIPED::VT_HEROS, heros);
  }
  void add_decks(flatbuffers::Offset<DECKS> decks) {
    fbb_.AddOffset(INVENTORY_EQUIPED::VT_DECKS, decks);
  }
  explicit INVENTORY_EQUIPEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_EQUIPEDBuilder &operator=(const INVENTORY_EQUIPEDBuilder &);
  flatbuffers::Offset<INVENTORY_EQUIPED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_EQUIPED>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_EQUIPED> CreateINVENTORY_EQUIPED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ITEM>>> items = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO>>> heros = 0,
    flatbuffers::Offset<DECKS> decks = 0) {
  INVENTORY_EQUIPEDBuilder builder_(_fbb);
  builder_.add_decks(decks);
  builder_.add_heros(heros);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_EQUIPED> CreateINVENTORY_EQUIPEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ITEM>> *items = nullptr,
    const std::vector<flatbuffers::Offset<HERO>> *heros = nullptr,
    flatbuffers::Offset<DECKS> decks = 0) {
  return OVERLORD::STRUCT::CreateINVENTORY_EQUIPED(
      _fbb,
      items ? _fbb.CreateVector<flatbuffers::Offset<ITEM>>(*items) : 0,
      heros ? _fbb.CreateVector<flatbuffers::Offset<HERO>>(*heros) : 0,
      decks);
}

flatbuffers::Offset<INVENTORY_EQUIPED> CreateINVENTORY_EQUIPED(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_EQUIPEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UNLOCK_NOTIFYT : public flatbuffers::NativeTable {
  typedef UNLOCK_NOTIFY TableType;
  std::vector<int32_t> notify;
  UNLOCK_NOTIFYT() {
  }
};

struct UNLOCK_NOTIFY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UNLOCK_NOTIFYT NativeTableType;
  enum {
    VT_NOTIFY = 4
  };
  const flatbuffers::Vector<int32_t> *notify() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NOTIFY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFY) &&
           verifier.Verify(notify()) &&
           verifier.EndTable();
  }
  UNLOCK_NOTIFYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UNLOCK_NOTIFYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UNLOCK_NOTIFY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_NOTIFYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UNLOCK_NOTIFYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_notify(flatbuffers::Offset<flatbuffers::Vector<int32_t>> notify) {
    fbb_.AddOffset(UNLOCK_NOTIFY::VT_NOTIFY, notify);
  }
  explicit UNLOCK_NOTIFYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNLOCK_NOTIFYBuilder &operator=(const UNLOCK_NOTIFYBuilder &);
  flatbuffers::Offset<UNLOCK_NOTIFY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNLOCK_NOTIFY>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNLOCK_NOTIFY> CreateUNLOCK_NOTIFY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> notify = 0) {
  UNLOCK_NOTIFYBuilder builder_(_fbb);
  builder_.add_notify(notify);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNLOCK_NOTIFY> CreateUNLOCK_NOTIFYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *notify = nullptr) {
  return OVERLORD::STRUCT::CreateUNLOCK_NOTIFY(
      _fbb,
      notify ? _fbb.CreateVector<int32_t>(*notify) : 0);
}

flatbuffers::Offset<UNLOCK_NOTIFY> CreateUNLOCK_NOTIFY(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_NOTIFYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UNLOCK_LISTT : public flatbuffers::NativeTable {
  typedef UNLOCK_LIST TableType;
  std::vector<int32_t> list;
  UNLOCK_LISTT() {
  }
};

struct UNLOCK_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UNLOCK_LISTT NativeTableType;
  enum {
    VT_LIST = 4
  };
  const flatbuffers::Vector<int32_t> *list() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.Verify(list()) &&
           verifier.EndTable();
  }
  UNLOCK_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UNLOCK_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UNLOCK_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UNLOCK_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_list(flatbuffers::Offset<flatbuffers::Vector<int32_t>> list) {
    fbb_.AddOffset(UNLOCK_LIST::VT_LIST, list);
  }
  explicit UNLOCK_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UNLOCK_LISTBuilder &operator=(const UNLOCK_LISTBuilder &);
  flatbuffers::Offset<UNLOCK_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UNLOCK_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<UNLOCK_LIST> CreateUNLOCK_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> list = 0) {
  UNLOCK_LISTBuilder builder_(_fbb);
  builder_.add_list(list);
  return builder_.Finish();
}

inline flatbuffers::Offset<UNLOCK_LIST> CreateUNLOCK_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *list = nullptr) {
  return OVERLORD::STRUCT::CreateUNLOCK_LIST(
      _fbb,
      list ? _fbb.CreateVector<int32_t>(*list) : 0);
}

flatbuffers::Offset<UNLOCK_LIST> CreateUNLOCK_LIST(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_STATUST : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_STATUS TableType;
  int32_t score;
  std::vector<int32_t> rewardable;
  std::vector<int32_t> clearcount;
  int32_t timeleft;
  DAILY_QUEST_STATUST()
      : score(0),
        timeleft(0) {
  }
};

struct DAILY_QUEST_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_STATUST NativeTableType;
  enum {
    VT_SCORE = 4,
    VT_REWARDABLE = 6,
    VT_CLEARCOUNT = 8,
    VT_TIMELEFT = 10
  };
  int32_t score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  const flatbuffers::Vector<int32_t> *rewardable() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_REWARDABLE);
  }
  const flatbuffers::Vector<int32_t> *clearcount() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLEARCOUNT);
  }
  int32_t timeleft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCORE) &&
           VerifyOffset(verifier, VT_REWARDABLE) &&
           verifier.Verify(rewardable()) &&
           VerifyOffset(verifier, VT_CLEARCOUNT) &&
           verifier.Verify(clearcount()) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           verifier.EndTable();
  }
  DAILY_QUEST_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_score(int32_t score) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_STATUS::VT_SCORE, score, 0);
  }
  void add_rewardable(flatbuffers::Offset<flatbuffers::Vector<int32_t>> rewardable) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_REWARDABLE, rewardable);
  }
  void add_clearcount(flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearcount) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_CLEARCOUNT, clearcount);
  }
  void add_timeleft(int32_t timeleft) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_STATUS::VT_TIMELEFT, timeleft, 0);
  }
  explicit DAILY_QUEST_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_STATUSBuilder &operator=(const DAILY_QUEST_STATUSBuilder &);
  flatbuffers::Offset<DAILY_QUEST_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t score = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> rewardable = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearcount = 0,
    int32_t timeleft = 0) {
  DAILY_QUEST_STATUSBuilder builder_(_fbb);
  builder_.add_timeleft(timeleft);
  builder_.add_clearcount(clearcount);
  builder_.add_rewardable(rewardable);
  builder_.add_score(score);
  return builder_.Finish();
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t score = 0,
    const std::vector<int32_t> *rewardable = nullptr,
    const std::vector<int32_t> *clearcount = nullptr,
    int32_t timeleft = 0) {
  return OVERLORD::STRUCT::CreateDAILY_QUEST_STATUS(
      _fbb,
      score,
      rewardable ? _fbb.CreateVector<int32_t>(*rewardable) : 0,
      clearcount ? _fbb.CreateVector<int32_t>(*clearcount) : 0,
      timeleft);
}

flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_UPDATET : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_UPDATE TableType;
  int32_t score;
  std::vector<int32_t> rewardable;
  std::vector<int32_t> clearcount;
  int32_t timeleft;
  DAILY_QUEST_UPDATET()
      : score(0),
        timeleft(0) {
  }
};

struct DAILY_QUEST_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_UPDATET NativeTableType;
  enum {
    VT_SCORE = 4,
    VT_REWARDABLE = 6,
    VT_CLEARCOUNT = 8,
    VT_TIMELEFT = 10
  };
  int32_t score() const {
    return GetField<int32_t>(VT_SCORE, 0);
  }
  const flatbuffers::Vector<int32_t> *rewardable() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_REWARDABLE);
  }
  const flatbuffers::Vector<int32_t> *clearcount() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLEARCOUNT);
  }
  int32_t timeleft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SCORE) &&
           VerifyOffset(verifier, VT_REWARDABLE) &&
           verifier.Verify(rewardable()) &&
           VerifyOffset(verifier, VT_CLEARCOUNT) &&
           verifier.Verify(clearcount()) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           verifier.EndTable();
  }
  DAILY_QUEST_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_score(int32_t score) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_UPDATE::VT_SCORE, score, 0);
  }
  void add_rewardable(flatbuffers::Offset<flatbuffers::Vector<int32_t>> rewardable) {
    fbb_.AddOffset(DAILY_QUEST_UPDATE::VT_REWARDABLE, rewardable);
  }
  void add_clearcount(flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearcount) {
    fbb_.AddOffset(DAILY_QUEST_UPDATE::VT_CLEARCOUNT, clearcount);
  }
  void add_timeleft(int32_t timeleft) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_UPDATE::VT_TIMELEFT, timeleft, 0);
  }
  explicit DAILY_QUEST_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_UPDATEBuilder &operator=(const DAILY_QUEST_UPDATEBuilder &);
  flatbuffers::Offset<DAILY_QUEST_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_UPDATE> CreateDAILY_QUEST_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t score = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> rewardable = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearcount = 0,
    int32_t timeleft = 0) {
  DAILY_QUEST_UPDATEBuilder builder_(_fbb);
  builder_.add_timeleft(timeleft);
  builder_.add_clearcount(clearcount);
  builder_.add_rewardable(rewardable);
  builder_.add_score(score);
  return builder_.Finish();
}

inline flatbuffers::Offset<DAILY_QUEST_UPDATE> CreateDAILY_QUEST_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t score = 0,
    const std::vector<int32_t> *rewardable = nullptr,
    const std::vector<int32_t> *clearcount = nullptr,
    int32_t timeleft = 0) {
  return OVERLORD::STRUCT::CreateDAILY_QUEST_UPDATE(
      _fbb,
      score,
      rewardable ? _fbb.CreateVector<int32_t>(*rewardable) : 0,
      clearcount ? _fbb.CreateVector<int32_t>(*clearcount) : 0,
      timeleft);
}

flatbuffers::Offset<DAILY_QUEST_UPDATE> CreateDAILY_QUEST_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REALTIME_USER_BASIC_INFOT : public flatbuffers::NativeTable {
  typedef REALTIME_USER_BASIC_INFO TableType;
  int32_t kId;
  std::string nick;
  int32_t level;
  std::string guild;
  int32_t guild_id;
  REALTIME_USER_BASIC_INFOT()
      : kId(0),
        level(0),
        guild_id(0) {
  }
};

struct REALTIME_USER_BASIC_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REALTIME_USER_BASIC_INFOT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_LEVEL = 8,
    VT_GUILD = 10,
    VT_GUILD_ID = 12
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  REALTIME_USER_BASIC_INFOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REALTIME_USER_BASIC_INFOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REALTIME_USER_BASIC_INFO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_USER_BASIC_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REALTIME_USER_BASIC_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(REALTIME_USER_BASIC_INFO::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(REALTIME_USER_BASIC_INFO::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(REALTIME_USER_BASIC_INFO::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(REALTIME_USER_BASIC_INFO::VT_GUILD, guild);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(REALTIME_USER_BASIC_INFO::VT_GUILD_ID, guild_id, 0);
  }
  explicit REALTIME_USER_BASIC_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REALTIME_USER_BASIC_INFOBuilder &operator=(const REALTIME_USER_BASIC_INFOBuilder &);
  flatbuffers::Offset<REALTIME_USER_BASIC_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REALTIME_USER_BASIC_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<REALTIME_USER_BASIC_INFO> CreateREALTIME_USER_BASIC_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t guild_id = 0) {
  REALTIME_USER_BASIC_INFOBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<REALTIME_USER_BASIC_INFO> CreateREALTIME_USER_BASIC_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    int32_t guild_id = 0) {
  return OVERLORD::STRUCT::CreateREALTIME_USER_BASIC_INFO(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      guild_id);
}

flatbuffers::Offset<REALTIME_USER_BASIC_INFO> CreateREALTIME_USER_BASIC_INFO(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_USER_BASIC_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REALTIME_COLOSSEUM_STATUST : public flatbuffers::NativeTable {
  typedef REALTIME_COLOSSEUM_STATUS TableType;
  int32_t league;
  int32_t rank;
  int32_t power;
  int32_t point;
  int32_t rPoint;
  int32_t win;
  int32_t lose;
  int32_t contWin;
  REALTIME_COLOSSEUM_STATUST()
      : league(0),
        rank(0),
        power(0),
        point(0),
        rPoint(0),
        win(0),
        lose(0),
        contWin(0) {
  }
};

struct REALTIME_COLOSSEUM_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REALTIME_COLOSSEUM_STATUST NativeTableType;
  enum {
    VT_LEAGUE = 4,
    VT_RANK = 6,
    VT_POWER = 8,
    VT_POINT = 10,
    VT_RPOINT = 12,
    VT_WIN = 14,
    VT_LOSE = 16,
    VT_CONTWIN = 18
  };
  int32_t league() const {
    return GetField<int32_t>(VT_LEAGUE, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t rPoint() const {
    return GetField<int32_t>(VT_RPOINT, 0);
  }
  int32_t win() const {
    return GetField<int32_t>(VT_WIN, 0);
  }
  int32_t lose() const {
    return GetField<int32_t>(VT_LOSE, 0);
  }
  int32_t contWin() const {
    return GetField<int32_t>(VT_CONTWIN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_LEAGUE) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_RPOINT) &&
           VerifyField<int32_t>(verifier, VT_WIN) &&
           VerifyField<int32_t>(verifier, VT_LOSE) &&
           VerifyField<int32_t>(verifier, VT_CONTWIN) &&
           verifier.EndTable();
  }
  REALTIME_COLOSSEUM_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REALTIME_COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REALTIME_COLOSSEUM_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_league(int32_t league) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_LEAGUE, league, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_RANK, rank, 0);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_POWER, power, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_POINT, point, 0);
  }
  void add_rPoint(int32_t rPoint) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_RPOINT, rPoint, 0);
  }
  void add_win(int32_t win) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_WIN, win, 0);
  }
  void add_lose(int32_t lose) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_LOSE, lose, 0);
  }
  void add_contWin(int32_t contWin) {
    fbb_.AddElement<int32_t>(REALTIME_COLOSSEUM_STATUS::VT_CONTWIN, contWin, 0);
  }
  explicit REALTIME_COLOSSEUM_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REALTIME_COLOSSEUM_STATUSBuilder &operator=(const REALTIME_COLOSSEUM_STATUSBuilder &);
  flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> CreateREALTIME_COLOSSEUM_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t league = 0,
    int32_t rank = 0,
    int32_t power = 0,
    int32_t point = 0,
    int32_t rPoint = 0,
    int32_t win = 0,
    int32_t lose = 0,
    int32_t contWin = 0) {
  REALTIME_COLOSSEUM_STATUSBuilder builder_(_fbb);
  builder_.add_contWin(contWin);
  builder_.add_lose(lose);
  builder_.add_win(win);
  builder_.add_rPoint(rPoint);
  builder_.add_point(point);
  builder_.add_power(power);
  builder_.add_rank(rank);
  builder_.add_league(league);
  return builder_.Finish();
}

flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> CreateREALTIME_COLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_SHOP_PRODUCTT : public flatbuffers::NativeTable {
  typedef HERO_SHOP_PRODUCT TableType;
  std::string productId;
  std::string currencyType;
  int32_t price;
  int32_t priceTotal;
  int32_t primeCostPrice;
  int32_t primeCostTotalPrice;
  int32_t maxQuantity;
  int32_t remainQuantity;
  HERO_SHOP_PRODUCTT()
      : price(0),
        priceTotal(0),
        primeCostPrice(0),
        primeCostTotalPrice(0),
        maxQuantity(0),
        remainQuantity(0) {
  }
};

struct HERO_SHOP_PRODUCT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_SHOP_PRODUCTT NativeTableType;
  enum {
    VT_PRODUCTID = 4,
    VT_CURRENCYTYPE = 6,
    VT_PRICE = 8,
    VT_PRICETOTAL = 10,
    VT_PRIMECOSTPRICE = 12,
    VT_PRIMECOSTTOTALPRICE = 14,
    VT_MAXQUANTITY = 16,
    VT_REMAINQUANTITY = 18
  };
  const flatbuffers::String *productId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCTID);
  }
  const flatbuffers::String *currencyType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCYTYPE);
  }
  int32_t price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  int32_t priceTotal() const {
    return GetField<int32_t>(VT_PRICETOTAL, 0);
  }
  int32_t primeCostPrice() const {
    return GetField<int32_t>(VT_PRIMECOSTPRICE, 0);
  }
  int32_t primeCostTotalPrice() const {
    return GetField<int32_t>(VT_PRIMECOSTTOTALPRICE, 0);
  }
  int32_t maxQuantity() const {
    return GetField<int32_t>(VT_MAXQUANTITY, 0);
  }
  int32_t remainQuantity() const {
    return GetField<int32_t>(VT_REMAINQUANTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRODUCTID) &&
           verifier.Verify(productId()) &&
           VerifyOffset(verifier, VT_CURRENCYTYPE) &&
           verifier.Verify(currencyType()) &&
           VerifyField<int32_t>(verifier, VT_PRICE) &&
           VerifyField<int32_t>(verifier, VT_PRICETOTAL) &&
           VerifyField<int32_t>(verifier, VT_PRIMECOSTPRICE) &&
           VerifyField<int32_t>(verifier, VT_PRIMECOSTTOTALPRICE) &&
           VerifyField<int32_t>(verifier, VT_MAXQUANTITY) &&
           VerifyField<int32_t>(verifier, VT_REMAINQUANTITY) &&
           verifier.EndTable();
  }
  HERO_SHOP_PRODUCTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_SHOP_PRODUCTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_SHOP_PRODUCT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PRODUCTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_SHOP_PRODUCTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_productId(flatbuffers::Offset<flatbuffers::String> productId) {
    fbb_.AddOffset(HERO_SHOP_PRODUCT::VT_PRODUCTID, productId);
  }
  void add_currencyType(flatbuffers::Offset<flatbuffers::String> currencyType) {
    fbb_.AddOffset(HERO_SHOP_PRODUCT::VT_CURRENCYTYPE, currencyType);
  }
  void add_price(int32_t price) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_PRICE, price, 0);
  }
  void add_priceTotal(int32_t priceTotal) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_PRICETOTAL, priceTotal, 0);
  }
  void add_primeCostPrice(int32_t primeCostPrice) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_PRIMECOSTPRICE, primeCostPrice, 0);
  }
  void add_primeCostTotalPrice(int32_t primeCostTotalPrice) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_PRIMECOSTTOTALPRICE, primeCostTotalPrice, 0);
  }
  void add_maxQuantity(int32_t maxQuantity) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_MAXQUANTITY, maxQuantity, 0);
  }
  void add_remainQuantity(int32_t remainQuantity) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PRODUCT::VT_REMAINQUANTITY, remainQuantity, 0);
  }
  explicit HERO_SHOP_PRODUCTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_SHOP_PRODUCTBuilder &operator=(const HERO_SHOP_PRODUCTBuilder &);
  flatbuffers::Offset<HERO_SHOP_PRODUCT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_SHOP_PRODUCT>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_SHOP_PRODUCT> CreateHERO_SHOP_PRODUCT(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> productId = 0,
    flatbuffers::Offset<flatbuffers::String> currencyType = 0,
    int32_t price = 0,
    int32_t priceTotal = 0,
    int32_t primeCostPrice = 0,
    int32_t primeCostTotalPrice = 0,
    int32_t maxQuantity = 0,
    int32_t remainQuantity = 0) {
  HERO_SHOP_PRODUCTBuilder builder_(_fbb);
  builder_.add_remainQuantity(remainQuantity);
  builder_.add_maxQuantity(maxQuantity);
  builder_.add_primeCostTotalPrice(primeCostTotalPrice);
  builder_.add_primeCostPrice(primeCostPrice);
  builder_.add_priceTotal(priceTotal);
  builder_.add_price(price);
  builder_.add_currencyType(currencyType);
  builder_.add_productId(productId);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_SHOP_PRODUCT> CreateHERO_SHOP_PRODUCTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *productId = nullptr,
    const char *currencyType = nullptr,
    int32_t price = 0,
    int32_t priceTotal = 0,
    int32_t primeCostPrice = 0,
    int32_t primeCostTotalPrice = 0,
    int32_t maxQuantity = 0,
    int32_t remainQuantity = 0) {
  return OVERLORD::STRUCT::CreateHERO_SHOP_PRODUCT(
      _fbb,
      productId ? _fbb.CreateString(productId) : 0,
      currencyType ? _fbb.CreateString(currencyType) : 0,
      price,
      priceTotal,
      primeCostPrice,
      primeCostTotalPrice,
      maxQuantity,
      remainQuantity);
}

flatbuffers::Offset<HERO_SHOP_PRODUCT> CreateHERO_SHOP_PRODUCT(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PRODUCTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_SHOP_PANELT : public flatbuffers::NativeTable {
  typedef HERO_SHOP_PANEL TableType;
  std::string panelId;
  std::string resetCurrencyType;
  int32_t resetPrice;
  int32_t resetRemainCount;
  int32_t timer;
  std::vector<std::unique_ptr<HERO_SHOP_PRODUCTT>> productList;
  std::string synergyId;
  HERO_SHOP_PANELT()
      : resetPrice(0),
        resetRemainCount(0),
        timer(0) {
  }
};

struct HERO_SHOP_PANEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_SHOP_PANELT NativeTableType;
  enum {
    VT_PANELID = 4,
    VT_RESETCURRENCYTYPE = 6,
    VT_RESETPRICE = 8,
    VT_RESETREMAINCOUNT = 10,
    VT_TIMER = 12,
    VT_PRODUCTLIST = 14,
    VT_SYNERGYID = 16
  };
  const flatbuffers::String *panelId() const {
    return GetPointer<const flatbuffers::String *>(VT_PANELID);
  }
  const flatbuffers::String *resetCurrencyType() const {
    return GetPointer<const flatbuffers::String *>(VT_RESETCURRENCYTYPE);
  }
  int32_t resetPrice() const {
    return GetField<int32_t>(VT_RESETPRICE, 0);
  }
  int32_t resetRemainCount() const {
    return GetField<int32_t>(VT_RESETREMAINCOUNT, 0);
  }
  int32_t timer() const {
    return GetField<int32_t>(VT_TIMER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HERO_SHOP_PRODUCT>> *productList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HERO_SHOP_PRODUCT>> *>(VT_PRODUCTLIST);
  }
  const flatbuffers::String *synergyId() const {
    return GetPointer<const flatbuffers::String *>(VT_SYNERGYID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PANELID) &&
           verifier.Verify(panelId()) &&
           VerifyOffset(verifier, VT_RESETCURRENCYTYPE) &&
           verifier.Verify(resetCurrencyType()) &&
           VerifyField<int32_t>(verifier, VT_RESETPRICE) &&
           VerifyField<int32_t>(verifier, VT_RESETREMAINCOUNT) &&
           VerifyField<int32_t>(verifier, VT_TIMER) &&
           VerifyOffset(verifier, VT_PRODUCTLIST) &&
           verifier.Verify(productList()) &&
           verifier.VerifyVectorOfTables(productList()) &&
           VerifyOffset(verifier, VT_SYNERGYID) &&
           verifier.Verify(synergyId()) &&
           verifier.EndTable();
  }
  HERO_SHOP_PANELT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_SHOP_PANELT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_SHOP_PANEL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PANELT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_SHOP_PANELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_panelId(flatbuffers::Offset<flatbuffers::String> panelId) {
    fbb_.AddOffset(HERO_SHOP_PANEL::VT_PANELID, panelId);
  }
  void add_resetCurrencyType(flatbuffers::Offset<flatbuffers::String> resetCurrencyType) {
    fbb_.AddOffset(HERO_SHOP_PANEL::VT_RESETCURRENCYTYPE, resetCurrencyType);
  }
  void add_resetPrice(int32_t resetPrice) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PANEL::VT_RESETPRICE, resetPrice, 0);
  }
  void add_resetRemainCount(int32_t resetRemainCount) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PANEL::VT_RESETREMAINCOUNT, resetRemainCount, 0);
  }
  void add_timer(int32_t timer) {
    fbb_.AddElement<int32_t>(HERO_SHOP_PANEL::VT_TIMER, timer, 0);
  }
  void add_productList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO_SHOP_PRODUCT>>> productList) {
    fbb_.AddOffset(HERO_SHOP_PANEL::VT_PRODUCTLIST, productList);
  }
  void add_synergyId(flatbuffers::Offset<flatbuffers::String> synergyId) {
    fbb_.AddOffset(HERO_SHOP_PANEL::VT_SYNERGYID, synergyId);
  }
  explicit HERO_SHOP_PANELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_SHOP_PANELBuilder &operator=(const HERO_SHOP_PANELBuilder &);
  flatbuffers::Offset<HERO_SHOP_PANEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_SHOP_PANEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_SHOP_PANEL> CreateHERO_SHOP_PANEL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> panelId = 0,
    flatbuffers::Offset<flatbuffers::String> resetCurrencyType = 0,
    int32_t resetPrice = 0,
    int32_t resetRemainCount = 0,
    int32_t timer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO_SHOP_PRODUCT>>> productList = 0,
    flatbuffers::Offset<flatbuffers::String> synergyId = 0) {
  HERO_SHOP_PANELBuilder builder_(_fbb);
  builder_.add_synergyId(synergyId);
  builder_.add_productList(productList);
  builder_.add_timer(timer);
  builder_.add_resetRemainCount(resetRemainCount);
  builder_.add_resetPrice(resetPrice);
  builder_.add_resetCurrencyType(resetCurrencyType);
  builder_.add_panelId(panelId);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_SHOP_PANEL> CreateHERO_SHOP_PANELDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *panelId = nullptr,
    const char *resetCurrencyType = nullptr,
    int32_t resetPrice = 0,
    int32_t resetRemainCount = 0,
    int32_t timer = 0,
    const std::vector<flatbuffers::Offset<HERO_SHOP_PRODUCT>> *productList = nullptr,
    const char *synergyId = nullptr) {
  return OVERLORD::STRUCT::CreateHERO_SHOP_PANEL(
      _fbb,
      panelId ? _fbb.CreateString(panelId) : 0,
      resetCurrencyType ? _fbb.CreateString(resetCurrencyType) : 0,
      resetPrice,
      resetRemainCount,
      timer,
      productList ? _fbb.CreateVector<flatbuffers::Offset<HERO_SHOP_PRODUCT>>(*productList) : 0,
      synergyId ? _fbb.CreateString(synergyId) : 0);
}

flatbuffers::Offset<HERO_SHOP_PANEL> CreateHERO_SHOP_PANEL(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PANELT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROA_QUESTT : public flatbuffers::NativeTable {
  typedef ROA_QUEST TableType;
  int32_t quest;
  int32_t max;
  int32_t now;
  std::string rewardKey;
  bool rewarded;
  bool complete;
  ROA_QUESTT()
      : quest(0),
        max(0),
        now(0),
        rewarded(false),
        complete(false) {
  }
};

struct ROA_QUEST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROA_QUESTT NativeTableType;
  enum {
    VT_QUEST = 4,
    VT_MAX = 6,
    VT_NOW = 8,
    VT_REWARDKEY = 10,
    VT_REWARDED = 12,
    VT_COMPLETE = 14
  };
  int32_t quest() const {
    return GetField<int32_t>(VT_QUEST, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  int32_t now() const {
    return GetField<int32_t>(VT_NOW, 0);
  }
  const flatbuffers::String *rewardKey() const {
    return GetPointer<const flatbuffers::String *>(VT_REWARDKEY);
  }
  bool rewarded() const {
    return GetField<uint8_t>(VT_REWARDED, 0) != 0;
  }
  bool complete() const {
    return GetField<uint8_t>(VT_COMPLETE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUEST) &&
           VerifyField<int32_t>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NOW) &&
           VerifyOffset(verifier, VT_REWARDKEY) &&
           verifier.Verify(rewardKey()) &&
           VerifyField<uint8_t>(verifier, VT_REWARDED) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETE) &&
           verifier.EndTable();
  }
  ROA_QUESTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROA_QUESTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROA_QUEST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_QUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROA_QUESTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_quest(int32_t quest) {
    fbb_.AddElement<int32_t>(ROA_QUEST::VT_QUEST, quest, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(ROA_QUEST::VT_MAX, max, 0);
  }
  void add_now(int32_t now) {
    fbb_.AddElement<int32_t>(ROA_QUEST::VT_NOW, now, 0);
  }
  void add_rewardKey(flatbuffers::Offset<flatbuffers::String> rewardKey) {
    fbb_.AddOffset(ROA_QUEST::VT_REWARDKEY, rewardKey);
  }
  void add_rewarded(bool rewarded) {
    fbb_.AddElement<uint8_t>(ROA_QUEST::VT_REWARDED, static_cast<uint8_t>(rewarded), 0);
  }
  void add_complete(bool complete) {
    fbb_.AddElement<uint8_t>(ROA_QUEST::VT_COMPLETE, static_cast<uint8_t>(complete), 0);
  }
  explicit ROA_QUESTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROA_QUESTBuilder &operator=(const ROA_QUESTBuilder &);
  flatbuffers::Offset<ROA_QUEST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROA_QUEST>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROA_QUEST> CreateROA_QUEST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t quest = 0,
    int32_t max = 0,
    int32_t now = 0,
    flatbuffers::Offset<flatbuffers::String> rewardKey = 0,
    bool rewarded = false,
    bool complete = false) {
  ROA_QUESTBuilder builder_(_fbb);
  builder_.add_rewardKey(rewardKey);
  builder_.add_now(now);
  builder_.add_max(max);
  builder_.add_quest(quest);
  builder_.add_complete(complete);
  builder_.add_rewarded(rewarded);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROA_QUEST> CreateROA_QUESTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t quest = 0,
    int32_t max = 0,
    int32_t now = 0,
    const char *rewardKey = nullptr,
    bool rewarded = false,
    bool complete = false) {
  return OVERLORD::STRUCT::CreateROA_QUEST(
      _fbb,
      quest,
      max,
      now,
      rewardKey ? _fbb.CreateString(rewardKey) : 0,
      rewarded,
      complete);
}

flatbuffers::Offset<ROA_QUEST> CreateROA_QUEST(flatbuffers::FlatBufferBuilder &_fbb, const ROA_QUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROA_CHAPTER_QUESTST : public flatbuffers::NativeTable {
  typedef ROA_CHAPTER_QUESTS TableType;
  int32_t day;
  std::vector<std::unique_ptr<ROA_QUESTT>> quests;
  ROA_CHAPTER_QUESTST()
      : day(0) {
  }
};

struct ROA_CHAPTER_QUESTS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROA_CHAPTER_QUESTST NativeTableType;
  enum {
    VT_DAY = 4,
    VT_QUESTS = 6
  };
  int32_t day() const {
    return GetField<int32_t>(VT_DAY, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ROA_QUEST>> *quests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ROA_QUEST>> *>(VT_QUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DAY) &&
           VerifyOffset(verifier, VT_QUESTS) &&
           verifier.Verify(quests()) &&
           verifier.VerifyVectorOfTables(quests()) &&
           verifier.EndTable();
  }
  ROA_CHAPTER_QUESTST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROA_CHAPTER_QUESTST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROA_CHAPTER_QUESTS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_CHAPTER_QUESTST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROA_CHAPTER_QUESTSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_day(int32_t day) {
    fbb_.AddElement<int32_t>(ROA_CHAPTER_QUESTS::VT_DAY, day, 0);
  }
  void add_quests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ROA_QUEST>>> quests) {
    fbb_.AddOffset(ROA_CHAPTER_QUESTS::VT_QUESTS, quests);
  }
  explicit ROA_CHAPTER_QUESTSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROA_CHAPTER_QUESTSBuilder &operator=(const ROA_CHAPTER_QUESTSBuilder &);
  flatbuffers::Offset<ROA_CHAPTER_QUESTS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROA_CHAPTER_QUESTS>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROA_CHAPTER_QUESTS> CreateROA_CHAPTER_QUESTS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t day = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ROA_QUEST>>> quests = 0) {
  ROA_CHAPTER_QUESTSBuilder builder_(_fbb);
  builder_.add_quests(quests);
  builder_.add_day(day);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROA_CHAPTER_QUESTS> CreateROA_CHAPTER_QUESTSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t day = 0,
    const std::vector<flatbuffers::Offset<ROA_QUEST>> *quests = nullptr) {
  return OVERLORD::STRUCT::CreateROA_CHAPTER_QUESTS(
      _fbb,
      day,
      quests ? _fbb.CreateVector<flatbuffers::Offset<ROA_QUEST>>(*quests) : 0);
}

flatbuffers::Offset<ROA_CHAPTER_QUESTS> CreateROA_CHAPTER_QUESTS(flatbuffers::FlatBufferBuilder &_fbb, const ROA_CHAPTER_QUESTST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ROA_ADVENTURET : public flatbuffers::NativeTable {
  typedef ROA_ADVENTURE TableType;
  int32_t chapter;
  int32_t day;
  std::string rewardKey;
  bool rewarded;
  bool complete;
  std::vector<std::unique_ptr<ROA_CHAPTER_QUESTST>> days;
  ROA_ADVENTURET()
      : chapter(0),
        day(0),
        rewarded(false),
        complete(false) {
  }
};

struct ROA_ADVENTURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROA_ADVENTURET NativeTableType;
  enum {
    VT_CHAPTER = 4,
    VT_DAY = 6,
    VT_REWARDKEY = 8,
    VT_REWARDED = 10,
    VT_COMPLETE = 12,
    VT_DAYS = 14
  };
  int32_t chapter() const {
    return GetField<int32_t>(VT_CHAPTER, 0);
  }
  int32_t day() const {
    return GetField<int32_t>(VT_DAY, 0);
  }
  const flatbuffers::String *rewardKey() const {
    return GetPointer<const flatbuffers::String *>(VT_REWARDKEY);
  }
  bool rewarded() const {
    return GetField<uint8_t>(VT_REWARDED, 0) != 0;
  }
  bool complete() const {
    return GetField<uint8_t>(VT_COMPLETE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>> *days() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>> *>(VT_DAYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHAPTER) &&
           VerifyField<int32_t>(verifier, VT_DAY) &&
           VerifyOffset(verifier, VT_REWARDKEY) &&
           verifier.Verify(rewardKey()) &&
           VerifyField<uint8_t>(verifier, VT_REWARDED) &&
           VerifyField<uint8_t>(verifier, VT_COMPLETE) &&
           VerifyOffset(verifier, VT_DAYS) &&
           verifier.Verify(days()) &&
           verifier.VerifyVectorOfTables(days()) &&
           verifier.EndTable();
  }
  ROA_ADVENTURET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ROA_ADVENTURET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ROA_ADVENTURE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_ADVENTURET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ROA_ADVENTUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_chapter(int32_t chapter) {
    fbb_.AddElement<int32_t>(ROA_ADVENTURE::VT_CHAPTER, chapter, 0);
  }
  void add_day(int32_t day) {
    fbb_.AddElement<int32_t>(ROA_ADVENTURE::VT_DAY, day, 0);
  }
  void add_rewardKey(flatbuffers::Offset<flatbuffers::String> rewardKey) {
    fbb_.AddOffset(ROA_ADVENTURE::VT_REWARDKEY, rewardKey);
  }
  void add_rewarded(bool rewarded) {
    fbb_.AddElement<uint8_t>(ROA_ADVENTURE::VT_REWARDED, static_cast<uint8_t>(rewarded), 0);
  }
  void add_complete(bool complete) {
    fbb_.AddElement<uint8_t>(ROA_ADVENTURE::VT_COMPLETE, static_cast<uint8_t>(complete), 0);
  }
  void add_days(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>>> days) {
    fbb_.AddOffset(ROA_ADVENTURE::VT_DAYS, days);
  }
  explicit ROA_ADVENTUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROA_ADVENTUREBuilder &operator=(const ROA_ADVENTUREBuilder &);
  flatbuffers::Offset<ROA_ADVENTURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROA_ADVENTURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROA_ADVENTURE> CreateROA_ADVENTURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chapter = 0,
    int32_t day = 0,
    flatbuffers::Offset<flatbuffers::String> rewardKey = 0,
    bool rewarded = false,
    bool complete = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>>> days = 0) {
  ROA_ADVENTUREBuilder builder_(_fbb);
  builder_.add_days(days);
  builder_.add_rewardKey(rewardKey);
  builder_.add_day(day);
  builder_.add_chapter(chapter);
  builder_.add_complete(complete);
  builder_.add_rewarded(rewarded);
  return builder_.Finish();
}

inline flatbuffers::Offset<ROA_ADVENTURE> CreateROA_ADVENTUREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t chapter = 0,
    int32_t day = 0,
    const char *rewardKey = nullptr,
    bool rewarded = false,
    bool complete = false,
    const std::vector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>> *days = nullptr) {
  return OVERLORD::STRUCT::CreateROA_ADVENTURE(
      _fbb,
      chapter,
      day,
      rewardKey ? _fbb.CreateString(rewardKey) : 0,
      rewarded,
      complete,
      days ? _fbb.CreateVector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>>(*days) : 0);
}

flatbuffers::Offset<ROA_ADVENTURE> CreateROA_ADVENTURE(flatbuffers::FlatBufferBuilder &_fbb, const ROA_ADVENTURET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BILLING_PREPARE_KAKAOPAYT : public flatbuffers::NativeTable {
  typedef BILLING_PREPARE_KAKAOPAY TableType;
  std::string tid;
  std::string next_redirect_app_url;
  std::string next_redirect_mobile_url;
  std::string next_redirect_pc_url;
  std::string android_app_scheme;
  std::string ios_app_scheme;
  BILLING_PREPARE_KAKAOPAYT() {
  }
};

struct BILLING_PREPARE_KAKAOPAY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BILLING_PREPARE_KAKAOPAYT NativeTableType;
  enum {
    VT_TID = 4,
    VT_NEXT_REDIRECT_APP_URL = 6,
    VT_NEXT_REDIRECT_MOBILE_URL = 8,
    VT_NEXT_REDIRECT_PC_URL = 10,
    VT_ANDROID_APP_SCHEME = 12,
    VT_IOS_APP_SCHEME = 14
  };
  const flatbuffers::String *tid() const {
    return GetPointer<const flatbuffers::String *>(VT_TID);
  }
  const flatbuffers::String *next_redirect_app_url() const {
    return GetPointer<const flatbuffers::String *>(VT_NEXT_REDIRECT_APP_URL);
  }
  const flatbuffers::String *next_redirect_mobile_url() const {
    return GetPointer<const flatbuffers::String *>(VT_NEXT_REDIRECT_MOBILE_URL);
  }
  const flatbuffers::String *next_redirect_pc_url() const {
    return GetPointer<const flatbuffers::String *>(VT_NEXT_REDIRECT_PC_URL);
  }
  const flatbuffers::String *android_app_scheme() const {
    return GetPointer<const flatbuffers::String *>(VT_ANDROID_APP_SCHEME);
  }
  const flatbuffers::String *ios_app_scheme() const {
    return GetPointer<const flatbuffers::String *>(VT_IOS_APP_SCHEME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TID) &&
           verifier.Verify(tid()) &&
           VerifyOffset(verifier, VT_NEXT_REDIRECT_APP_URL) &&
           verifier.Verify(next_redirect_app_url()) &&
           VerifyOffset(verifier, VT_NEXT_REDIRECT_MOBILE_URL) &&
           verifier.Verify(next_redirect_mobile_url()) &&
           VerifyOffset(verifier, VT_NEXT_REDIRECT_PC_URL) &&
           verifier.Verify(next_redirect_pc_url()) &&
           VerifyOffset(verifier, VT_ANDROID_APP_SCHEME) &&
           verifier.Verify(android_app_scheme()) &&
           VerifyOffset(verifier, VT_IOS_APP_SCHEME) &&
           verifier.Verify(ios_app_scheme()) &&
           verifier.EndTable();
  }
  BILLING_PREPARE_KAKAOPAYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BILLING_PREPARE_KAKAOPAYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_PREPARE_KAKAOPAYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BILLING_PREPARE_KAKAOPAYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tid(flatbuffers::Offset<flatbuffers::String> tid) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_TID, tid);
  }
  void add_next_redirect_app_url(flatbuffers::Offset<flatbuffers::String> next_redirect_app_url) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_NEXT_REDIRECT_APP_URL, next_redirect_app_url);
  }
  void add_next_redirect_mobile_url(flatbuffers::Offset<flatbuffers::String> next_redirect_mobile_url) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_NEXT_REDIRECT_MOBILE_URL, next_redirect_mobile_url);
  }
  void add_next_redirect_pc_url(flatbuffers::Offset<flatbuffers::String> next_redirect_pc_url) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_NEXT_REDIRECT_PC_URL, next_redirect_pc_url);
  }
  void add_android_app_scheme(flatbuffers::Offset<flatbuffers::String> android_app_scheme) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_ANDROID_APP_SCHEME, android_app_scheme);
  }
  void add_ios_app_scheme(flatbuffers::Offset<flatbuffers::String> ios_app_scheme) {
    fbb_.AddOffset(BILLING_PREPARE_KAKAOPAY::VT_IOS_APP_SCHEME, ios_app_scheme);
  }
  explicit BILLING_PREPARE_KAKAOPAYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BILLING_PREPARE_KAKAOPAYBuilder &operator=(const BILLING_PREPARE_KAKAOPAYBuilder &);
  flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY>(end);
    return o;
  }
};

inline flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> CreateBILLING_PREPARE_KAKAOPAY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> tid = 0,
    flatbuffers::Offset<flatbuffers::String> next_redirect_app_url = 0,
    flatbuffers::Offset<flatbuffers::String> next_redirect_mobile_url = 0,
    flatbuffers::Offset<flatbuffers::String> next_redirect_pc_url = 0,
    flatbuffers::Offset<flatbuffers::String> android_app_scheme = 0,
    flatbuffers::Offset<flatbuffers::String> ios_app_scheme = 0) {
  BILLING_PREPARE_KAKAOPAYBuilder builder_(_fbb);
  builder_.add_ios_app_scheme(ios_app_scheme);
  builder_.add_android_app_scheme(android_app_scheme);
  builder_.add_next_redirect_pc_url(next_redirect_pc_url);
  builder_.add_next_redirect_mobile_url(next_redirect_mobile_url);
  builder_.add_next_redirect_app_url(next_redirect_app_url);
  builder_.add_tid(tid);
  return builder_.Finish();
}

inline flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> CreateBILLING_PREPARE_KAKAOPAYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *tid = nullptr,
    const char *next_redirect_app_url = nullptr,
    const char *next_redirect_mobile_url = nullptr,
    const char *next_redirect_pc_url = nullptr,
    const char *android_app_scheme = nullptr,
    const char *ios_app_scheme = nullptr) {
  return OVERLORD::STRUCT::CreateBILLING_PREPARE_KAKAOPAY(
      _fbb,
      tid ? _fbb.CreateString(tid) : 0,
      next_redirect_app_url ? _fbb.CreateString(next_redirect_app_url) : 0,
      next_redirect_mobile_url ? _fbb.CreateString(next_redirect_mobile_url) : 0,
      next_redirect_pc_url ? _fbb.CreateString(next_redirect_pc_url) : 0,
      android_app_scheme ? _fbb.CreateString(android_app_scheme) : 0,
      ios_app_scheme ? _fbb.CreateString(ios_app_scheme) : 0);
}

flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> CreateBILLING_PREPARE_KAKAOPAY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_PREPARE_KAKAOPAYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REALTIME_REWARDT : public flatbuffers::NativeTable {
  typedef REALTIME_REWARD TableType;
  std::vector<std::unique_ptr<REWARDT>> rewards;
  REALTIME_REWARDT() {
  }
};

struct REALTIME_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REALTIME_REWARDT NativeTableType;
  enum {
    VT_REWARDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  REALTIME_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REALTIME_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REALTIME_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REALTIME_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards) {
    fbb_.AddOffset(REALTIME_REWARD::VT_REWARDS, rewards);
  }
  explicit REALTIME_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REALTIME_REWARDBuilder &operator=(const REALTIME_REWARDBuilder &);
  flatbuffers::Offset<REALTIME_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REALTIME_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<REALTIME_REWARD> CreateREALTIME_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards = 0) {
  REALTIME_REWARDBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  return builder_.Finish();
}

inline flatbuffers::Offset<REALTIME_REWARD> CreateREALTIME_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<REWARD>> *rewards = nullptr) {
  return OVERLORD::STRUCT::CreateREALTIME_REWARD(
      _fbb,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<REALTIME_REWARD> CreateREALTIME_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REALTIME_BG_REWARDT : public flatbuffers::NativeTable {
  typedef REALTIME_BG_REWARD TableType;
  std::vector<std::unique_ptr<REWARDT>> pouch;
  std::vector<std::unique_ptr<REWARDT>> rank;
  REALTIME_BG_REWARDT() {
  }
};

struct REALTIME_BG_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REALTIME_BG_REWARDT NativeTableType;
  enum {
    VT_POUCH = 4,
    VT_RANK = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *pouch() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_POUCH);
  }
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *rank() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_RANK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POUCH) &&
           verifier.Verify(pouch()) &&
           verifier.VerifyVectorOfTables(pouch()) &&
           VerifyOffset(verifier, VT_RANK) &&
           verifier.Verify(rank()) &&
           verifier.VerifyVectorOfTables(rank()) &&
           verifier.EndTable();
  }
  REALTIME_BG_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REALTIME_BG_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REALTIME_BG_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_BG_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REALTIME_BG_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pouch(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> pouch) {
    fbb_.AddOffset(REALTIME_BG_REWARD::VT_POUCH, pouch);
  }
  void add_rank(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rank) {
    fbb_.AddOffset(REALTIME_BG_REWARD::VT_RANK, rank);
  }
  explicit REALTIME_BG_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REALTIME_BG_REWARDBuilder &operator=(const REALTIME_BG_REWARDBuilder &);
  flatbuffers::Offset<REALTIME_BG_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REALTIME_BG_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<REALTIME_BG_REWARD> CreateREALTIME_BG_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> pouch = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rank = 0) {
  REALTIME_BG_REWARDBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_pouch(pouch);
  return builder_.Finish();
}

inline flatbuffers::Offset<REALTIME_BG_REWARD> CreateREALTIME_BG_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<REWARD>> *pouch = nullptr,
    const std::vector<flatbuffers::Offset<REWARD>> *rank = nullptr) {
  return OVERLORD::STRUCT::CreateREALTIME_BG_REWARD(
      _fbb,
      pouch ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*pouch) : 0,
      rank ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*rank) : 0);
}

flatbuffers::Offset<REALTIME_BG_REWARD> CreateREALTIME_BG_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_BG_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_RECORDT : public flatbuffers::NativeTable {
  typedef ACCOUNT_RECORD TableType;
  std::string name;
  int32_t winCount;
  int32_t totalCount;
  ACCOUNT_RECORDT()
      : winCount(0),
        totalCount(0) {
  }
};

struct ACCOUNT_RECORD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_RECORDT NativeTableType;
  enum {
    VT_NAME = 4,
    VT_WINCOUNT = 6,
    VT_TOTALCOUNT = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  int32_t winCount() const {
    return GetField<int32_t>(VT_WINCOUNT, 0);
  }
  int32_t totalCount() const {
    return GetField<int32_t>(VT_TOTALCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_WINCOUNT) &&
           VerifyField<int32_t>(verifier, VT_TOTALCOUNT) &&
           verifier.EndTable();
  }
  ACCOUNT_RECORDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_RECORDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_RECORD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_RECORDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_RECORDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ACCOUNT_RECORD::VT_NAME, name);
  }
  void add_winCount(int32_t winCount) {
    fbb_.AddElement<int32_t>(ACCOUNT_RECORD::VT_WINCOUNT, winCount, 0);
  }
  void add_totalCount(int32_t totalCount) {
    fbb_.AddElement<int32_t>(ACCOUNT_RECORD::VT_TOTALCOUNT, totalCount, 0);
  }
  explicit ACCOUNT_RECORDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_RECORDBuilder &operator=(const ACCOUNT_RECORDBuilder &);
  flatbuffers::Offset<ACCOUNT_RECORD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_RECORD>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_RECORD> CreateACCOUNT_RECORD(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t winCount = 0,
    int32_t totalCount = 0) {
  ACCOUNT_RECORDBuilder builder_(_fbb);
  builder_.add_totalCount(totalCount);
  builder_.add_winCount(winCount);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_RECORD> CreateACCOUNT_RECORDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t winCount = 0,
    int32_t totalCount = 0) {
  return OVERLORD::STRUCT::CreateACCOUNT_RECORD(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      winCount,
      totalCount);
}

flatbuffers::Offset<ACCOUNT_RECORD> CreateACCOUNT_RECORD(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_RECORDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_USAGET : public flatbuffers::NativeTable {
  typedef HERO_USAGE TableType;
  std::string GradeID;
  int32_t count;
  HERO_USAGET()
      : count(0) {
  }
};

struct HERO_USAGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_USAGET NativeTableType;
  enum {
    VT_GRADEID = 4,
    VT_COUNT = 6
  };
  const flatbuffers::String *GradeID() const {
    return GetPointer<const flatbuffers::String *>(VT_GRADEID);
  }
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRADEID) &&
           verifier.Verify(GradeID()) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           verifier.EndTable();
  }
  HERO_USAGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_USAGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_USAGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_USAGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_GradeID(flatbuffers::Offset<flatbuffers::String> GradeID) {
    fbb_.AddOffset(HERO_USAGE::VT_GRADEID, GradeID);
  }
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(HERO_USAGE::VT_COUNT, count, 0);
  }
  explicit HERO_USAGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_USAGEBuilder &operator=(const HERO_USAGEBuilder &);
  flatbuffers::Offset<HERO_USAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_USAGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_USAGE> CreateHERO_USAGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> GradeID = 0,
    int32_t count = 0) {
  HERO_USAGEBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_GradeID(GradeID);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_USAGE> CreateHERO_USAGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *GradeID = nullptr,
    int32_t count = 0) {
  return OVERLORD::STRUCT::CreateHERO_USAGE(
      _fbb,
      GradeID ? _fbb.CreateString(GradeID) : 0,
      count);
}

flatbuffers::Offset<HERO_USAGE> CreateHERO_USAGE(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct HERO_USAGE_TABT : public flatbuffers::NativeTable {
  typedef HERO_USAGE_TAB TableType;
  int32_t tab;
  std::vector<std::unique_ptr<HERO_USAGET>> usages;
  HERO_USAGE_TABT()
      : tab(0) {
  }
};

struct HERO_USAGE_TAB FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HERO_USAGE_TABT NativeTableType;
  enum {
    VT_TAB = 4,
    VT_USAGES = 6
  };
  int32_t tab() const {
    return GetField<int32_t>(VT_TAB, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<HERO_USAGE>> *usages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<HERO_USAGE>> *>(VT_USAGES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TAB) &&
           VerifyOffset(verifier, VT_USAGES) &&
           verifier.Verify(usages()) &&
           verifier.VerifyVectorOfTables(usages()) &&
           verifier.EndTable();
  }
  HERO_USAGE_TABT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(HERO_USAGE_TABT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<HERO_USAGE_TAB> Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGE_TABT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct HERO_USAGE_TABBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tab(int32_t tab) {
    fbb_.AddElement<int32_t>(HERO_USAGE_TAB::VT_TAB, tab, 0);
  }
  void add_usages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO_USAGE>>> usages) {
    fbb_.AddOffset(HERO_USAGE_TAB::VT_USAGES, usages);
  }
  explicit HERO_USAGE_TABBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HERO_USAGE_TABBuilder &operator=(const HERO_USAGE_TABBuilder &);
  flatbuffers::Offset<HERO_USAGE_TAB> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HERO_USAGE_TAB>(end);
    return o;
  }
};

inline flatbuffers::Offset<HERO_USAGE_TAB> CreateHERO_USAGE_TAB(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tab = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<HERO_USAGE>>> usages = 0) {
  HERO_USAGE_TABBuilder builder_(_fbb);
  builder_.add_usages(usages);
  builder_.add_tab(tab);
  return builder_.Finish();
}

inline flatbuffers::Offset<HERO_USAGE_TAB> CreateHERO_USAGE_TABDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tab = 0,
    const std::vector<flatbuffers::Offset<HERO_USAGE>> *usages = nullptr) {
  return OVERLORD::STRUCT::CreateHERO_USAGE_TAB(
      _fbb,
      tab,
      usages ? _fbb.CreateVector<flatbuffers::Offset<HERO_USAGE>>(*usages) : 0);
}

flatbuffers::Offset<HERO_USAGE_TAB> CreateHERO_USAGE_TAB(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGE_TABT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CRUSADER_HERO_HPT : public flatbuffers::NativeTable {
  typedef CRUSADER_HERO_HP TableType;
  std::string heroUD;
  int32_t hp;
  CRUSADER_HERO_HPT()
      : hp(0) {
  }
};

struct CRUSADER_HERO_HP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CRUSADER_HERO_HPT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_HP = 6
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           verifier.EndTable();
  }
  CRUSADER_HERO_HPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CRUSADER_HERO_HPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CRUSADER_HERO_HP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CRUSADER_HERO_HPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CRUSADER_HERO_HPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(CRUSADER_HERO_HP::VT_HEROUD, heroUD);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CRUSADER_HERO_HP::VT_HP, hp, 0);
  }
  explicit CRUSADER_HERO_HPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CRUSADER_HERO_HPBuilder &operator=(const CRUSADER_HERO_HPBuilder &);
  flatbuffers::Offset<CRUSADER_HERO_HP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CRUSADER_HERO_HP>(end);
    return o;
  }
};

inline flatbuffers::Offset<CRUSADER_HERO_HP> CreateCRUSADER_HERO_HP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    int32_t hp = 0) {
  CRUSADER_HERO_HPBuilder builder_(_fbb);
  builder_.add_hp(hp);
  builder_.add_heroUD(heroUD);
  return builder_.Finish();
}

inline flatbuffers::Offset<CRUSADER_HERO_HP> CreateCRUSADER_HERO_HPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    int32_t hp = 0) {
  return OVERLORD::STRUCT::CreateCRUSADER_HERO_HP(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      hp);
}

flatbuffers::Offset<CRUSADER_HERO_HP> CreateCRUSADER_HERO_HP(flatbuffers::FlatBufferBuilder &_fbb, const CRUSADER_HERO_HPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TREASURET : public flatbuffers::NativeTable {
  typedef TREASURE TableType;
  std::string treasureId;
  int32_t left;
  int32_t key;
  TREASURET()
      : left(0),
        key(0) {
  }
};

struct TREASURE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TREASURET NativeTableType;
  enum {
    VT_TREASUREID = 4,
    VT_LEFT = 6,
    VT_KEY = 8
  };
  const flatbuffers::String *treasureId() const {
    return GetPointer<const flatbuffers::String *>(VT_TREASUREID);
  }
  int32_t left() const {
    return GetField<int32_t>(VT_LEFT, 0);
  }
  int32_t key() const {
    return GetField<int32_t>(VT_KEY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TREASUREID) &&
           verifier.Verify(treasureId()) &&
           VerifyField<int32_t>(verifier, VT_LEFT) &&
           VerifyField<int32_t>(verifier, VT_KEY) &&
           verifier.EndTable();
  }
  TREASURET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TREASURET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TREASURE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TREASUREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_treasureId(flatbuffers::Offset<flatbuffers::String> treasureId) {
    fbb_.AddOffset(TREASURE::VT_TREASUREID, treasureId);
  }
  void add_left(int32_t left) {
    fbb_.AddElement<int32_t>(TREASURE::VT_LEFT, left, 0);
  }
  void add_key(int32_t key) {
    fbb_.AddElement<int32_t>(TREASURE::VT_KEY, key, 0);
  }
  explicit TREASUREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TREASUREBuilder &operator=(const TREASUREBuilder &);
  flatbuffers::Offset<TREASURE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TREASURE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TREASURE> CreateTREASURE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> treasureId = 0,
    int32_t left = 0,
    int32_t key = 0) {
  TREASUREBuilder builder_(_fbb);
  builder_.add_key(key);
  builder_.add_left(left);
  builder_.add_treasureId(treasureId);
  return builder_.Finish();
}

inline flatbuffers::Offset<TREASURE> CreateTREASUREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *treasureId = nullptr,
    int32_t left = 0,
    int32_t key = 0) {
  return OVERLORD::STRUCT::CreateTREASURE(
      _fbb,
      treasureId ? _fbb.CreateString(treasureId) : 0,
      left,
      key);
}

flatbuffers::Offset<TREASURE> CreateTREASURE(flatbuffers::FlatBufferBuilder &_fbb, const TREASURET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BG_USERT : public flatbuffers::NativeTable {
  typedef BG_USER TableType;
  int32_t kId;
  std::string nick;
  int32_t level;
  int32_t point;
  int32_t rank;
  BG_USERT()
      : kId(0),
        level(0),
        point(0),
        rank(0) {
  }
};

struct BG_USER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BG_USERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_LEVEL = 8,
    VT_POINT = 10,
    VT_RANK = 12
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           verifier.EndTable();
  }
  BG_USERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BG_USERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BG_USER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BG_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BG_USERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(BG_USER::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(BG_USER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(BG_USER::VT_LEVEL, level, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(BG_USER::VT_POINT, point, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(BG_USER::VT_RANK, rank, 0);
  }
  explicit BG_USERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BG_USERBuilder &operator=(const BG_USERBuilder &);
  flatbuffers::Offset<BG_USER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BG_USER>(end);
    return o;
  }
};

inline flatbuffers::Offset<BG_USER> CreateBG_USER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    int32_t point = 0,
    int32_t rank = 0) {
  BG_USERBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_point(point);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<BG_USER> CreateBG_USERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t level = 0,
    int32_t point = 0,
    int32_t rank = 0) {
  return OVERLORD::STRUCT::CreateBG_USER(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      point,
      rank);
}

flatbuffers::Offset<BG_USER> CreateBG_USER(flatbuffers::FlatBufferBuilder &_fbb, const BG_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FLOOR_QUEST_STATUST : public flatbuffers::NativeTable {
  typedef FLOOR_QUEST_STATUS TableType;
  int32_t questId;
  int32_t progress;
  FLOOR_QUEST_STATUST()
      : questId(0),
        progress(0) {
  }
};

struct FLOOR_QUEST_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOOR_QUEST_STATUST NativeTableType;
  enum {
    VT_QUESTID = 4,
    VT_PROGRESS = 6
  };
  int32_t questId() const {
    return GetField<int32_t>(VT_QUESTID, 0);
  }
  int32_t progress() const {
    return GetField<int32_t>(VT_PROGRESS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_QUESTID) &&
           VerifyField<int32_t>(verifier, VT_PROGRESS) &&
           verifier.EndTable();
  }
  FLOOR_QUEST_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FLOOR_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FLOOR_QUEST_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FLOOR_QUEST_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_questId(int32_t questId) {
    fbb_.AddElement<int32_t>(FLOOR_QUEST_STATUS::VT_QUESTID, questId, 0);
  }
  void add_progress(int32_t progress) {
    fbb_.AddElement<int32_t>(FLOOR_QUEST_STATUS::VT_PROGRESS, progress, 0);
  }
  explicit FLOOR_QUEST_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FLOOR_QUEST_STATUSBuilder &operator=(const FLOOR_QUEST_STATUSBuilder &);
  flatbuffers::Offset<FLOOR_QUEST_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR_QUEST_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR_QUEST_STATUS> CreateFLOOR_QUEST_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t questId = 0,
    int32_t progress = 0) {
  FLOOR_QUEST_STATUSBuilder builder_(_fbb);
  builder_.add_progress(progress);
  builder_.add_questId(questId);
  return builder_.Finish();
}

flatbuffers::Offset<FLOOR_QUEST_STATUS> CreateFLOOR_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FLOOR_MISSIONT : public flatbuffers::NativeTable {
  typedef FLOOR_MISSION TableType;
  std::string id;
  std::string stageId;
  OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE cls;
  int32_t rewardAmt;
  int32_t goal;
  int32_t current;
  FLOOR_MISSIONT()
      : cls(OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER),
        rewardAmt(0),
        goal(0),
        current(0) {
  }
};

struct FLOOR_MISSION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOOR_MISSIONT NativeTableType;
  enum {
    VT_ID = 4,
    VT_STAGEID = 6,
    VT_CLS = 8,
    VT_REWARDAMT = 10,
    VT_GOAL = 12,
    VT_CURRENT = 14
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE cls() const {
    return static_cast<OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE>(GetField<int8_t>(VT_CLS, 0));
  }
  int32_t rewardAmt() const {
    return GetField<int32_t>(VT_REWARDAMT, 0);
  }
  int32_t goal() const {
    return GetField<int32_t>(VT_GOAL, 0);
  }
  int32_t current() const {
    return GetField<int32_t>(VT_CURRENT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           VerifyField<int8_t>(verifier, VT_CLS) &&
           VerifyField<int32_t>(verifier, VT_REWARDAMT) &&
           VerifyField<int32_t>(verifier, VT_GOAL) &&
           VerifyField<int32_t>(verifier, VT_CURRENT) &&
           verifier.EndTable();
  }
  FLOOR_MISSIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FLOOR_MISSIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FLOOR_MISSION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FLOOR_MISSIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(FLOOR_MISSION::VT_ID, id);
  }
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(FLOOR_MISSION::VT_STAGEID, stageId);
  }
  void add_cls(OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE cls) {
    fbb_.AddElement<int8_t>(FLOOR_MISSION::VT_CLS, static_cast<int8_t>(cls), 0);
  }
  void add_rewardAmt(int32_t rewardAmt) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION::VT_REWARDAMT, rewardAmt, 0);
  }
  void add_goal(int32_t goal) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION::VT_GOAL, goal, 0);
  }
  void add_current(int32_t current) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION::VT_CURRENT, current, 0);
  }
  explicit FLOOR_MISSIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FLOOR_MISSIONBuilder &operator=(const FLOOR_MISSIONBuilder &);
  flatbuffers::Offset<FLOOR_MISSION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR_MISSION>(end);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR_MISSION> CreateFLOOR_MISSION(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> stageId = 0,
    OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE cls = OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER,
    int32_t rewardAmt = 0,
    int32_t goal = 0,
    int32_t current = 0) {
  FLOOR_MISSIONBuilder builder_(_fbb);
  builder_.add_current(current);
  builder_.add_goal(goal);
  builder_.add_rewardAmt(rewardAmt);
  builder_.add_stageId(stageId);
  builder_.add_id(id);
  builder_.add_cls(cls);
  return builder_.Finish();
}

inline flatbuffers::Offset<FLOOR_MISSION> CreateFLOOR_MISSIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *stageId = nullptr,
    OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE cls = OVERLORD::ENUM::FLOOR_MISSION_CLASS_CONDITION_TYPE_TANKER,
    int32_t rewardAmt = 0,
    int32_t goal = 0,
    int32_t current = 0) {
  return OVERLORD::STRUCT::CreateFLOOR_MISSION(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      stageId ? _fbb.CreateString(stageId) : 0,
      cls,
      rewardAmt,
      goal,
      current);
}

flatbuffers::Offset<FLOOR_MISSION> CreateFLOOR_MISSION(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct FLOOR_MISSION_STATUST : public flatbuffers::NativeTable {
  typedef FLOOR_MISSION_STATUS TableType;
  int32_t floor;
  std::vector<std::unique_ptr<FLOOR_MISSIONT>> missions;
  int32_t step;
  int32_t timeleft;
  FLOOR_MISSION_STATUST()
      : floor(0),
        step(0),
        timeleft(0) {
  }
};

struct FLOOR_MISSION_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FLOOR_MISSION_STATUST NativeTableType;
  enum {
    VT_FLOOR = 4,
    VT_MISSIONS = 6,
    VT_STEP = 8,
    VT_TIMELEFT = 10
  };
  int32_t floor() const {
    return GetField<int32_t>(VT_FLOOR, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FLOOR_MISSION>> *missions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FLOOR_MISSION>> *>(VT_MISSIONS);
  }
  int32_t step() const {
    return GetField<int32_t>(VT_STEP, 0);
  }
  int32_t timeleft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FLOOR) &&
           VerifyOffset(verifier, VT_MISSIONS) &&
           verifier.Verify(missions()) &&
           verifier.VerifyVectorOfTables(missions()) &&
           VerifyField<int32_t>(verifier, VT_STEP) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           verifier.EndTable();
  }
  FLOOR_MISSION_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FLOOR_MISSION_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<FLOOR_MISSION_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSION_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FLOOR_MISSION_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_floor(int32_t floor) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION_STATUS::VT_FLOOR, floor, 0);
  }
  void add_missions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FLOOR_MISSION>>> missions) {
    fbb_.AddOffset(FLOOR_MISSION_STATUS::VT_MISSIONS, missions);
  }
  void add_step(int32_t step) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION_STATUS::VT_STEP, step, 0);
  }
  void add_timeleft(int32_t timeleft) {
    fbb_.AddElement<int32_t>(FLOOR_MISSION_STATUS::VT_TIMELEFT, timeleft, 0);
  }
  explicit FLOOR_MISSION_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FLOOR_MISSION_STATUSBuilder &operator=(const FLOOR_MISSION_STATUSBuilder &);
  flatbuffers::Offset<FLOOR_MISSION_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FLOOR_MISSION_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<FLOOR_MISSION_STATUS> CreateFLOOR_MISSION_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FLOOR_MISSION>>> missions = 0,
    int32_t step = 0,
    int32_t timeleft = 0) {
  FLOOR_MISSION_STATUSBuilder builder_(_fbb);
  builder_.add_timeleft(timeleft);
  builder_.add_step(step);
  builder_.add_missions(missions);
  builder_.add_floor(floor);
  return builder_.Finish();
}

inline flatbuffers::Offset<FLOOR_MISSION_STATUS> CreateFLOOR_MISSION_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t floor = 0,
    const std::vector<flatbuffers::Offset<FLOOR_MISSION>> *missions = nullptr,
    int32_t step = 0,
    int32_t timeleft = 0) {
  return OVERLORD::STRUCT::CreateFLOOR_MISSION_STATUS(
      _fbb,
      floor,
      missions ? _fbb.CreateVector<flatbuffers::Offset<FLOOR_MISSION>>(*missions) : 0,
      step,
      timeleft);
}

flatbuffers::Offset<FLOOR_MISSION_STATUS> CreateFLOOR_MISSION_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSION_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_STATUST : public flatbuffers::NativeTable {
  typedef TOWER_STATUS TableType;
  int32_t currentFloor;
  std::vector<int32_t> clearGrades;
  std::vector<int32_t> raidClearGrades;
  std::vector<bool> treasureBoxes;
  std::unique_ptr<FLOOR_QUEST_STATUST> floorQuestStatus;
  std::unique_ptr<FLOOR_MISSION_STATUST> floorMissionStatus;
  TOWER_STATUST()
      : currentFloor(1) {
  }
};

struct TOWER_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_STATUST NativeTableType;
  enum {
    VT_CURRENTFLOOR = 4,
    VT_CLEARGRADES = 6,
    VT_RAIDCLEARGRADES = 8,
    VT_TREASUREBOXES = 10,
    VT_FLOORQUESTSTATUS = 12,
    VT_FLOORMISSIONSTATUS = 14
  };
  int32_t currentFloor() const {
    return GetField<int32_t>(VT_CURRENTFLOOR, 1);
  }
  const flatbuffers::Vector<int32_t> *clearGrades() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLEARGRADES);
  }
  const flatbuffers::Vector<int32_t> *raidClearGrades() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_RAIDCLEARGRADES);
  }
  const flatbuffers::Vector<uint8_t> *treasureBoxes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TREASUREBOXES);
  }
  const FLOOR_QUEST_STATUS *floorQuestStatus() const {
    return GetPointer<const FLOOR_QUEST_STATUS *>(VT_FLOORQUESTSTATUS);
  }
  const FLOOR_MISSION_STATUS *floorMissionStatus() const {
    return GetPointer<const FLOOR_MISSION_STATUS *>(VT_FLOORMISSIONSTATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CURRENTFLOOR) &&
           VerifyOffset(verifier, VT_CLEARGRADES) &&
           verifier.Verify(clearGrades()) &&
           VerifyOffset(verifier, VT_RAIDCLEARGRADES) &&
           verifier.Verify(raidClearGrades()) &&
           VerifyOffset(verifier, VT_TREASUREBOXES) &&
           verifier.Verify(treasureBoxes()) &&
           VerifyOffset(verifier, VT_FLOORQUESTSTATUS) &&
           verifier.VerifyTable(floorQuestStatus()) &&
           VerifyOffset(verifier, VT_FLOORMISSIONSTATUS) &&
           verifier.VerifyTable(floorMissionStatus()) &&
           verifier.EndTable();
  }
  TOWER_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currentFloor(int32_t currentFloor) {
    fbb_.AddElement<int32_t>(TOWER_STATUS::VT_CURRENTFLOOR, currentFloor, 1);
  }
  void add_clearGrades(flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades) {
    fbb_.AddOffset(TOWER_STATUS::VT_CLEARGRADES, clearGrades);
  }
  void add_raidClearGrades(flatbuffers::Offset<flatbuffers::Vector<int32_t>> raidClearGrades) {
    fbb_.AddOffset(TOWER_STATUS::VT_RAIDCLEARGRADES, raidClearGrades);
  }
  void add_treasureBoxes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> treasureBoxes) {
    fbb_.AddOffset(TOWER_STATUS::VT_TREASUREBOXES, treasureBoxes);
  }
  void add_floorQuestStatus(flatbuffers::Offset<FLOOR_QUEST_STATUS> floorQuestStatus) {
    fbb_.AddOffset(TOWER_STATUS::VT_FLOORQUESTSTATUS, floorQuestStatus);
  }
  void add_floorMissionStatus(flatbuffers::Offset<FLOOR_MISSION_STATUS> floorMissionStatus) {
    fbb_.AddOffset(TOWER_STATUS::VT_FLOORMISSIONSTATUS, floorMissionStatus);
  }
  explicit TOWER_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_STATUSBuilder &operator=(const TOWER_STATUSBuilder &);
  flatbuffers::Offset<TOWER_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t currentFloor = 1,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> raidClearGrades = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> treasureBoxes = 0,
    flatbuffers::Offset<FLOOR_QUEST_STATUS> floorQuestStatus = 0,
    flatbuffers::Offset<FLOOR_MISSION_STATUS> floorMissionStatus = 0) {
  TOWER_STATUSBuilder builder_(_fbb);
  builder_.add_floorMissionStatus(floorMissionStatus);
  builder_.add_floorQuestStatus(floorQuestStatus);
  builder_.add_treasureBoxes(treasureBoxes);
  builder_.add_raidClearGrades(raidClearGrades);
  builder_.add_clearGrades(clearGrades);
  builder_.add_currentFloor(currentFloor);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t currentFloor = 1,
    const std::vector<int32_t> *clearGrades = nullptr,
    const std::vector<int32_t> *raidClearGrades = nullptr,
    const std::vector<uint8_t> *treasureBoxes = nullptr,
    flatbuffers::Offset<FLOOR_QUEST_STATUS> floorQuestStatus = 0,
    flatbuffers::Offset<FLOOR_MISSION_STATUS> floorMissionStatus = 0) {
  return OVERLORD::STRUCT::CreateTOWER_STATUS(
      _fbb,
      currentFloor,
      clearGrades ? _fbb.CreateVector<int32_t>(*clearGrades) : 0,
      raidClearGrades ? _fbb.CreateVector<int32_t>(*raidClearGrades) : 0,
      treasureBoxes ? _fbb.CreateVector<uint8_t>(*treasureBoxes) : 0,
      floorQuestStatus,
      floorMissionStatus);
}

flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BATTLE_USERT : public flatbuffers::NativeTable {
  typedef BATTLE_USER TableType;
  int32_t kId;
  std::string nick;
  int32_t level;
  std::vector<int32_t> ability;
  int32_t icon;
  std::string guild;
  std::vector<std::unique_ptr<EQUIPED_HEROT>> heros;
  std::unique_ptr<DECKST> decks;
  BATTLE_USERT()
      : kId(0),
        level(0),
        icon(1) {
  }
};

struct BATTLE_USER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BATTLE_USERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_LEVEL = 8,
    VT_ABILITY = 10,
    VT_ICON = 12,
    VT_GUILD = 14,
    VT_HEROS = 16,
    VT_DECKS = 18
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::Vector<int32_t> *ability() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ABILITY);
  }
  int32_t icon() const {
    return GetField<int32_t>(VT_ICON, 1);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>> *heros() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>> *>(VT_HEROS);
  }
  const DECKS *decks() const {
    return GetPointer<const DECKS *>(VT_DECKS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_ABILITY) &&
           verifier.Verify(ability()) &&
           VerifyField<int32_t>(verifier, VT_ICON) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyOffset(verifier, VT_HEROS) &&
           verifier.Verify(heros()) &&
           verifier.VerifyVectorOfTables(heros()) &&
           VerifyOffset(verifier, VT_DECKS) &&
           verifier.VerifyTable(decks()) &&
           verifier.EndTable();
  }
  BATTLE_USERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BATTLE_USERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BATTLE_USER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BATTLE_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BATTLE_USERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(BATTLE_USER::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(BATTLE_USER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(BATTLE_USER::VT_LEVEL, level, 0);
  }
  void add_ability(flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability) {
    fbb_.AddOffset(BATTLE_USER::VT_ABILITY, ability);
  }
  void add_icon(int32_t icon) {
    fbb_.AddElement<int32_t>(BATTLE_USER::VT_ICON, icon, 1);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(BATTLE_USER::VT_GUILD, guild);
  }
  void add_heros(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>>> heros) {
    fbb_.AddOffset(BATTLE_USER::VT_HEROS, heros);
  }
  void add_decks(flatbuffers::Offset<DECKS> decks) {
    fbb_.AddOffset(BATTLE_USER::VT_DECKS, decks);
  }
  explicit BATTLE_USERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BATTLE_USERBuilder &operator=(const BATTLE_USERBuilder &);
  flatbuffers::Offset<BATTLE_USER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BATTLE_USER>(end);
    return o;
  }
};

inline flatbuffers::Offset<BATTLE_USER> CreateBATTLE_USER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> ability = 0,
    int32_t icon = 1,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EQUIPED_HERO>>> heros = 0,
    flatbuffers::Offset<DECKS> decks = 0) {
  BATTLE_USERBuilder builder_(_fbb);
  builder_.add_decks(decks);
  builder_.add_heros(heros);
  builder_.add_guild(guild);
  builder_.add_icon(icon);
  builder_.add_ability(ability);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<BATTLE_USER> CreateBATTLE_USERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    int32_t level = 0,
    const std::vector<int32_t> *ability = nullptr,
    int32_t icon = 1,
    const char *guild = nullptr,
    const std::vector<flatbuffers::Offset<EQUIPED_HERO>> *heros = nullptr,
    flatbuffers::Offset<DECKS> decks = 0) {
  return OVERLORD::STRUCT::CreateBATTLE_USER(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      ability ? _fbb.CreateVector<int32_t>(*ability) : 0,
      icon,
      guild ? _fbb.CreateString(guild) : 0,
      heros ? _fbb.CreateVector<flatbuffers::Offset<EQUIPED_HERO>>(*heros) : 0,
      decks);
}

flatbuffers::Offset<BATTLE_USER> CreateBATTLE_USER(flatbuffers::FlatBufferBuilder &_fbb, const BATTLE_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_HISTORYT : public flatbuffers::NativeTable {
  typedef ARENA_HISTORY TableType;
  int32_t kId;
  bool isDefense;
  bool isWin;
  std::string nick;
  int32_t level;
  std::string guild;
  std::vector<std::string> heroIDs;
  int32_t power;
  int32_t deltaPoint;
  ARENA_HISTORYT()
      : kId(0),
        isDefense(true),
        isWin(true),
        level(0),
        power(0),
        deltaPoint(0) {
  }
};

struct ARENA_HISTORY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_HISTORYT NativeTableType;
  enum {
    VT_KID = 4,
    VT_ISDEFENSE = 6,
    VT_ISWIN = 8,
    VT_NICK = 10,
    VT_LEVEL = 12,
    VT_GUILD = 14,
    VT_HEROIDS = 16,
    VT_POWER = 18,
    VT_DELTAPOINT = 20
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool isDefense() const {
    return GetField<uint8_t>(VT_ISDEFENSE, 1) != 0;
  }
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 1) != 0;
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroIDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROIDS);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  int32_t deltaPoint() const {
    return GetField<int32_t>(VT_DELTAPOINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint8_t>(verifier, VT_ISDEFENSE) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyOffset(verifier, VT_HEROIDS) &&
           verifier.Verify(heroIDs()) &&
           verifier.VerifyVectorOfStrings(heroIDs()) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           VerifyField<int32_t>(verifier, VT_DELTAPOINT) &&
           verifier.EndTable();
  }
  ARENA_HISTORYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_HISTORY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_HISTORYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ARENA_HISTORY::VT_KID, kId, 0);
  }
  void add_isDefense(bool isDefense) {
    fbb_.AddElement<uint8_t>(ARENA_HISTORY::VT_ISDEFENSE, static_cast<uint8_t>(isDefense), 1);
  }
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(ARENA_HISTORY::VT_ISWIN, static_cast<uint8_t>(isWin), 1);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ARENA_HISTORY::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ARENA_HISTORY::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(ARENA_HISTORY::VT_GUILD, guild);
  }
  void add_heroIDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroIDs) {
    fbb_.AddOffset(ARENA_HISTORY::VT_HEROIDS, heroIDs);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(ARENA_HISTORY::VT_POWER, power, 0);
  }
  void add_deltaPoint(int32_t deltaPoint) {
    fbb_.AddElement<int32_t>(ARENA_HISTORY::VT_DELTAPOINT, deltaPoint, 0);
  }
  explicit ARENA_HISTORYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_HISTORYBuilder &operator=(const ARENA_HISTORYBuilder &);
  flatbuffers::Offset<ARENA_HISTORY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_HISTORY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_HISTORY> CreateARENA_HISTORY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    bool isDefense = true,
    bool isWin = true,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroIDs = 0,
    int32_t power = 0,
    int32_t deltaPoint = 0) {
  ARENA_HISTORYBuilder builder_(_fbb);
  builder_.add_deltaPoint(deltaPoint);
  builder_.add_power(power);
  builder_.add_heroIDs(heroIDs);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_isWin(isWin);
  builder_.add_isDefense(isDefense);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_HISTORY> CreateARENA_HISTORYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    bool isDefense = true,
    bool isWin = true,
    const char *nick = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroIDs = nullptr,
    int32_t power = 0,
    int32_t deltaPoint = 0) {
  return OVERLORD::STRUCT::CreateARENA_HISTORY(
      _fbb,
      kId,
      isDefense,
      isWin,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      heroIDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroIDs) : 0,
      power,
      deltaPoint);
}

flatbuffers::Offset<ARENA_HISTORY> CreateARENA_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_STATUST : public flatbuffers::NativeTable {
  typedef ARENA_STATUS TableType;
  bool seasonEnd;
  int32_t seasonLeft;
  int32_t rank;
  int32_t rankPosition;
  int32_t point;
  std::vector<std::unique_ptr<ARENA_HISTORYT>> history;
  bool defenseRewardEnabled;
  int32_t defenseCount;
  int32_t defenseCountMax;
  int32_t defenseLeftTime;
  ARENA_STATUST()
      : seasonEnd(false),
        seasonLeft(0),
        rank(0),
        rankPosition(0),
        point(0),
        defenseRewardEnabled(false),
        defenseCount(0),
        defenseCountMax(0),
        defenseLeftTime(0) {
  }
};

struct ARENA_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_STATUST NativeTableType;
  enum {
    VT_SEASONEND = 4,
    VT_SEASONLEFT = 6,
    VT_RANK = 8,
    VT_RANKPOSITION = 10,
    VT_POINT = 12,
    VT_HISTORY = 14,
    VT_DEFENSEREWARDENABLED = 16,
    VT_DEFENSECOUNT = 18,
    VT_DEFENSECOUNTMAX = 20,
    VT_DEFENSELEFTTIME = 22
  };
  bool seasonEnd() const {
    return GetField<uint8_t>(VT_SEASONEND, 0) != 0;
  }
  int32_t seasonLeft() const {
    return GetField<int32_t>(VT_SEASONLEFT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t rankPosition() const {
    return GetField<int32_t>(VT_RANKPOSITION, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ARENA_HISTORY>> *history() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ARENA_HISTORY>> *>(VT_HISTORY);
  }
  bool defenseRewardEnabled() const {
    return GetField<uint8_t>(VT_DEFENSEREWARDENABLED, 0) != 0;
  }
  int32_t defenseCount() const {
    return GetField<int32_t>(VT_DEFENSECOUNT, 0);
  }
  int32_t defenseCountMax() const {
    return GetField<int32_t>(VT_DEFENSECOUNTMAX, 0);
  }
  int32_t defenseLeftTime() const {
    return GetField<int32_t>(VT_DEFENSELEFTTIME, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEASONEND) &&
           VerifyField<int32_t>(verifier, VT_SEASONLEFT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_RANKPOSITION) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyOffset(verifier, VT_HISTORY) &&
           verifier.Verify(history()) &&
           verifier.VerifyVectorOfTables(history()) &&
           VerifyField<uint8_t>(verifier, VT_DEFENSEREWARDENABLED) &&
           VerifyField<int32_t>(verifier, VT_DEFENSECOUNT) &&
           VerifyField<int32_t>(verifier, VT_DEFENSECOUNTMAX) &&
           VerifyField<int32_t>(verifier, VT_DEFENSELEFTTIME) &&
           verifier.EndTable();
  }
  ARENA_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seasonEnd(bool seasonEnd) {
    fbb_.AddElement<uint8_t>(ARENA_STATUS::VT_SEASONEND, static_cast<uint8_t>(seasonEnd), 0);
  }
  void add_seasonLeft(int32_t seasonLeft) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_SEASONLEFT, seasonLeft, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_RANK, rank, 0);
  }
  void add_rankPosition(int32_t rankPosition) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_RANKPOSITION, rankPosition, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_POINT, point, 0);
  }
  void add_history(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ARENA_HISTORY>>> history) {
    fbb_.AddOffset(ARENA_STATUS::VT_HISTORY, history);
  }
  void add_defenseRewardEnabled(bool defenseRewardEnabled) {
    fbb_.AddElement<uint8_t>(ARENA_STATUS::VT_DEFENSEREWARDENABLED, static_cast<uint8_t>(defenseRewardEnabled), 0);
  }
  void add_defenseCount(int32_t defenseCount) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_DEFENSECOUNT, defenseCount, 0);
  }
  void add_defenseCountMax(int32_t defenseCountMax) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_DEFENSECOUNTMAX, defenseCountMax, 0);
  }
  void add_defenseLeftTime(int32_t defenseLeftTime) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_DEFENSELEFTTIME, defenseLeftTime, 0);
  }
  explicit ARENA_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_STATUSBuilder &operator=(const ARENA_STATUSBuilder &);
  flatbuffers::Offset<ARENA_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool seasonEnd = false,
    int32_t seasonLeft = 0,
    int32_t rank = 0,
    int32_t rankPosition = 0,
    int32_t point = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ARENA_HISTORY>>> history = 0,
    bool defenseRewardEnabled = false,
    int32_t defenseCount = 0,
    int32_t defenseCountMax = 0,
    int32_t defenseLeftTime = 0) {
  ARENA_STATUSBuilder builder_(_fbb);
  builder_.add_defenseLeftTime(defenseLeftTime);
  builder_.add_defenseCountMax(defenseCountMax);
  builder_.add_defenseCount(defenseCount);
  builder_.add_history(history);
  builder_.add_point(point);
  builder_.add_rankPosition(rankPosition);
  builder_.add_rank(rank);
  builder_.add_seasonLeft(seasonLeft);
  builder_.add_defenseRewardEnabled(defenseRewardEnabled);
  builder_.add_seasonEnd(seasonEnd);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool seasonEnd = false,
    int32_t seasonLeft = 0,
    int32_t rank = 0,
    int32_t rankPosition = 0,
    int32_t point = 0,
    const std::vector<flatbuffers::Offset<ARENA_HISTORY>> *history = nullptr,
    bool defenseRewardEnabled = false,
    int32_t defenseCount = 0,
    int32_t defenseCountMax = 0,
    int32_t defenseLeftTime = 0) {
  return OVERLORD::STRUCT::CreateARENA_STATUS(
      _fbb,
      seasonEnd,
      seasonLeft,
      rank,
      rankPosition,
      point,
      history ? _fbb.CreateVector<flatbuffers::Offset<ARENA_HISTORY>>(*history) : 0,
      defenseRewardEnabled,
      defenseCount,
      defenseCountMax,
      defenseLeftTime);
}

flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_RANK_USERT : public flatbuffers::NativeTable {
  typedef ARENA_RANK_USER TableType;
  std::string nick;
  int32_t level;
  std::string guild;
  int32_t rank;
  int32_t point;
  int32_t power;
  ARENA_RANK_USERT()
      : level(0),
        rank(0),
        point(0),
        power(0) {
  }
};

struct ARENA_RANK_USER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_RANK_USERT NativeTableType;
  enum {
    VT_NICK = 4,
    VT_LEVEL = 6,
    VT_GUILD = 8,
    VT_RANK = 10,
    VT_POINT = 12,
    VT_POWER = 14
  };
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           verifier.EndTable();
  }
  ARENA_RANK_USERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_RANK_USERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_RANK_USER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANK_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_RANK_USERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ARENA_RANK_USER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ARENA_RANK_USER::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(ARENA_RANK_USER::VT_GUILD, guild);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(ARENA_RANK_USER::VT_RANK, rank, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(ARENA_RANK_USER::VT_POINT, point, 0);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(ARENA_RANK_USER::VT_POWER, power, 0);
  }
  explicit ARENA_RANK_USERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_RANK_USERBuilder &operator=(const ARENA_RANK_USERBuilder &);
  flatbuffers::Offset<ARENA_RANK_USER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_RANK_USER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_RANK_USER> CreateARENA_RANK_USER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t rank = 0,
    int32_t point = 0,
    int32_t power = 0) {
  ARENA_RANK_USERBuilder builder_(_fbb);
  builder_.add_power(power);
  builder_.add_point(point);
  builder_.add_rank(rank);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_nick(nick);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_RANK_USER> CreateARENA_RANK_USERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    int32_t rank = 0,
    int32_t point = 0,
    int32_t power = 0) {
  return OVERLORD::STRUCT::CreateARENA_RANK_USER(
      _fbb,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      rank,
      point,
      power);
}

flatbuffers::Offset<ARENA_RANK_USER> CreateARENA_RANK_USER(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANK_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_HERO_HPT : public flatbuffers::NativeTable {
  typedef MIRROR_HERO_HP TableType;
  std::string heroUD;
  int32_t hp;
  MIRROR_HERO_HPT()
      : hp(0) {
  }
};

struct MIRROR_HERO_HP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_HERO_HPT NativeTableType;
  enum {
    VT_HEROUD = 4,
    VT_HP = 6
  };
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           verifier.EndTable();
  }
  MIRROR_HERO_HPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_HERO_HPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_HERO_HP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_HERO_HPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_HERO_HPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(MIRROR_HERO_HP::VT_HEROUD, heroUD);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(MIRROR_HERO_HP::VT_HP, hp, 0);
  }
  explicit MIRROR_HERO_HPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_HERO_HPBuilder &operator=(const MIRROR_HERO_HPBuilder &);
  flatbuffers::Offset<MIRROR_HERO_HP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_HERO_HP>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_HERO_HP> CreateMIRROR_HERO_HP(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    int32_t hp = 0) {
  MIRROR_HERO_HPBuilder builder_(_fbb);
  builder_.add_hp(hp);
  builder_.add_heroUD(heroUD);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_HERO_HP> CreateMIRROR_HERO_HPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *heroUD = nullptr,
    int32_t hp = 0) {
  return OVERLORD::STRUCT::CreateMIRROR_HERO_HP(
      _fbb,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      hp);
}

flatbuffers::Offset<MIRROR_HERO_HP> CreateMIRROR_HERO_HP(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_HERO_HPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRRORT : public flatbuffers::NativeTable {
  typedef MIRROR TableType;
  std::string mirrorUD;
  OVERLORD::ENUM::MIRROR_TYPE mirrorType;
  std::unique_ptr<BATTLE_USERT> user;
  std::vector<int32_t> hpList;
  std::vector<std::unique_ptr<REWARDT>> rewards;
  MIRRORT()
      : mirrorType(OVERLORD::ENUM::MIRROR_TYPE_PAST) {
  }
};

struct MIRROR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRRORT NativeTableType;
  enum {
    VT_MIRRORUD = 4,
    VT_MIRRORTYPE = 6,
    VT_USER = 8,
    VT_HPLIST = 10,
    VT_REWARDS = 12
  };
  const flatbuffers::String *mirrorUD() const {
    return GetPointer<const flatbuffers::String *>(VT_MIRRORUD);
  }
  OVERLORD::ENUM::MIRROR_TYPE mirrorType() const {
    return static_cast<OVERLORD::ENUM::MIRROR_TYPE>(GetField<int8_t>(VT_MIRRORTYPE, 0));
  }
  const BATTLE_USER *user() const {
    return GetPointer<const BATTLE_USER *>(VT_USER);
  }
  const flatbuffers::Vector<int32_t> *hpList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_HPLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIRRORUD) &&
           verifier.Verify(mirrorUD()) &&
           VerifyField<int8_t>(verifier, VT_MIRRORTYPE) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_HPLIST) &&
           verifier.Verify(hpList()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  MIRRORT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRRORT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRRORT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRRORBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mirrorUD(flatbuffers::Offset<flatbuffers::String> mirrorUD) {
    fbb_.AddOffset(MIRROR::VT_MIRRORUD, mirrorUD);
  }
  void add_mirrorType(OVERLORD::ENUM::MIRROR_TYPE mirrorType) {
    fbb_.AddElement<int8_t>(MIRROR::VT_MIRRORTYPE, static_cast<int8_t>(mirrorType), 0);
  }
  void add_user(flatbuffers::Offset<BATTLE_USER> user) {
    fbb_.AddOffset(MIRROR::VT_USER, user);
  }
  void add_hpList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> hpList) {
    fbb_.AddOffset(MIRROR::VT_HPLIST, hpList);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards) {
    fbb_.AddOffset(MIRROR::VT_REWARDS, rewards);
  }
  explicit MIRRORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRRORBuilder &operator=(const MIRRORBuilder &);
  flatbuffers::Offset<MIRROR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR> CreateMIRROR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mirrorUD = 0,
    OVERLORD::ENUM::MIRROR_TYPE mirrorType = OVERLORD::ENUM::MIRROR_TYPE_PAST,
    flatbuffers::Offset<BATTLE_USER> user = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> hpList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARD>>> rewards = 0) {
  MIRRORBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_hpList(hpList);
  builder_.add_user(user);
  builder_.add_mirrorUD(mirrorUD);
  builder_.add_mirrorType(mirrorType);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR> CreateMIRRORDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mirrorUD = nullptr,
    OVERLORD::ENUM::MIRROR_TYPE mirrorType = OVERLORD::ENUM::MIRROR_TYPE_PAST,
    flatbuffers::Offset<BATTLE_USER> user = 0,
    const std::vector<int32_t> *hpList = nullptr,
    const std::vector<flatbuffers::Offset<REWARD>> *rewards = nullptr) {
  return OVERLORD::STRUCT::CreateMIRROR(
      _fbb,
      mirrorUD ? _fbb.CreateString(mirrorUD) : 0,
      mirrorType,
      user,
      hpList ? _fbb.CreateVector<int32_t>(*hpList) : 0,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<MIRROR> CreateMIRROR(flatbuffers::FlatBufferBuilder &_fbb, const MIRRORT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_STATUST : public flatbuffers::NativeTable {
  typedef MIRROR_STATUS TableType;
  std::vector<std::unique_ptr<MIRRORT>> mirrors;
  int32_t resetLeftTime;
  std::vector<std::unique_ptr<MIRROR_HERO_HPT>> heroHPs;
  MIRROR_STATUST()
      : resetLeftTime(0) {
  }
};

struct MIRROR_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_STATUST NativeTableType;
  enum {
    VT_MIRRORS = 4,
    VT_RESETLEFTTIME = 6,
    VT_HEROHPS = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<MIRROR>> *mirrors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MIRROR>> *>(VT_MIRRORS);
  }
  int32_t resetLeftTime() const {
    return GetField<int32_t>(VT_RESETLEFTTIME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MIRROR_HERO_HP>> *heroHPs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MIRROR_HERO_HP>> *>(VT_HEROHPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIRRORS) &&
           verifier.Verify(mirrors()) &&
           verifier.VerifyVectorOfTables(mirrors()) &&
           VerifyField<int32_t>(verifier, VT_RESETLEFTTIME) &&
           VerifyOffset(verifier, VT_HEROHPS) &&
           verifier.Verify(heroHPs()) &&
           verifier.VerifyVectorOfTables(heroHPs()) &&
           verifier.EndTable();
  }
  MIRROR_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mirrors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MIRROR>>> mirrors) {
    fbb_.AddOffset(MIRROR_STATUS::VT_MIRRORS, mirrors);
  }
  void add_resetLeftTime(int32_t resetLeftTime) {
    fbb_.AddElement<int32_t>(MIRROR_STATUS::VT_RESETLEFTTIME, resetLeftTime, 0);
  }
  void add_heroHPs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MIRROR_HERO_HP>>> heroHPs) {
    fbb_.AddOffset(MIRROR_STATUS::VT_HEROHPS, heroHPs);
  }
  explicit MIRROR_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_STATUSBuilder &operator=(const MIRROR_STATUSBuilder &);
  flatbuffers::Offset<MIRROR_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MIRROR>>> mirrors = 0,
    int32_t resetLeftTime = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MIRROR_HERO_HP>>> heroHPs = 0) {
  MIRROR_STATUSBuilder builder_(_fbb);
  builder_.add_heroHPs(heroHPs);
  builder_.add_resetLeftTime(resetLeftTime);
  builder_.add_mirrors(mirrors);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<MIRROR>> *mirrors = nullptr,
    int32_t resetLeftTime = 0,
    const std::vector<flatbuffers::Offset<MIRROR_HERO_HP>> *heroHPs = nullptr) {
  return OVERLORD::STRUCT::CreateMIRROR_STATUS(
      _fbb,
      mirrors ? _fbb.CreateVector<flatbuffers::Offset<MIRROR>>(*mirrors) : 0,
      resetLeftTime,
      heroHPs ? _fbb.CreateVector<flatbuffers::Offset<MIRROR_HERO_HP>>(*heroHPs) : 0);
}

flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_HISTORYT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_HISTORY TableType;
  int32_t kId;
  int32_t gradeId;
  bool isWin;
  std::string nick;
  int32_t level;
  std::string guild;
  std::vector<std::string> heroIDs;
  int32_t power;
  int32_t deltaPoint;
  OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE playType;
  COLOSSEUM_HISTORYT()
      : kId(0),
        gradeId(0),
        isWin(true),
        level(0),
        power(0),
        deltaPoint(0),
        playType(OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE_NONE) {
  }
};

struct COLOSSEUM_HISTORY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_HISTORYT NativeTableType;
  enum {
    VT_KID = 4,
    VT_GRADEID = 6,
    VT_ISWIN = 8,
    VT_NICK = 10,
    VT_LEVEL = 12,
    VT_GUILD = 14,
    VT_HEROIDS = 16,
    VT_POWER = 18,
    VT_DELTAPOINT = 20,
    VT_PLAYTYPE = 22
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  int32_t gradeId() const {
    return GetField<int32_t>(VT_GRADEID, 0);
  }
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 1) != 0;
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroIDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROIDS);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  int32_t deltaPoint() const {
    return GetField<int32_t>(VT_DELTAPOINT, 0);
  }
  OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE playType() const {
    return static_cast<OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE>(GetField<int8_t>(VT_PLAYTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<int32_t>(verifier, VT_GRADEID) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyOffset(verifier, VT_HEROIDS) &&
           verifier.Verify(heroIDs()) &&
           verifier.VerifyVectorOfStrings(heroIDs()) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           VerifyField<int32_t>(verifier, VT_DELTAPOINT) &&
           VerifyField<int8_t>(verifier, VT_PLAYTYPE) &&
           verifier.EndTable();
  }
  COLOSSEUM_HISTORYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_HISTORY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_HISTORYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(COLOSSEUM_HISTORY::VT_KID, kId, 0);
  }
  void add_gradeId(int32_t gradeId) {
    fbb_.AddElement<int32_t>(COLOSSEUM_HISTORY::VT_GRADEID, gradeId, 0);
  }
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(COLOSSEUM_HISTORY::VT_ISWIN, static_cast<uint8_t>(isWin), 1);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(COLOSSEUM_HISTORY::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(COLOSSEUM_HISTORY::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(COLOSSEUM_HISTORY::VT_GUILD, guild);
  }
  void add_heroIDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroIDs) {
    fbb_.AddOffset(COLOSSEUM_HISTORY::VT_HEROIDS, heroIDs);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(COLOSSEUM_HISTORY::VT_POWER, power, 0);
  }
  void add_deltaPoint(int32_t deltaPoint) {
    fbb_.AddElement<int32_t>(COLOSSEUM_HISTORY::VT_DELTAPOINT, deltaPoint, 0);
  }
  void add_playType(OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE playType) {
    fbb_.AddElement<int8_t>(COLOSSEUM_HISTORY::VT_PLAYTYPE, static_cast<int8_t>(playType), 0);
  }
  explicit COLOSSEUM_HISTORYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_HISTORYBuilder &operator=(const COLOSSEUM_HISTORYBuilder &);
  flatbuffers::Offset<COLOSSEUM_HISTORY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_HISTORY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_HISTORY> CreateCOLOSSEUM_HISTORY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t gradeId = 0,
    bool isWin = true,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroIDs = 0,
    int32_t power = 0,
    int32_t deltaPoint = 0,
    OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE playType = OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE_NONE) {
  COLOSSEUM_HISTORYBuilder builder_(_fbb);
  builder_.add_deltaPoint(deltaPoint);
  builder_.add_power(power);
  builder_.add_heroIDs(heroIDs);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_nick(nick);
  builder_.add_gradeId(gradeId);
  builder_.add_kId(kId);
  builder_.add_playType(playType);
  builder_.add_isWin(isWin);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_HISTORY> CreateCOLOSSEUM_HISTORYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    int32_t gradeId = 0,
    bool isWin = true,
    const char *nick = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroIDs = nullptr,
    int32_t power = 0,
    int32_t deltaPoint = 0,
    OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE playType = OVERLORD::ENUM::COLOSSEUM_PLAY_TYPE_NONE) {
  return OVERLORD::STRUCT::CreateCOLOSSEUM_HISTORY(
      _fbb,
      kId,
      gradeId,
      isWin,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      heroIDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroIDs) : 0,
      power,
      deltaPoint,
      playType);
}

flatbuffers::Offset<COLOSSEUM_HISTORY> CreateCOLOSSEUM_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_STATUST : public flatbuffers::NativeTable {
  typedef COLOSSEUM_STATUS TableType;
  bool seasonEnd;
  int32_t seasonLeft;
  int32_t rank;
  int32_t gradeId;
  int32_t point;
  std::vector<std::unique_ptr<COLOSSEUM_HISTORYT>> history;
  int32_t win;
  int32_t lose;
  int32_t continuous_win;
  COLOSSEUM_STATUST()
      : seasonEnd(false),
        seasonLeft(0),
        rank(0),
        gradeId(0),
        point(0),
        win(0),
        lose(0),
        continuous_win(0) {
  }
};

struct COLOSSEUM_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_STATUST NativeTableType;
  enum {
    VT_SEASONEND = 4,
    VT_SEASONLEFT = 6,
    VT_RANK = 8,
    VT_GRADEID = 10,
    VT_POINT = 12,
    VT_HISTORY = 14,
    VT_WIN = 16,
    VT_LOSE = 18,
    VT_CONTINUOUS_WIN = 20
  };
  bool seasonEnd() const {
    return GetField<uint8_t>(VT_SEASONEND, 0) != 0;
  }
  int32_t seasonLeft() const {
    return GetField<int32_t>(VT_SEASONLEFT, 0);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t gradeId() const {
    return GetField<int32_t>(VT_GRADEID, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<COLOSSEUM_HISTORY>> *history() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<COLOSSEUM_HISTORY>> *>(VT_HISTORY);
  }
  int32_t win() const {
    return GetField<int32_t>(VT_WIN, 0);
  }
  int32_t lose() const {
    return GetField<int32_t>(VT_LOSE, 0);
  }
  int32_t continuous_win() const {
    return GetField<int32_t>(VT_CONTINUOUS_WIN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEASONEND) &&
           VerifyField<int32_t>(verifier, VT_SEASONLEFT) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_GRADEID) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyOffset(verifier, VT_HISTORY) &&
           verifier.Verify(history()) &&
           verifier.VerifyVectorOfTables(history()) &&
           VerifyField<int32_t>(verifier, VT_WIN) &&
           VerifyField<int32_t>(verifier, VT_LOSE) &&
           VerifyField<int32_t>(verifier, VT_CONTINUOUS_WIN) &&
           verifier.EndTable();
  }
  COLOSSEUM_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seasonEnd(bool seasonEnd) {
    fbb_.AddElement<uint8_t>(COLOSSEUM_STATUS::VT_SEASONEND, static_cast<uint8_t>(seasonEnd), 0);
  }
  void add_seasonLeft(int32_t seasonLeft) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_SEASONLEFT, seasonLeft, 0);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_RANK, rank, 0);
  }
  void add_gradeId(int32_t gradeId) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_GRADEID, gradeId, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_POINT, point, 0);
  }
  void add_history(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<COLOSSEUM_HISTORY>>> history) {
    fbb_.AddOffset(COLOSSEUM_STATUS::VT_HISTORY, history);
  }
  void add_win(int32_t win) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_WIN, win, 0);
  }
  void add_lose(int32_t lose) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_LOSE, lose, 0);
  }
  void add_continuous_win(int32_t continuous_win) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_CONTINUOUS_WIN, continuous_win, 0);
  }
  explicit COLOSSEUM_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_STATUSBuilder &operator=(const COLOSSEUM_STATUSBuilder &);
  flatbuffers::Offset<COLOSSEUM_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool seasonEnd = false,
    int32_t seasonLeft = 0,
    int32_t rank = 0,
    int32_t gradeId = 0,
    int32_t point = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<COLOSSEUM_HISTORY>>> history = 0,
    int32_t win = 0,
    int32_t lose = 0,
    int32_t continuous_win = 0) {
  COLOSSEUM_STATUSBuilder builder_(_fbb);
  builder_.add_continuous_win(continuous_win);
  builder_.add_lose(lose);
  builder_.add_win(win);
  builder_.add_history(history);
  builder_.add_point(point);
  builder_.add_gradeId(gradeId);
  builder_.add_rank(rank);
  builder_.add_seasonLeft(seasonLeft);
  builder_.add_seasonEnd(seasonEnd);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool seasonEnd = false,
    int32_t seasonLeft = 0,
    int32_t rank = 0,
    int32_t gradeId = 0,
    int32_t point = 0,
    const std::vector<flatbuffers::Offset<COLOSSEUM_HISTORY>> *history = nullptr,
    int32_t win = 0,
    int32_t lose = 0,
    int32_t continuous_win = 0) {
  return OVERLORD::STRUCT::CreateCOLOSSEUM_STATUS(
      _fbb,
      seasonEnd,
      seasonLeft,
      rank,
      gradeId,
      point,
      history ? _fbb.CreateVector<flatbuffers::Offset<COLOSSEUM_HISTORY>>(*history) : 0,
      win,
      lose,
      continuous_win);
}

flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_RANK_USERT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_RANK_USER TableType;
  std::string nick;
  int32_t level;
  std::string guild;
  int32_t rank;
  int32_t point;
  COLOSSEUM_RANK_USERT()
      : level(0),
        rank(0),
        point(0) {
  }
};

struct COLOSSEUM_RANK_USER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_RANK_USERT NativeTableType;
  enum {
    VT_NICK = 4,
    VT_LEVEL = 6,
    VT_GUILD = 8,
    VT_RANK = 10,
    VT_POINT = 12
  };
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *guild() const {
    return GetPointer<const flatbuffers::String *>(VT_GUILD);
  }
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_GUILD) &&
           verifier.Verify(guild()) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           verifier.EndTable();
  }
  COLOSSEUM_RANK_USERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_RANK_USERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_RANK_USER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANK_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_RANK_USERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(COLOSSEUM_RANK_USER::VT_NICK, nick);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(COLOSSEUM_RANK_USER::VT_LEVEL, level, 0);
  }
  void add_guild(flatbuffers::Offset<flatbuffers::String> guild) {
    fbb_.AddOffset(COLOSSEUM_RANK_USER::VT_GUILD, guild);
  }
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(COLOSSEUM_RANK_USER::VT_RANK, rank, 0);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(COLOSSEUM_RANK_USER::VT_POINT, point, 0);
  }
  explicit COLOSSEUM_RANK_USERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_RANK_USERBuilder &operator=(const COLOSSEUM_RANK_USERBuilder &);
  flatbuffers::Offset<COLOSSEUM_RANK_USER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_RANK_USER>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_RANK_USER> CreateCOLOSSEUM_RANK_USER(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> guild = 0,
    int32_t rank = 0,
    int32_t point = 0) {
  COLOSSEUM_RANK_USERBuilder builder_(_fbb);
  builder_.add_point(point);
  builder_.add_rank(rank);
  builder_.add_guild(guild);
  builder_.add_level(level);
  builder_.add_nick(nick);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_RANK_USER> CreateCOLOSSEUM_RANK_USERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *nick = nullptr,
    int32_t level = 0,
    const char *guild = nullptr,
    int32_t rank = 0,
    int32_t point = 0) {
  return OVERLORD::STRUCT::CreateCOLOSSEUM_RANK_USER(
      _fbb,
      nick ? _fbb.CreateString(nick) : 0,
      level,
      guild ? _fbb.CreateString(guild) : 0,
      rank,
      point);
}

flatbuffers::Offset<COLOSSEUM_RANK_USER> CreateCOLOSSEUM_RANK_USER(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANK_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_SLOTT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_SLOT TableType;
  int32_t slotId;
  OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE state;
  int32_t openGem;
  OVERLORD::ENUM::REWARD_TYPE type;
  std::string rewardId;
  int32_t amt;
  std::string currencyType;
  int32_t price;
  SHOP_FLOORSHOP_SLOTT()
      : slotId(0),
        state(OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT),
        openGem(0),
        type(OVERLORD::ENUM::REWARD_TYPE_NONE),
        amt(0),
        price(0) {
  }
};

struct SHOP_FLOORSHOP_SLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_SLOTT NativeTableType;
  enum {
    VT_SLOTID = 4,
    VT_STATE = 6,
    VT_OPENGEM = 8,
    VT_TYPE = 10,
    VT_REWARDID = 12,
    VT_AMT = 14,
    VT_CURRENCYTYPE = 16,
    VT_PRICE = 18
  };
  int32_t slotId() const {
    return GetField<int32_t>(VT_SLOTID, 0);
  }
  OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE state() const {
    return static_cast<OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE>(GetField<int8_t>(VT_STATE, 0));
  }
  int32_t openGem() const {
    return GetField<int32_t>(VT_OPENGEM, 0);
  }
  OVERLORD::ENUM::REWARD_TYPE type() const {
    return static_cast<OVERLORD::ENUM::REWARD_TYPE>(GetField<int8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *rewardId() const {
    return GetPointer<const flatbuffers::String *>(VT_REWARDID);
  }
  int32_t amt() const {
    return GetField<int32_t>(VT_AMT, 0);
  }
  const flatbuffers::String *currencyType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCYTYPE);
  }
  int32_t price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOTID) &&
           VerifyField<int8_t>(verifier, VT_STATE) &&
           VerifyField<int32_t>(verifier, VT_OPENGEM) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_REWARDID) &&
           verifier.Verify(rewardId()) &&
           VerifyField<int32_t>(verifier, VT_AMT) &&
           VerifyOffset(verifier, VT_CURRENCYTYPE) &&
           verifier.Verify(currencyType()) &&
           VerifyField<int32_t>(verifier, VT_PRICE) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_SLOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_SLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slotId(int32_t slotId) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_SLOT::VT_SLOTID, slotId, 0);
  }
  void add_state(OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE state) {
    fbb_.AddElement<int8_t>(SHOP_FLOORSHOP_SLOT::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_openGem(int32_t openGem) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_SLOT::VT_OPENGEM, openGem, 0);
  }
  void add_type(OVERLORD::ENUM::REWARD_TYPE type) {
    fbb_.AddElement<int8_t>(SHOP_FLOORSHOP_SLOT::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_rewardId(flatbuffers::Offset<flatbuffers::String> rewardId) {
    fbb_.AddOffset(SHOP_FLOORSHOP_SLOT::VT_REWARDID, rewardId);
  }
  void add_amt(int32_t amt) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_SLOT::VT_AMT, amt, 0);
  }
  void add_currencyType(flatbuffers::Offset<flatbuffers::String> currencyType) {
    fbb_.AddOffset(SHOP_FLOORSHOP_SLOT::VT_CURRENCYTYPE, currencyType);
  }
  void add_price(int32_t price) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_SLOT::VT_PRICE, price, 0);
  }
  explicit SHOP_FLOORSHOP_SLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_SLOTBuilder &operator=(const SHOP_FLOORSHOP_SLOTBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> CreateSHOP_FLOORSHOP_SLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slotId = 0,
    OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE state = OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT,
    int32_t openGem = 0,
    OVERLORD::ENUM::REWARD_TYPE type = OVERLORD::ENUM::REWARD_TYPE_NONE,
    flatbuffers::Offset<flatbuffers::String> rewardId = 0,
    int32_t amt = 0,
    flatbuffers::Offset<flatbuffers::String> currencyType = 0,
    int32_t price = 0) {
  SHOP_FLOORSHOP_SLOTBuilder builder_(_fbb);
  builder_.add_price(price);
  builder_.add_currencyType(currencyType);
  builder_.add_amt(amt);
  builder_.add_rewardId(rewardId);
  builder_.add_openGem(openGem);
  builder_.add_slotId(slotId);
  builder_.add_type(type);
  builder_.add_state(state);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> CreateSHOP_FLOORSHOP_SLOTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slotId = 0,
    OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE state = OVERLORD::ENUM::SHOP_FLOORSHOP_SLOT_STATE_SOLDOUT,
    int32_t openGem = 0,
    OVERLORD::ENUM::REWARD_TYPE type = OVERLORD::ENUM::REWARD_TYPE_NONE,
    const char *rewardId = nullptr,
    int32_t amt = 0,
    const char *currencyType = nullptr,
    int32_t price = 0) {
  return OVERLORD::STRUCT::CreateSHOP_FLOORSHOP_SLOT(
      _fbb,
      slotId,
      state,
      openGem,
      type,
      rewardId ? _fbb.CreateString(rewardId) : 0,
      amt,
      currencyType ? _fbb.CreateString(currencyType) : 0,
      price);
}

flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> CreateSHOP_FLOORSHOP_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_STATUST : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_STATUS TableType;
  int32_t shopId;
  int32_t timeLeft;
  std::vector<std::unique_ptr<SHOP_FLOORSHOP_SLOTT>> slots;
  SHOP_FLOORSHOP_STATUST()
      : shopId(0),
        timeLeft(0) {
  }
};

struct SHOP_FLOORSHOP_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_STATUST NativeTableType;
  enum {
    VT_SHOPID = 4,
    VT_TIMELEFT = 6,
    VT_SLOTS = 8
  };
  int32_t shopId() const {
    return GetField<int32_t>(VT_SHOPID, 0);
  }
  int32_t timeLeft() const {
    return GetField<int32_t>(VT_TIMELEFT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>> *slots() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>> *>(VT_SLOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SHOPID) &&
           VerifyField<int32_t>(verifier, VT_TIMELEFT) &&
           VerifyOffset(verifier, VT_SLOTS) &&
           verifier.Verify(slots()) &&
           verifier.VerifyVectorOfTables(slots()) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shopId(int32_t shopId) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_STATUS::VT_SHOPID, shopId, 0);
  }
  void add_timeLeft(int32_t timeLeft) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_STATUS::VT_TIMELEFT, timeLeft, 0);
  }
  void add_slots(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>>> slots) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS::VT_SLOTS, slots);
  }
  explicit SHOP_FLOORSHOP_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_STATUSBuilder &operator=(const SHOP_FLOORSHOP_STATUSBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shopId = 0,
    int32_t timeLeft = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>>> slots = 0) {
  SHOP_FLOORSHOP_STATUSBuilder builder_(_fbb);
  builder_.add_slots(slots);
  builder_.add_timeLeft(timeLeft);
  builder_.add_shopId(shopId);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t shopId = 0,
    int32_t timeLeft = 0,
    const std::vector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>> *slots = nullptr) {
  return OVERLORD::STRUCT::CreateSHOP_FLOORSHOP_STATUS(
      _fbb,
      shopId,
      timeLeft,
      slots ? _fbb.CreateVector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>>(*slots) : 0);
}

flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_STATUST : public flatbuffers::NativeTable {
  typedef WORLDBOSS_STATUS TableType;
  std::vector<int32_t> clearGrades;
  WORLDBOSS_STATUST() {
  }
};

struct WORLDBOSS_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_STATUST NativeTableType;
  enum {
    VT_CLEARGRADES = 4
  };
  const flatbuffers::Vector<int32_t> *clearGrades() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CLEARGRADES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLEARGRADES) &&
           verifier.Verify(clearGrades()) &&
           verifier.EndTable();
  }
  WORLDBOSS_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clearGrades(flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades) {
    fbb_.AddOffset(WORLDBOSS_STATUS::VT_CLEARGRADES, clearGrades);
  }
  explicit WORLDBOSS_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_STATUSBuilder &operator=(const WORLDBOSS_STATUSBuilder &);
  flatbuffers::Offset<WORLDBOSS_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> clearGrades = 0) {
  WORLDBOSS_STATUSBuilder builder_(_fbb);
  builder_.add_clearGrades(clearGrades);
  return builder_.Finish();
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *clearGrades = nullptr) {
  return OVERLORD::STRUCT::CreateWORLDBOSS_STATUS(
      _fbb,
      clearGrades ? _fbb.CreateVector<int32_t>(*clearGrades) : 0);
}

flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SELECTIVE_TUTORIALT : public flatbuffers::NativeTable {
  typedef SELECTIVE_TUTORIAL TableType;
  std::vector<int32_t> flags;
  SELECTIVE_TUTORIALT() {
  }
};

struct SELECTIVE_TUTORIAL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SELECTIVE_TUTORIALT NativeTableType;
  enum {
    VT_FLAGS = 4
  };
  const flatbuffers::Vector<int32_t> *flags() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FLAGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FLAGS) &&
           verifier.Verify(flags()) &&
           verifier.EndTable();
  }
  SELECTIVE_TUTORIALT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SELECTIVE_TUTORIALT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SELECTIVE_TUTORIAL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SELECTIVE_TUTORIALT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SELECTIVE_TUTORIALBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_flags(flatbuffers::Offset<flatbuffers::Vector<int32_t>> flags) {
    fbb_.AddOffset(SELECTIVE_TUTORIAL::VT_FLAGS, flags);
  }
  explicit SELECTIVE_TUTORIALBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SELECTIVE_TUTORIALBuilder &operator=(const SELECTIVE_TUTORIALBuilder &);
  flatbuffers::Offset<SELECTIVE_TUTORIAL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SELECTIVE_TUTORIAL>(end);
    return o;
  }
};

inline flatbuffers::Offset<SELECTIVE_TUTORIAL> CreateSELECTIVE_TUTORIAL(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> flags = 0) {
  SELECTIVE_TUTORIALBuilder builder_(_fbb);
  builder_.add_flags(flags);
  return builder_.Finish();
}

inline flatbuffers::Offset<SELECTIVE_TUTORIAL> CreateSELECTIVE_TUTORIALDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *flags = nullptr) {
  return OVERLORD::STRUCT::CreateSELECTIVE_TUTORIAL(
      _fbb,
      flags ? _fbb.CreateVector<int32_t>(*flags) : 0);
}

flatbuffers::Offset<SELECTIVE_TUTORIAL> CreateSELECTIVE_TUTORIAL(flatbuffers::FlatBufferBuilder &_fbb, const SELECTIVE_TUTORIALT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPDATE_PACKETT : public flatbuffers::NativeTable {
  typedef UPDATE_PACKET TableType;
  std::unique_ptr<AVATART> avatar;
  std::unique_ptr<INVENTORY_UPDATET> inventoryUpdate;
  int32_t rewardLength;
  std::vector<std::unique_ptr<REWARDSETT>> rewards;
  UPDATE_PACKETT()
      : rewardLength(0) {
  }
};

struct UPDATE_PACKET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPDATE_PACKETT NativeTableType;
  enum {
    VT_AVATAR = 4,
    VT_INVENTORYUPDATE = 6,
    VT_REWARDLENGTH = 8,
    VT_REWARDS = 10
  };
  const AVATAR *avatar() const {
    return GetPointer<const AVATAR *>(VT_AVATAR);
  }
  const INVENTORY_UPDATE *inventoryUpdate() const {
    return GetPointer<const INVENTORY_UPDATE *>(VT_INVENTORYUPDATE);
  }
  int32_t rewardLength() const {
    return GetField<int32_t>(VT_REWARDLENGTH, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<REWARDSET>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<REWARDSET>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.VerifyTable(avatar()) &&
           VerifyOffset(verifier, VT_INVENTORYUPDATE) &&
           verifier.VerifyTable(inventoryUpdate()) &&
           VerifyField<int32_t>(verifier, VT_REWARDLENGTH) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  UPDATE_PACKETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPDATE_PACKETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPDATE_PACKET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPDATE_PACKETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_avatar(flatbuffers::Offset<AVATAR> avatar) {
    fbb_.AddOffset(UPDATE_PACKET::VT_AVATAR, avatar);
  }
  void add_inventoryUpdate(flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate) {
    fbb_.AddOffset(UPDATE_PACKET::VT_INVENTORYUPDATE, inventoryUpdate);
  }
  void add_rewardLength(int32_t rewardLength) {
    fbb_.AddElement<int32_t>(UPDATE_PACKET::VT_REWARDLENGTH, rewardLength, 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARDSET>>> rewards) {
    fbb_.AddOffset(UPDATE_PACKET::VT_REWARDS, rewards);
  }
  explicit UPDATE_PACKETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPDATE_PACKETBuilder &operator=(const UPDATE_PACKETBuilder &);
  flatbuffers::Offset<UPDATE_PACKET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPDATE_PACKET>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPDATE_PACKET> CreateUPDATE_PACKET(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AVATAR> avatar = 0,
    flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate = 0,
    int32_t rewardLength = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<REWARDSET>>> rewards = 0) {
  UPDATE_PACKETBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_rewardLength(rewardLength);
  builder_.add_inventoryUpdate(inventoryUpdate);
  builder_.add_avatar(avatar);
  return builder_.Finish();
}

inline flatbuffers::Offset<UPDATE_PACKET> CreateUPDATE_PACKETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AVATAR> avatar = 0,
    flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate = 0,
    int32_t rewardLength = 0,
    const std::vector<flatbuffers::Offset<REWARDSET>> *rewards = nullptr) {
  return OVERLORD::STRUCT::CreateUPDATE_PACKET(
      _fbb,
      avatar,
      inventoryUpdate,
      rewardLength,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<REWARDSET>>(*rewards) : 0);
}

flatbuffers::Offset<UPDATE_PACKET> CreateUPDATE_PACKET(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UPDATE_PACKET_SLIMT : public flatbuffers::NativeTable {
  typedef UPDATE_PACKET_SLIM TableType;
  std::unique_ptr<AVATART> avatar;
  std::unique_ptr<INVENTORY_UPDATET> inventoryUpdate;
  std::unique_ptr<UNLOCK_NOTIFYT> unlockNotify;
  std::vector<std::unique_ptr<ACHIEVE_UPDATET>> achieveUpdate;
  std::unique_ptr<DAILY_QUEST_UPDATET> dailyQuestUpdate;
  UPDATE_PACKET_SLIMT() {
  }
};

struct UPDATE_PACKET_SLIM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UPDATE_PACKET_SLIMT NativeTableType;
  enum {
    VT_AVATAR = 4,
    VT_INVENTORYUPDATE = 6,
    VT_UNLOCKNOTIFY = 8,
    VT_ACHIEVEUPDATE = 10,
    VT_DAILYQUESTUPDATE = 12
  };
  const AVATAR *avatar() const {
    return GetPointer<const AVATAR *>(VT_AVATAR);
  }
  const INVENTORY_UPDATE *inventoryUpdate() const {
    return GetPointer<const INVENTORY_UPDATE *>(VT_INVENTORYUPDATE);
  }
  const UNLOCK_NOTIFY *unlockNotify() const {
    return GetPointer<const UNLOCK_NOTIFY *>(VT_UNLOCKNOTIFY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ACHIEVE_UPDATE>> *achieveUpdate() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ACHIEVE_UPDATE>> *>(VT_ACHIEVEUPDATE);
  }
  const DAILY_QUEST_UPDATE *dailyQuestUpdate() const {
    return GetPointer<const DAILY_QUEST_UPDATE *>(VT_DAILYQUESTUPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.VerifyTable(avatar()) &&
           VerifyOffset(verifier, VT_INVENTORYUPDATE) &&
           verifier.VerifyTable(inventoryUpdate()) &&
           VerifyOffset(verifier, VT_UNLOCKNOTIFY) &&
           verifier.VerifyTable(unlockNotify()) &&
           VerifyOffset(verifier, VT_ACHIEVEUPDATE) &&
           verifier.Verify(achieveUpdate()) &&
           verifier.VerifyVectorOfTables(achieveUpdate()) &&
           VerifyOffset(verifier, VT_DAILYQUESTUPDATE) &&
           verifier.VerifyTable(dailyQuestUpdate()) &&
           verifier.EndTable();
  }
  UPDATE_PACKET_SLIMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UPDATE_PACKET_SLIMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UPDATE_PACKET_SLIM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKET_SLIMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UPDATE_PACKET_SLIMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_avatar(flatbuffers::Offset<AVATAR> avatar) {
    fbb_.AddOffset(UPDATE_PACKET_SLIM::VT_AVATAR, avatar);
  }
  void add_inventoryUpdate(flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate) {
    fbb_.AddOffset(UPDATE_PACKET_SLIM::VT_INVENTORYUPDATE, inventoryUpdate);
  }
  void add_unlockNotify(flatbuffers::Offset<UNLOCK_NOTIFY> unlockNotify) {
    fbb_.AddOffset(UPDATE_PACKET_SLIM::VT_UNLOCKNOTIFY, unlockNotify);
  }
  void add_achieveUpdate(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ACHIEVE_UPDATE>>> achieveUpdate) {
    fbb_.AddOffset(UPDATE_PACKET_SLIM::VT_ACHIEVEUPDATE, achieveUpdate);
  }
  void add_dailyQuestUpdate(flatbuffers::Offset<DAILY_QUEST_UPDATE> dailyQuestUpdate) {
    fbb_.AddOffset(UPDATE_PACKET_SLIM::VT_DAILYQUESTUPDATE, dailyQuestUpdate);
  }
  explicit UPDATE_PACKET_SLIMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UPDATE_PACKET_SLIMBuilder &operator=(const UPDATE_PACKET_SLIMBuilder &);
  flatbuffers::Offset<UPDATE_PACKET_SLIM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UPDATE_PACKET_SLIM>(end);
    return o;
  }
};

inline flatbuffers::Offset<UPDATE_PACKET_SLIM> CreateUPDATE_PACKET_SLIM(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AVATAR> avatar = 0,
    flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate = 0,
    flatbuffers::Offset<UNLOCK_NOTIFY> unlockNotify = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ACHIEVE_UPDATE>>> achieveUpdate = 0,
    flatbuffers::Offset<DAILY_QUEST_UPDATE> dailyQuestUpdate = 0) {
  UPDATE_PACKET_SLIMBuilder builder_(_fbb);
  builder_.add_dailyQuestUpdate(dailyQuestUpdate);
  builder_.add_achieveUpdate(achieveUpdate);
  builder_.add_unlockNotify(unlockNotify);
  builder_.add_inventoryUpdate(inventoryUpdate);
  builder_.add_avatar(avatar);
  return builder_.Finish();
}

inline flatbuffers::Offset<UPDATE_PACKET_SLIM> CreateUPDATE_PACKET_SLIMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<AVATAR> avatar = 0,
    flatbuffers::Offset<INVENTORY_UPDATE> inventoryUpdate = 0,
    flatbuffers::Offset<UNLOCK_NOTIFY> unlockNotify = 0,
    const std::vector<flatbuffers::Offset<ACHIEVE_UPDATE>> *achieveUpdate = nullptr,
    flatbuffers::Offset<DAILY_QUEST_UPDATE> dailyQuestUpdate = 0) {
  return OVERLORD::STRUCT::CreateUPDATE_PACKET_SLIM(
      _fbb,
      avatar,
      inventoryUpdate,
      unlockNotify,
      achieveUpdate ? _fbb.CreateVector<flatbuffers::Offset<ACHIEVE_UPDATE>>(*achieveUpdate) : 0,
      dailyQuestUpdate);
}

flatbuffers::Offset<UPDATE_PACKET_SLIM> CreateUPDATE_PACKET_SLIM(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKET_SLIMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace STRUCT

namespace REQUEST {

struct LOGINT : public flatbuffers::NativeTable {
  typedef LOGIN TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t flag;
  LOGINT()
      : type(8450),
        flag(0) {
  }
};

struct LOGIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGINT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_FLAG = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8450);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           verifier.EndTable();
  }
  LOGINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LOGINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LOGIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LOGINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LOGINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(LOGIN::VT_TYPE, type, 8450);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(LOGIN::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(LOGIN::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(LOGIN::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(LOGIN::VT_VERSION, version);
  }
  void add_flag(int32_t flag) {
    fbb_.AddElement<int32_t>(LOGIN::VT_FLAG, flag, 0);
  }
  explicit LOGINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LOGINBuilder &operator=(const LOGINBuilder &);
  flatbuffers::Offset<LOGIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LOGIN> CreateLOGIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8450,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t flag = 0) {
  LOGINBuilder builder_(_fbb);
  builder_.add_flag(flag);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<LOGIN> CreateLOGINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8450,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t flag = 0) {
  return OVERLORD::REQUEST::CreateLOGIN(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      flag);
}

flatbuffers::Offset<LOGIN> CreateLOGIN(flatbuffers::FlatBufferBuilder &_fbb, const LOGINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_CREATET : public flatbuffers::NativeTable {
  typedef ACCOUNT_CREATE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t language;
  std::string nick;
  ACCOUNT_CREATET()
      : type(8451),
        language(0) {
  }
};

struct ACCOUNT_CREATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_CREATET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_LANGUAGE = 14,
    VT_NICK = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8451);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           verifier.EndTable();
  }
  ACCOUNT_CREATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_CREATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_CREATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_CREATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_CREATE::VT_TYPE, type, 8451);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ACCOUNT_CREATE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ACCOUNT_CREATE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ACCOUNT_CREATE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ACCOUNT_CREATE::VT_VERSION, version);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(ACCOUNT_CREATE::VT_LANGUAGE, language, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ACCOUNT_CREATE::VT_NICK, nick);
  }
  explicit ACCOUNT_CREATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_CREATEBuilder &operator=(const ACCOUNT_CREATEBuilder &);
  flatbuffers::Offset<ACCOUNT_CREATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_CREATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_CREATE> CreateACCOUNT_CREATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8451,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t language = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0) {
  ACCOUNT_CREATEBuilder builder_(_fbb);
  builder_.add_nick(nick);
  builder_.add_language(language);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_CREATE> CreateACCOUNT_CREATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8451,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t language = 0,
    const char *nick = nullptr) {
  return OVERLORD::REQUEST::CreateACCOUNT_CREATE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      language,
      nick ? _fbb.CreateString(nick) : 0);
}

flatbuffers::Offset<ACCOUNT_CREATE> CreateACCOUNT_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_REMOVET : public flatbuffers::NativeTable {
  typedef ACCOUNT_REMOVE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ACCOUNT_REMOVET()
      : type(8452) {
  }
};

struct ACCOUNT_REMOVE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_REMOVET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8452);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ACCOUNT_REMOVET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_REMOVET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_REMOVE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_REMOVEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_REMOVE::VT_TYPE, type, 8452);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ACCOUNT_REMOVE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ACCOUNT_REMOVE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ACCOUNT_REMOVE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ACCOUNT_REMOVE::VT_VERSION, version);
  }
  explicit ACCOUNT_REMOVEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_REMOVEBuilder &operator=(const ACCOUNT_REMOVEBuilder &);
  flatbuffers::Offset<ACCOUNT_REMOVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_REMOVE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_REMOVE> CreateACCOUNT_REMOVE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8452,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ACCOUNT_REMOVEBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_REMOVE> CreateACCOUNT_REMOVEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8452,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateACCOUNT_REMOVE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ACCOUNT_REMOVE> CreateACCOUNT_REMOVE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INIT_CLIENT_KEYT : public flatbuffers::NativeTable {
  typedef INIT_CLIENT_KEY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string pwd;
  std::string id;
  std::string redirect_uri;
  std::string access_token;
  std::string code;
  std::string publisher;
  INIT_CLIENT_KEYT()
      : type(8453) {
  }
};

struct INIT_CLIENT_KEY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INIT_CLIENT_KEYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PWD = 14,
    VT_ID = 16,
    VT_REDIRECT_URI = 18,
    VT_ACCESS_TOKEN = 20,
    VT_CODE = 22,
    VT_PUBLISHER = 24
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8453);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *pwd() const {
    return GetPointer<const flatbuffers::String *>(VT_PWD);
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *redirect_uri() const {
    return GetPointer<const flatbuffers::String *>(VT_REDIRECT_URI);
  }
  const flatbuffers::String *access_token() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCESS_TOKEN);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *publisher() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLISHER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.Verify(pwd()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_REDIRECT_URI) &&
           verifier.Verify(redirect_uri()) &&
           VerifyOffset(verifier, VT_ACCESS_TOKEN) &&
           verifier.Verify(access_token()) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           VerifyOffset(verifier, VT_PUBLISHER) &&
           verifier.Verify(publisher()) &&
           verifier.EndTable();
  }
  INIT_CLIENT_KEYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INIT_CLIENT_KEYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INIT_CLIENT_KEY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INIT_CLIENT_KEYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INIT_CLIENT_KEY::VT_TYPE, type, 8453);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_VERSION, version);
  }
  void add_pwd(flatbuffers::Offset<flatbuffers::String> pwd) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_PWD, pwd);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_ID, id);
  }
  void add_redirect_uri(flatbuffers::Offset<flatbuffers::String> redirect_uri) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_REDIRECT_URI, redirect_uri);
  }
  void add_access_token(flatbuffers::Offset<flatbuffers::String> access_token) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_ACCESS_TOKEN, access_token);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_CODE, code);
  }
  void add_publisher(flatbuffers::Offset<flatbuffers::String> publisher) {
    fbb_.AddOffset(INIT_CLIENT_KEY::VT_PUBLISHER, publisher);
  }
  explicit INIT_CLIENT_KEYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INIT_CLIENT_KEYBuilder &operator=(const INIT_CLIENT_KEYBuilder &);
  flatbuffers::Offset<INIT_CLIENT_KEY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INIT_CLIENT_KEY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INIT_CLIENT_KEY> CreateINIT_CLIENT_KEY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8453,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> pwd = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> redirect_uri = 0,
    flatbuffers::Offset<flatbuffers::String> access_token = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> publisher = 0) {
  INIT_CLIENT_KEYBuilder builder_(_fbb);
  builder_.add_publisher(publisher);
  builder_.add_code(code);
  builder_.add_access_token(access_token);
  builder_.add_redirect_uri(redirect_uri);
  builder_.add_id(id);
  builder_.add_pwd(pwd);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INIT_CLIENT_KEY> CreateINIT_CLIENT_KEYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8453,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *pwd = nullptr,
    const char *id = nullptr,
    const char *redirect_uri = nullptr,
    const char *access_token = nullptr,
    const char *code = nullptr,
    const char *publisher = nullptr) {
  return OVERLORD::REQUEST::CreateINIT_CLIENT_KEY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      pwd ? _fbb.CreateString(pwd) : 0,
      id ? _fbb.CreateString(id) : 0,
      redirect_uri ? _fbb.CreateString(redirect_uri) : 0,
      access_token ? _fbb.CreateString(access_token) : 0,
      code ? _fbb.CreateString(code) : 0,
      publisher ? _fbb.CreateString(publisher) : 0);
}

flatbuffers::Offset<INIT_CLIENT_KEY> CreateINIT_CLIENT_KEY(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ADD_REFER_PUBLISHERT : public flatbuffers::NativeTable {
  typedef ADD_REFER_PUBLISHER TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string pwd;
  std::string id;
  std::string redirect_uri;
  std::string access_token;
  std::string code;
  std::string publisher;
  ADD_REFER_PUBLISHERT()
      : type(8454) {
  }
};

struct ADD_REFER_PUBLISHER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADD_REFER_PUBLISHERT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PWD = 14,
    VT_ID = 16,
    VT_REDIRECT_URI = 18,
    VT_ACCESS_TOKEN = 20,
    VT_CODE = 22,
    VT_PUBLISHER = 24
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8454);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *pwd() const {
    return GetPointer<const flatbuffers::String *>(VT_PWD);
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *redirect_uri() const {
    return GetPointer<const flatbuffers::String *>(VT_REDIRECT_URI);
  }
  const flatbuffers::String *access_token() const {
    return GetPointer<const flatbuffers::String *>(VT_ACCESS_TOKEN);
  }
  const flatbuffers::String *code() const {
    return GetPointer<const flatbuffers::String *>(VT_CODE);
  }
  const flatbuffers::String *publisher() const {
    return GetPointer<const flatbuffers::String *>(VT_PUBLISHER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_PWD) &&
           verifier.Verify(pwd()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyOffset(verifier, VT_REDIRECT_URI) &&
           verifier.Verify(redirect_uri()) &&
           VerifyOffset(verifier, VT_ACCESS_TOKEN) &&
           verifier.Verify(access_token()) &&
           VerifyOffset(verifier, VT_CODE) &&
           verifier.Verify(code()) &&
           VerifyOffset(verifier, VT_PUBLISHER) &&
           verifier.Verify(publisher()) &&
           verifier.EndTable();
  }
  ADD_REFER_PUBLISHERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ADD_REFER_PUBLISHERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ADD_REFER_PUBLISHER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ADD_REFER_PUBLISHERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ADD_REFER_PUBLISHER::VT_TYPE, type, 8454);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_VERSION, version);
  }
  void add_pwd(flatbuffers::Offset<flatbuffers::String> pwd) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_PWD, pwd);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_ID, id);
  }
  void add_redirect_uri(flatbuffers::Offset<flatbuffers::String> redirect_uri) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_REDIRECT_URI, redirect_uri);
  }
  void add_access_token(flatbuffers::Offset<flatbuffers::String> access_token) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_ACCESS_TOKEN, access_token);
  }
  void add_code(flatbuffers::Offset<flatbuffers::String> code) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_CODE, code);
  }
  void add_publisher(flatbuffers::Offset<flatbuffers::String> publisher) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER::VT_PUBLISHER, publisher);
  }
  explicit ADD_REFER_PUBLISHERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ADD_REFER_PUBLISHERBuilder &operator=(const ADD_REFER_PUBLISHERBuilder &);
  flatbuffers::Offset<ADD_REFER_PUBLISHER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD_REFER_PUBLISHER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ADD_REFER_PUBLISHER> CreateADD_REFER_PUBLISHER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8454,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> pwd = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> redirect_uri = 0,
    flatbuffers::Offset<flatbuffers::String> access_token = 0,
    flatbuffers::Offset<flatbuffers::String> code = 0,
    flatbuffers::Offset<flatbuffers::String> publisher = 0) {
  ADD_REFER_PUBLISHERBuilder builder_(_fbb);
  builder_.add_publisher(publisher);
  builder_.add_code(code);
  builder_.add_access_token(access_token);
  builder_.add_redirect_uri(redirect_uri);
  builder_.add_id(id);
  builder_.add_pwd(pwd);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER> CreateADD_REFER_PUBLISHERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8454,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *pwd = nullptr,
    const char *id = nullptr,
    const char *redirect_uri = nullptr,
    const char *access_token = nullptr,
    const char *code = nullptr,
    const char *publisher = nullptr) {
  return OVERLORD::REQUEST::CreateADD_REFER_PUBLISHER(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      pwd ? _fbb.CreateString(pwd) : 0,
      id ? _fbb.CreateString(id) : 0,
      redirect_uri ? _fbb.CreateString(redirect_uri) : 0,
      access_token ? _fbb.CreateString(access_token) : 0,
      code ? _fbb.CreateString(code) : 0,
      publisher ? _fbb.CreateString(publisher) : 0);
}

flatbuffers::Offset<ADD_REFER_PUBLISHER> CreateADD_REFER_PUBLISHER(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GET_REFER_LISTT : public flatbuffers::NativeTable {
  typedef GET_REFER_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GET_REFER_LISTT()
      : type(8455) {
  }
};

struct GET_REFER_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GET_REFER_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8455);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GET_REFER_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GET_REFER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GET_REFER_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GET_REFER_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GET_REFER_LIST::VT_TYPE, type, 8455);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GET_REFER_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GET_REFER_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GET_REFER_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GET_REFER_LIST::VT_VERSION, version);
  }
  explicit GET_REFER_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GET_REFER_LISTBuilder &operator=(const GET_REFER_LISTBuilder &);
  flatbuffers::Offset<GET_REFER_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GET_REFER_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GET_REFER_LIST> CreateGET_REFER_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8455,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GET_REFER_LISTBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GET_REFER_LIST> CreateGET_REFER_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8455,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGET_REFER_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GET_REFER_LIST> CreateGET_REFER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_CHANGE_LANGUAGET : public flatbuffers::NativeTable {
  typedef ACCOUNT_CHANGE_LANGUAGE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t language;
  ACCOUNT_CHANGE_LANGUAGET()
      : type(8456),
        language(0) {
  }
};

struct ACCOUNT_CHANGE_LANGUAGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_CHANGE_LANGUAGET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_LANGUAGE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8456);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t language() const {
    return GetField<int32_t>(VT_LANGUAGE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_LANGUAGE) &&
           verifier.EndTable();
  }
  ACCOUNT_CHANGE_LANGUAGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_CHANGE_LANGUAGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_CHANGE_LANGUAGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_CHANGE_LANGUAGE::VT_TYPE, type, 8456);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ACCOUNT_CHANGE_LANGUAGE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ACCOUNT_CHANGE_LANGUAGE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ACCOUNT_CHANGE_LANGUAGE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ACCOUNT_CHANGE_LANGUAGE::VT_VERSION, version);
  }
  void add_language(int32_t language) {
    fbb_.AddElement<int32_t>(ACCOUNT_CHANGE_LANGUAGE::VT_LANGUAGE, language, 0);
  }
  explicit ACCOUNT_CHANGE_LANGUAGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_CHANGE_LANGUAGEBuilder &operator=(const ACCOUNT_CHANGE_LANGUAGEBuilder &);
  flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> CreateACCOUNT_CHANGE_LANGUAGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8456,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t language = 0) {
  ACCOUNT_CHANGE_LANGUAGEBuilder builder_(_fbb);
  builder_.add_language(language);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> CreateACCOUNT_CHANGE_LANGUAGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8456,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t language = 0) {
  return OVERLORD::REQUEST::CreateACCOUNT_CHANGE_LANGUAGE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      language);
}

flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> CreateACCOUNT_CHANGE_LANGUAGE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CLIENT_SDK_ACTIONT : public flatbuffers::NativeTable {
  typedef CLIENT_SDK_ACTION TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t flag;
  CLIENT_SDK_ACTIONT()
      : type(8457),
        flag(0) {
  }
};

struct CLIENT_SDK_ACTION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CLIENT_SDK_ACTIONT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_FLAG = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8457);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t flag() const {
    return GetField<int32_t>(VT_FLAG, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           verifier.EndTable();
  }
  CLIENT_SDK_ACTIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CLIENT_SDK_ACTIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CLIENT_SDK_ACTION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CLIENT_SDK_ACTIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CLIENT_SDK_ACTION::VT_TYPE, type, 8457);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(CLIENT_SDK_ACTION::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(CLIENT_SDK_ACTION::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(CLIENT_SDK_ACTION::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CLIENT_SDK_ACTION::VT_VERSION, version);
  }
  void add_flag(int32_t flag) {
    fbb_.AddElement<int32_t>(CLIENT_SDK_ACTION::VT_FLAG, flag, 0);
  }
  explicit CLIENT_SDK_ACTIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLIENT_SDK_ACTIONBuilder &operator=(const CLIENT_SDK_ACTIONBuilder &);
  flatbuffers::Offset<CLIENT_SDK_ACTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CLIENT_SDK_ACTION>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLIENT_SDK_ACTION> CreateCLIENT_SDK_ACTION(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8457,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t flag = 0) {
  CLIENT_SDK_ACTIONBuilder builder_(_fbb);
  builder_.add_flag(flag);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CLIENT_SDK_ACTION> CreateCLIENT_SDK_ACTIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8457,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t flag = 0) {
  return OVERLORD::REQUEST::CreateCLIENT_SDK_ACTION(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      flag);
}

flatbuffers::Offset<CLIENT_SDK_ACTION> CreateCLIENT_SDK_ACTION(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_STATUST : public flatbuffers::NativeTable {
  typedef ARENA_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ARENA_STATUST()
      : type(4800) {
  }
};

struct ARENA_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4800);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ARENA_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_STATUS::VT_TYPE, type, 4800);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_STATUS::VT_VERSION, version);
  }
  explicit ARENA_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_STATUSBuilder &operator=(const ARENA_STATUSBuilder &);
  flatbuffers::Offset<ARENA_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4800,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ARENA_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4800,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_TARGET_INFOT : public flatbuffers::NativeTable {
  typedef ARENA_TARGET_INFO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool refresh;
  ARENA_TARGET_INFOT()
      : type(4801),
        refresh(false) {
  }
};

struct ARENA_TARGET_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_TARGET_INFOT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_REFRESH = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4801);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool refresh() const {
    return GetField<uint8_t>(VT_REFRESH, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_REFRESH) &&
           verifier.EndTable();
  }
  ARENA_TARGET_INFOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_TARGET_INFOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_TARGET_INFO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_TARGET_INFOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_TARGET_INFO::VT_TYPE, type, 4801);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_TARGET_INFO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_TARGET_INFO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_TARGET_INFO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_TARGET_INFO::VT_VERSION, version);
  }
  void add_refresh(bool refresh) {
    fbb_.AddElement<uint8_t>(ARENA_TARGET_INFO::VT_REFRESH, static_cast<uint8_t>(refresh), 0);
  }
  explicit ARENA_TARGET_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_TARGET_INFOBuilder &operator=(const ARENA_TARGET_INFOBuilder &);
  flatbuffers::Offset<ARENA_TARGET_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_TARGET_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_TARGET_INFO> CreateARENA_TARGET_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4801,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool refresh = false) {
  ARENA_TARGET_INFOBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_refresh(refresh);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_TARGET_INFO> CreateARENA_TARGET_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4801,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool refresh = false) {
  return OVERLORD::REQUEST::CreateARENA_TARGET_INFO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      refresh);
}

flatbuffers::Offset<ARENA_TARGET_INFO> CreateARENA_TARGET_INFO(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_PLAYT : public flatbuffers::NativeTable {
  typedef ARENA_PLAY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t target_power;
  int32_t power;
  std::vector<std::string> heroUDs;
  int32_t target_kId;
  ARENA_PLAYT()
      : type(4802),
        target_power(0),
        power(0),
        target_kId(0) {
  }
};

struct ARENA_PLAY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_PLAYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_TARGET_POWER = 14,
    VT_POWER = 16,
    VT_HEROUDS = 18,
    VT_TARGET_KID = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4802);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t target_power() const {
    return GetField<int32_t>(VT_TARGET_POWER, 0);
  }
  int32_t power() const {
    return GetField<int32_t>(VT_POWER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS);
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_POWER) &&
           VerifyField<int32_t>(verifier, VT_POWER) &&
           VerifyOffset(verifier, VT_HEROUDS) &&
           verifier.Verify(heroUDs()) &&
           verifier.VerifyVectorOfStrings(heroUDs()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  ARENA_PLAYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_PLAY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_PLAYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_PLAY::VT_TYPE, type, 4802);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_PLAY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_PLAY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_PLAY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_PLAY::VT_VERSION, version);
  }
  void add_target_power(int32_t target_power) {
    fbb_.AddElement<int32_t>(ARENA_PLAY::VT_TARGET_POWER, target_power, 0);
  }
  void add_power(int32_t power) {
    fbb_.AddElement<int32_t>(ARENA_PLAY::VT_POWER, power, 0);
  }
  void add_heroUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs) {
    fbb_.AddOffset(ARENA_PLAY::VT_HEROUDS, heroUDs);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(ARENA_PLAY::VT_TARGET_KID, target_kId, 0);
  }
  explicit ARENA_PLAYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_PLAYBuilder &operator=(const ARENA_PLAYBuilder &);
  flatbuffers::Offset<ARENA_PLAY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_PLAY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_PLAY> CreateARENA_PLAY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4802,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t target_power = 0,
    int32_t power = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs = 0,
    int32_t target_kId = 0) {
  ARENA_PLAYBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_heroUDs(heroUDs);
  builder_.add_power(power);
  builder_.add_target_power(target_power);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_PLAY> CreateARENA_PLAYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4802,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t target_power = 0,
    int32_t power = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs = nullptr,
    int32_t target_kId = 0) {
  return OVERLORD::REQUEST::CreateARENA_PLAY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      target_power,
      power,
      heroUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs) : 0,
      target_kId);
}

flatbuffers::Offset<ARENA_PLAY> CreateARENA_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_PLAY_DONET : public flatbuffers::NativeTable {
  typedef ARENA_PLAY_DONE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool isWin;
  std::string playUD;
  ARENA_PLAY_DONET()
      : type(4803),
        isWin(false) {
  }
};

struct ARENA_PLAY_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_PLAY_DONET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ISWIN = 14,
    VT_PLAYUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4803);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 0) != 0;
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           verifier.EndTable();
  }
  ARENA_PLAY_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_PLAY_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_PLAY_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_PLAY_DONE::VT_TYPE, type, 4803);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_PLAY_DONE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_PLAY_DONE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_PLAY_DONE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_PLAY_DONE::VT_VERSION, version);
  }
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(ARENA_PLAY_DONE::VT_ISWIN, static_cast<uint8_t>(isWin), 0);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(ARENA_PLAY_DONE::VT_PLAYUD, playUD);
  }
  explicit ARENA_PLAY_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_PLAY_DONEBuilder &operator=(const ARENA_PLAY_DONEBuilder &);
  flatbuffers::Offset<ARENA_PLAY_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_PLAY_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_PLAY_DONE> CreateARENA_PLAY_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4803,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool isWin = false,
    flatbuffers::Offset<flatbuffers::String> playUD = 0) {
  ARENA_PLAY_DONEBuilder builder_(_fbb);
  builder_.add_playUD(playUD);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_isWin(isWin);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_PLAY_DONE> CreateARENA_PLAY_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4803,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool isWin = false,
    const char *playUD = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_PLAY_DONE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      isWin,
      playUD ? _fbb.CreateString(playUD) : 0);
}

flatbuffers::Offset<ARENA_PLAY_DONE> CreateARENA_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_DEFENSE_REWARDT : public flatbuffers::NativeTable {
  typedef ARENA_DEFENSE_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ARENA_DEFENSE_REWARDT()
      : type(4804) {
  }
};

struct ARENA_DEFENSE_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_DEFENSE_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4804);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ARENA_DEFENSE_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_DEFENSE_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_DEFENSE_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_DEFENSE_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_DEFENSE_REWARD::VT_TYPE, type, 4804);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD::VT_VERSION, version);
  }
  explicit ARENA_DEFENSE_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_DEFENSE_REWARDBuilder &operator=(const ARENA_DEFENSE_REWARDBuilder &);
  flatbuffers::Offset<ARENA_DEFENSE_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_DEFENSE_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD> CreateARENA_DEFENSE_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4804,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ARENA_DEFENSE_REWARDBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD> CreateARENA_DEFENSE_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4804,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_DEFENSE_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ARENA_DEFENSE_REWARD> CreateARENA_DEFENSE_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_SEASON_DONET : public flatbuffers::NativeTable {
  typedef ARENA_SEASON_DONE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ARENA_SEASON_DONET()
      : type(4805) {
  }
};

struct ARENA_SEASON_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_SEASON_DONET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4805);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ARENA_SEASON_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_SEASON_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_SEASON_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_SEASON_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_SEASON_DONE::VT_TYPE, type, 4805);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_SEASON_DONE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_SEASON_DONE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_SEASON_DONE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_SEASON_DONE::VT_VERSION, version);
  }
  explicit ARENA_SEASON_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_SEASON_DONEBuilder &operator=(const ARENA_SEASON_DONEBuilder &);
  flatbuffers::Offset<ARENA_SEASON_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_SEASON_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_SEASON_DONE> CreateARENA_SEASON_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4805,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ARENA_SEASON_DONEBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_SEASON_DONE> CreateARENA_SEASON_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4805,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_SEASON_DONE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ARENA_SEASON_DONE> CreateARENA_SEASON_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_RANKING_LISTT : public flatbuffers::NativeTable {
  typedef ARENA_RANKING_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ARENA_RANKING_LISTT()
      : type(4806) {
  }
};

struct ARENA_RANKING_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_RANKING_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4806);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ARENA_RANKING_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_RANKING_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_RANKING_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_RANKING_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_RANKING_LIST::VT_TYPE, type, 4806);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_RANKING_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_RANKING_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_RANKING_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_RANKING_LIST::VT_VERSION, version);
  }
  explicit ARENA_RANKING_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_RANKING_LISTBuilder &operator=(const ARENA_RANKING_LISTBuilder &);
  flatbuffers::Offset<ARENA_RANKING_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_RANKING_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_RANKING_LIST> CreateARENA_RANKING_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4806,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ARENA_RANKING_LISTBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_RANKING_LIST> CreateARENA_RANKING_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4806,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_RANKING_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ARENA_RANKING_LIST> CreateARENA_RANKING_LIST(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_DEFENSE_DECK_SETT : public flatbuffers::NativeTable {
  typedef ARENA_DEFENSE_DECK_SET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> defense;
  ARENA_DEFENSE_DECK_SETT()
      : type(4807) {
  }
};

struct ARENA_DEFENSE_DECK_SET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_DEFENSE_DECK_SETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_DEFENSE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4807);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *defense() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEFENSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_DEFENSE) &&
           verifier.Verify(defense()) &&
           verifier.VerifyVectorOfStrings(defense()) &&
           verifier.EndTable();
  }
  ARENA_DEFENSE_DECK_SETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_DEFENSE_DECK_SETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_DEFENSE_DECK_SETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_DEFENSE_DECK_SET::VT_TYPE, type, 4807);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET::VT_VERSION, version);
  }
  void add_defense(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET::VT_DEFENSE, defense);
  }
  explicit ARENA_DEFENSE_DECK_SETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_DEFENSE_DECK_SETBuilder &operator=(const ARENA_DEFENSE_DECK_SETBuilder &);
  flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_DEFENSE_DECK_SET>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> CreateARENA_DEFENSE_DECK_SET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4807,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense = 0) {
  ARENA_DEFENSE_DECK_SETBuilder builder_(_fbb);
  builder_.add_defense(defense);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> CreateARENA_DEFENSE_DECK_SETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4807,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *defense = nullptr) {
  return OVERLORD::REQUEST::CreateARENA_DEFENSE_DECK_SET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      defense ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*defense) : 0);
}

flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> CreateARENA_DEFENSE_DECK_SET(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ABILITY_UPT : public flatbuffers::NativeTable {
  typedef AVATAR_ABILITY_UP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t point;
  int32_t abilityIndex;
  AVATAR_ABILITY_UPT()
      : type(7650),
        point(0),
        abilityIndex(0) {
  }
};

struct AVATAR_ABILITY_UP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ABILITY_UPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_POINT = 14,
    VT_ABILITYINDEX = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7650);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t point() const {
    return GetField<int32_t>(VT_POINT, 0);
  }
  int32_t abilityIndex() const {
    return GetField<int32_t>(VT_ABILITYINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_POINT) &&
           VerifyField<int32_t>(verifier, VT_ABILITYINDEX) &&
           verifier.EndTable();
  }
  AVATAR_ABILITY_UPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ABILITY_UPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ABILITY_UP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ABILITY_UPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_UP::VT_TYPE, type, 7650);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_ABILITY_UP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_ABILITY_UP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_ABILITY_UP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_ABILITY_UP::VT_VERSION, version);
  }
  void add_point(int32_t point) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_UP::VT_POINT, point, 0);
  }
  void add_abilityIndex(int32_t abilityIndex) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_UP::VT_ABILITYINDEX, abilityIndex, 0);
  }
  explicit AVATAR_ABILITY_UPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ABILITY_UPBuilder &operator=(const AVATAR_ABILITY_UPBuilder &);
  flatbuffers::Offset<AVATAR_ABILITY_UP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ABILITY_UP>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ABILITY_UP> CreateAVATAR_ABILITY_UP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7650,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t point = 0,
    int32_t abilityIndex = 0) {
  AVATAR_ABILITY_UPBuilder builder_(_fbb);
  builder_.add_abilityIndex(abilityIndex);
  builder_.add_point(point);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_ABILITY_UP> CreateAVATAR_ABILITY_UPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7650,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t point = 0,
    int32_t abilityIndex = 0) {
  return OVERLORD::REQUEST::CreateAVATAR_ABILITY_UP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      point,
      abilityIndex);
}

flatbuffers::Offset<AVATAR_ABILITY_UP> CreateAVATAR_ABILITY_UP(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ABILITY_RESETT : public flatbuffers::NativeTable {
  typedef AVATAR_ABILITY_RESET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  AVATAR_ABILITY_RESETT()
      : type(7651) {
  }
};

struct AVATAR_ABILITY_RESET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ABILITY_RESETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7651);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  AVATAR_ABILITY_RESETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ABILITY_RESETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ABILITY_RESET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ABILITY_RESETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_RESET::VT_TYPE, type, 7651);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET::VT_VERSION, version);
  }
  explicit AVATAR_ABILITY_RESETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ABILITY_RESETBuilder &operator=(const AVATAR_ABILITY_RESETBuilder &);
  flatbuffers::Offset<AVATAR_ABILITY_RESET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ABILITY_RESET>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ABILITY_RESET> CreateAVATAR_ABILITY_RESET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7651,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AVATAR_ABILITY_RESETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_ABILITY_RESET> CreateAVATAR_ABILITY_RESETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7651,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateAVATAR_ABILITY_RESET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<AVATAR_ABILITY_RESET> CreateAVATAR_ABILITY_RESET(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ICON_LISTT : public flatbuffers::NativeTable {
  typedef AVATAR_ICON_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  AVATAR_ICON_LISTT()
      : type(7652) {
  }
};

struct AVATAR_ICON_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ICON_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7652);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  AVATAR_ICON_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ICON_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ICON_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ICON_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ICON_LIST::VT_TYPE, type, 7652);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_ICON_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_ICON_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_ICON_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_ICON_LIST::VT_VERSION, version);
  }
  explicit AVATAR_ICON_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ICON_LISTBuilder &operator=(const AVATAR_ICON_LISTBuilder &);
  flatbuffers::Offset<AVATAR_ICON_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ICON_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ICON_LIST> CreateAVATAR_ICON_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7652,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AVATAR_ICON_LISTBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_ICON_LIST> CreateAVATAR_ICON_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7652,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateAVATAR_ICON_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<AVATAR_ICON_LIST> CreateAVATAR_ICON_LIST(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ICON_SETT : public flatbuffers::NativeTable {
  typedef AVATAR_ICON_SET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t icon;
  AVATAR_ICON_SETT()
      : type(7653),
        icon(0) {
  }
};

struct AVATAR_ICON_SET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ICON_SETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ICON = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7653);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t icon() const {
    return GetField<int32_t>(VT_ICON, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_ICON) &&
           verifier.EndTable();
  }
  AVATAR_ICON_SETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ICON_SETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ICON_SET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ICON_SETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ICON_SET::VT_TYPE, type, 7653);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_ICON_SET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_ICON_SET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_ICON_SET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_ICON_SET::VT_VERSION, version);
  }
  void add_icon(int32_t icon) {
    fbb_.AddElement<int32_t>(AVATAR_ICON_SET::VT_ICON, icon, 0);
  }
  explicit AVATAR_ICON_SETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ICON_SETBuilder &operator=(const AVATAR_ICON_SETBuilder &);
  flatbuffers::Offset<AVATAR_ICON_SET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ICON_SET>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ICON_SET> CreateAVATAR_ICON_SET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7653,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t icon = 0) {
  AVATAR_ICON_SETBuilder builder_(_fbb);
  builder_.add_icon(icon);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_ICON_SET> CreateAVATAR_ICON_SETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7653,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t icon = 0) {
  return OVERLORD::REQUEST::CreateAVATAR_ICON_SET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      icon);
}

flatbuffers::Offset<AVATAR_ICON_SET> CreateAVATAR_ICON_SET(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_PROFILET : public flatbuffers::NativeTable {
  typedef AVATAR_PROFILE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  AVATAR_PROFILET()
      : type(7654) {
  }
};

struct AVATAR_PROFILE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_PROFILET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7654);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  AVATAR_PROFILET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_PROFILET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_PROFILE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_PROFILEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_PROFILE::VT_TYPE, type, 7654);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_PROFILE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_PROFILE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_PROFILE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_PROFILE::VT_VERSION, version);
  }
  explicit AVATAR_PROFILEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_PROFILEBuilder &operator=(const AVATAR_PROFILEBuilder &);
  flatbuffers::Offset<AVATAR_PROFILE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_PROFILE>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_PROFILE> CreateAVATAR_PROFILE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7654,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AVATAR_PROFILEBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_PROFILE> CreateAVATAR_PROFILEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7654,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateAVATAR_PROFILE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<AVATAR_PROFILE> CreateAVATAR_PROFILE(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_LOBBYT : public flatbuffers::NativeTable {
  typedef AVATAR_LOBBY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  AVATAR_LOBBYT()
      : type(7655) {
  }
};

struct AVATAR_LOBBY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_LOBBYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7655);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  AVATAR_LOBBYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_LOBBYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_LOBBY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_LOBBYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_LOBBY::VT_TYPE, type, 7655);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_LOBBY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_LOBBY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_LOBBY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_LOBBY::VT_VERSION, version);
  }
  explicit AVATAR_LOBBYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_LOBBYBuilder &operator=(const AVATAR_LOBBYBuilder &);
  flatbuffers::Offset<AVATAR_LOBBY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_LOBBY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_LOBBY> CreateAVATAR_LOBBY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7655,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AVATAR_LOBBYBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_LOBBY> CreateAVATAR_LOBBYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7655,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateAVATAR_LOBBY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<AVATAR_LOBBY> CreateAVATAR_LOBBY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_GAME_DATAT : public flatbuffers::NativeTable {
  typedef AVATAR_GAME_DATA TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  AVATAR_GAME_DATAT()
      : type(7656) {
  }
};

struct AVATAR_GAME_DATA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_GAME_DATAT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7656);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  AVATAR_GAME_DATAT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_GAME_DATAT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_GAME_DATA> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_GAME_DATABuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_GAME_DATA::VT_TYPE, type, 7656);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_GAME_DATA::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_GAME_DATA::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_GAME_DATA::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_GAME_DATA::VT_VERSION, version);
  }
  explicit AVATAR_GAME_DATABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_GAME_DATABuilder &operator=(const AVATAR_GAME_DATABuilder &);
  flatbuffers::Offset<AVATAR_GAME_DATA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_GAME_DATA>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_GAME_DATA> CreateAVATAR_GAME_DATA(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7656,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  AVATAR_GAME_DATABuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_GAME_DATA> CreateAVATAR_GAME_DATADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7656,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateAVATAR_GAME_DATA(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<AVATAR_GAME_DATA> CreateAVATAR_GAME_DATA(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_SELECTIVE_TUTORIAL_UPDATET : public flatbuffers::NativeTable {
  typedef AVATAR_SELECTIVE_TUTORIAL_UPDATE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t value;
  int32_t idx;
  AVATAR_SELECTIVE_TUTORIAL_UPDATET()
      : type(7657),
        value(0),
        idx(0) {
  }
};

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_SELECTIVE_TUTORIAL_UPDATET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_VALUE = 14,
    VT_IDX = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7657);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           verifier.EndTable();
  }
  AVATAR_SELECTIVE_TUTORIAL_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_SELECTIVE_TUTORIAL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_SELECTIVE_TUTORIAL_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_TYPE, type, 7657);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_VERSION, version);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_VALUE, value, 0);
  }
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(AVATAR_SELECTIVE_TUTORIAL_UPDATE::VT_IDX, idx, 0);
  }
  explicit AVATAR_SELECTIVE_TUTORIAL_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_SELECTIVE_TUTORIAL_UPDATEBuilder &operator=(const AVATAR_SELECTIVE_TUTORIAL_UPDATEBuilder &);
  flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7657,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t value = 0,
    int32_t idx = 0) {
  AVATAR_SELECTIVE_TUTORIAL_UPDATEBuilder builder_(_fbb);
  builder_.add_idx(idx);
  builder_.add_value(value);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7657,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t value = 0,
    int32_t idx = 0) {
  return OVERLORD::REQUEST::CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      value,
      idx);
}

flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_INFO_LISTT : public flatbuffers::NativeTable {
  typedef CHANNEL_INFO_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  CHANNEL_INFO_LISTT()
      : type(13150) {
  }
};

struct CHANNEL_INFO_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_INFO_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 13150);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  CHANNEL_INFO_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_INFO_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_INFO_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_INFO_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO_LIST::VT_TYPE, type, 13150);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(CHANNEL_INFO_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(CHANNEL_INFO_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(CHANNEL_INFO_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CHANNEL_INFO_LIST::VT_VERSION, version);
  }
  explicit CHANNEL_INFO_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_INFO_LISTBuilder &operator=(const CHANNEL_INFO_LISTBuilder &);
  flatbuffers::Offset<CHANNEL_INFO_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_INFO_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_INFO_LIST> CreateCHANNEL_INFO_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 13150,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  CHANNEL_INFO_LISTBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST> CreateCHANNEL_INFO_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 13150,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateCHANNEL_INFO_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<CHANNEL_INFO_LIST> CreateCHANNEL_INFO_LIST(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_DETAILT : public flatbuffers::NativeTable {
  typedef CHANNEL_DETAIL TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t no;
  CHANNEL_DETAILT()
      : type(13151),
        no(0) {
  }
};

struct CHANNEL_DETAIL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_DETAILT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_NO = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 13151);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t no() const {
    return GetField<int32_t>(VT_NO, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_NO) &&
           verifier.EndTable();
  }
  CHANNEL_DETAILT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_DETAILT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_DETAIL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_DETAILBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL::VT_TYPE, type, 13151);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CHANNEL_DETAIL::VT_VERSION, version);
  }
  void add_no(int32_t no) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL::VT_NO, no, 0);
  }
  explicit CHANNEL_DETAILBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_DETAILBuilder &operator=(const CHANNEL_DETAILBuilder &);
  flatbuffers::Offset<CHANNEL_DETAIL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_DETAIL>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 13151,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t no = 0) {
  CHANNEL_DETAILBuilder builder_(_fbb);
  builder_.add_no(no);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAILDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 13151,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t no = 0) {
  return OVERLORD::REQUEST::CreateCHANNEL_DETAIL(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      no);
}

flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BILLING_TRANSACTION_CREATET : public flatbuffers::NativeTable {
  typedef BILLING_TRANSACTION_CREATE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string redirect;
  std::string product;
  std::string purchase_system;
  BILLING_TRANSACTION_CREATET()
      : type(7800) {
  }
};

struct BILLING_TRANSACTION_CREATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BILLING_TRANSACTION_CREATET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_REDIRECT = 14,
    VT_PRODUCT = 16,
    VT_PURCHASE_SYSTEM = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7800);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *redirect() const {
    return GetPointer<const flatbuffers::String *>(VT_REDIRECT);
  }
  const flatbuffers::String *product() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCT);
  }
  const flatbuffers::String *purchase_system() const {
    return GetPointer<const flatbuffers::String *>(VT_PURCHASE_SYSTEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_REDIRECT) &&
           verifier.Verify(redirect()) &&
           VerifyOffset(verifier, VT_PRODUCT) &&
           verifier.Verify(product()) &&
           VerifyOffset(verifier, VT_PURCHASE_SYSTEM) &&
           verifier.Verify(purchase_system()) &&
           verifier.EndTable();
  }
  BILLING_TRANSACTION_CREATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BILLING_TRANSACTION_CREATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BILLING_TRANSACTION_CREATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BILLING_TRANSACTION_CREATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BILLING_TRANSACTION_CREATE::VT_TYPE, type, 7800);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_VERSION, version);
  }
  void add_redirect(flatbuffers::Offset<flatbuffers::String> redirect) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_REDIRECT, redirect);
  }
  void add_product(flatbuffers::Offset<flatbuffers::String> product) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_PRODUCT, product);
  }
  void add_purchase_system(flatbuffers::Offset<flatbuffers::String> purchase_system) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE::VT_PURCHASE_SYSTEM, purchase_system);
  }
  explicit BILLING_TRANSACTION_CREATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BILLING_TRANSACTION_CREATEBuilder &operator=(const BILLING_TRANSACTION_CREATEBuilder &);
  flatbuffers::Offset<BILLING_TRANSACTION_CREATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BILLING_TRANSACTION_CREATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE> CreateBILLING_TRANSACTION_CREATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7800,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> redirect = 0,
    flatbuffers::Offset<flatbuffers::String> product = 0,
    flatbuffers::Offset<flatbuffers::String> purchase_system = 0) {
  BILLING_TRANSACTION_CREATEBuilder builder_(_fbb);
  builder_.add_purchase_system(purchase_system);
  builder_.add_product(product);
  builder_.add_redirect(redirect);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE> CreateBILLING_TRANSACTION_CREATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7800,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *redirect = nullptr,
    const char *product = nullptr,
    const char *purchase_system = nullptr) {
  return OVERLORD::REQUEST::CreateBILLING_TRANSACTION_CREATE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      redirect ? _fbb.CreateString(redirect) : 0,
      product ? _fbb.CreateString(product) : 0,
      purchase_system ? _fbb.CreateString(purchase_system) : 0);
}

flatbuffers::Offset<BILLING_TRANSACTION_CREATE> CreateBILLING_TRANSACTION_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BILLING_TRANSACTION_SUCCESST : public flatbuffers::NativeTable {
  typedef BILLING_TRANSACTION_SUCCESS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string transaction_id;
  std::string product;
  std::string receipt;
  std::string purchase_system;
  BILLING_TRANSACTION_SUCCESST()
      : type(7801) {
  }
};

struct BILLING_TRANSACTION_SUCCESS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BILLING_TRANSACTION_SUCCESST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_TRANSACTION_ID = 14,
    VT_PRODUCT = 16,
    VT_RECEIPT = 18,
    VT_PURCHASE_SYSTEM = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 7801);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *transaction_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRANSACTION_ID);
  }
  const flatbuffers::String *product() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCT);
  }
  const flatbuffers::String *receipt() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIPT);
  }
  const flatbuffers::String *purchase_system() const {
    return GetPointer<const flatbuffers::String *>(VT_PURCHASE_SYSTEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_TRANSACTION_ID) &&
           verifier.Verify(transaction_id()) &&
           VerifyOffset(verifier, VT_PRODUCT) &&
           verifier.Verify(product()) &&
           VerifyOffset(verifier, VT_RECEIPT) &&
           verifier.Verify(receipt()) &&
           VerifyOffset(verifier, VT_PURCHASE_SYSTEM) &&
           verifier.Verify(purchase_system()) &&
           verifier.EndTable();
  }
  BILLING_TRANSACTION_SUCCESST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BILLING_TRANSACTION_SUCCESST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BILLING_TRANSACTION_SUCCESSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BILLING_TRANSACTION_SUCCESS::VT_TYPE, type, 7801);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_VERSION, version);
  }
  void add_transaction_id(flatbuffers::Offset<flatbuffers::String> transaction_id) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_TRANSACTION_ID, transaction_id);
  }
  void add_product(flatbuffers::Offset<flatbuffers::String> product) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_PRODUCT, product);
  }
  void add_receipt(flatbuffers::Offset<flatbuffers::String> receipt) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_RECEIPT, receipt);
  }
  void add_purchase_system(flatbuffers::Offset<flatbuffers::String> purchase_system) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS::VT_PURCHASE_SYSTEM, purchase_system);
  }
  explicit BILLING_TRANSACTION_SUCCESSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BILLING_TRANSACTION_SUCCESSBuilder &operator=(const BILLING_TRANSACTION_SUCCESSBuilder &);
  flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS>(end);
    return o;
  }
};

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> CreateBILLING_TRANSACTION_SUCCESS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7801,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> transaction_id = 0,
    flatbuffers::Offset<flatbuffers::String> product = 0,
    flatbuffers::Offset<flatbuffers::String> receipt = 0,
    flatbuffers::Offset<flatbuffers::String> purchase_system = 0) {
  BILLING_TRANSACTION_SUCCESSBuilder builder_(_fbb);
  builder_.add_purchase_system(purchase_system);
  builder_.add_receipt(receipt);
  builder_.add_product(product);
  builder_.add_transaction_id(transaction_id);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> CreateBILLING_TRANSACTION_SUCCESSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 7801,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *transaction_id = nullptr,
    const char *product = nullptr,
    const char *receipt = nullptr,
    const char *purchase_system = nullptr) {
  return OVERLORD::REQUEST::CreateBILLING_TRANSACTION_SUCCESS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      transaction_id ? _fbb.CreateString(transaction_id) : 0,
      product ? _fbb.CreateString(product) : 0,
      receipt ? _fbb.CreateString(receipt) : 0,
      purchase_system ? _fbb.CreateString(purchase_system) : 0);
}

flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> CreateBILLING_TRANSACTION_SUCCESS(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_STATUST : public flatbuffers::NativeTable {
  typedef COLOSSEUM_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  COLOSSEUM_STATUST()
      : type(10450) {
  }
};

struct COLOSSEUM_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10450);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  COLOSSEUM_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS::VT_TYPE, type, 10450);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COLOSSEUM_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COLOSSEUM_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COLOSSEUM_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COLOSSEUM_STATUS::VT_VERSION, version);
  }
  explicit COLOSSEUM_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_STATUSBuilder &operator=(const COLOSSEUM_STATUSBuilder &);
  flatbuffers::Offset<COLOSSEUM_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10450,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  COLOSSEUM_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10450,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateCOLOSSEUM_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_PLAY_RESULTT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_PLAY_RESULT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string roomKey;
  COLOSSEUM_PLAY_RESULTT()
      : type(10451) {
  }
};

struct COLOSSEUM_PLAY_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_PLAY_RESULTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ROOMKEY = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10451);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *roomKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomKey()) &&
           verifier.EndTable();
  }
  COLOSSEUM_PLAY_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_PLAY_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_PLAY_RESULT::VT_TYPE, type, 10451);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT::VT_VERSION, version);
  }
  void add_roomKey(flatbuffers::Offset<flatbuffers::String> roomKey) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT::VT_ROOMKEY, roomKey);
  }
  explicit COLOSSEUM_PLAY_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_PLAY_RESULTBuilder &operator=(const COLOSSEUM_PLAY_RESULTBuilder &);
  flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_PLAY_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> CreateCOLOSSEUM_PLAY_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10451,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> roomKey = 0) {
  COLOSSEUM_PLAY_RESULTBuilder builder_(_fbb);
  builder_.add_roomKey(roomKey);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> CreateCOLOSSEUM_PLAY_RESULTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10451,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *roomKey = nullptr) {
  return OVERLORD::REQUEST::CreateCOLOSSEUM_PLAY_RESULT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      roomKey ? _fbb.CreateString(roomKey) : 0);
}

flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> CreateCOLOSSEUM_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_SEASON_DONET : public flatbuffers::NativeTable {
  typedef COLOSSEUM_SEASON_DONE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  COLOSSEUM_SEASON_DONET()
      : type(10452) {
  }
};

struct COLOSSEUM_SEASON_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_SEASON_DONET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10452);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  COLOSSEUM_SEASON_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_SEASON_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_SEASON_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_SEASON_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_SEASON_DONE::VT_TYPE, type, 10452);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE::VT_VERSION, version);
  }
  explicit COLOSSEUM_SEASON_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_SEASON_DONEBuilder &operator=(const COLOSSEUM_SEASON_DONEBuilder &);
  flatbuffers::Offset<COLOSSEUM_SEASON_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_SEASON_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE> CreateCOLOSSEUM_SEASON_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10452,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  COLOSSEUM_SEASON_DONEBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE> CreateCOLOSSEUM_SEASON_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10452,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateCOLOSSEUM_SEASON_DONE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<COLOSSEUM_SEASON_DONE> CreateCOLOSSEUM_SEASON_DONE(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_RANKING_LISTT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_RANKING_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  COLOSSEUM_RANKING_LISTT()
      : type(10453) {
  }
};

struct COLOSSEUM_RANKING_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_RANKING_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10453);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  COLOSSEUM_RANKING_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_RANKING_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_RANKING_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_RANKING_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_RANKING_LIST::VT_TYPE, type, 10453);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST::VT_VERSION, version);
  }
  explicit COLOSSEUM_RANKING_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_RANKING_LISTBuilder &operator=(const COLOSSEUM_RANKING_LISTBuilder &);
  flatbuffers::Offset<COLOSSEUM_RANKING_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_RANKING_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST> CreateCOLOSSEUM_RANKING_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10453,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  COLOSSEUM_RANKING_LISTBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST> CreateCOLOSSEUM_RANKING_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10453,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateCOLOSSEUM_RANKING_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<COLOSSEUM_RANKING_LIST> CreateCOLOSSEUM_RANKING_LIST(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_WRITE_HEROT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_WRITE_HERO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string contents;
  std::string heroId;
  COMMUNITY_ARTICLE_WRITE_HEROT()
      : type(11100) {
  }
};

struct COMMUNITY_ARTICLE_WRITE_HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_WRITE_HEROT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_CONTENTS = 14,
    VT_HEROID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11100);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *contents() const {
    return GetPointer<const flatbuffers::String *>(VT_CONTENTS);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_CONTENTS) &&
           verifier.Verify(contents()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_WRITE_HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_WRITE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_WRITE_HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_WRITE_HERO::VT_TYPE, type, 11100);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_VERSION, version);
  }
  void add_contents(flatbuffers::Offset<flatbuffers::String> contents) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_CONTENTS, contents);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO::VT_HEROID, heroId);
  }
  explicit COMMUNITY_ARTICLE_WRITE_HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_WRITE_HEROBuilder &operator=(const COMMUNITY_ARTICLE_WRITE_HEROBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> CreateCOMMUNITY_ARTICLE_WRITE_HERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11100,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> contents = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0) {
  COMMUNITY_ARTICLE_WRITE_HEROBuilder builder_(_fbb);
  builder_.add_heroId(heroId);
  builder_.add_contents(contents);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> CreateCOMMUNITY_ARTICLE_WRITE_HERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11100,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *contents = nullptr,
    const char *heroId = nullptr) {
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_WRITE_HERO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      contents ? _fbb.CreateString(contents) : 0,
      heroId ? _fbb.CreateString(heroId) : 0);
}

flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> CreateCOMMUNITY_ARTICLE_WRITE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_DELETE_HEROT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_DELETE_HERO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string articleId;
  COMMUNITY_ARTICLE_DELETE_HEROT()
      : type(11101) {
  }
};

struct COMMUNITY_ARTICLE_DELETE_HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_DELETE_HEROT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ARTICLEID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11101);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *articleId() const {
    return GetPointer<const flatbuffers::String *>(VT_ARTICLEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ARTICLEID) &&
           verifier.Verify(articleId()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_DELETE_HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_DELETE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_DELETE_HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_DELETE_HERO::VT_TYPE, type, 11101);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO::VT_VERSION, version);
  }
  void add_articleId(flatbuffers::Offset<flatbuffers::String> articleId) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO::VT_ARTICLEID, articleId);
  }
  explicit COMMUNITY_ARTICLE_DELETE_HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_DELETE_HEROBuilder &operator=(const COMMUNITY_ARTICLE_DELETE_HEROBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> CreateCOMMUNITY_ARTICLE_DELETE_HERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11101,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> articleId = 0) {
  COMMUNITY_ARTICLE_DELETE_HEROBuilder builder_(_fbb);
  builder_.add_articleId(articleId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> CreateCOMMUNITY_ARTICLE_DELETE_HERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11101,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *articleId = nullptr) {
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_DELETE_HERO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      articleId ? _fbb.CreateString(articleId) : 0);
}

flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> CreateCOMMUNITY_ARTICLE_DELETE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_LIST_HEROT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_LIST_HERO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t sortType;
  std::string heroId;
  COMMUNITY_ARTICLE_LIST_HEROT()
      : type(11102),
        sortType(0) {
  }
};

struct COMMUNITY_ARTICLE_LIST_HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_LIST_HEROT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SORTTYPE = 14,
    VT_HEROID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11102);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t sortType() const {
    return GetField<int32_t>(VT_SORTTYPE, 0);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SORTTYPE) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_LIST_HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_LIST_HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_LIST_HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_LIST_HERO::VT_TYPE, type, 11102);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO::VT_VERSION, version);
  }
  void add_sortType(int32_t sortType) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_LIST_HERO::VT_SORTTYPE, sortType, 0);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO::VT_HEROID, heroId);
  }
  explicit COMMUNITY_ARTICLE_LIST_HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_LIST_HEROBuilder &operator=(const COMMUNITY_ARTICLE_LIST_HEROBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> CreateCOMMUNITY_ARTICLE_LIST_HERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11102,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t sortType = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0) {
  COMMUNITY_ARTICLE_LIST_HEROBuilder builder_(_fbb);
  builder_.add_heroId(heroId);
  builder_.add_sortType(sortType);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> CreateCOMMUNITY_ARTICLE_LIST_HERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11102,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t sortType = 0,
    const char *heroId = nullptr) {
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_LIST_HERO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      sortType,
      heroId ? _fbb.CreateString(heroId) : 0);
}

flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> CreateCOMMUNITY_ARTICLE_LIST_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_VOTE_HEROT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_VOTE_HERO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool recommend;
  std::string articleId;
  COMMUNITY_ARTICLE_VOTE_HEROT()
      : type(11103),
        recommend(true) {
  }
};

struct COMMUNITY_ARTICLE_VOTE_HERO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_VOTE_HEROT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_RECOMMEND = 14,
    VT_ARTICLEID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11103);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool recommend() const {
    return GetField<uint8_t>(VT_RECOMMEND, 1) != 0;
  }
  const flatbuffers::String *articleId() const {
    return GetPointer<const flatbuffers::String *>(VT_ARTICLEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_RECOMMEND) &&
           VerifyOffset(verifier, VT_ARTICLEID) &&
           verifier.Verify(articleId()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_VOTE_HEROT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_VOTE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_VOTE_HEROBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_VOTE_HERO::VT_TYPE, type, 11103);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO::VT_VERSION, version);
  }
  void add_recommend(bool recommend) {
    fbb_.AddElement<uint8_t>(COMMUNITY_ARTICLE_VOTE_HERO::VT_RECOMMEND, static_cast<uint8_t>(recommend), 1);
  }
  void add_articleId(flatbuffers::Offset<flatbuffers::String> articleId) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO::VT_ARTICLEID, articleId);
  }
  explicit COMMUNITY_ARTICLE_VOTE_HEROBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_VOTE_HEROBuilder &operator=(const COMMUNITY_ARTICLE_VOTE_HEROBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> CreateCOMMUNITY_ARTICLE_VOTE_HERO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11103,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool recommend = true,
    flatbuffers::Offset<flatbuffers::String> articleId = 0) {
  COMMUNITY_ARTICLE_VOTE_HEROBuilder builder_(_fbb);
  builder_.add_articleId(articleId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_recommend(recommend);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> CreateCOMMUNITY_ARTICLE_VOTE_HERODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11103,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool recommend = true,
    const char *articleId = nullptr) {
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_VOTE_HERO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      recommend,
      articleId ? _fbb.CreateString(articleId) : 0);
}

flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> CreateCOMMUNITY_ARTICLE_VOTE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CONTENT_RESET_STATUST : public flatbuffers::NativeTable {
  typedef CONTENT_RESET_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string resetKey;
  std::string resetType;
  CONTENT_RESET_STATUST()
      : type(15650) {
  }
};

struct CONTENT_RESET_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONTENT_RESET_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_RESETKEY = 14,
    VT_RESETTYPE = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 15650);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *resetKey() const {
    return GetPointer<const flatbuffers::String *>(VT_RESETKEY);
  }
  const flatbuffers::String *resetType() const {
    return GetPointer<const flatbuffers::String *>(VT_RESETTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_RESETKEY) &&
           verifier.Verify(resetKey()) &&
           VerifyOffset(verifier, VT_RESETTYPE) &&
           verifier.Verify(resetType()) &&
           verifier.EndTable();
  }
  CONTENT_RESET_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CONTENT_RESET_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CONTENT_RESET_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CONTENT_RESET_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CONTENT_RESET_STATUS::VT_TYPE, type, 15650);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_VERSION, version);
  }
  void add_resetKey(flatbuffers::Offset<flatbuffers::String> resetKey) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_RESETKEY, resetKey);
  }
  void add_resetType(flatbuffers::Offset<flatbuffers::String> resetType) {
    fbb_.AddOffset(CONTENT_RESET_STATUS::VT_RESETTYPE, resetType);
  }
  explicit CONTENT_RESET_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CONTENT_RESET_STATUSBuilder &operator=(const CONTENT_RESET_STATUSBuilder &);
  flatbuffers::Offset<CONTENT_RESET_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONTENT_RESET_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<CONTENT_RESET_STATUS> CreateCONTENT_RESET_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 15650,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> resetKey = 0,
    flatbuffers::Offset<flatbuffers::String> resetType = 0) {
  CONTENT_RESET_STATUSBuilder builder_(_fbb);
  builder_.add_resetType(resetType);
  builder_.add_resetKey(resetKey);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CONTENT_RESET_STATUS> CreateCONTENT_RESET_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 15650,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *resetKey = nullptr,
    const char *resetType = nullptr) {
  return OVERLORD::REQUEST::CreateCONTENT_RESET_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      resetKey ? _fbb.CreateString(resetKey) : 0,
      resetType ? _fbb.CreateString(resetType) : 0);
}

flatbuffers::Offset<CONTENT_RESET_STATUS> CreateCONTENT_RESET_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CONTENT_RESETT : public flatbuffers::NativeTable {
  typedef CONTENT_RESET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string resetKey;
  std::string resetType;
  CONTENT_RESETT()
      : type(15651) {
  }
};

struct CONTENT_RESET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONTENT_RESETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_RESETKEY = 14,
    VT_RESETTYPE = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 15651);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *resetKey() const {
    return GetPointer<const flatbuffers::String *>(VT_RESETKEY);
  }
  const flatbuffers::String *resetType() const {
    return GetPointer<const flatbuffers::String *>(VT_RESETTYPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_RESETKEY) &&
           verifier.Verify(resetKey()) &&
           VerifyOffset(verifier, VT_RESETTYPE) &&
           verifier.Verify(resetType()) &&
           verifier.EndTable();
  }
  CONTENT_RESETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CONTENT_RESETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CONTENT_RESET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CONTENT_RESETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CONTENT_RESET::VT_TYPE, type, 15651);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(CONTENT_RESET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(CONTENT_RESET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(CONTENT_RESET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(CONTENT_RESET::VT_VERSION, version);
  }
  void add_resetKey(flatbuffers::Offset<flatbuffers::String> resetKey) {
    fbb_.AddOffset(CONTENT_RESET::VT_RESETKEY, resetKey);
  }
  void add_resetType(flatbuffers::Offset<flatbuffers::String> resetType) {
    fbb_.AddOffset(CONTENT_RESET::VT_RESETTYPE, resetType);
  }
  explicit CONTENT_RESETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CONTENT_RESETBuilder &operator=(const CONTENT_RESETBuilder &);
  flatbuffers::Offset<CONTENT_RESET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONTENT_RESET>(end);
    return o;
  }
};

inline flatbuffers::Offset<CONTENT_RESET> CreateCONTENT_RESET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 15651,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> resetKey = 0,
    flatbuffers::Offset<flatbuffers::String> resetType = 0) {
  CONTENT_RESETBuilder builder_(_fbb);
  builder_.add_resetType(resetType);
  builder_.add_resetKey(resetKey);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CONTENT_RESET> CreateCONTENT_RESETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 15651,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *resetKey = nullptr,
    const char *resetType = nullptr) {
  return OVERLORD::REQUEST::CreateCONTENT_RESET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      resetKey ? _fbb.CreateString(resetKey) : 0,
      resetType ? _fbb.CreateString(resetType) : 0);
}

flatbuffers::Offset<CONTENT_RESET> CreateCONTENT_RESET(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ATTENDANCE_GETT : public flatbuffers::NativeTable {
  typedef ATTENDANCE_GET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  ATTENDANCE_GETT()
      : type(5750) {
  }
};

struct ATTENDANCE_GET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ATTENDANCE_GETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5750);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  ATTENDANCE_GETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ATTENDANCE_GETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ATTENDANCE_GET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ATTENDANCE_GETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ATTENDANCE_GET::VT_TYPE, type, 5750);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ATTENDANCE_GET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(ATTENDANCE_GET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(ATTENDANCE_GET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(ATTENDANCE_GET::VT_VERSION, version);
  }
  explicit ATTENDANCE_GETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ATTENDANCE_GETBuilder &operator=(const ATTENDANCE_GETBuilder &);
  flatbuffers::Offset<ATTENDANCE_GET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ATTENDANCE_GET>(end);
    return o;
  }
};

inline flatbuffers::Offset<ATTENDANCE_GET> CreateATTENDANCE_GET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5750,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  ATTENDANCE_GETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ATTENDANCE_GET> CreateATTENDANCE_GETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5750,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateATTENDANCE_GET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<ATTENDANCE_GET> CreateATTENDANCE_GET(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CREATET : public flatbuffers::NativeTable {
  typedef GUILD_CREATE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool auto_grade_up;
  std::string notice;
  std::string desc;
  std::string name;
  GUILD_CREATET()
      : type(5050),
        auto_grade_up(false) {
  }
};

struct GUILD_CREATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CREATET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_AUTO_GRADE_UP = 14,
    VT_NOTICE = 16,
    VT_DESC = 18,
    VT_NAME = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5050);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool auto_grade_up() const {
    return GetField<uint8_t>(VT_AUTO_GRADE_UP, 0) != 0;
  }
  const flatbuffers::String *notice() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICE);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_GRADE_UP) &&
           VerifyOffset(verifier, VT_NOTICE) &&
           verifier.Verify(notice()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
  GUILD_CREATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CREATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CREATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CREATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CREATE::VT_TYPE, type, 5050);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CREATE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CREATE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CREATE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CREATE::VT_VERSION, version);
  }
  void add_auto_grade_up(bool auto_grade_up) {
    fbb_.AddElement<uint8_t>(GUILD_CREATE::VT_AUTO_GRADE_UP, static_cast<uint8_t>(auto_grade_up), 0);
  }
  void add_notice(flatbuffers::Offset<flatbuffers::String> notice) {
    fbb_.AddOffset(GUILD_CREATE::VT_NOTICE, notice);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(GUILD_CREATE::VT_DESC, desc);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GUILD_CREATE::VT_NAME, name);
  }
  explicit GUILD_CREATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CREATEBuilder &operator=(const GUILD_CREATEBuilder &);
  flatbuffers::Offset<GUILD_CREATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CREATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CREATE> CreateGUILD_CREATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5050,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool auto_grade_up = false,
    flatbuffers::Offset<flatbuffers::String> notice = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GUILD_CREATEBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_desc(desc);
  builder_.add_notice(notice);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_auto_grade_up(auto_grade_up);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CREATE> CreateGUILD_CREATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5050,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool auto_grade_up = false,
    const char *notice = nullptr,
    const char *desc = nullptr,
    const char *name = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_CREATE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      auto_grade_up,
      notice ? _fbb.CreateString(notice) : 0,
      desc ? _fbb.CreateString(desc) : 0,
      name ? _fbb.CreateString(name) : 0);
}

flatbuffers::Offset<GUILD_CREATE> CreateGUILD_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CLOSET : public flatbuffers::NativeTable {
  typedef GUILD_CLOSE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_CLOSET()
      : type(5051) {
  }
};

struct GUILD_CLOSE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CLOSET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5051);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_CLOSET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CLOSET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CLOSE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CLOSEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CLOSE::VT_TYPE, type, 5051);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CLOSE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CLOSE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CLOSE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CLOSE::VT_VERSION, version);
  }
  explicit GUILD_CLOSEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CLOSEBuilder &operator=(const GUILD_CLOSEBuilder &);
  flatbuffers::Offset<GUILD_CLOSE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CLOSE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CLOSE> CreateGUILD_CLOSE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5051,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_CLOSEBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CLOSE> CreateGUILD_CLOSEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5051,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_CLOSE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_CLOSE> CreateGUILD_CLOSE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_GETT : public flatbuffers::NativeTable {
  typedef GUILD_GET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_GETT()
      : type(5052) {
  }
};

struct GUILD_GET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_GETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5052);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_GETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_GETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_GET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_GETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_GET::VT_TYPE, type, 5052);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_GET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_GET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_GET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_GET::VT_VERSION, version);
  }
  explicit GUILD_GETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_GETBuilder &operator=(const GUILD_GETBuilder &);
  flatbuffers::Offset<GUILD_GET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_GET>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_GET> CreateGUILD_GET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5052,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_GETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_GET> CreateGUILD_GETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5052,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_GET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_GET> CreateGUILD_GET(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_GET_GUESTT : public flatbuffers::NativeTable {
  typedef GUILD_GET_GUEST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t page;
  int32_t guild_id;
  GUILD_GET_GUESTT()
      : type(5053),
        page(1),
        guild_id(0) {
  }
};

struct GUILD_GET_GUEST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_GET_GUESTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PAGE = 14,
    VT_GUILD_ID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5053);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 1);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_GET_GUESTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_GET_GUESTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_GET_GUEST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_GET_GUESTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_GET_GUEST::VT_TYPE, type, 5053);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_GET_GUEST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_GET_GUEST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_GET_GUEST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_GET_GUEST::VT_VERSION, version);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GUILD_GET_GUEST::VT_PAGE, page, 1);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_GET_GUEST::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_GET_GUESTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_GET_GUESTBuilder &operator=(const GUILD_GET_GUESTBuilder &);
  flatbuffers::Offset<GUILD_GET_GUEST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_GET_GUEST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_GET_GUEST> CreateGUILD_GET_GUEST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5053,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t page = 1,
    int32_t guild_id = 0) {
  GUILD_GET_GUESTBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_page(page);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_GET_GUEST> CreateGUILD_GET_GUESTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5053,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t page = 1,
    int32_t guild_id = 0) {
  return OVERLORD::REQUEST::CreateGUILD_GET_GUEST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      page,
      guild_id);
}

flatbuffers::Offset<GUILD_GET_GUEST> CreateGUILD_GET_GUEST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_LISTT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t page;
  GUILD_MEMBER_LISTT()
      : type(5054),
        page(1) {
  }
};

struct GUILD_MEMBER_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PAGE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5054);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_LIST::VT_TYPE, type, 5054);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_MEMBER_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_MEMBER_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_MEMBER_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_MEMBER_LIST::VT_VERSION, version);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_LIST::VT_PAGE, page, 1);
  }
  explicit GUILD_MEMBER_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_LISTBuilder &operator=(const GUILD_MEMBER_LISTBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_LIST> CreateGUILD_MEMBER_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5054,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t page = 1) {
  GUILD_MEMBER_LISTBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST> CreateGUILD_MEMBER_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5054,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t page = 1) {
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      page);
}

flatbuffers::Offset<GUILD_MEMBER_LIST> CreateGUILD_MEMBER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_LISTT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t page;
  GUILD_AWAITER_LISTT()
      : type(5055),
        page(1) {
  }
};

struct GUILD_AWAITER_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PAGE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5055);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_LIST::VT_TYPE, type, 5055);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_AWAITER_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_AWAITER_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_AWAITER_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_AWAITER_LIST::VT_VERSION, version);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_LIST::VT_PAGE, page, 1);
  }
  explicit GUILD_AWAITER_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_LISTBuilder &operator=(const GUILD_AWAITER_LISTBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_LIST> CreateGUILD_AWAITER_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5055,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t page = 1) {
  GUILD_AWAITER_LISTBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST> CreateGUILD_AWAITER_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5055,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t page = 1) {
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      page);
}

flatbuffers::Offset<GUILD_AWAITER_LIST> CreateGUILD_AWAITER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_ACCEPTT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_ACCEPT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool accept;
  int32_t target_kId;
  GUILD_AWAITER_ACCEPTT()
      : type(5056),
        accept(false),
        target_kId(0) {
  }
};

struct GUILD_AWAITER_ACCEPT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_ACCEPTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ACCEPT = 14,
    VT_TARGET_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5056);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool accept() const {
    return GetField<uint8_t>(VT_ACCEPT, 0) != 0;
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_ACCEPT) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_ACCEPTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_ACCEPTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_ACCEPT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_ACCEPTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_ACCEPT::VT_TYPE, type, 5056);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_AWAITER_ACCEPT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_AWAITER_ACCEPT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_AWAITER_ACCEPT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_AWAITER_ACCEPT::VT_VERSION, version);
  }
  void add_accept(bool accept) {
    fbb_.AddElement<uint8_t>(GUILD_AWAITER_ACCEPT::VT_ACCEPT, static_cast<uint8_t>(accept), 0);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_ACCEPT::VT_TARGET_KID, target_kId, 0);
  }
  explicit GUILD_AWAITER_ACCEPTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_ACCEPTBuilder &operator=(const GUILD_AWAITER_ACCEPTBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_ACCEPT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_ACCEPT>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT> CreateGUILD_AWAITER_ACCEPT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5056,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool accept = false,
    int32_t target_kId = 0) {
  GUILD_AWAITER_ACCEPTBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_accept(accept);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT> CreateGUILD_AWAITER_ACCEPTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5056,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool accept = false,
    int32_t target_kId = 0) {
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_ACCEPT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      accept,
      target_kId);
}

flatbuffers::Offset<GUILD_AWAITER_ACCEPT> CreateGUILD_AWAITER_ACCEPT(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_CANCELT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_CANCEL TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t guild_id;
  GUILD_AWAITER_CANCELT()
      : type(5057),
        guild_id(0) {
  }
};

struct GUILD_AWAITER_CANCEL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_CANCELT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_GUILD_ID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5057);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_CANCELT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_CANCELT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_CANCEL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCELT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_CANCELBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_CANCEL::VT_TYPE, type, 5057);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_AWAITER_CANCEL::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_AWAITER_CANCEL::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_AWAITER_CANCEL::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_AWAITER_CANCEL::VT_VERSION, version);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_CANCEL::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_AWAITER_CANCELBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_CANCELBuilder &operator=(const GUILD_AWAITER_CANCELBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_CANCEL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_CANCEL>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL> CreateGUILD_AWAITER_CANCEL(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5057,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t guild_id = 0) {
  GUILD_AWAITER_CANCELBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL> CreateGUILD_AWAITER_CANCELDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5057,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t guild_id = 0) {
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_CANCEL(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      guild_id);
}

flatbuffers::Offset<GUILD_AWAITER_CANCEL> CreateGUILD_AWAITER_CANCEL(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCELT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_FIND_NAMET : public flatbuffers::NativeTable {
  typedef GUILD_FIND_NAME TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string name;
  GUILD_FIND_NAMET()
      : type(5058) {
  }
};

struct GUILD_FIND_NAME FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_FIND_NAMET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_NAME = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5058);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
  GUILD_FIND_NAMET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_FIND_NAMET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_FIND_NAME> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAMET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_FIND_NAMEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_FIND_NAME::VT_TYPE, type, 5058);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_FIND_NAME::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_FIND_NAME::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_FIND_NAME::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_FIND_NAME::VT_VERSION, version);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GUILD_FIND_NAME::VT_NAME, name);
  }
  explicit GUILD_FIND_NAMEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_FIND_NAMEBuilder &operator=(const GUILD_FIND_NAMEBuilder &);
  flatbuffers::Offset<GUILD_FIND_NAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_FIND_NAME>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_FIND_NAME> CreateGUILD_FIND_NAME(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5058,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GUILD_FIND_NAMEBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_FIND_NAME> CreateGUILD_FIND_NAMEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5058,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *name = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_FIND_NAME(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      name ? _fbb.CreateString(name) : 0);
}

flatbuffers::Offset<GUILD_FIND_NAME> CreateGUILD_FIND_NAME(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAMET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CHANGE_NAMET : public flatbuffers::NativeTable {
  typedef GUILD_CHANGE_NAME TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string name;
  GUILD_CHANGE_NAMET()
      : type(5059) {
  }
};

struct GUILD_CHANGE_NAME FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CHANGE_NAMET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_NAME = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5059);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           verifier.EndTable();
  }
  GUILD_CHANGE_NAMET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CHANGE_NAMET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CHANGE_NAME> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAMET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CHANGE_NAMEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CHANGE_NAME::VT_TYPE, type, 5059);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CHANGE_NAME::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CHANGE_NAME::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CHANGE_NAME::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CHANGE_NAME::VT_VERSION, version);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(GUILD_CHANGE_NAME::VT_NAME, name);
  }
  explicit GUILD_CHANGE_NAMEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CHANGE_NAMEBuilder &operator=(const GUILD_CHANGE_NAMEBuilder &);
  flatbuffers::Offset<GUILD_CHANGE_NAME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CHANGE_NAME>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CHANGE_NAME> CreateGUILD_CHANGE_NAME(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5059,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  GUILD_CHANGE_NAMEBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CHANGE_NAME> CreateGUILD_CHANGE_NAMEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5059,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *name = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_CHANGE_NAME(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      name ? _fbb.CreateString(name) : 0);
}

flatbuffers::Offset<GUILD_CHANGE_NAME> CreateGUILD_CHANGE_NAME(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAMET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_DESCT : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_DESC TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string desc;
  GUILD_EDIT_DESCT()
      : type(5060) {
  }
};

struct GUILD_EDIT_DESC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_DESCT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_DESC = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5060);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.Verify(desc()) &&
           verifier.EndTable();
  }
  GUILD_EDIT_DESCT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_DESCT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_DESC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESCT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_DESCBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_DESC::VT_TYPE, type, 5060);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_EDIT_DESC::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_EDIT_DESC::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_EDIT_DESC::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_EDIT_DESC::VT_VERSION, version);
  }
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(GUILD_EDIT_DESC::VT_DESC, desc);
  }
  explicit GUILD_EDIT_DESCBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_DESCBuilder &operator=(const GUILD_EDIT_DESCBuilder &);
  flatbuffers::Offset<GUILD_EDIT_DESC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_DESC>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_DESC> CreateGUILD_EDIT_DESC(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5060,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> desc = 0) {
  GUILD_EDIT_DESCBuilder builder_(_fbb);
  builder_.add_desc(desc);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_EDIT_DESC> CreateGUILD_EDIT_DESCDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5060,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *desc = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_EDIT_DESC(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      desc ? _fbb.CreateString(desc) : 0);
}

flatbuffers::Offset<GUILD_EDIT_DESC> CreateGUILD_EDIT_DESC(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESCT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_NOTICET : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_NOTICE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string notice;
  GUILD_EDIT_NOTICET()
      : type(5061) {
  }
};

struct GUILD_EDIT_NOTICE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_NOTICET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_NOTICE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5061);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *notice() const {
    return GetPointer<const flatbuffers::String *>(VT_NOTICE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_NOTICE) &&
           verifier.Verify(notice()) &&
           verifier.EndTable();
  }
  GUILD_EDIT_NOTICET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_NOTICET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_NOTICE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_NOTICEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_NOTICE::VT_TYPE, type, 5061);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE::VT_VERSION, version);
  }
  void add_notice(flatbuffers::Offset<flatbuffers::String> notice) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE::VT_NOTICE, notice);
  }
  explicit GUILD_EDIT_NOTICEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_NOTICEBuilder &operator=(const GUILD_EDIT_NOTICEBuilder &);
  flatbuffers::Offset<GUILD_EDIT_NOTICE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_NOTICE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_NOTICE> CreateGUILD_EDIT_NOTICE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5061,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> notice = 0) {
  GUILD_EDIT_NOTICEBuilder builder_(_fbb);
  builder_.add_notice(notice);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_EDIT_NOTICE> CreateGUILD_EDIT_NOTICEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5061,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *notice = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_EDIT_NOTICE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      notice ? _fbb.CreateString(notice) : 0);
}

flatbuffers::Offset<GUILD_EDIT_NOTICE> CreateGUILD_EDIT_NOTICE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_AUTO_GRADE_UPT : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_AUTO_GRADE_UP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool auto_grade_up;
  GUILD_EDIT_AUTO_GRADE_UPT()
      : type(5062),
        auto_grade_up(false) {
  }
};

struct GUILD_EDIT_AUTO_GRADE_UP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_AUTO_GRADE_UPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_AUTO_GRADE_UP = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5062);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool auto_grade_up() const {
    return GetField<uint8_t>(VT_AUTO_GRADE_UP, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_GRADE_UP) &&
           verifier.EndTable();
  }
  GUILD_EDIT_AUTO_GRADE_UPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_AUTO_GRADE_UPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_AUTO_GRADE_UPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_AUTO_GRADE_UP::VT_TYPE, type, 5062);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP::VT_VERSION, version);
  }
  void add_auto_grade_up(bool auto_grade_up) {
    fbb_.AddElement<uint8_t>(GUILD_EDIT_AUTO_GRADE_UP::VT_AUTO_GRADE_UP, static_cast<uint8_t>(auto_grade_up), 0);
  }
  explicit GUILD_EDIT_AUTO_GRADE_UPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_AUTO_GRADE_UPBuilder &operator=(const GUILD_EDIT_AUTO_GRADE_UPBuilder &);
  flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> CreateGUILD_EDIT_AUTO_GRADE_UP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5062,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool auto_grade_up = false) {
  GUILD_EDIT_AUTO_GRADE_UPBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_auto_grade_up(auto_grade_up);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> CreateGUILD_EDIT_AUTO_GRADE_UPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5062,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool auto_grade_up = false) {
  return OVERLORD::REQUEST::CreateGUILD_EDIT_AUTO_GRADE_UP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      auto_grade_up);
}

flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> CreateGUILD_EDIT_AUTO_GRADE_UP(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_JOINT : public flatbuffers::NativeTable {
  typedef GUILD_JOIN TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t guild_id;
  GUILD_JOINT()
      : type(5063),
        guild_id(0) {
  }
};

struct GUILD_JOIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_JOINT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_GUILD_ID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5063);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_JOINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_JOINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_JOIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_JOINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_JOIN::VT_TYPE, type, 5063);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_JOIN::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_JOIN::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_JOIN::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_JOIN::VT_VERSION, version);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_JOIN::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_JOINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_JOINBuilder &operator=(const GUILD_JOINBuilder &);
  flatbuffers::Offset<GUILD_JOIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_JOIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_JOIN> CreateGUILD_JOIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5063,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t guild_id = 0) {
  GUILD_JOINBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_JOIN> CreateGUILD_JOINDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5063,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t guild_id = 0) {
  return OVERLORD::REQUEST::CreateGUILD_JOIN(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      guild_id);
}

flatbuffers::Offset<GUILD_JOIN> CreateGUILD_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_JOIN_AUTOT : public flatbuffers::NativeTable {
  typedef GUILD_JOIN_AUTO TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_JOIN_AUTOT()
      : type(5064) {
  }
};

struct GUILD_JOIN_AUTO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_JOIN_AUTOT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5064);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_JOIN_AUTOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_JOIN_AUTOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_JOIN_AUTO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_JOIN_AUTOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_JOIN_AUTO::VT_TYPE, type, 5064);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_JOIN_AUTO::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_JOIN_AUTO::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_JOIN_AUTO::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_JOIN_AUTO::VT_VERSION, version);
  }
  explicit GUILD_JOIN_AUTOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_JOIN_AUTOBuilder &operator=(const GUILD_JOIN_AUTOBuilder &);
  flatbuffers::Offset<GUILD_JOIN_AUTO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_JOIN_AUTO>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_JOIN_AUTO> CreateGUILD_JOIN_AUTO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5064,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_JOIN_AUTOBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_JOIN_AUTO> CreateGUILD_JOIN_AUTODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5064,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_JOIN_AUTO(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_JOIN_AUTO> CreateGUILD_JOIN_AUTO(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_GRADET : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_GRADE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t grade;
  int32_t target_kId;
  GUILD_MEMBER_GRADET()
      : type(5065),
        grade(0),
        target_kId(0) {
  }
};

struct GUILD_MEMBER_GRADE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_GRADET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_GRADE = 14,
    VT_TARGET_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5065);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t grade() const {
    return GetField<int32_t>(VT_GRADE, 0);
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_GRADE) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_GRADET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_GRADET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_GRADE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_GRADEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_GRADE::VT_TYPE, type, 5065);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE::VT_VERSION, version);
  }
  void add_grade(int32_t grade) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_GRADE::VT_GRADE, grade, 0);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_GRADE::VT_TARGET_KID, target_kId, 0);
  }
  explicit GUILD_MEMBER_GRADEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_GRADEBuilder &operator=(const GUILD_MEMBER_GRADEBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_GRADE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_GRADE>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_GRADE> CreateGUILD_MEMBER_GRADE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5065,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t grade = 0,
    int32_t target_kId = 0) {
  GUILD_MEMBER_GRADEBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_grade(grade);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_MEMBER_GRADE> CreateGUILD_MEMBER_GRADEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5065,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t grade = 0,
    int32_t target_kId = 0) {
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_GRADE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      grade,
      target_kId);
}

flatbuffers::Offset<GUILD_MEMBER_GRADE> CreateGUILD_MEMBER_GRADE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_KICKT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_KICK TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t target_kId;
  GUILD_MEMBER_KICKT()
      : type(5066),
        target_kId(0) {
  }
};

struct GUILD_MEMBER_KICK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_KICKT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_TARGET_KID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5066);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_KICKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_KICKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_KICK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_KICKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_KICK::VT_TYPE, type, 5066);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_MEMBER_KICK::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_MEMBER_KICK::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_MEMBER_KICK::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_MEMBER_KICK::VT_VERSION, version);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_KICK::VT_TARGET_KID, target_kId, 0);
  }
  explicit GUILD_MEMBER_KICKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_KICKBuilder &operator=(const GUILD_MEMBER_KICKBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_KICK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_KICK>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_KICK> CreateGUILD_MEMBER_KICK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5066,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t target_kId = 0) {
  GUILD_MEMBER_KICKBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_MEMBER_KICK> CreateGUILD_MEMBER_KICKDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5066,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t target_kId = 0) {
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_KICK(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      target_kId);
}

flatbuffers::Offset<GUILD_MEMBER_KICK> CreateGUILD_MEMBER_KICK(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTIONT : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTION TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t contributionType;
  GUILD_CONTRIBUTIONT()
      : type(5067),
        contributionType(0) {
  }
};

struct GUILD_CONTRIBUTION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTIONT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_CONTRIBUTIONTYPE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5067);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t contributionType() const {
    return GetField<int32_t>(VT_CONTRIBUTIONTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_CONTRIBUTIONTYPE) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTION::VT_TYPE, type, 5067);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CONTRIBUTION::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CONTRIBUTION::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CONTRIBUTION::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CONTRIBUTION::VT_VERSION, version);
  }
  void add_contributionType(int32_t contributionType) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTION::VT_CONTRIBUTIONTYPE, contributionType, 0);
  }
  explicit GUILD_CONTRIBUTIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTIONBuilder &operator=(const GUILD_CONTRIBUTIONBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTION>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTION> CreateGUILD_CONTRIBUTION(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5067,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t contributionType = 0) {
  GUILD_CONTRIBUTIONBuilder builder_(_fbb);
  builder_.add_contributionType(contributionType);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION> CreateGUILD_CONTRIBUTIONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5067,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t contributionType = 0) {
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTION(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      contributionType);
}

flatbuffers::Offset<GUILD_CONTRIBUTION> CreateGUILD_CONTRIBUTION(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTE_RANKINGT : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTE_RANKING TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t page;
  GUILD_CONTRIBUTE_RANKINGT()
      : type(5068),
        page(1) {
  }
};

struct GUILD_CONTRIBUTE_RANKING FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTE_RANKINGT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PAGE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5068);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t page() const {
    return GetField<int32_t>(VT_PAGE, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PAGE) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTE_RANKINGT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTE_RANKINGT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKINGT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTE_RANKINGBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTE_RANKING::VT_TYPE, type, 5068);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING::VT_VERSION, version);
  }
  void add_page(int32_t page) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTE_RANKING::VT_PAGE, page, 1);
  }
  explicit GUILD_CONTRIBUTE_RANKINGBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTE_RANKINGBuilder &operator=(const GUILD_CONTRIBUTE_RANKINGBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> CreateGUILD_CONTRIBUTE_RANKING(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5068,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t page = 1) {
  GUILD_CONTRIBUTE_RANKINGBuilder builder_(_fbb);
  builder_.add_page(page);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> CreateGUILD_CONTRIBUTE_RANKINGDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5068,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t page = 1) {
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTE_RANKING(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      page);
}

flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> CreateGUILD_CONTRIBUTE_RANKING(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKINGT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTION_STATUST : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTION_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_CONTRIBUTION_STATUST()
      : type(5069) {
  }
};

struct GUILD_CONTRIBUTION_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTION_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5069);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTION_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTION_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTION_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTION_STATUS::VT_TYPE, type, 5069);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_STATUS::VT_VERSION, version);
  }
  explicit GUILD_CONTRIBUTION_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTION_STATUSBuilder &operator=(const GUILD_CONTRIBUTION_STATUSBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> CreateGUILD_CONTRIBUTION_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5069,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_CONTRIBUTION_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> CreateGUILD_CONTRIBUTION_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5069,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTION_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> CreateGUILD_CONTRIBUTION_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_STATUST : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_ATTENDANCE_STATUST()
      : type(5070) {
  }
};

struct GUILD_ATTENDANCE_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5070);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_STATUS::VT_TYPE, type, 5070);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_ATTENDANCE_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_ATTENDANCE_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_ATTENDANCE_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_ATTENDANCE_STATUS::VT_VERSION, version);
  }
  explicit GUILD_ATTENDANCE_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_STATUSBuilder &operator=(const GUILD_ATTENDANCE_STATUSBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> CreateGUILD_ATTENDANCE_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5070,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_ATTENDANCE_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> CreateGUILD_ATTENDANCE_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5070,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> CreateGUILD_ATTENDANCE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_DAILY_REWARDT : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_DAILY_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_ATTENDANCE_DAILY_REWARDT()
      : type(5071) {
  }
};

struct GUILD_ATTENDANCE_DAILY_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_DAILY_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5071);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_DAILY_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_DAILY_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_DAILY_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_DAILY_REWARD::VT_TYPE, type, 5071);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD::VT_VERSION, version);
  }
  explicit GUILD_ATTENDANCE_DAILY_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_DAILY_REWARDBuilder &operator=(const GUILD_ATTENDANCE_DAILY_REWARDBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> CreateGUILD_ATTENDANCE_DAILY_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5071,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_ATTENDANCE_DAILY_REWARDBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> CreateGUILD_ATTENDANCE_DAILY_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5071,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_DAILY_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> CreateGUILD_ATTENDANCE_DAILY_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_WEEKLY_REWARDT : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_WEEKLY_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_ATTENDANCE_WEEKLY_REWARDT()
      : type(5072) {
  }
};

struct GUILD_ATTENDANCE_WEEKLY_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_WEEKLY_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5072);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_WEEKLY_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_WEEKLY_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_WEEKLY_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_WEEKLY_REWARD::VT_TYPE, type, 5072);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD::VT_VERSION, version);
  }
  explicit GUILD_ATTENDANCE_WEEKLY_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_WEEKLY_REWARDBuilder &operator=(const GUILD_ATTENDANCE_WEEKLY_REWARDBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> CreateGUILD_ATTENDANCE_WEEKLY_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5072,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_ATTENDANCE_WEEKLY_REWARDBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> CreateGUILD_ATTENDANCE_WEEKLY_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5072,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_WEEKLY_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> CreateGUILD_ATTENDANCE_WEEKLY_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_STATUST : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_RUNE_STATUST()
      : type(5073) {
  }
};

struct GUILD_RUNE_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5073);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_RUNE_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_STATUS::VT_TYPE, type, 5073);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_RUNE_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_RUNE_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_RUNE_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_RUNE_STATUS::VT_VERSION, version);
  }
  explicit GUILD_RUNE_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_STATUSBuilder &operator=(const GUILD_RUNE_STATUSBuilder &);
  flatbuffers::Offset<GUILD_RUNE_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_STATUS> CreateGUILD_RUNE_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5073,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_RUNE_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS> CreateGUILD_RUNE_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5073,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_RUNE_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_RUNE_STATUS> CreateGUILD_RUNE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_REQUESTT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_REQUEST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string heroId;
  GUILD_RUNE_REQUESTT()
      : type(5074) {
  }
};

struct GUILD_RUNE_REQUEST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_REQUESTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_HEROID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5074);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           verifier.EndTable();
  }
  GUILD_RUNE_REQUESTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_REQUESTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_REQUEST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_REQUESTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUEST::VT_TYPE, type, 5074);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST::VT_VERSION, version);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST::VT_HEROID, heroId);
  }
  explicit GUILD_RUNE_REQUESTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_REQUESTBuilder &operator=(const GUILD_RUNE_REQUESTBuilder &);
  flatbuffers::Offset<GUILD_RUNE_REQUEST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_REQUEST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_REQUEST> CreateGUILD_RUNE_REQUEST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5074,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0) {
  GUILD_RUNE_REQUESTBuilder builder_(_fbb);
  builder_.add_heroId(heroId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST> CreateGUILD_RUNE_REQUESTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5074,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *heroId = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_RUNE_REQUEST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      heroId ? _fbb.CreateString(heroId) : 0);
}

flatbuffers::Offset<GUILD_RUNE_REQUEST> CreateGUILD_RUNE_REQUEST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_SUPPORTT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_SUPPORT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t amount;
  std::string heroId;
  int32_t requester_kId;
  GUILD_RUNE_SUPPORTT()
      : type(5075),
        amount(0),
        requester_kId(0) {
  }
};

struct GUILD_RUNE_SUPPORT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_SUPPORTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_AMOUNT = 14,
    VT_HEROID = 16,
    VT_REQUESTER_KID = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5075);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t requester_kId() const {
    return GetField<int32_t>(VT_REQUESTER_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_REQUESTER_KID) &&
           verifier.EndTable();
  }
  GUILD_RUNE_SUPPORTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_SUPPORTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_SUPPORT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_SUPPORTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_SUPPORT::VT_TYPE, type, 5075);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT::VT_VERSION, version);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_SUPPORT::VT_AMOUNT, amount, 0);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT::VT_HEROID, heroId);
  }
  void add_requester_kId(int32_t requester_kId) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_SUPPORT::VT_REQUESTER_KID, requester_kId, 0);
  }
  explicit GUILD_RUNE_SUPPORTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_SUPPORTBuilder &operator=(const GUILD_RUNE_SUPPORTBuilder &);
  flatbuffers::Offset<GUILD_RUNE_SUPPORT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_SUPPORT>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT> CreateGUILD_RUNE_SUPPORT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5075,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t amount = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t requester_kId = 0) {
  GUILD_RUNE_SUPPORTBuilder builder_(_fbb);
  builder_.add_requester_kId(requester_kId);
  builder_.add_heroId(heroId);
  builder_.add_amount(amount);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT> CreateGUILD_RUNE_SUPPORTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5075,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t amount = 0,
    const char *heroId = nullptr,
    int32_t requester_kId = 0) {
  return OVERLORD::REQUEST::CreateGUILD_RUNE_SUPPORT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      amount,
      heroId ? _fbb.CreateString(heroId) : 0,
      requester_kId);
}

flatbuffers::Offset<GUILD_RUNE_SUPPORT> CreateGUILD_RUNE_SUPPORT(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_GETT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_GET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_RUNE_GETT()
      : type(5076) {
  }
};

struct GUILD_RUNE_GET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_GETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5076);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_RUNE_GETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_GETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_GET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_GETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_GET::VT_TYPE, type, 5076);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_RUNE_GET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_RUNE_GET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_RUNE_GET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_RUNE_GET::VT_VERSION, version);
  }
  explicit GUILD_RUNE_GETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_GETBuilder &operator=(const GUILD_RUNE_GETBuilder &);
  flatbuffers::Offset<GUILD_RUNE_GET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_GET>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_GET> CreateGUILD_RUNE_GET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5076,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_RUNE_GETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_GET> CreateGUILD_RUNE_GETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5076,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_RUNE_GET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_RUNE_GET> CreateGUILD_RUNE_GET(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_HISTORYT : public flatbuffers::NativeTable {
  typedef GUILD_HISTORY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GUILD_HISTORYT()
      : type(5077) {
  }
};

struct GUILD_HISTORY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_HISTORYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5077);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GUILD_HISTORYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_HISTORY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_HISTORYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_HISTORY::VT_TYPE, type, 5077);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_HISTORY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_HISTORY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_HISTORY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_HISTORY::VT_VERSION, version);
  }
  explicit GUILD_HISTORYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_HISTORYBuilder &operator=(const GUILD_HISTORYBuilder &);
  flatbuffers::Offset<GUILD_HISTORY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_HISTORY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5077,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GUILD_HISTORYBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5077,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGUILD_HISTORY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_LEVEL_UPT : public flatbuffers::NativeTable {
  typedef GUILD_LEVEL_UP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t level;
  GUILD_LEVEL_UPT()
      : type(5078),
        level(0) {
  }
};

struct GUILD_LEVEL_UP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_LEVEL_UPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_LEVEL = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 5078);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           verifier.EndTable();
  }
  GUILD_LEVEL_UPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_LEVEL_UPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_LEVEL_UP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_LEVEL_UPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_LEVEL_UP::VT_TYPE, type, 5078);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GUILD_LEVEL_UP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GUILD_LEVEL_UP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GUILD_LEVEL_UP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GUILD_LEVEL_UP::VT_VERSION, version);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(GUILD_LEVEL_UP::VT_LEVEL, level, 0);
  }
  explicit GUILD_LEVEL_UPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_LEVEL_UPBuilder &operator=(const GUILD_LEVEL_UPBuilder &);
  flatbuffers::Offset<GUILD_LEVEL_UP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_LEVEL_UP>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_LEVEL_UP> CreateGUILD_LEVEL_UP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5078,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t level = 0) {
  GUILD_LEVEL_UPBuilder builder_(_fbb);
  builder_.add_level(level);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_LEVEL_UP> CreateGUILD_LEVEL_UPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 5078,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t level = 0) {
  return OVERLORD::REQUEST::CreateGUILD_LEVEL_UP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      level);
}

flatbuffers::Offset<GUILD_LEVEL_UP> CreateGUILD_LEVEL_UP(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_UPGRADET : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_UPGRADE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> materials4;
  std::vector<std::string> materials3;
  std::vector<std::string> materials2;
  std::vector<std::string> materials1;
  std::string heroUD;
  INVENTORY_HERO_UPGRADET()
      : type(11200) {
  }
};

struct INVENTORY_HERO_UPGRADE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_UPGRADET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_MATERIALS4 = 14,
    VT_MATERIALS3 = 16,
    VT_MATERIALS2 = 18,
    VT_MATERIALS1 = 20,
    VT_HEROUD = 22
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11200);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials4() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS4);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials3() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS3);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials2() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS2);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *materials1() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIALS1);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_MATERIALS4) &&
           verifier.Verify(materials4()) &&
           verifier.VerifyVectorOfStrings(materials4()) &&
           VerifyOffset(verifier, VT_MATERIALS3) &&
           verifier.Verify(materials3()) &&
           verifier.VerifyVectorOfStrings(materials3()) &&
           VerifyOffset(verifier, VT_MATERIALS2) &&
           verifier.Verify(materials2()) &&
           verifier.VerifyVectorOfStrings(materials2()) &&
           VerifyOffset(verifier, VT_MATERIALS1) &&
           verifier.Verify(materials1()) &&
           verifier.VerifyVectorOfStrings(materials1()) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_UPGRADET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_UPGRADE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_UPGRADEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_UPGRADE::VT_TYPE, type, 11200);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_VERSION, version);
  }
  void add_materials4(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials4) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_MATERIALS4, materials4);
  }
  void add_materials3(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials3) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_MATERIALS3, materials3);
  }
  void add_materials2(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials2) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_MATERIALS2, materials2);
  }
  void add_materials1(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials1) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_MATERIALS1, materials1);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_UPGRADEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_UPGRADEBuilder &operator=(const INVENTORY_HERO_UPGRADEBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_UPGRADE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_UPGRADE>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE> CreateINVENTORY_HERO_UPGRADE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11200,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials4 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials3 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials2 = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> materials1 = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_UPGRADEBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_materials1(materials1);
  builder_.add_materials2(materials2);
  builder_.add_materials3(materials3);
  builder_.add_materials4(materials4);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE> CreateINVENTORY_HERO_UPGRADEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11200,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials4 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials3 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials2 = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *materials1 = nullptr,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_UPGRADE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      materials4 ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials4) : 0,
      materials3 ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials3) : 0,
      materials2 ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials2) : 0,
      materials1 ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*materials1) : 0,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_UPGRADE> CreateINVENTORY_HERO_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_LEVELUPT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_LEVELUP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t level;
  std::string heroUD;
  INVENTORY_HERO_LEVELUPT()
      : type(11201),
        level(0) {
  }
};

struct INVENTORY_HERO_LEVELUP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_LEVELUPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_LEVEL = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11201);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_LEVELUPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_LEVELUP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_LEVELUPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_LEVELUP::VT_TYPE, type, 11201);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP::VT_VERSION, version);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_LEVELUP::VT_LEVEL, level, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_LEVELUPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_LEVELUPBuilder &operator=(const INVENTORY_HERO_LEVELUPBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_LEVELUP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_LEVELUP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP> CreateINVENTORY_HERO_LEVELUP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11201,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t level = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_LEVELUPBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_level(level);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP> CreateINVENTORY_HERO_LEVELUPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11201,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t level = 0,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_LEVELUP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      level,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_LEVELUP> CreateINVENTORY_HERO_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_GRINDT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_GRIND TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> heroUDs;
  INVENTORY_HERO_GRINDT()
      : type(11202) {
  }
};

struct INVENTORY_HERO_GRIND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_GRINDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_HEROUDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11202);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_HEROUDS) &&
           verifier.Verify(heroUDs()) &&
           verifier.VerifyVectorOfStrings(heroUDs()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_GRINDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_GRINDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_GRIND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRINDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_GRINDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_GRIND::VT_TYPE, type, 11202);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND::VT_VERSION, version);
  }
  void add_heroUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND::VT_HEROUDS, heroUDs);
  }
  explicit INVENTORY_HERO_GRINDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_GRINDBuilder &operator=(const INVENTORY_HERO_GRINDBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_GRIND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_GRIND>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_GRIND> CreateINVENTORY_HERO_GRIND(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11202,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs = 0) {
  INVENTORY_HERO_GRINDBuilder builder_(_fbb);
  builder_.add_heroUDs(heroUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND> CreateINVENTORY_HERO_GRINDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11202,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_GRIND(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      heroUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_GRIND> CreateINVENTORY_HERO_GRIND(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRINDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_EQUIPT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_EQUIP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string itemUD;
  std::string heroUD;
  INVENTORY_HERO_EQUIPT()
      : type(11203) {
  }
};

struct INVENTORY_HERO_EQUIP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_EQUIPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ITEMUD = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11203);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_EQUIPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_EQUIPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_EQUIP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_EQUIPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_EQUIP::VT_TYPE, type, 11203);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_VERSION, version);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_ITEMUD, itemUD);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_EQUIPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_EQUIPBuilder &operator=(const INVENTORY_HERO_EQUIPBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_EQUIP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_EQUIP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP> CreateINVENTORY_HERO_EQUIP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11203,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_EQUIPBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_itemUD(itemUD);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP> CreateINVENTORY_HERO_EQUIPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11203,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *itemUD = nullptr,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_EQUIP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_EQUIP> CreateINVENTORY_HERO_EQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_UNEQUIPT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_UNEQUIP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string itemUD;
  std::string heroUD;
  INVENTORY_HERO_UNEQUIPT()
      : type(11204) {
  }
};

struct INVENTORY_HERO_UNEQUIP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_UNEQUIPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ITEMUD = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11204);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_UNEQUIPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_UNEQUIPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_UNEQUIPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_UNEQUIP::VT_TYPE, type, 11204);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_VERSION, version);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_ITEMUD, itemUD);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_UNEQUIPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_UNEQUIPBuilder &operator=(const INVENTORY_HERO_UNEQUIPBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_UNEQUIP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> CreateINVENTORY_HERO_UNEQUIP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11204,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_UNEQUIPBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_itemUD(itemUD);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> CreateINVENTORY_HERO_UNEQUIPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11204,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *itemUD = nullptr,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_UNEQUIP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> CreateINVENTORY_HERO_UNEQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_GRINDT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_GRIND TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> itemUDs;
  INVENTORY_ITEM_GRINDT()
      : type(11205) {
  }
};

struct INVENTORY_ITEM_GRIND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_GRINDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ITEMUDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11205);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ITEMUDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ITEMUDS) &&
           verifier.Verify(itemUDs()) &&
           verifier.VerifyVectorOfStrings(itemUDs()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_GRINDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_GRINDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_GRIND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRINDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_GRINDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_GRIND::VT_TYPE, type, 11205);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND::VT_VERSION, version);
  }
  void add_itemUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND::VT_ITEMUDS, itemUDs);
  }
  explicit INVENTORY_ITEM_GRINDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_GRINDBuilder &operator=(const INVENTORY_ITEM_GRINDBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_GRIND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_GRIND>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND> CreateINVENTORY_ITEM_GRIND(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11205,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs = 0) {
  INVENTORY_ITEM_GRINDBuilder builder_(_fbb);
  builder_.add_itemUDs(itemUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND> CreateINVENTORY_ITEM_GRINDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11205,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_GRIND(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      itemUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*itemUDs) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_GRIND> CreateINVENTORY_ITEM_GRIND(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRINDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_EQUIPT : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_EQUIP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> equipRunes;
  std::string itemUD;
  INVENTORY_RUNE_EQUIPT()
      : type(11206) {
  }
};

struct INVENTORY_RUNE_EQUIP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_EQUIPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_EQUIPRUNES = 14,
    VT_ITEMUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11206);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *equipRunes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_EQUIPRUNES);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_EQUIPRUNES) &&
           verifier.Verify(equipRunes()) &&
           verifier.VerifyVectorOfStrings(equipRunes()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_EQUIPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_EQUIPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_EQUIP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_EQUIPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_EQUIP::VT_TYPE, type, 11206);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_VERSION, version);
  }
  void add_equipRunes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> equipRunes) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_EQUIPRUNES, equipRunes);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_RUNE_EQUIPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_EQUIPBuilder &operator=(const INVENTORY_RUNE_EQUIPBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_EQUIP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_EQUIP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP> CreateINVENTORY_RUNE_EQUIP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11206,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> equipRunes = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_RUNE_EQUIPBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_equipRunes(equipRunes);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP> CreateINVENTORY_RUNE_EQUIPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11206,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *equipRunes = nullptr,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_EQUIP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      equipRunes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*equipRunes) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_RUNE_EQUIP> CreateINVENTORY_RUNE_EQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_UNEQUIPT : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_UNEQUIP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<bool> unequipSlots;
  std::string itemUD;
  INVENTORY_RUNE_UNEQUIPT()
      : type(11207) {
  }
};

struct INVENTORY_RUNE_UNEQUIP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_UNEQUIPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_UNEQUIPSLOTS = 14,
    VT_ITEMUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11207);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<uint8_t> *unequipSlots() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_UNEQUIPSLOTS);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_UNEQUIPSLOTS) &&
           verifier.Verify(unequipSlots()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_UNEQUIPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_UNEQUIPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_UNEQUIPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_UNEQUIP::VT_TYPE, type, 11207);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_VERSION, version);
  }
  void add_unequipSlots(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> unequipSlots) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_UNEQUIPSLOTS, unequipSlots);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_RUNE_UNEQUIPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_UNEQUIPBuilder &operator=(const INVENTORY_RUNE_UNEQUIPBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> CreateINVENTORY_RUNE_UNEQUIP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11207,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> unequipSlots = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_RUNE_UNEQUIPBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_unequipSlots(unequipSlots);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> CreateINVENTORY_RUNE_UNEQUIPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11207,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<uint8_t> *unequipSlots = nullptr,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_UNEQUIP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      unequipSlots ? _fbb.CreateVector<uint8_t>(*unequipSlots) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> CreateINVENTORY_RUNE_UNEQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_MAKET : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_MAKE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t amount;
  std::string rune;
  INVENTORY_RUNE_MAKET()
      : type(11208),
        amount(1) {
  }
};

struct INVENTORY_RUNE_MAKE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_MAKET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_AMOUNT = 14,
    VT_RUNE = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11208);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 1);
  }
  const flatbuffers::String *rune() const {
    return GetPointer<const flatbuffers::String *>(VT_RUNE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_RUNE) &&
           verifier.Verify(rune()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_MAKET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_MAKET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_MAKE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_MAKEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_MAKE::VT_TYPE, type, 11208);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE::VT_VERSION, version);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_MAKE::VT_AMOUNT, amount, 1);
  }
  void add_rune(flatbuffers::Offset<flatbuffers::String> rune) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE::VT_RUNE, rune);
  }
  explicit INVENTORY_RUNE_MAKEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_MAKEBuilder &operator=(const INVENTORY_RUNE_MAKEBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_MAKE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_MAKE>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE> CreateINVENTORY_RUNE_MAKE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11208,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t amount = 1,
    flatbuffers::Offset<flatbuffers::String> rune = 0) {
  INVENTORY_RUNE_MAKEBuilder builder_(_fbb);
  builder_.add_rune(rune);
  builder_.add_amount(amount);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE> CreateINVENTORY_RUNE_MAKEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11208,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t amount = 1,
    const char *rune = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_MAKE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      amount,
      rune ? _fbb.CreateString(rune) : 0);
}

flatbuffers::Offset<INVENTORY_RUNE_MAKE> CreateINVENTORY_RUNE_MAKE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_LEVELUPT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_LEVELUP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t amount;
  std::string itemUD;
  INVENTORY_ITEM_LEVELUPT()
      : type(11209),
        amount(1) {
  }
};

struct INVENTORY_ITEM_LEVELUP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_LEVELUPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_AMOUNT = 14,
    VT_ITEMUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11209);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 1);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_LEVELUPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_LEVELUPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_LEVELUP::VT_TYPE, type, 11209);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP::VT_VERSION, version);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_LEVELUP::VT_AMOUNT, amount, 1);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_ITEM_LEVELUPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_LEVELUPBuilder &operator=(const INVENTORY_ITEM_LEVELUPBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_LEVELUP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> CreateINVENTORY_ITEM_LEVELUP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11209,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t amount = 1,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_ITEM_LEVELUPBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_amount(amount);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> CreateINVENTORY_ITEM_LEVELUPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11209,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t amount = 1,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_LEVELUP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      amount,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> CreateINVENTORY_ITEM_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_ENCHANTT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_ENCHANT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool useProtection;
  bool specialEnchant;
  std::string itemUD;
  INVENTORY_ITEM_ENCHANTT()
      : type(11210),
        useProtection(false),
        specialEnchant(false) {
  }
};

struct INVENTORY_ITEM_ENCHANT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_ENCHANTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_USEPROTECTION = 14,
    VT_SPECIALENCHANT = 16,
    VT_ITEMUD = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11210);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool useProtection() const {
    return GetField<uint8_t>(VT_USEPROTECTION, 0) != 0;
  }
  bool specialEnchant() const {
    return GetField<uint8_t>(VT_SPECIALENCHANT, 0) != 0;
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_USEPROTECTION) &&
           VerifyField<uint8_t>(verifier, VT_SPECIALENCHANT) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_ENCHANTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_ENCHANTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_ENCHANTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_ENCHANT::VT_TYPE, type, 11210);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT::VT_VERSION, version);
  }
  void add_useProtection(bool useProtection) {
    fbb_.AddElement<uint8_t>(INVENTORY_ITEM_ENCHANT::VT_USEPROTECTION, static_cast<uint8_t>(useProtection), 0);
  }
  void add_specialEnchant(bool specialEnchant) {
    fbb_.AddElement<uint8_t>(INVENTORY_ITEM_ENCHANT::VT_SPECIALENCHANT, static_cast<uint8_t>(specialEnchant), 0);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_ITEM_ENCHANTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_ENCHANTBuilder &operator=(const INVENTORY_ITEM_ENCHANTBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_ENCHANT>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> CreateINVENTORY_ITEM_ENCHANT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11210,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool useProtection = false,
    bool specialEnchant = false,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_ITEM_ENCHANTBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_specialEnchant(specialEnchant);
  builder_.add_useProtection(useProtection);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> CreateINVENTORY_ITEM_ENCHANTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11210,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool useProtection = false,
    bool specialEnchant = false,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_ENCHANT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      useProtection,
      specialEnchant,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> CreateINVENTORY_ITEM_ENCHANT(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_HERO_LOCKT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_HERO_LOCK TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> heroUDs_unlock;
  std::vector<std::string> heroUDs_lock;
  std::vector<std::string> itemUDs_unlock;
  std::vector<std::string> itemUDs_lock;
  INVENTORY_ITEM_HERO_LOCKT()
      : type(11211) {
  }
};

struct INVENTORY_ITEM_HERO_LOCK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_HERO_LOCKT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_HEROUDS_UNLOCK = 14,
    VT_HEROUDS_LOCK = 16,
    VT_ITEMUDS_UNLOCK = 18,
    VT_ITEMUDS_LOCK = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11211);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs_unlock() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS_UNLOCK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs_lock() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS_LOCK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs_unlock() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ITEMUDS_UNLOCK);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs_lock() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ITEMUDS_LOCK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_HEROUDS_UNLOCK) &&
           verifier.Verify(heroUDs_unlock()) &&
           verifier.VerifyVectorOfStrings(heroUDs_unlock()) &&
           VerifyOffset(verifier, VT_HEROUDS_LOCK) &&
           verifier.Verify(heroUDs_lock()) &&
           verifier.VerifyVectorOfStrings(heroUDs_lock()) &&
           VerifyOffset(verifier, VT_ITEMUDS_UNLOCK) &&
           verifier.Verify(itemUDs_unlock()) &&
           verifier.VerifyVectorOfStrings(itemUDs_unlock()) &&
           VerifyOffset(verifier, VT_ITEMUDS_LOCK) &&
           verifier.Verify(itemUDs_lock()) &&
           verifier.VerifyVectorOfStrings(itemUDs_lock()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_HERO_LOCKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_HERO_LOCKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_HERO_LOCKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_HERO_LOCK::VT_TYPE, type, 11211);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_VERSION, version);
  }
  void add_heroUDs_unlock(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs_unlock) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_HEROUDS_UNLOCK, heroUDs_unlock);
  }
  void add_heroUDs_lock(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs_lock) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_HEROUDS_LOCK, heroUDs_lock);
  }
  void add_itemUDs_unlock(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs_unlock) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_ITEMUDS_UNLOCK, itemUDs_unlock);
  }
  void add_itemUDs_lock(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs_lock) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK::VT_ITEMUDS_LOCK, itemUDs_lock);
  }
  explicit INVENTORY_ITEM_HERO_LOCKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_HERO_LOCKBuilder &operator=(const INVENTORY_ITEM_HERO_LOCKBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> CreateINVENTORY_ITEM_HERO_LOCK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11211,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs_unlock = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs_lock = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs_unlock = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs_lock = 0) {
  INVENTORY_ITEM_HERO_LOCKBuilder builder_(_fbb);
  builder_.add_itemUDs_lock(itemUDs_lock);
  builder_.add_itemUDs_unlock(itemUDs_unlock);
  builder_.add_heroUDs_lock(heroUDs_lock);
  builder_.add_heroUDs_unlock(heroUDs_unlock);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> CreateINVENTORY_ITEM_HERO_LOCKDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11211,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs_unlock = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs_lock = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs_unlock = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs_lock = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_HERO_LOCK(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      heroUDs_unlock ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs_unlock) : 0,
      heroUDs_lock ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs_lock) : 0,
      itemUDs_unlock ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*itemUDs_unlock) : 0,
      itemUDs_lock ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*itemUDs_lock) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> CreateINVENTORY_ITEM_HERO_LOCK(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_SKILL_LEVELUPT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_SKILL_LEVELUP TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t slot;
  std::string heroUD;
  INVENTORY_HERO_SKILL_LEVELUPT()
      : type(11212),
        slot(0) {
  }
};

struct INVENTORY_HERO_SKILL_LEVELUP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_SKILL_LEVELUPT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SLOT = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11212);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t slot() const {
    return GetField<int32_t>(VT_SLOT, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_SKILL_LEVELUPT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_SKILL_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_SKILL_LEVELUPBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_SKILL_LEVELUP::VT_TYPE, type, 11212);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP::VT_VERSION, version);
  }
  void add_slot(int32_t slot) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_SKILL_LEVELUP::VT_SLOT, slot, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_SKILL_LEVELUPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_SKILL_LEVELUPBuilder &operator=(const INVENTORY_HERO_SKILL_LEVELUPBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> CreateINVENTORY_HERO_SKILL_LEVELUP(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11212,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t slot = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_SKILL_LEVELUPBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_slot(slot);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> CreateINVENTORY_HERO_SKILL_LEVELUPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11212,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t slot = 0,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_SKILL_LEVELUP(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      slot,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> CreateINVENTORY_HERO_SKILL_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_ENCHANT_CONSUMET : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_ENCHANT_CONSUME TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> spiritUDs;
  std::string heroUD;
  INVENTORY_HERO_ENCHANT_CONSUMET()
      : type(11213) {
  }
};

struct INVENTORY_HERO_ENCHANT_CONSUME FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_ENCHANT_CONSUMET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SPIRITUDS = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11213);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *spiritUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_SPIRITUDS);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_SPIRITUDS) &&
           verifier.Verify(spiritUDs()) &&
           verifier.VerifyVectorOfStrings(spiritUDs()) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_ENCHANT_CONSUMET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_ENCHANT_CONSUMET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUMET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_ENCHANT_CONSUMEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_ENCHANT_CONSUME::VT_TYPE, type, 11213);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_VERSION, version);
  }
  void add_spiritUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> spiritUDs) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_SPIRITUDS, spiritUDs);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_ENCHANT_CONSUMEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_ENCHANT_CONSUMEBuilder &operator=(const INVENTORY_HERO_ENCHANT_CONSUMEBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> CreateINVENTORY_HERO_ENCHANT_CONSUME(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11213,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> spiritUDs = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_ENCHANT_CONSUMEBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_spiritUDs(spiritUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> CreateINVENTORY_HERO_ENCHANT_CONSUMEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11213,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *spiritUDs = nullptr,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_ENCHANT_CONSUME(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      spiritUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*spiritUDs) : 0,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> CreateINVENTORY_HERO_ENCHANT_CONSUME(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUMET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_ENCHANT_STATT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_ENCHANT_STAT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<int32_t> enchantStat;
  std::string heroUD;
  INVENTORY_HERO_ENCHANT_STATT()
      : type(11214) {
  }
};

struct INVENTORY_HERO_ENCHANT_STAT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_ENCHANT_STATT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ENCHANTSTAT = 14,
    VT_HEROUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11214);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<int32_t> *enchantStat() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ENCHANTSTAT);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ENCHANTSTAT) &&
           verifier.Verify(enchantStat()) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_ENCHANT_STATT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_ENCHANT_STATT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STATT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_ENCHANT_STATBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_ENCHANT_STAT::VT_TYPE, type, 11214);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_VERSION, version);
  }
  void add_enchantStat(flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_ENCHANTSTAT, enchantStat);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT::VT_HEROUD, heroUD);
  }
  explicit INVENTORY_HERO_ENCHANT_STATBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_ENCHANT_STATBuilder &operator=(const INVENTORY_HERO_ENCHANT_STATBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> CreateINVENTORY_HERO_ENCHANT_STAT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11214,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> enchantStat = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0) {
  INVENTORY_HERO_ENCHANT_STATBuilder builder_(_fbb);
  builder_.add_heroUD(heroUD);
  builder_.add_enchantStat(enchantStat);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> CreateINVENTORY_HERO_ENCHANT_STATDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11214,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<int32_t> *enchantStat = nullptr,
    const char *heroUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_ENCHANT_STAT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      enchantStat ? _fbb.CreateVector<int32_t>(*enchantStat) : 0,
      heroUD ? _fbb.CreateString(heroUD) : 0);
}

flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> CreateINVENTORY_HERO_ENCHANT_STAT(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STATT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_SELLT : public flatbuffers::NativeTable {
  typedef INVENTORY_SELL TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<int32_t> walletQtyList;
  std::vector<std::string> walletIdList;
  std::vector<std::string> itemUDs;
  INVENTORY_SELLT()
      : type(11215) {
  }
};

struct INVENTORY_SELL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_SELLT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_WALLETQTYLIST = 14,
    VT_WALLETIDLIST = 16,
    VT_ITEMUDS = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11215);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<int32_t> *walletQtyList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_WALLETQTYLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *walletIdList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_WALLETIDLIST);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ITEMUDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_WALLETQTYLIST) &&
           verifier.Verify(walletQtyList()) &&
           VerifyOffset(verifier, VT_WALLETIDLIST) &&
           verifier.Verify(walletIdList()) &&
           verifier.VerifyVectorOfStrings(walletIdList()) &&
           VerifyOffset(verifier, VT_ITEMUDS) &&
           verifier.Verify(itemUDs()) &&
           verifier.VerifyVectorOfStrings(itemUDs()) &&
           verifier.EndTable();
  }
  INVENTORY_SELLT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_SELLT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_SELL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELLT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_SELLBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_SELL::VT_TYPE, type, 11215);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_SELL::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_SELL::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_SELL::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_SELL::VT_VERSION, version);
  }
  void add_walletQtyList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> walletQtyList) {
    fbb_.AddOffset(INVENTORY_SELL::VT_WALLETQTYLIST, walletQtyList);
  }
  void add_walletIdList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> walletIdList) {
    fbb_.AddOffset(INVENTORY_SELL::VT_WALLETIDLIST, walletIdList);
  }
  void add_itemUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs) {
    fbb_.AddOffset(INVENTORY_SELL::VT_ITEMUDS, itemUDs);
  }
  explicit INVENTORY_SELLBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_SELLBuilder &operator=(const INVENTORY_SELLBuilder &);
  flatbuffers::Offset<INVENTORY_SELL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_SELL>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_SELL> CreateINVENTORY_SELL(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11215,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> walletQtyList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> walletIdList = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> itemUDs = 0) {
  INVENTORY_SELLBuilder builder_(_fbb);
  builder_.add_itemUDs(itemUDs);
  builder_.add_walletIdList(walletIdList);
  builder_.add_walletQtyList(walletQtyList);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_SELL> CreateINVENTORY_SELLDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11215,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<int32_t> *walletQtyList = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *walletIdList = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *itemUDs = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_SELL(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      walletQtyList ? _fbb.CreateVector<int32_t>(*walletQtyList) : 0,
      walletIdList ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*walletIdList) : 0,
      itemUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*itemUDs) : 0);
}

flatbuffers::Offset<INVENTORY_SELL> CreateINVENTORY_SELL(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELLT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_UPGRADET : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_UPGRADE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> material_itemUDs;
  std::string itemUD;
  INVENTORY_ITEM_UPGRADET()
      : type(11216) {
  }
};

struct INVENTORY_ITEM_UPGRADE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_UPGRADET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_MATERIAL_ITEMUDS = 14,
    VT_ITEMUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11216);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *material_itemUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIAL_ITEMUDS);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_MATERIAL_ITEMUDS) &&
           verifier.Verify(material_itemUDs()) &&
           verifier.VerifyVectorOfStrings(material_itemUDs()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_UPGRADET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_UPGRADEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_UPGRADE::VT_TYPE, type, 11216);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_VERSION, version);
  }
  void add_material_itemUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> material_itemUDs) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_MATERIAL_ITEMUDS, material_itemUDs);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_ITEM_UPGRADEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_UPGRADEBuilder &operator=(const INVENTORY_ITEM_UPGRADEBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_UPGRADE>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> CreateINVENTORY_ITEM_UPGRADE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11216,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> material_itemUDs = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_ITEM_UPGRADEBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_material_itemUDs(material_itemUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> CreateINVENTORY_ITEM_UPGRADEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11216,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *material_itemUDs = nullptr,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_UPGRADE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      material_itemUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*material_itemUDs) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> CreateINVENTORY_ITEM_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_OPTION_RESETT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_OPTION_RESET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> material_itemUDs;
  std::string itemUD;
  INVENTORY_ITEM_OPTION_RESETT()
      : type(11217) {
  }
};

struct INVENTORY_ITEM_OPTION_RESET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_OPTION_RESETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_MATERIAL_ITEMUDS = 14,
    VT_ITEMUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11217);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *material_itemUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MATERIAL_ITEMUDS);
  }
  const flatbuffers::String *itemUD() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_MATERIAL_ITEMUDS) &&
           verifier.Verify(material_itemUDs()) &&
           verifier.VerifyVectorOfStrings(material_itemUDs()) &&
           VerifyOffset(verifier, VT_ITEMUD) &&
           verifier.Verify(itemUD()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_OPTION_RESETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_OPTION_RESETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_OPTION_RESETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_OPTION_RESET::VT_TYPE, type, 11217);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_VERSION, version);
  }
  void add_material_itemUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> material_itemUDs) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_MATERIAL_ITEMUDS, material_itemUDs);
  }
  void add_itemUD(flatbuffers::Offset<flatbuffers::String> itemUD) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET::VT_ITEMUD, itemUD);
  }
  explicit INVENTORY_ITEM_OPTION_RESETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_OPTION_RESETBuilder &operator=(const INVENTORY_ITEM_OPTION_RESETBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> CreateINVENTORY_ITEM_OPTION_RESET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11217,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> material_itemUDs = 0,
    flatbuffers::Offset<flatbuffers::String> itemUD = 0) {
  INVENTORY_ITEM_OPTION_RESETBuilder builder_(_fbb);
  builder_.add_itemUD(itemUD);
  builder_.add_material_itemUDs(material_itemUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> CreateINVENTORY_ITEM_OPTION_RESETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11217,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *material_itemUDs = nullptr,
    const char *itemUD = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_OPTION_RESET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      material_itemUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*material_itemUDs) : 0,
      itemUD ? _fbb.CreateString(itemUD) : 0);
}

flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> CreateINVENTORY_ITEM_OPTION_RESET(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_TIMETREASURE_GETT : public flatbuffers::NativeTable {
  typedef INVENTORY_TIMETREASURE_GET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  INVENTORY_TIMETREASURE_GETT()
      : type(11218) {
  }
};

struct INVENTORY_TIMETREASURE_GET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_TIMETREASURE_GETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11218);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  INVENTORY_TIMETREASURE_GETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_TIMETREASURE_GETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_TIMETREASURE_GETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_TIMETREASURE_GET::VT_TYPE, type, 11218);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET::VT_VERSION, version);
  }
  explicit INVENTORY_TIMETREASURE_GETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_TIMETREASURE_GETBuilder &operator=(const INVENTORY_TIMETREASURE_GETBuilder &);
  flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_TIMETREASURE_GET>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> CreateINVENTORY_TIMETREASURE_GET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11218,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  INVENTORY_TIMETREASURE_GETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> CreateINVENTORY_TIMETREASURE_GETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11218,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateINVENTORY_TIMETREASURE_GET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> CreateINVENTORY_TIMETREASURE_GET(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_UPGRADET : public flatbuffers::NativeTable {
  typedef INVENTORY_UPGRADE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t upgradeType;
  int32_t upgrade;
  INVENTORY_UPGRADET()
      : type(11219),
        upgradeType(0),
        upgrade(0) {
  }
};

struct INVENTORY_UPGRADE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_UPGRADET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_UPGRADETYPE = 14,
    VT_UPGRADE = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 11219);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t upgradeType() const {
    return GetField<int32_t>(VT_UPGRADETYPE, 0);
  }
  int32_t upgrade() const {
    return GetField<int32_t>(VT_UPGRADE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_UPGRADETYPE) &&
           VerifyField<int32_t>(verifier, VT_UPGRADE) &&
           verifier.EndTable();
  }
  INVENTORY_UPGRADET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_UPGRADE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_UPGRADEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_UPGRADE::VT_TYPE, type, 11219);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INVENTORY_UPGRADE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(INVENTORY_UPGRADE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(INVENTORY_UPGRADE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(INVENTORY_UPGRADE::VT_VERSION, version);
  }
  void add_upgradeType(int32_t upgradeType) {
    fbb_.AddElement<int32_t>(INVENTORY_UPGRADE::VT_UPGRADETYPE, upgradeType, 0);
  }
  void add_upgrade(int32_t upgrade) {
    fbb_.AddElement<int32_t>(INVENTORY_UPGRADE::VT_UPGRADE, upgrade, 0);
  }
  explicit INVENTORY_UPGRADEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_UPGRADEBuilder &operator=(const INVENTORY_UPGRADEBuilder &);
  flatbuffers::Offset<INVENTORY_UPGRADE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_UPGRADE>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_UPGRADE> CreateINVENTORY_UPGRADE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11219,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t upgradeType = 0,
    int32_t upgrade = 0) {
  INVENTORY_UPGRADEBuilder builder_(_fbb);
  builder_.add_upgrade(upgrade);
  builder_.add_upgradeType(upgradeType);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_UPGRADE> CreateINVENTORY_UPGRADEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 11219,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t upgradeType = 0,
    int32_t upgrade = 0) {
  return OVERLORD::REQUEST::CreateINVENTORY_UPGRADE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      upgradeType,
      upgrade);
}

flatbuffers::Offset<INVENTORY_UPGRADE> CreateINVENTORY_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIFT_LISTT : public flatbuffers::NativeTable {
  typedef GIFT_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t size;
  int32_t holds;
  GIFT_LISTT()
      : type(8600),
        size(0),
        holds(0) {
  }
};

struct GIFT_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIFT_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SIZE = 14,
    VT_HOLDS = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8600);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  int32_t holds() const {
    return GetField<int32_t>(VT_HOLDS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_HOLDS) &&
           verifier.EndTable();
  }
  GIFT_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIFT_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIFT_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIFT_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIFT_LIST::VT_TYPE, type, 8600);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GIFT_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GIFT_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GIFT_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GIFT_LIST::VT_VERSION, version);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(GIFT_LIST::VT_SIZE, size, 0);
  }
  void add_holds(int32_t holds) {
    fbb_.AddElement<int32_t>(GIFT_LIST::VT_HOLDS, holds, 0);
  }
  explicit GIFT_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIFT_LISTBuilder &operator=(const GIFT_LISTBuilder &);
  flatbuffers::Offset<GIFT_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIFT_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIFT_LIST> CreateGIFT_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8600,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t size = 0,
    int32_t holds = 0) {
  GIFT_LISTBuilder builder_(_fbb);
  builder_.add_holds(holds);
  builder_.add_size(size);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIFT_LIST> CreateGIFT_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8600,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t size = 0,
    int32_t holds = 0) {
  return OVERLORD::REQUEST::CreateGIFT_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      size,
      holds);
}

flatbuffers::Offset<GIFT_LIST> CreateGIFT_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIFT_OPENT : public flatbuffers::NativeTable {
  typedef GIFT_OPEN TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> mailUDs;
  GIFT_OPENT()
      : type(8601) {
  }
};

struct GIFT_OPEN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIFT_OPENT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_MAILUDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8601);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mailUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MAILUDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_MAILUDS) &&
           verifier.Verify(mailUDs()) &&
           verifier.VerifyVectorOfStrings(mailUDs()) &&
           verifier.EndTable();
  }
  GIFT_OPENT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIFT_OPENT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIFT_OPEN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIFT_OPENBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIFT_OPEN::VT_TYPE, type, 8601);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GIFT_OPEN::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GIFT_OPEN::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GIFT_OPEN::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GIFT_OPEN::VT_VERSION, version);
  }
  void add_mailUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUDs) {
    fbb_.AddOffset(GIFT_OPEN::VT_MAILUDS, mailUDs);
  }
  explicit GIFT_OPENBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIFT_OPENBuilder &operator=(const GIFT_OPENBuilder &);
  flatbuffers::Offset<GIFT_OPEN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIFT_OPEN>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIFT_OPEN> CreateGIFT_OPEN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8601,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUDs = 0) {
  GIFT_OPENBuilder builder_(_fbb);
  builder_.add_mailUDs(mailUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIFT_OPEN> CreateGIFT_OPENDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8601,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *mailUDs = nullptr) {
  return OVERLORD::REQUEST::CreateGIFT_OPEN(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      mailUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*mailUDs) : 0);
}

flatbuffers::Offset<GIFT_OPEN> CreateGIFT_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SPECIAL_GIFT_LISTT : public flatbuffers::NativeTable {
  typedef SPECIAL_GIFT_LIST TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t size;
  int32_t holds;
  SPECIAL_GIFT_LISTT()
      : type(8602),
        size(0),
        holds(0) {
  }
};

struct SPECIAL_GIFT_LIST FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPECIAL_GIFT_LISTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SIZE = 14,
    VT_HOLDS = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8602);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  int32_t holds() const {
    return GetField<int32_t>(VT_HOLDS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyField<int32_t>(verifier, VT_HOLDS) &&
           verifier.EndTable();
  }
  SPECIAL_GIFT_LISTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SPECIAL_GIFT_LISTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SPECIAL_GIFT_LIST> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SPECIAL_GIFT_LISTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST::VT_TYPE, type, 8602);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST::VT_VERSION, version);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST::VT_SIZE, size, 0);
  }
  void add_holds(int32_t holds) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST::VT_HOLDS, holds, 0);
  }
  explicit SPECIAL_GIFT_LISTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SPECIAL_GIFT_LISTBuilder &operator=(const SPECIAL_GIFT_LISTBuilder &);
  flatbuffers::Offset<SPECIAL_GIFT_LIST> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPECIAL_GIFT_LIST>(end);
    return o;
  }
};

inline flatbuffers::Offset<SPECIAL_GIFT_LIST> CreateSPECIAL_GIFT_LIST(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8602,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t size = 0,
    int32_t holds = 0) {
  SPECIAL_GIFT_LISTBuilder builder_(_fbb);
  builder_.add_holds(holds);
  builder_.add_size(size);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST> CreateSPECIAL_GIFT_LISTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8602,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t size = 0,
    int32_t holds = 0) {
  return OVERLORD::REQUEST::CreateSPECIAL_GIFT_LIST(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      size,
      holds);
}

flatbuffers::Offset<SPECIAL_GIFT_LIST> CreateSPECIAL_GIFT_LIST(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SPECIAL_GIFT_OPENT : public flatbuffers::NativeTable {
  typedef SPECIAL_GIFT_OPEN TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t giftIdx;
  std::vector<std::string> mailUD;
  SPECIAL_GIFT_OPENT()
      : type(8603),
        giftIdx(0) {
  }
};

struct SPECIAL_GIFT_OPEN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPECIAL_GIFT_OPENT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_GIFTIDX = 14,
    VT_MAILUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8603);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t giftIdx() const {
    return GetField<int32_t>(VT_GIFTIDX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mailUD() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MAILUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_GIFTIDX) &&
           VerifyOffset(verifier, VT_MAILUD) &&
           verifier.Verify(mailUD()) &&
           verifier.VerifyVectorOfStrings(mailUD()) &&
           verifier.EndTable();
  }
  SPECIAL_GIFT_OPENT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SPECIAL_GIFT_OPENT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SPECIAL_GIFT_OPEN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SPECIAL_GIFT_OPENBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_OPEN::VT_TYPE, type, 8603);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN::VT_VERSION, version);
  }
  void add_giftIdx(int32_t giftIdx) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_OPEN::VT_GIFTIDX, giftIdx, 0);
  }
  void add_mailUD(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUD) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN::VT_MAILUD, mailUD);
  }
  explicit SPECIAL_GIFT_OPENBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SPECIAL_GIFT_OPENBuilder &operator=(const SPECIAL_GIFT_OPENBuilder &);
  flatbuffers::Offset<SPECIAL_GIFT_OPEN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPECIAL_GIFT_OPEN>(end);
    return o;
  }
};

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN> CreateSPECIAL_GIFT_OPEN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8603,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t giftIdx = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUD = 0) {
  SPECIAL_GIFT_OPENBuilder builder_(_fbb);
  builder_.add_mailUD(mailUD);
  builder_.add_giftIdx(giftIdx);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN> CreateSPECIAL_GIFT_OPENDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8603,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t giftIdx = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *mailUD = nullptr) {
  return OVERLORD::REQUEST::CreateSPECIAL_GIFT_OPEN(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      giftIdx,
      mailUD ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*mailUD) : 0);
}

flatbuffers::Offset<SPECIAL_GIFT_OPEN> CreateSPECIAL_GIFT_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_STATUST : public flatbuffers::NativeTable {
  typedef MIRROR_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  MIRROR_STATUST()
      : type(6950) {
  }
};

struct MIRROR_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6950);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  MIRROR_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_STATUS::VT_TYPE, type, 6950);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(MIRROR_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(MIRROR_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(MIRROR_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MIRROR_STATUS::VT_VERSION, version);
  }
  explicit MIRROR_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_STATUSBuilder &operator=(const MIRROR_STATUSBuilder &);
  flatbuffers::Offset<MIRROR_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6950,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  MIRROR_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6950,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateMIRROR_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_PLAY_STARTT : public flatbuffers::NativeTable {
  typedef MIRROR_PLAY_START TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> heroUDs;
  std::string mirrorUD;
  MIRROR_PLAY_STARTT()
      : type(6951) {
  }
};

struct MIRROR_PLAY_START FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_PLAY_STARTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_HEROUDS = 14,
    VT_MIRRORUD = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6951);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS);
  }
  const flatbuffers::String *mirrorUD() const {
    return GetPointer<const flatbuffers::String *>(VT_MIRRORUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_HEROUDS) &&
           verifier.Verify(heroUDs()) &&
           verifier.VerifyVectorOfStrings(heroUDs()) &&
           VerifyOffset(verifier, VT_MIRRORUD) &&
           verifier.Verify(mirrorUD()) &&
           verifier.EndTable();
  }
  MIRROR_PLAY_STARTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_PLAY_START> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_PLAY_STARTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_PLAY_START::VT_TYPE, type, 6951);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_VERSION, version);
  }
  void add_heroUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_HEROUDS, heroUDs);
  }
  void add_mirrorUD(flatbuffers::Offset<flatbuffers::String> mirrorUD) {
    fbb_.AddOffset(MIRROR_PLAY_START::VT_MIRRORUD, mirrorUD);
  }
  explicit MIRROR_PLAY_STARTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_PLAY_STARTBuilder &operator=(const MIRROR_PLAY_STARTBuilder &);
  flatbuffers::Offset<MIRROR_PLAY_START> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_PLAY_START>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_PLAY_START> CreateMIRROR_PLAY_START(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6951,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs = 0,
    flatbuffers::Offset<flatbuffers::String> mirrorUD = 0) {
  MIRROR_PLAY_STARTBuilder builder_(_fbb);
  builder_.add_mirrorUD(mirrorUD);
  builder_.add_heroUDs(heroUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_PLAY_START> CreateMIRROR_PLAY_STARTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6951,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs = nullptr,
    const char *mirrorUD = nullptr) {
  return OVERLORD::REQUEST::CreateMIRROR_PLAY_START(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      heroUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs) : 0,
      mirrorUD ? _fbb.CreateString(mirrorUD) : 0);
}

flatbuffers::Offset<MIRROR_PLAY_START> CreateMIRROR_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_PLAY_DONET : public flatbuffers::NativeTable {
  typedef MIRROR_PLAY_DONE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<int32_t> target_heroHPs_hp;
  std::vector<int32_t> heroHPs_hp;
  int32_t clearGrade;
  std::string playUD;
  MIRROR_PLAY_DONET()
      : type(6952),
        clearGrade(0) {
  }
};

struct MIRROR_PLAY_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_PLAY_DONET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_TARGET_HEROHPS_HP = 14,
    VT_HEROHPS_HP = 16,
    VT_CLEARGRADE = 18,
    VT_PLAYUD = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6952);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<int32_t> *target_heroHPs_hp() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_TARGET_HEROHPS_HP);
  }
  const flatbuffers::Vector<int32_t> *heroHPs_hp() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_HEROHPS_HP);
  }
  int32_t clearGrade() const {
    return GetField<int32_t>(VT_CLEARGRADE, 0);
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_TARGET_HEROHPS_HP) &&
           verifier.Verify(target_heroHPs_hp()) &&
           VerifyOffset(verifier, VT_HEROHPS_HP) &&
           verifier.Verify(heroHPs_hp()) &&
           VerifyField<int32_t>(verifier, VT_CLEARGRADE) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           verifier.EndTable();
  }
  MIRROR_PLAY_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_PLAY_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_PLAY_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_PLAY_DONE::VT_TYPE, type, 6952);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_VERSION, version);
  }
  void add_target_heroHPs_hp(flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_heroHPs_hp) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_TARGET_HEROHPS_HP, target_heroHPs_hp);
  }
  void add_heroHPs_hp(flatbuffers::Offset<flatbuffers::Vector<int32_t>> heroHPs_hp) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_HEROHPS_HP, heroHPs_hp);
  }
  void add_clearGrade(int32_t clearGrade) {
    fbb_.AddElement<int32_t>(MIRROR_PLAY_DONE::VT_CLEARGRADE, clearGrade, 0);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(MIRROR_PLAY_DONE::VT_PLAYUD, playUD);
  }
  explicit MIRROR_PLAY_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_PLAY_DONEBuilder &operator=(const MIRROR_PLAY_DONEBuilder &);
  flatbuffers::Offset<MIRROR_PLAY_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_PLAY_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_PLAY_DONE> CreateMIRROR_PLAY_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6952,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> target_heroHPs_hp = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> heroHPs_hp = 0,
    int32_t clearGrade = 0,
    flatbuffers::Offset<flatbuffers::String> playUD = 0) {
  MIRROR_PLAY_DONEBuilder builder_(_fbb);
  builder_.add_playUD(playUD);
  builder_.add_clearGrade(clearGrade);
  builder_.add_heroHPs_hp(heroHPs_hp);
  builder_.add_target_heroHPs_hp(target_heroHPs_hp);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE> CreateMIRROR_PLAY_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6952,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<int32_t> *target_heroHPs_hp = nullptr,
    const std::vector<int32_t> *heroHPs_hp = nullptr,
    int32_t clearGrade = 0,
    const char *playUD = nullptr) {
  return OVERLORD::REQUEST::CreateMIRROR_PLAY_DONE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      target_heroHPs_hp ? _fbb.CreateVector<int32_t>(*target_heroHPs_hp) : 0,
      heroHPs_hp ? _fbb.CreateVector<int32_t>(*heroHPs_hp) : 0,
      clearGrade,
      playUD ? _fbb.CreateString(playUD) : 0);
}

flatbuffers::Offset<MIRROR_PLAY_DONE> CreateMIRROR_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_RESETT : public flatbuffers::NativeTable {
  typedef MIRROR_RESET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  bool useGem;
  MIRROR_RESETT()
      : type(6953),
        useGem(false) {
  }
};

struct MIRROR_RESET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_RESETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_USEGEM = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6953);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool useGem() const {
    return GetField<uint8_t>(VT_USEGEM, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<uint8_t>(verifier, VT_USEGEM) &&
           verifier.EndTable();
  }
  MIRROR_RESETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_RESETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_RESET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_RESETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_RESET::VT_TYPE, type, 6953);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(MIRROR_RESET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(MIRROR_RESET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(MIRROR_RESET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MIRROR_RESET::VT_VERSION, version);
  }
  void add_useGem(bool useGem) {
    fbb_.AddElement<uint8_t>(MIRROR_RESET::VT_USEGEM, static_cast<uint8_t>(useGem), 0);
  }
  explicit MIRROR_RESETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_RESETBuilder &operator=(const MIRROR_RESETBuilder &);
  flatbuffers::Offset<MIRROR_RESET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_RESET>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_RESET> CreateMIRROR_RESET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6953,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    bool useGem = false) {
  MIRROR_RESETBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  builder_.add_useGem(useGem);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_RESET> CreateMIRROR_RESETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6953,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    bool useGem = false) {
  return OVERLORD::REQUEST::CreateMIRROR_RESET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      useGem);
}

flatbuffers::Offset<MIRROR_RESET> CreateMIRROR_RESET(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_DEFENSE_DECK_SETT : public flatbuffers::NativeTable {
  typedef MIRROR_DEFENSE_DECK_SET TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> defense;
  MIRROR_DEFENSE_DECK_SETT()
      : type(6954) {
  }
};

struct MIRROR_DEFENSE_DECK_SET FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_DEFENSE_DECK_SETT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_DEFENSE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6954);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *defense() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_DEFENSE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_DEFENSE) &&
           verifier.Verify(defense()) &&
           verifier.VerifyVectorOfStrings(defense()) &&
           verifier.EndTable();
  }
  MIRROR_DEFENSE_DECK_SETT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_DEFENSE_DECK_SETT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_DEFENSE_DECK_SETBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_DEFENSE_DECK_SET::VT_TYPE, type, 6954);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET::VT_VERSION, version);
  }
  void add_defense(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET::VT_DEFENSE, defense);
  }
  explicit MIRROR_DEFENSE_DECK_SETBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_DEFENSE_DECK_SETBuilder &operator=(const MIRROR_DEFENSE_DECK_SETBuilder &);
  flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> CreateMIRROR_DEFENSE_DECK_SET(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6954,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> defense = 0) {
  MIRROR_DEFENSE_DECK_SETBuilder builder_(_fbb);
  builder_.add_defense(defense);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> CreateMIRROR_DEFENSE_DECK_SETDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6954,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *defense = nullptr) {
  return OVERLORD::REQUEST::CreateMIRROR_DEFENSE_DECK_SET(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      defense ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*defense) : 0);
}

flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> CreateMIRROR_DEFENSE_DECK_SET(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIVE_ACHIEVE_REWARDT : public flatbuffers::NativeTable {
  typedef GIVE_ACHIEVE_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t target_level;
  int32_t srl;
  GIVE_ACHIEVE_REWARDT()
      : type(8100),
        target_level(0),
        srl(0) {
  }
};

struct GIVE_ACHIEVE_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIVE_ACHIEVE_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_TARGET_LEVEL = 14,
    VT_SRL = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8100);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t target_level() const {
    return GetField<int32_t>(VT_TARGET_LEVEL, 0);
  }
  int32_t srl() const {
    return GetField<int32_t>(VT_SRL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_TARGET_LEVEL) &&
           VerifyField<int32_t>(verifier, VT_SRL) &&
           verifier.EndTable();
  }
  GIVE_ACHIEVE_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIVE_ACHIEVE_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIVE_ACHIEVE_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIVE_ACHIEVE_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIVE_ACHIEVE_REWARD::VT_TYPE, type, 8100);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD::VT_VERSION, version);
  }
  void add_target_level(int32_t target_level) {
    fbb_.AddElement<int32_t>(GIVE_ACHIEVE_REWARD::VT_TARGET_LEVEL, target_level, 0);
  }
  void add_srl(int32_t srl) {
    fbb_.AddElement<int32_t>(GIVE_ACHIEVE_REWARD::VT_SRL, srl, 0);
  }
  explicit GIVE_ACHIEVE_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIVE_ACHIEVE_REWARDBuilder &operator=(const GIVE_ACHIEVE_REWARDBuilder &);
  flatbuffers::Offset<GIVE_ACHIEVE_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIVE_ACHIEVE_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD> CreateGIVE_ACHIEVE_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8100,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t target_level = 0,
    int32_t srl = 0) {
  GIVE_ACHIEVE_REWARDBuilder builder_(_fbb);
  builder_.add_srl(srl);
  builder_.add_target_level(target_level);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD> CreateGIVE_ACHIEVE_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8100,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t target_level = 0,
    int32_t srl = 0) {
  return OVERLORD::REQUEST::CreateGIVE_ACHIEVE_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      target_level,
      srl);
}

flatbuffers::Offset<GIVE_ACHIEVE_REWARD> CreateGIVE_ACHIEVE_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_STATUST : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  DAILY_QUEST_STATUST()
      : type(8101) {
  }
};

struct DAILY_QUEST_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8101);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  DAILY_QUEST_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_STATUS::VT_TYPE, type, 8101);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(DAILY_QUEST_STATUS::VT_VERSION, version);
  }
  explicit DAILY_QUEST_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_STATUSBuilder &operator=(const DAILY_QUEST_STATUSBuilder &);
  flatbuffers::Offset<DAILY_QUEST_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8101,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  DAILY_QUEST_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8101,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateDAILY_QUEST_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_REWARDT : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t idx;
  DAILY_QUEST_REWARDT()
      : type(8102),
        idx(0) {
  }
};

struct DAILY_QUEST_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_IDX = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8102);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t idx() const {
    return GetField<int32_t>(VT_IDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_IDX) &&
           verifier.EndTable();
  }
  DAILY_QUEST_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_REWARD::VT_TYPE, type, 8102);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(DAILY_QUEST_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(DAILY_QUEST_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(DAILY_QUEST_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(DAILY_QUEST_REWARD::VT_VERSION, version);
  }
  void add_idx(int32_t idx) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_REWARD::VT_IDX, idx, 0);
  }
  explicit DAILY_QUEST_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_REWARDBuilder &operator=(const DAILY_QUEST_REWARDBuilder &);
  flatbuffers::Offset<DAILY_QUEST_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_REWARD> CreateDAILY_QUEST_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8102,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t idx = 0) {
  DAILY_QUEST_REWARDBuilder builder_(_fbb);
  builder_.add_idx(idx);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD> CreateDAILY_QUEST_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8102,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t idx = 0) {
  return OVERLORD::REQUEST::CreateDAILY_QUEST_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      idx);
}

flatbuffers::Offset<DAILY_QUEST_REWARD> CreateDAILY_QUEST_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_USER_DATAT : public flatbuffers::NativeTable {
  typedef SHOP_USER_DATA TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  SHOP_USER_DATAT()
      : type(4150) {
  }
};

struct SHOP_USER_DATA FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_USER_DATAT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4150);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  SHOP_USER_DATAT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_USER_DATAT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_USER_DATA> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_USER_DATABuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_USER_DATA::VT_TYPE, type, 4150);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_USER_DATA::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_USER_DATA::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_USER_DATA::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_USER_DATA::VT_VERSION, version);
  }
  explicit SHOP_USER_DATABuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_USER_DATABuilder &operator=(const SHOP_USER_DATABuilder &);
  flatbuffers::Offset<SHOP_USER_DATA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_USER_DATA>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4150,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  SHOP_USER_DATABuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATADirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4150,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateSHOP_USER_DATA(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_BUYT : public flatbuffers::NativeTable {
  typedef SHOP_BUY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t price;
  std::string currencyType;
  int32_t amount;
  int32_t productType;
  std::string productId;
  SHOP_BUYT()
      : type(4151),
        price(0),
        amount(0),
        productType(0) {
  }
};

struct SHOP_BUY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_BUYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PRICE = 14,
    VT_CURRENCYTYPE = 16,
    VT_AMOUNT = 18,
    VT_PRODUCTTYPE = 20,
    VT_PRODUCTID = 22
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4151);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t price() const {
    return GetField<int32_t>(VT_PRICE, 0);
  }
  const flatbuffers::String *currencyType() const {
    return GetPointer<const flatbuffers::String *>(VT_CURRENCYTYPE);
  }
  int32_t amount() const {
    return GetField<int32_t>(VT_AMOUNT, 0);
  }
  int32_t productType() const {
    return GetField<int32_t>(VT_PRODUCTTYPE, 0);
  }
  const flatbuffers::String *productId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PRICE) &&
           VerifyOffset(verifier, VT_CURRENCYTYPE) &&
           verifier.Verify(currencyType()) &&
           VerifyField<int32_t>(verifier, VT_AMOUNT) &&
           VerifyField<int32_t>(verifier, VT_PRODUCTTYPE) &&
           VerifyOffset(verifier, VT_PRODUCTID) &&
           verifier.Verify(productId()) &&
           verifier.EndTable();
  }
  SHOP_BUYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_BUYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_BUY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_BUYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_BUY::VT_TYPE, type, 4151);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_BUY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_BUY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_BUY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_BUY::VT_VERSION, version);
  }
  void add_price(int32_t price) {
    fbb_.AddElement<int32_t>(SHOP_BUY::VT_PRICE, price, 0);
  }
  void add_currencyType(flatbuffers::Offset<flatbuffers::String> currencyType) {
    fbb_.AddOffset(SHOP_BUY::VT_CURRENCYTYPE, currencyType);
  }
  void add_amount(int32_t amount) {
    fbb_.AddElement<int32_t>(SHOP_BUY::VT_AMOUNT, amount, 0);
  }
  void add_productType(int32_t productType) {
    fbb_.AddElement<int32_t>(SHOP_BUY::VT_PRODUCTTYPE, productType, 0);
  }
  void add_productId(flatbuffers::Offset<flatbuffers::String> productId) {
    fbb_.AddOffset(SHOP_BUY::VT_PRODUCTID, productId);
  }
  explicit SHOP_BUYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_BUYBuilder &operator=(const SHOP_BUYBuilder &);
  flatbuffers::Offset<SHOP_BUY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_BUY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_BUY> CreateSHOP_BUY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4151,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t price = 0,
    flatbuffers::Offset<flatbuffers::String> currencyType = 0,
    int32_t amount = 0,
    int32_t productType = 0,
    flatbuffers::Offset<flatbuffers::String> productId = 0) {
  SHOP_BUYBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_productType(productType);
  builder_.add_amount(amount);
  builder_.add_currencyType(currencyType);
  builder_.add_price(price);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_BUY> CreateSHOP_BUYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4151,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t price = 0,
    const char *currencyType = nullptr,
    int32_t amount = 0,
    int32_t productType = 0,
    const char *productId = nullptr) {
  return OVERLORD::REQUEST::CreateSHOP_BUY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      price,
      currencyType ? _fbb.CreateString(currencyType) : 0,
      amount,
      productType,
      productId ? _fbb.CreateString(productId) : 0);
}

flatbuffers::Offset<SHOP_BUY> CreateSHOP_BUY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_CHARACTER_SUMMONT : public flatbuffers::NativeTable {
  typedef SHOP_CHARACTER_SUMMON TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t summonId;
  SHOP_CHARACTER_SUMMONT()
      : type(4152),
        summonId(0) {
  }
};

struct SHOP_CHARACTER_SUMMON FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_CHARACTER_SUMMONT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SUMMONID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4152);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t summonId() const {
    return GetField<int32_t>(VT_SUMMONID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SUMMONID) &&
           verifier.EndTable();
  }
  SHOP_CHARACTER_SUMMONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_CHARACTER_SUMMONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_CHARACTER_SUMMON> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_CHARACTER_SUMMONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_CHARACTER_SUMMON::VT_TYPE, type, 4152);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON::VT_VERSION, version);
  }
  void add_summonId(int32_t summonId) {
    fbb_.AddElement<int32_t>(SHOP_CHARACTER_SUMMON::VT_SUMMONID, summonId, 0);
  }
  explicit SHOP_CHARACTER_SUMMONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_CHARACTER_SUMMONBuilder &operator=(const SHOP_CHARACTER_SUMMONBuilder &);
  flatbuffers::Offset<SHOP_CHARACTER_SUMMON> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_CHARACTER_SUMMON>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON> CreateSHOP_CHARACTER_SUMMON(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4152,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t summonId = 0) {
  SHOP_CHARACTER_SUMMONBuilder builder_(_fbb);
  builder_.add_summonId(summonId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON> CreateSHOP_CHARACTER_SUMMONDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4152,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t summonId = 0) {
  return OVERLORD::REQUEST::CreateSHOP_CHARACTER_SUMMON(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      summonId);
}

flatbuffers::Offset<SHOP_CHARACTER_SUMMON> CreateSHOP_CHARACTER_SUMMON(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_STATUST : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  SHOP_FLOORSHOP_STATUST()
      : type(4153) {
  }
};

struct SHOP_FLOORSHOP_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4153);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_STATUS::VT_TYPE, type, 4153);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS::VT_VERSION, version);
  }
  explicit SHOP_FLOORSHOP_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_STATUSBuilder &operator=(const SHOP_FLOORSHOP_STATUSBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4153,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  SHOP_FLOORSHOP_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4153,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_BUYT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_BUY TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t slotId;
  int32_t shopId;
  SHOP_FLOORSHOP_BUYT()
      : type(4154),
        slotId(0),
        shopId(0) {
  }
};

struct SHOP_FLOORSHOP_BUY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_BUYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SLOTID = 14,
    VT_SHOPID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4154);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t slotId() const {
    return GetField<int32_t>(VT_SLOTID, 0);
  }
  int32_t shopId() const {
    return GetField<int32_t>(VT_SHOPID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SLOTID) &&
           VerifyField<int32_t>(verifier, VT_SHOPID) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_BUYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_BUYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_BUY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_BUYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_BUY::VT_TYPE, type, 4154);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY::VT_VERSION, version);
  }
  void add_slotId(int32_t slotId) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_BUY::VT_SLOTID, slotId, 0);
  }
  void add_shopId(int32_t shopId) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_BUY::VT_SHOPID, shopId, 0);
  }
  explicit SHOP_FLOORSHOP_BUYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_BUYBuilder &operator=(const SHOP_FLOORSHOP_BUYBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_BUY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_BUY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY> CreateSHOP_FLOORSHOP_BUY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4154,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t slotId = 0,
    int32_t shopId = 0) {
  SHOP_FLOORSHOP_BUYBuilder builder_(_fbb);
  builder_.add_shopId(shopId);
  builder_.add_slotId(slotId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY> CreateSHOP_FLOORSHOP_BUYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4154,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t slotId = 0,
    int32_t shopId = 0) {
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_BUY(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      slotId,
      shopId);
}

flatbuffers::Offset<SHOP_FLOORSHOP_BUY> CreateSHOP_FLOORSHOP_BUY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_OPEN_SLOTT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_OPEN_SLOT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t slotId;
  SHOP_FLOORSHOP_OPEN_SLOTT()
      : type(4155),
        slotId(0) {
  }
};

struct SHOP_FLOORSHOP_OPEN_SLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_OPEN_SLOTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_SLOTID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 4155);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t slotId() const {
    return GetField<int32_t>(VT_SLOTID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_SLOTID) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_OPEN_SLOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_OPEN_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_OPEN_SLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_OPEN_SLOT::VT_TYPE, type, 4155);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT::VT_VERSION, version);
  }
  void add_slotId(int32_t slotId) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_OPEN_SLOT::VT_SLOTID, slotId, 0);
  }
  explicit SHOP_FLOORSHOP_OPEN_SLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_OPEN_SLOTBuilder &operator=(const SHOP_FLOORSHOP_OPEN_SLOTBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> CreateSHOP_FLOORSHOP_OPEN_SLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4155,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t slotId = 0) {
  SHOP_FLOORSHOP_OPEN_SLOTBuilder builder_(_fbb);
  builder_.add_slotId(slotId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> CreateSHOP_FLOORSHOP_OPEN_SLOTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 4155,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t slotId = 0) {
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_OPEN_SLOT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      slotId);
}

flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> CreateSHOP_FLOORSHOP_OPEN_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_STATUST : public flatbuffers::NativeTable {
  typedef TOWER_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  TOWER_STATUST()
      : type(6100) {
  }
};

struct TOWER_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6100);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  TOWER_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_STATUS::VT_TYPE, type, 6100);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_STATUS::VT_VERSION, version);
  }
  explicit TOWER_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_STATUSBuilder &operator=(const TOWER_STATUSBuilder &);
  flatbuffers::Offset<TOWER_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6100,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  TOWER_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6100,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_PLAY_STARTT : public flatbuffers::NativeTable {
  typedef TOWER_PLAY_START TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::vector<std::string> heroUDs;
  std::string stageId;
  TOWER_PLAY_STARTT()
      : type(6101) {
  }
};

struct TOWER_PLAY_START FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_PLAY_STARTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_HEROUDS = 14,
    VT_STAGEID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6101);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_HEROUDS);
  }
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_HEROUDS) &&
           verifier.Verify(heroUDs()) &&
           verifier.VerifyVectorOfStrings(heroUDs()) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           verifier.EndTable();
  }
  TOWER_PLAY_STARTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_PLAY_START> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_PLAY_STARTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_START::VT_TYPE, type, 6101);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_VERSION, version);
  }
  void add_heroUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_HEROUDS, heroUDs);
  }
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(TOWER_PLAY_START::VT_STAGEID, stageId);
  }
  explicit TOWER_PLAY_STARTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_PLAY_STARTBuilder &operator=(const TOWER_PLAY_STARTBuilder &);
  flatbuffers::Offset<TOWER_PLAY_START> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_PLAY_START>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_PLAY_START> CreateTOWER_PLAY_START(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6101,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> heroUDs = 0,
    flatbuffers::Offset<flatbuffers::String> stageId = 0) {
  TOWER_PLAY_STARTBuilder builder_(_fbb);
  builder_.add_stageId(stageId);
  builder_.add_heroUDs(heroUDs);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_PLAY_START> CreateTOWER_PLAY_STARTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6101,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *heroUDs = nullptr,
    const char *stageId = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_PLAY_START(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      heroUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*heroUDs) : 0,
      stageId ? _fbb.CreateString(stageId) : 0);
}

flatbuffers::Offset<TOWER_PLAY_START> CreateTOWER_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_PLAY_DONET : public flatbuffers::NativeTable {
  typedef TOWER_PLAY_DONE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t playTime;
  int32_t clearGrade;
  std::string playUD;
  TOWER_PLAY_DONET()
      : type(6102),
        playTime(0),
        clearGrade(0) {
  }
};

struct TOWER_PLAY_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_PLAY_DONET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_PLAYTIME = 14,
    VT_CLEARGRADE = 16,
    VT_PLAYUD = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6102);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t playTime() const {
    return GetField<int32_t>(VT_PLAYTIME, 0);
  }
  int32_t clearGrade() const {
    return GetField<int32_t>(VT_CLEARGRADE, 0);
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_PLAYTIME) &&
           VerifyField<int32_t>(verifier, VT_CLEARGRADE) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           verifier.EndTable();
  }
  TOWER_PLAY_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_PLAY_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_PLAY_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_DONE::VT_TYPE, type, 6102);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_PLAY_DONE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_PLAY_DONE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_PLAY_DONE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_PLAY_DONE::VT_VERSION, version);
  }
  void add_playTime(int32_t playTime) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_DONE::VT_PLAYTIME, playTime, 0);
  }
  void add_clearGrade(int32_t clearGrade) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_DONE::VT_CLEARGRADE, clearGrade, 0);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(TOWER_PLAY_DONE::VT_PLAYUD, playUD);
  }
  explicit TOWER_PLAY_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_PLAY_DONEBuilder &operator=(const TOWER_PLAY_DONEBuilder &);
  flatbuffers::Offset<TOWER_PLAY_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_PLAY_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_PLAY_DONE> CreateTOWER_PLAY_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6102,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t playTime = 0,
    int32_t clearGrade = 0,
    flatbuffers::Offset<flatbuffers::String> playUD = 0) {
  TOWER_PLAY_DONEBuilder builder_(_fbb);
  builder_.add_playUD(playUD);
  builder_.add_clearGrade(clearGrade);
  builder_.add_playTime(playTime);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_PLAY_DONE> CreateTOWER_PLAY_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6102,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t playTime = 0,
    int32_t clearGrade = 0,
    const char *playUD = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_PLAY_DONE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      playTime,
      clearGrade,
      playUD ? _fbb.CreateString(playUD) : 0);
}

flatbuffers::Offset<TOWER_PLAY_DONE> CreateTOWER_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_TREASURE_BOXT : public flatbuffers::NativeTable {
  typedef TOWER_TREASURE_BOX TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t boxIdx;
  TOWER_TREASURE_BOXT()
      : type(6103),
        boxIdx(0) {
  }
};

struct TOWER_TREASURE_BOX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_TREASURE_BOXT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_BOXIDX = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6103);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t boxIdx() const {
    return GetField<int32_t>(VT_BOXIDX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_BOXIDX) &&
           verifier.EndTable();
  }
  TOWER_TREASURE_BOXT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_TREASURE_BOXT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_TREASURE_BOX> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOXT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_TREASURE_BOXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_TREASURE_BOX::VT_TYPE, type, 6103);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_TREASURE_BOX::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_TREASURE_BOX::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_TREASURE_BOX::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_TREASURE_BOX::VT_VERSION, version);
  }
  void add_boxIdx(int32_t boxIdx) {
    fbb_.AddElement<int32_t>(TOWER_TREASURE_BOX::VT_BOXIDX, boxIdx, 0);
  }
  explicit TOWER_TREASURE_BOXBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_TREASURE_BOXBuilder &operator=(const TOWER_TREASURE_BOXBuilder &);
  flatbuffers::Offset<TOWER_TREASURE_BOX> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_TREASURE_BOX>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_TREASURE_BOX> CreateTOWER_TREASURE_BOX(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6103,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t boxIdx = 0) {
  TOWER_TREASURE_BOXBuilder builder_(_fbb);
  builder_.add_boxIdx(boxIdx);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX> CreateTOWER_TREASURE_BOXDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6103,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t boxIdx = 0) {
  return OVERLORD::REQUEST::CreateTOWER_TREASURE_BOX(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      boxIdx);
}

flatbuffers::Offset<TOWER_TREASURE_BOX> CreateTOWER_TREASURE_BOX(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOXT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_BOSS_PLAY_CHECKT : public flatbuffers::NativeTable {
  typedef TOWER_BOSS_PLAY_CHECK TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string stageId;
  TOWER_BOSS_PLAY_CHECKT()
      : type(6104) {
  }
};

struct TOWER_BOSS_PLAY_CHECK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_BOSS_PLAY_CHECKT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_STAGEID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6104);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *stageId() const {
    return GetPointer<const flatbuffers::String *>(VT_STAGEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_STAGEID) &&
           verifier.Verify(stageId()) &&
           verifier.EndTable();
  }
  TOWER_BOSS_PLAY_CHECKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_BOSS_PLAY_CHECKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_BOSS_PLAY_CHECKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_BOSS_PLAY_CHECK::VT_TYPE, type, 6104);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK::VT_VERSION, version);
  }
  void add_stageId(flatbuffers::Offset<flatbuffers::String> stageId) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK::VT_STAGEID, stageId);
  }
  explicit TOWER_BOSS_PLAY_CHECKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_BOSS_PLAY_CHECKBuilder &operator=(const TOWER_BOSS_PLAY_CHECKBuilder &);
  flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> CreateTOWER_BOSS_PLAY_CHECK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6104,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> stageId = 0) {
  TOWER_BOSS_PLAY_CHECKBuilder builder_(_fbb);
  builder_.add_stageId(stageId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> CreateTOWER_BOSS_PLAY_CHECKDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6104,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *stageId = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_BOSS_PLAY_CHECK(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      stageId ? _fbb.CreateString(stageId) : 0);
}

flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> CreateTOWER_BOSS_PLAY_CHECK(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_BOSS_PLAY_RESULTT : public flatbuffers::NativeTable {
  typedef TOWER_BOSS_PLAY_RESULT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string roomKey;
  TOWER_BOSS_PLAY_RESULTT()
      : type(6105) {
  }
};

struct TOWER_BOSS_PLAY_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_BOSS_PLAY_RESULTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ROOMKEY = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6105);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *roomKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomKey()) &&
           verifier.EndTable();
  }
  TOWER_BOSS_PLAY_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_BOSS_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_BOSS_PLAY_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_BOSS_PLAY_RESULT::VT_TYPE, type, 6105);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT::VT_VERSION, version);
  }
  void add_roomKey(flatbuffers::Offset<flatbuffers::String> roomKey) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT::VT_ROOMKEY, roomKey);
  }
  explicit TOWER_BOSS_PLAY_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_BOSS_PLAY_RESULTBuilder &operator=(const TOWER_BOSS_PLAY_RESULTBuilder &);
  flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> CreateTOWER_BOSS_PLAY_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6105,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> roomKey = 0) {
  TOWER_BOSS_PLAY_RESULTBuilder builder_(_fbb);
  builder_.add_roomKey(roomKey);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> CreateTOWER_BOSS_PLAY_RESULTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6105,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *roomKey = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_BOSS_PLAY_RESULT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      roomKey ? _fbb.CreateString(roomKey) : 0);
}

flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> CreateTOWER_BOSS_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_FLOOR_MISSION_ACTIVET : public flatbuffers::NativeTable {
  typedef TOWER_FLOOR_MISSION_ACTIVE TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  int32_t floor;
  TOWER_FLOOR_MISSION_ACTIVET()
      : type(6106),
        floor(0) {
  }
};

struct TOWER_FLOOR_MISSION_ACTIVE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_FLOOR_MISSION_ACTIVET NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_FLOOR = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6106);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t floor() const {
    return GetField<int32_t>(VT_FLOOR, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<int32_t>(verifier, VT_FLOOR) &&
           verifier.EndTable();
  }
  TOWER_FLOOR_MISSION_ACTIVET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_FLOOR_MISSION_ACTIVET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_FLOOR_MISSION_ACTIVEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_FLOOR_MISSION_ACTIVE::VT_TYPE, type, 6106);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE::VT_VERSION, version);
  }
  void add_floor(int32_t floor) {
    fbb_.AddElement<int32_t>(TOWER_FLOOR_MISSION_ACTIVE::VT_FLOOR, floor, 0);
  }
  explicit TOWER_FLOOR_MISSION_ACTIVEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_FLOOR_MISSION_ACTIVEBuilder &operator=(const TOWER_FLOOR_MISSION_ACTIVEBuilder &);
  flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> CreateTOWER_FLOOR_MISSION_ACTIVE(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6106,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t floor = 0) {
  TOWER_FLOOR_MISSION_ACTIVEBuilder builder_(_fbb);
  builder_.add_floor(floor);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> CreateTOWER_FLOOR_MISSION_ACTIVEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6106,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    int32_t floor = 0) {
  return OVERLORD::REQUEST::CreateTOWER_FLOOR_MISSION_ACTIVE(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      floor);
}

flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> CreateTOWER_FLOOR_MISSION_ACTIVE(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_FLOOR_MISSION_REWARDT : public flatbuffers::NativeTable {
  typedef TOWER_FLOOR_MISSION_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string id;
  TOWER_FLOOR_MISSION_REWARDT()
      : type(6107) {
  }
};

struct TOWER_FLOOR_MISSION_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_FLOOR_MISSION_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 6107);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           verifier.EndTable();
  }
  TOWER_FLOOR_MISSION_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_FLOOR_MISSION_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_FLOOR_MISSION_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_FLOOR_MISSION_REWARD::VT_TYPE, type, 6107);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD::VT_VERSION, version);
  }
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD::VT_ID, id);
  }
  explicit TOWER_FLOOR_MISSION_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_FLOOR_MISSION_REWARDBuilder &operator=(const TOWER_FLOOR_MISSION_REWARDBuilder &);
  flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> CreateTOWER_FLOOR_MISSION_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6107,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> id = 0) {
  TOWER_FLOOR_MISSION_REWARDBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> CreateTOWER_FLOOR_MISSION_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 6107,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *id = nullptr) {
  return OVERLORD::REQUEST::CreateTOWER_FLOOR_MISSION_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      id ? _fbb.CreateString(id) : 0);
}

flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> CreateTOWER_FLOOR_MISSION_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TREASURE_GET_REWARDT : public flatbuffers::NativeTable {
  typedef TREASURE_GET_REWARD TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  TREASURE_GET_REWARDT()
      : type(8850) {
  }
};

struct TREASURE_GET_REWARD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TREASURE_GET_REWARDT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 8850);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  TREASURE_GET_REWARDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TREASURE_GET_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TREASURE_GET_REWARD> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TREASURE_GET_REWARDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TREASURE_GET_REWARD::VT_TYPE, type, 8850);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(TREASURE_GET_REWARD::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(TREASURE_GET_REWARD::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(TREASURE_GET_REWARD::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(TREASURE_GET_REWARD::VT_VERSION, version);
  }
  explicit TREASURE_GET_REWARDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TREASURE_GET_REWARDBuilder &operator=(const TREASURE_GET_REWARDBuilder &);
  flatbuffers::Offset<TREASURE_GET_REWARD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TREASURE_GET_REWARD>(end);
    return o;
  }
};

inline flatbuffers::Offset<TREASURE_GET_REWARD> CreateTREASURE_GET_REWARD(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8850,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  TREASURE_GET_REWARDBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TREASURE_GET_REWARD> CreateTREASURE_GET_REWARDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 8850,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateTREASURE_GET_REWARD(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<TREASURE_GET_REWARD> CreateTREASURE_GET_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GET_TARGET_SERVERT : public flatbuffers::NativeTable {
  typedef GET_TARGET_SERVER TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  GET_TARGET_SERVERT()
      : type(17450) {
  }
};

struct GET_TARGET_SERVER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GET_TARGET_SERVERT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 17450);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  GET_TARGET_SERVERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GET_TARGET_SERVERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GET_TARGET_SERVER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GET_TARGET_SERVERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GET_TARGET_SERVER::VT_TYPE, type, 17450);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(GET_TARGET_SERVER::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(GET_TARGET_SERVER::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(GET_TARGET_SERVER::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(GET_TARGET_SERVER::VT_VERSION, version);
  }
  explicit GET_TARGET_SERVERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GET_TARGET_SERVERBuilder &operator=(const GET_TARGET_SERVERBuilder &);
  flatbuffers::Offset<GET_TARGET_SERVER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GET_TARGET_SERVER>(end);
    return o;
  }
};

inline flatbuffers::Offset<GET_TARGET_SERVER> CreateGET_TARGET_SERVER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 17450,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  GET_TARGET_SERVERBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GET_TARGET_SERVER> CreateGET_TARGET_SERVERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 17450,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateGET_TARGET_SERVER(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<GET_TARGET_SERVER> CreateGET_TARGET_SERVER(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_STATUST : public flatbuffers::NativeTable {
  typedef WORLDBOSS_STATUS TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  WORLDBOSS_STATUST()
      : type(10850) {
  }
};

struct WORLDBOSS_STATUS FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_STATUST NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10850);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           verifier.EndTable();
  }
  WORLDBOSS_STATUST *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_STATUST *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_STATUS> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_STATUSBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_STATUS::VT_TYPE, type, 10850);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(WORLDBOSS_STATUS::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(WORLDBOSS_STATUS::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(WORLDBOSS_STATUS::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(WORLDBOSS_STATUS::VT_VERSION, version);
  }
  explicit WORLDBOSS_STATUSBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_STATUSBuilder &operator=(const WORLDBOSS_STATUSBuilder &);
  flatbuffers::Offset<WORLDBOSS_STATUS> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_STATUS>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10850,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0) {
  WORLDBOSS_STATUSBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUSDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10850,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr) {
  return OVERLORD::REQUEST::CreateWORLDBOSS_STATUS(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0);
}

flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_PLAY_CHECKT : public flatbuffers::NativeTable {
  typedef WORLDBOSS_PLAY_CHECK TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string worldBossStageId;
  WORLDBOSS_PLAY_CHECKT()
      : type(10851) {
  }
};

struct WORLDBOSS_PLAY_CHECK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_PLAY_CHECKT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_WORLDBOSSSTAGEID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10851);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *worldBossStageId() const {
    return GetPointer<const flatbuffers::String *>(VT_WORLDBOSSSTAGEID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_WORLDBOSSSTAGEID) &&
           verifier.Verify(worldBossStageId()) &&
           verifier.EndTable();
  }
  WORLDBOSS_PLAY_CHECKT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_PLAY_CHECKT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECKT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_PLAY_CHECKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_PLAY_CHECK::VT_TYPE, type, 10851);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK::VT_VERSION, version);
  }
  void add_worldBossStageId(flatbuffers::Offset<flatbuffers::String> worldBossStageId) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK::VT_WORLDBOSSSTAGEID, worldBossStageId);
  }
  explicit WORLDBOSS_PLAY_CHECKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_PLAY_CHECKBuilder &operator=(const WORLDBOSS_PLAY_CHECKBuilder &);
  flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_PLAY_CHECK>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> CreateWORLDBOSS_PLAY_CHECK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10851,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> worldBossStageId = 0) {
  WORLDBOSS_PLAY_CHECKBuilder builder_(_fbb);
  builder_.add_worldBossStageId(worldBossStageId);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> CreateWORLDBOSS_PLAY_CHECKDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10851,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *worldBossStageId = nullptr) {
  return OVERLORD::REQUEST::CreateWORLDBOSS_PLAY_CHECK(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      worldBossStageId ? _fbb.CreateString(worldBossStageId) : 0);
}

flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> CreateWORLDBOSS_PLAY_CHECK(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECKT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_PLAY_RESULTT : public flatbuffers::NativeTable {
  typedef WORLDBOSS_PLAY_RESULT TableType;
  int32_t type;
  std::string clientkey;
  std::string deviceid;
  std::string protocol;
  std::string version;
  std::string roomKey;
  WORLDBOSS_PLAY_RESULTT()
      : type(10852) {
  }
};

struct WORLDBOSS_PLAY_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_PLAY_RESULTT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_CLIENTKEY = 6,
    VT_DEVICEID = 8,
    VT_PROTOCOL = 10,
    VT_VERSION = 12,
    VT_ROOMKEY = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 10852);
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  const flatbuffers::String *deviceid() const {
    return GetPointer<const flatbuffers::String *>(VT_DEVICEID);
  }
  const flatbuffers::String *protocol() const {
    return GetPointer<const flatbuffers::String *>(VT_PROTOCOL);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *roomKey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           VerifyOffset(verifier, VT_DEVICEID) &&
           verifier.Verify(deviceid()) &&
           VerifyOffset(verifier, VT_PROTOCOL) &&
           verifier.Verify(protocol()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomKey()) &&
           verifier.EndTable();
  }
  WORLDBOSS_PLAY_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_PLAY_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_PLAY_RESULT::VT_TYPE, type, 10852);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT::VT_CLIENTKEY, clientkey);
  }
  void add_deviceid(flatbuffers::Offset<flatbuffers::String> deviceid) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT::VT_DEVICEID, deviceid);
  }
  void add_protocol(flatbuffers::Offset<flatbuffers::String> protocol) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT::VT_PROTOCOL, protocol);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT::VT_VERSION, version);
  }
  void add_roomKey(flatbuffers::Offset<flatbuffers::String> roomKey) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT::VT_ROOMKEY, roomKey);
  }
  explicit WORLDBOSS_PLAY_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_PLAY_RESULTBuilder &operator=(const WORLDBOSS_PLAY_RESULTBuilder &);
  flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_PLAY_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> CreateWORLDBOSS_PLAY_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10852,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0,
    flatbuffers::Offset<flatbuffers::String> deviceid = 0,
    flatbuffers::Offset<flatbuffers::String> protocol = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> roomKey = 0) {
  WORLDBOSS_PLAY_RESULTBuilder builder_(_fbb);
  builder_.add_roomKey(roomKey);
  builder_.add_version(version);
  builder_.add_protocol(protocol);
  builder_.add_deviceid(deviceid);
  builder_.add_clientkey(clientkey);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> CreateWORLDBOSS_PLAY_RESULTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 10852,
    const char *clientkey = nullptr,
    const char *deviceid = nullptr,
    const char *protocol = nullptr,
    const char *version = nullptr,
    const char *roomKey = nullptr) {
  return OVERLORD::REQUEST::CreateWORLDBOSS_PLAY_RESULT(
      _fbb,
      type,
      clientkey ? _fbb.CreateString(clientkey) : 0,
      deviceid ? _fbb.CreateString(deviceid) : 0,
      protocol ? _fbb.CreateString(protocol) : 0,
      version ? _fbb.CreateString(version) : 0,
      roomKey ? _fbb.CreateString(roomKey) : 0);
}

flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> CreateWORLDBOSS_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace REQUEST

namespace RESPONSE {

struct LOGIN_REPLYT : public flatbuffers::NativeTable {
  typedef LOGIN_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool success;
  LOGIN_REPLYT()
      : type(-8450),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        success(true) {
  }
};

struct LOGIN_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LOGIN_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SUCCESS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8450);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  LOGIN_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LOGIN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LOGIN_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LOGIN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LOGIN_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(LOGIN_REPLY::VT_TYPE, type, -8450);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(LOGIN_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(LOGIN_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(LOGIN_REPLY::VT_SUCCESS, static_cast<uint8_t>(success), 1);
  }
  explicit LOGIN_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LOGIN_REPLYBuilder &operator=(const LOGIN_REPLYBuilder &);
  flatbuffers::Offset<LOGIN_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LOGIN_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<LOGIN_REPLY> CreateLOGIN_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8450,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool success = true) {
  LOGIN_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_success(success);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<LOGIN_REPLY> CreateLOGIN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const LOGIN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_CREATE_REPLYT : public flatbuffers::NativeTable {
  typedef ACCOUNT_CREATE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::string nick;
  bool exists;
  int32_t kId;
  ACCOUNT_CREATE_REPLYT()
      : type(-8451),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        exists(false),
        kId(0) {
  }
};

struct ACCOUNT_CREATE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_CREATE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_NICK = 10,
    VT_EXISTS = 12,
    VT_KID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8451);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  ACCOUNT_CREATE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_CREATE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_CREATE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_CREATE_REPLY::VT_TYPE, type, -8451);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ACCOUNT_CREATE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ACCOUNT_CREATE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ACCOUNT_CREATE_REPLY::VT_NICK, nick);
  }
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(ACCOUNT_CREATE_REPLY::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ACCOUNT_CREATE_REPLY::VT_KID, kId, 0);
  }
  explicit ACCOUNT_CREATE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_CREATE_REPLYBuilder &operator=(const ACCOUNT_CREATE_REPLYBuilder &);
  flatbuffers::Offset<ACCOUNT_CREATE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_CREATE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_CREATE_REPLY> CreateACCOUNT_CREATE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8451,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    bool exists = false,
    int32_t kId = 0) {
  ACCOUNT_CREATE_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_nick(nick);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_exists(exists);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_CREATE_REPLY> CreateACCOUNT_CREATE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8451,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const char *nick = nullptr,
    bool exists = false,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateACCOUNT_CREATE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      nick ? _fbb.CreateString(nick) : 0,
      exists,
      kId);
}

flatbuffers::Offset<ACCOUNT_CREATE_REPLY> CreateACCOUNT_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_REMOVE_REPLYT : public flatbuffers::NativeTable {
  typedef ACCOUNT_REMOVE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool exists;
  std::string nick;
  ACCOUNT_REMOVE_REPLYT()
      : type(-8452),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        exists(false) {
  }
};

struct ACCOUNT_REMOVE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_REMOVE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_EXISTS = 10,
    VT_NICK = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8452);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool exists() const {
    return GetField<uint8_t>(VT_EXISTS, 0) != 0;
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_EXISTS) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           verifier.EndTable();
  }
  ACCOUNT_REMOVE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_REMOVE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_REMOVE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_REMOVE_REPLY::VT_TYPE, type, -8452);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ACCOUNT_REMOVE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ACCOUNT_REMOVE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_exists(bool exists) {
    fbb_.AddElement<uint8_t>(ACCOUNT_REMOVE_REPLY::VT_EXISTS, static_cast<uint8_t>(exists), 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(ACCOUNT_REMOVE_REPLY::VT_NICK, nick);
  }
  explicit ACCOUNT_REMOVE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_REMOVE_REPLYBuilder &operator=(const ACCOUNT_REMOVE_REPLYBuilder &);
  flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_REMOVE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> CreateACCOUNT_REMOVE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8452,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool exists = false,
    flatbuffers::Offset<flatbuffers::String> nick = 0) {
  ACCOUNT_REMOVE_REPLYBuilder builder_(_fbb);
  builder_.add_nick(nick);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_exists(exists);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> CreateACCOUNT_REMOVE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8452,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool exists = false,
    const char *nick = nullptr) {
  return OVERLORD::RESPONSE::CreateACCOUNT_REMOVE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      exists,
      nick ? _fbb.CreateString(nick) : 0);
}

flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> CreateACCOUNT_REMOVE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INIT_CLIENT_KEY_REPLYT : public flatbuffers::NativeTable {
  typedef INIT_CLIENT_KEY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::string clientkey;
  INIT_CLIENT_KEY_REPLYT()
      : type(-8453),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INIT_CLIENT_KEY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INIT_CLIENT_KEY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CLIENTKEY = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8453);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           verifier.EndTable();
  }
  INIT_CLIENT_KEY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INIT_CLIENT_KEY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INIT_CLIENT_KEY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INIT_CLIENT_KEY_REPLY::VT_TYPE, type, -8453);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INIT_CLIENT_KEY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INIT_CLIENT_KEY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(INIT_CLIENT_KEY_REPLY::VT_CLIENTKEY, clientkey);
  }
  explicit INIT_CLIENT_KEY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INIT_CLIENT_KEY_REPLYBuilder &operator=(const INIT_CLIENT_KEY_REPLYBuilder &);
  flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INIT_CLIENT_KEY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> CreateINIT_CLIENT_KEY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8453,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0) {
  INIT_CLIENT_KEY_REPLYBuilder builder_(_fbb);
  builder_.add_clientkey(clientkey);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> CreateINIT_CLIENT_KEY_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8453,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const char *clientkey = nullptr) {
  return OVERLORD::RESPONSE::CreateINIT_CLIENT_KEY_REPLY(
      _fbb,
      type,
      error_info,
      is,
      clientkey ? _fbb.CreateString(clientkey) : 0);
}

flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> CreateINIT_CLIENT_KEY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ADD_REFER_PUBLISHER_REPLYT : public flatbuffers::NativeTable {
  typedef ADD_REFER_PUBLISHER_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::string clientkey;
  ADD_REFER_PUBLISHER_REPLYT()
      : type(-8454),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ADD_REFER_PUBLISHER_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ADD_REFER_PUBLISHER_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CLIENTKEY = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8454);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::String *clientkey() const {
    return GetPointer<const flatbuffers::String *>(VT_CLIENTKEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_CLIENTKEY) &&
           verifier.Verify(clientkey()) &&
           verifier.EndTable();
  }
  ADD_REFER_PUBLISHER_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ADD_REFER_PUBLISHER_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHER_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ADD_REFER_PUBLISHER_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ADD_REFER_PUBLISHER_REPLY::VT_TYPE, type, -8454);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ADD_REFER_PUBLISHER_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_clientkey(flatbuffers::Offset<flatbuffers::String> clientkey) {
    fbb_.AddOffset(ADD_REFER_PUBLISHER_REPLY::VT_CLIENTKEY, clientkey);
  }
  explicit ADD_REFER_PUBLISHER_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ADD_REFER_PUBLISHER_REPLYBuilder &operator=(const ADD_REFER_PUBLISHER_REPLYBuilder &);
  flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> CreateADD_REFER_PUBLISHER_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8454,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::String> clientkey = 0) {
  ADD_REFER_PUBLISHER_REPLYBuilder builder_(_fbb);
  builder_.add_clientkey(clientkey);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> CreateADD_REFER_PUBLISHER_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8454,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const char *clientkey = nullptr) {
  return OVERLORD::RESPONSE::CreateADD_REFER_PUBLISHER_REPLY(
      _fbb,
      type,
      error_info,
      is,
      clientkey ? _fbb.CreateString(clientkey) : 0);
}

flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> CreateADD_REFER_PUBLISHER_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHER_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GET_REFER_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef GET_REFER_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::string> publisher_list;
  GET_REFER_LIST_REPLYT()
      : type(-8455),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GET_REFER_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GET_REFER_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_PUBLISHER_LIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8455);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *publisher_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_PUBLISHER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_PUBLISHER_LIST) &&
           verifier.Verify(publisher_list()) &&
           verifier.VerifyVectorOfStrings(publisher_list()) &&
           verifier.EndTable();
  }
  GET_REFER_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GET_REFER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GET_REFER_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GET_REFER_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GET_REFER_LIST_REPLY::VT_TYPE, type, -8455);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GET_REFER_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GET_REFER_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_publisher_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> publisher_list) {
    fbb_.AddOffset(GET_REFER_LIST_REPLY::VT_PUBLISHER_LIST, publisher_list);
  }
  explicit GET_REFER_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GET_REFER_LIST_REPLYBuilder &operator=(const GET_REFER_LIST_REPLYBuilder &);
  flatbuffers::Offset<GET_REFER_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GET_REFER_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GET_REFER_LIST_REPLY> CreateGET_REFER_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8455,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> publisher_list = 0) {
  GET_REFER_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_publisher_list(publisher_list);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GET_REFER_LIST_REPLY> CreateGET_REFER_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8455,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *publisher_list = nullptr) {
  return OVERLORD::RESPONSE::CreateGET_REFER_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      publisher_list ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*publisher_list) : 0);
}

flatbuffers::Offset<GET_REFER_LIST_REPLY> CreateGET_REFER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACCOUNT_CHANGE_LANGUAGE_REPLYT : public flatbuffers::NativeTable {
  typedef ACCOUNT_CHANGE_LANGUAGE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool success;
  ACCOUNT_CHANGE_LANGUAGE_REPLYT()
      : type(-8456),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        success(true) {
  }
};

struct ACCOUNT_CHANGE_LANGUAGE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACCOUNT_CHANGE_LANGUAGE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SUCCESS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8456);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  ACCOUNT_CHANGE_LANGUAGE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACCOUNT_CHANGE_LANGUAGE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACCOUNT_CHANGE_LANGUAGE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ACCOUNT_CHANGE_LANGUAGE_REPLY::VT_TYPE, type, -8456);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ACCOUNT_CHANGE_LANGUAGE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ACCOUNT_CHANGE_LANGUAGE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ACCOUNT_CHANGE_LANGUAGE_REPLY::VT_SUCCESS, static_cast<uint8_t>(success), 1);
  }
  explicit ACCOUNT_CHANGE_LANGUAGE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACCOUNT_CHANGE_LANGUAGE_REPLYBuilder &operator=(const ACCOUNT_CHANGE_LANGUAGE_REPLYBuilder &);
  flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> CreateACCOUNT_CHANGE_LANGUAGE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8456,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool success = true) {
  ACCOUNT_CHANGE_LANGUAGE_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_success(success);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> CreateACCOUNT_CHANGE_LANGUAGE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CLIENT_SDK_ACTION_REPLYT : public flatbuffers::NativeTable {
  typedef CLIENT_SDK_ACTION_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::AVATART> avatar;
  CLIENT_SDK_ACTION_REPLYT()
      : type(-8457),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct CLIENT_SDK_ACTION_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CLIENT_SDK_ACTION_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AVATAR = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8457);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::AVATAR *avatar() const {
    return GetPointer<const OVERLORD::STRUCT::AVATAR *>(VT_AVATAR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.VerifyTable(avatar()) &&
           verifier.EndTable();
  }
  CLIENT_SDK_ACTION_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CLIENT_SDK_ACTION_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTION_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CLIENT_SDK_ACTION_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CLIENT_SDK_ACTION_REPLY::VT_TYPE, type, -8457);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(CLIENT_SDK_ACTION_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(CLIENT_SDK_ACTION_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_avatar(flatbuffers::Offset<OVERLORD::STRUCT::AVATAR> avatar) {
    fbb_.AddOffset(CLIENT_SDK_ACTION_REPLY::VT_AVATAR, avatar);
  }
  explicit CLIENT_SDK_ACTION_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CLIENT_SDK_ACTION_REPLYBuilder &operator=(const CLIENT_SDK_ACTION_REPLYBuilder &);
  flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> CreateCLIENT_SDK_ACTION_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8457,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::AVATAR> avatar = 0) {
  CLIENT_SDK_ACTION_REPLYBuilder builder_(_fbb);
  builder_.add_avatar(avatar);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> CreateCLIENT_SDK_ACTION_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTION_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST> arenaStatus;
  ARENA_STATUS_REPLYT()
      : type(-4800),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_ARENASTATUS = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4800);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::ARENA_STATUS *arenaStatus() const {
    return GetPointer<const OVERLORD::STRUCT::ARENA_STATUS *>(VT_ARENASTATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ARENASTATUS) &&
           verifier.VerifyTable(arenaStatus()) &&
           verifier.EndTable();
  }
  ARENA_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_STATUS_REPLY::VT_TYPE, type, -4800);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_STATUS_REPLY::VT_UPDATE, update);
  }
  void add_arenaStatus(flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus) {
    fbb_.AddOffset(ARENA_STATUS_REPLY::VT_ARENASTATUS, arenaStatus);
  }
  explicit ARENA_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_STATUS_REPLYBuilder &operator=(const ARENA_STATUS_REPLYBuilder &);
  flatbuffers::Offset<ARENA_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_STATUS_REPLY> CreateARENA_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4800,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0) {
  ARENA_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_arenaStatus(arenaStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<ARENA_STATUS_REPLY> CreateARENA_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_TARGET_INFO_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_TARGET_INFO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::BATTLE_USERT> target;
  ARENA_TARGET_INFO_REPLYT()
      : type(-4801),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_TARGET_INFO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_TARGET_INFO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_TARGET = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4801);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::BATTLE_USER *target() const {
    return GetPointer<const OVERLORD::STRUCT::BATTLE_USER *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  ARENA_TARGET_INFO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_TARGET_INFO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_TARGET_INFO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_TARGET_INFO_REPLY::VT_TYPE, type, -4801);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_TARGET_INFO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_TARGET_INFO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_TARGET_INFO_REPLY::VT_UPDATE, update);
  }
  void add_target(flatbuffers::Offset<OVERLORD::STRUCT::BATTLE_USER> target) {
    fbb_.AddOffset(ARENA_TARGET_INFO_REPLY::VT_TARGET, target);
  }
  explicit ARENA_TARGET_INFO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_TARGET_INFO_REPLYBuilder &operator=(const ARENA_TARGET_INFO_REPLYBuilder &);
  flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_TARGET_INFO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> CreateARENA_TARGET_INFO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4801,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::BATTLE_USER> target = 0) {
  ARENA_TARGET_INFO_REPLYBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> CreateARENA_TARGET_INFO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_PLAY_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_PLAY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::string playUD;
  ARENA_PLAY_REPLYT()
      : type(-4802),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_PLAY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_PLAY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_PLAYUD = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4802);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           verifier.EndTable();
  }
  ARENA_PLAY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_PLAY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_PLAY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_PLAY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_PLAY_REPLY::VT_TYPE, type, -4802);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_PLAY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_PLAY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_PLAY_REPLY::VT_UPDATE, update);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(ARENA_PLAY_REPLY::VT_PLAYUD, playUD);
  }
  explicit ARENA_PLAY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_PLAY_REPLYBuilder &operator=(const ARENA_PLAY_REPLYBuilder &);
  flatbuffers::Offset<ARENA_PLAY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_PLAY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_PLAY_REPLY> CreateARENA_PLAY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4802,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::String> playUD = 0) {
  ARENA_PLAY_REPLYBuilder builder_(_fbb);
  builder_.add_playUD(playUD);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_PLAY_REPLY> CreateARENA_PLAY_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4802,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const char *playUD = nullptr) {
  return OVERLORD::RESPONSE::CreateARENA_PLAY_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      playUD ? _fbb.CreateString(playUD) : 0);
}

flatbuffers::Offset<ARENA_PLAY_REPLY> CreateARENA_PLAY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_PLAY_DONE_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_PLAY_DONE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST> arenaStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  ARENA_PLAY_DONE_REPLYT()
      : type(-4803),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_PLAY_DONE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_PLAY_DONE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_ARENASTATUS = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4803);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::ARENA_STATUS *arenaStatus() const {
    return GetPointer<const OVERLORD::STRUCT::ARENA_STATUS *>(VT_ARENASTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ARENASTATUS) &&
           verifier.VerifyTable(arenaStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  ARENA_PLAY_DONE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_PLAY_DONE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_PLAY_DONE_REPLY::VT_TYPE, type, -4803);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_PLAY_DONE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_PLAY_DONE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_PLAY_DONE_REPLY::VT_UPDATE, update);
  }
  void add_arenaStatus(flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus) {
    fbb_.AddOffset(ARENA_PLAY_DONE_REPLY::VT_ARENASTATUS, arenaStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(ARENA_PLAY_DONE_REPLY::VT_REWARDS, rewards);
  }
  explicit ARENA_PLAY_DONE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_PLAY_DONE_REPLYBuilder &operator=(const ARENA_PLAY_DONE_REPLYBuilder &);
  flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_PLAY_DONE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> CreateARENA_PLAY_DONE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4803,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  ARENA_PLAY_DONE_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_arenaStatus(arenaStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> CreateARENA_PLAY_DONE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4803,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateARENA_PLAY_DONE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      arenaStatus,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> CreateARENA_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_DEFENSE_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_DEFENSE_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST> arenaStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  ARENA_DEFENSE_REWARD_REPLYT()
      : type(-4804),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_DEFENSE_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_DEFENSE_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_ARENASTATUS = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4804);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::ARENA_STATUS *arenaStatus() const {
    return GetPointer<const OVERLORD::STRUCT::ARENA_STATUS *>(VT_ARENASTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ARENASTATUS) &&
           verifier.VerifyTable(arenaStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  ARENA_DEFENSE_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_DEFENSE_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_DEFENSE_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_DEFENSE_REWARD_REPLY::VT_TYPE, type, -4804);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_DEFENSE_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_arenaStatus(flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD_REPLY::VT_ARENASTATUS, arenaStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(ARENA_DEFENSE_REWARD_REPLY::VT_REWARDS, rewards);
  }
  explicit ARENA_DEFENSE_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_DEFENSE_REWARD_REPLYBuilder &operator=(const ARENA_DEFENSE_REWARD_REPLYBuilder &);
  flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> CreateARENA_DEFENSE_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4804,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  ARENA_DEFENSE_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_arenaStatus(arenaStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> CreateARENA_DEFENSE_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4804,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateARENA_DEFENSE_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      arenaStatus,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> CreateARENA_DEFENSE_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_SEASON_DONE_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_SEASON_DONE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST> arenaStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  ARENA_SEASON_DONE_REPLYT()
      : type(-4805),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_SEASON_DONE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_SEASON_DONE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_ARENASTATUS = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4805);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::ARENA_STATUS *arenaStatus() const {
    return GetPointer<const OVERLORD::STRUCT::ARENA_STATUS *>(VT_ARENASTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ARENASTATUS) &&
           verifier.VerifyTable(arenaStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  ARENA_SEASON_DONE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_SEASON_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_SEASON_DONE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_SEASON_DONE_REPLY::VT_TYPE, type, -4805);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_SEASON_DONE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_SEASON_DONE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_SEASON_DONE_REPLY::VT_UPDATE, update);
  }
  void add_arenaStatus(flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus) {
    fbb_.AddOffset(ARENA_SEASON_DONE_REPLY::VT_ARENASTATUS, arenaStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(ARENA_SEASON_DONE_REPLY::VT_REWARDS, rewards);
  }
  explicit ARENA_SEASON_DONE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_SEASON_DONE_REPLYBuilder &operator=(const ARENA_SEASON_DONE_REPLYBuilder &);
  flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_SEASON_DONE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> CreateARENA_SEASON_DONE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4805,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  ARENA_SEASON_DONE_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_arenaStatus(arenaStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> CreateARENA_SEASON_DONE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4805,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::ARENA_STATUS> arenaStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateARENA_SEASON_DONE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      arenaStatus,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> CreateARENA_SEASON_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_RANKING_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_RANKING_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::ARENA_RANK_USERT>> rankingList;
  ARENA_RANKING_LIST_REPLYT()
      : type(-4806),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_RANKING_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_RANKING_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_RANKINGLIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4806);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>> *rankingList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>> *>(VT_RANKINGLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_RANKINGLIST) &&
           verifier.Verify(rankingList()) &&
           verifier.VerifyVectorOfTables(rankingList()) &&
           verifier.EndTable();
  }
  ARENA_RANKING_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_RANKING_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_RANKING_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_RANKING_LIST_REPLY::VT_TYPE, type, -4806);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_RANKING_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_RANKING_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_rankingList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>>> rankingList) {
    fbb_.AddOffset(ARENA_RANKING_LIST_REPLY::VT_RANKINGLIST, rankingList);
  }
  explicit ARENA_RANKING_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_RANKING_LIST_REPLYBuilder &operator=(const ARENA_RANKING_LIST_REPLYBuilder &);
  flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_RANKING_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> CreateARENA_RANKING_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4806,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>>> rankingList = 0) {
  ARENA_RANKING_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_rankingList(rankingList);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> CreateARENA_RANKING_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4806,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>> *rankingList = nullptr) {
  return OVERLORD::RESPONSE::CreateARENA_RANKING_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      rankingList ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>>(*rankingList) : 0);
}

flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> CreateARENA_RANKING_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ARENA_DEFENSE_DECK_SET_REPLYT : public flatbuffers::NativeTable {
  typedef ARENA_DEFENSE_DECK_SET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  ARENA_DEFENSE_DECK_SET_REPLYT()
      : type(-4807),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct ARENA_DEFENSE_DECK_SET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ARENA_DEFENSE_DECK_SET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4807);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  ARENA_DEFENSE_DECK_SET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ARENA_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ARENA_DEFENSE_DECK_SET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ARENA_DEFENSE_DECK_SET_REPLY::VT_TYPE, type, -4807);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ARENA_DEFENSE_DECK_SET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(ARENA_DEFENSE_DECK_SET_REPLY::VT_UPDATE, update);
  }
  explicit ARENA_DEFENSE_DECK_SET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ARENA_DEFENSE_DECK_SET_REPLYBuilder &operator=(const ARENA_DEFENSE_DECK_SET_REPLYBuilder &);
  flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> CreateARENA_DEFENSE_DECK_SET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4807,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  ARENA_DEFENSE_DECK_SET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> CreateARENA_DEFENSE_DECK_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ABILITY_UP_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_ABILITY_UP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  AVATAR_ABILITY_UP_REPLYT()
      : type(-7650),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_ABILITY_UP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ABILITY_UP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7650);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  AVATAR_ABILITY_UP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ABILITY_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ABILITY_UP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_UP_REPLY::VT_TYPE, type, -7650);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_ABILITY_UP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_ABILITY_UP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(AVATAR_ABILITY_UP_REPLY::VT_UPDATE, update);
  }
  explicit AVATAR_ABILITY_UP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ABILITY_UP_REPLYBuilder &operator=(const AVATAR_ABILITY_UP_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> CreateAVATAR_ABILITY_UP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7650,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  AVATAR_ABILITY_UP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> CreateAVATAR_ABILITY_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ABILITY_RESET_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_ABILITY_RESET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  AVATAR_ABILITY_RESET_REPLYT()
      : type(-7651),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_ABILITY_RESET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ABILITY_RESET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7651);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  AVATAR_ABILITY_RESET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ABILITY_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ABILITY_RESET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ABILITY_RESET_REPLY::VT_TYPE, type, -7651);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_ABILITY_RESET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(AVATAR_ABILITY_RESET_REPLY::VT_UPDATE, update);
  }
  explicit AVATAR_ABILITY_RESET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ABILITY_RESET_REPLYBuilder &operator=(const AVATAR_ABILITY_RESET_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> CreateAVATAR_ABILITY_RESET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7651,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  AVATAR_ABILITY_RESET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> CreateAVATAR_ABILITY_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ICON_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_ICON_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<int32_t> iconList;
  AVATAR_ICON_LIST_REPLYT()
      : type(-7652),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_ICON_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ICON_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ICONLIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7652);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<int32_t> *iconList() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ICONLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_ICONLIST) &&
           verifier.Verify(iconList()) &&
           verifier.EndTable();
  }
  AVATAR_ICON_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ICON_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ICON_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ICON_LIST_REPLY::VT_TYPE, type, -7652);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_ICON_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_ICON_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_iconList(flatbuffers::Offset<flatbuffers::Vector<int32_t>> iconList) {
    fbb_.AddOffset(AVATAR_ICON_LIST_REPLY::VT_ICONLIST, iconList);
  }
  explicit AVATAR_ICON_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ICON_LIST_REPLYBuilder &operator=(const AVATAR_ICON_LIST_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ICON_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> CreateAVATAR_ICON_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7652,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> iconList = 0) {
  AVATAR_ICON_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_iconList(iconList);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> CreateAVATAR_ICON_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7652,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<int32_t> *iconList = nullptr) {
  return OVERLORD::RESPONSE::CreateAVATAR_ICON_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      iconList ? _fbb.CreateVector<int32_t>(*iconList) : 0);
}

flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> CreateAVATAR_ICON_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_ICON_SET_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_ICON_SET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  AVATAR_ICON_SET_REPLYT()
      : type(-7653),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_ICON_SET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_ICON_SET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7653);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  AVATAR_ICON_SET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_ICON_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_ICON_SET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_ICON_SET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_ICON_SET_REPLY::VT_TYPE, type, -7653);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_ICON_SET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_ICON_SET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(AVATAR_ICON_SET_REPLY::VT_UPDATE, update);
  }
  explicit AVATAR_ICON_SET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_ICON_SET_REPLYBuilder &operator=(const AVATAR_ICON_SET_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_ICON_SET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_ICON_SET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_ICON_SET_REPLY> CreateAVATAR_ICON_SET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7653,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  AVATAR_ICON_SET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<AVATAR_ICON_SET_REPLY> CreateAVATAR_ICON_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_PROFILE_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_PROFILE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::HERO_USAGE_TABT>> heroUse;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::ACCOUNT_RECORDT>> records;
  int32_t kId;
  AVATAR_PROFILE_REPLYT()
      : type(-7654),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct AVATAR_PROFILE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_PROFILE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_HEROUSE = 10,
    VT_RECORDS = 12,
    VT_KID = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7654);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>> *heroUse() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>> *>(VT_HEROUSE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>> *>(VT_RECORDS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_HEROUSE) &&
           verifier.Verify(heroUse()) &&
           verifier.VerifyVectorOfTables(heroUse()) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.Verify(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  AVATAR_PROFILE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_PROFILE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_PROFILE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_PROFILE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_PROFILE_REPLY::VT_TYPE, type, -7654);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_PROFILE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_PROFILE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_heroUse(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>>> heroUse) {
    fbb_.AddOffset(AVATAR_PROFILE_REPLY::VT_HEROUSE, heroUse);
  }
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>>> records) {
    fbb_.AddOffset(AVATAR_PROFILE_REPLY::VT_RECORDS, records);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(AVATAR_PROFILE_REPLY::VT_KID, kId, 0);
  }
  explicit AVATAR_PROFILE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_PROFILE_REPLYBuilder &operator=(const AVATAR_PROFILE_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_PROFILE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_PROFILE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_PROFILE_REPLY> CreateAVATAR_PROFILE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7654,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>>> heroUse = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>>> records = 0,
    int32_t kId = 0) {
  AVATAR_PROFILE_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_records(records);
  builder_.add_heroUse(heroUse);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_PROFILE_REPLY> CreateAVATAR_PROFILE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7654,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>> *heroUse = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>> *records = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateAVATAR_PROFILE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      heroUse ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>>(*heroUse) : 0,
      records ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>>(*records) : 0,
      kId);
}

flatbuffers::Offset<AVATAR_PROFILE_REPLY> CreateAVATAR_PROFILE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_LOBBY_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_LOBBY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST> daily_quest_status;
  std::unique_ptr<OVERLORD::STRUCT::TREASURET> treasure;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  AVATAR_LOBBY_REPLYT()
      : type(-7655),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_LOBBY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_LOBBY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_DAILY_QUEST_STATUS = 10,
    VT_TREASURE = 12,
    VT_UPDATE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7655);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::DAILY_QUEST_STATUS *daily_quest_status() const {
    return GetPointer<const OVERLORD::STRUCT::DAILY_QUEST_STATUS *>(VT_DAILY_QUEST_STATUS);
  }
  const OVERLORD::STRUCT::TREASURE *treasure() const {
    return GetPointer<const OVERLORD::STRUCT::TREASURE *>(VT_TREASURE);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_DAILY_QUEST_STATUS) &&
           verifier.VerifyTable(daily_quest_status()) &&
           VerifyOffset(verifier, VT_TREASURE) &&
           verifier.VerifyTable(treasure()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  AVATAR_LOBBY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_LOBBY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_LOBBY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_LOBBY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_LOBBY_REPLY::VT_TYPE, type, -7655);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_LOBBY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_LOBBY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_daily_quest_status(flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status) {
    fbb_.AddOffset(AVATAR_LOBBY_REPLY::VT_DAILY_QUEST_STATUS, daily_quest_status);
  }
  void add_treasure(flatbuffers::Offset<OVERLORD::STRUCT::TREASURE> treasure) {
    fbb_.AddOffset(AVATAR_LOBBY_REPLY::VT_TREASURE, treasure);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(AVATAR_LOBBY_REPLY::VT_UPDATE, update);
  }
  explicit AVATAR_LOBBY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_LOBBY_REPLYBuilder &operator=(const AVATAR_LOBBY_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_LOBBY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_LOBBY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_LOBBY_REPLY> CreateAVATAR_LOBBY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7655,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TREASURE> treasure = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  AVATAR_LOBBY_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_treasure(treasure);
  builder_.add_daily_quest_status(daily_quest_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<AVATAR_LOBBY_REPLY> CreateAVATAR_LOBBY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_GAME_DATA_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_GAME_DATA_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::SELECTIVE_TUTORIALT> selectiveTutorial;
  std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST> dailyQuestStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::ACHIEVE_STATUST>> achieveStatus;
  std::unique_ptr<OVERLORD::STRUCT::UNLOCK_LISTT> unlockList;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> towerStatus;
  std::unique_ptr<OVERLORD::STRUCT::EVENT_ATTENDANCET> chart;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_MINET> guild_mine;
  std::unique_ptr<OVERLORD::STRUCT::INVENTORYT> inventory;
  std::unique_ptr<OVERLORD::STRUCT::AVATART> avatar;
  int32_t colosseumGradeId;
  int32_t kId;
  AVATAR_GAME_DATA_REPLYT()
      : type(-7656),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        colosseumGradeId(0),
        kId(0) {
  }
};

struct AVATAR_GAME_DATA_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_GAME_DATA_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SELECTIVETUTORIAL = 10,
    VT_DAILYQUESTSTATUS = 12,
    VT_ACHIEVESTATUS = 14,
    VT_UNLOCKLIST = 16,
    VT_TOWERSTATUS = 18,
    VT_CHART = 20,
    VT_GUILD_MINE = 22,
    VT_INVENTORY = 24,
    VT_AVATAR = 26,
    VT_COLOSSEUMGRADEID = 28,
    VT_KID = 30
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7656);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::SELECTIVE_TUTORIAL *selectiveTutorial() const {
    return GetPointer<const OVERLORD::STRUCT::SELECTIVE_TUTORIAL *>(VT_SELECTIVETUTORIAL);
  }
  const OVERLORD::STRUCT::DAILY_QUEST_STATUS *dailyQuestStatus() const {
    return GetPointer<const OVERLORD::STRUCT::DAILY_QUEST_STATUS *>(VT_DAILYQUESTSTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *achieveStatus() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *>(VT_ACHIEVESTATUS);
  }
  const OVERLORD::STRUCT::UNLOCK_LIST *unlockList() const {
    return GetPointer<const OVERLORD::STRUCT::UNLOCK_LIST *>(VT_UNLOCKLIST);
  }
  const OVERLORD::STRUCT::TOWER_STATUS *towerStatus() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWERSTATUS);
  }
  const OVERLORD::STRUCT::EVENT_ATTENDANCE *chart() const {
    return GetPointer<const OVERLORD::STRUCT::EVENT_ATTENDANCE *>(VT_CHART);
  }
  const OVERLORD::STRUCT::GUILD_MINE *guild_mine() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_MINE *>(VT_GUILD_MINE);
  }
  const OVERLORD::STRUCT::INVENTORY *inventory() const {
    return GetPointer<const OVERLORD::STRUCT::INVENTORY *>(VT_INVENTORY);
  }
  const OVERLORD::STRUCT::AVATAR *avatar() const {
    return GetPointer<const OVERLORD::STRUCT::AVATAR *>(VT_AVATAR);
  }
  int32_t colosseumGradeId() const {
    return GetField<int32_t>(VT_COLOSSEUMGRADEID, 0);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_SELECTIVETUTORIAL) &&
           verifier.VerifyTable(selectiveTutorial()) &&
           VerifyOffset(verifier, VT_DAILYQUESTSTATUS) &&
           verifier.VerifyTable(dailyQuestStatus()) &&
           VerifyOffset(verifier, VT_ACHIEVESTATUS) &&
           verifier.Verify(achieveStatus()) &&
           verifier.VerifyVectorOfTables(achieveStatus()) &&
           VerifyOffset(verifier, VT_UNLOCKLIST) &&
           verifier.VerifyTable(unlockList()) &&
           VerifyOffset(verifier, VT_TOWERSTATUS) &&
           verifier.VerifyTable(towerStatus()) &&
           VerifyOffset(verifier, VT_CHART) &&
           verifier.VerifyTable(chart()) &&
           VerifyOffset(verifier, VT_GUILD_MINE) &&
           verifier.VerifyTable(guild_mine()) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyTable(inventory()) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.VerifyTable(avatar()) &&
           VerifyField<int32_t>(verifier, VT_COLOSSEUMGRADEID) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  AVATAR_GAME_DATA_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_GAME_DATA_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATA_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_GAME_DATA_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_GAME_DATA_REPLY::VT_TYPE, type, -7656);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_GAME_DATA_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_selectiveTutorial(flatbuffers::Offset<OVERLORD::STRUCT::SELECTIVE_TUTORIAL> selectiveTutorial) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_SELECTIVETUTORIAL, selectiveTutorial);
  }
  void add_dailyQuestStatus(flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> dailyQuestStatus) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_DAILYQUESTSTATUS, dailyQuestStatus);
  }
  void add_achieveStatus(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>> achieveStatus) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_ACHIEVESTATUS, achieveStatus);
  }
  void add_unlockList(flatbuffers::Offset<OVERLORD::STRUCT::UNLOCK_LIST> unlockList) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_UNLOCKLIST, unlockList);
  }
  void add_towerStatus(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> towerStatus) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_TOWERSTATUS, towerStatus);
  }
  void add_chart(flatbuffers::Offset<OVERLORD::STRUCT::EVENT_ATTENDANCE> chart) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_CHART, chart);
  }
  void add_guild_mine(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MINE> guild_mine) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_GUILD_MINE, guild_mine);
  }
  void add_inventory(flatbuffers::Offset<OVERLORD::STRUCT::INVENTORY> inventory) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_INVENTORY, inventory);
  }
  void add_avatar(flatbuffers::Offset<OVERLORD::STRUCT::AVATAR> avatar) {
    fbb_.AddOffset(AVATAR_GAME_DATA_REPLY::VT_AVATAR, avatar);
  }
  void add_colosseumGradeId(int32_t colosseumGradeId) {
    fbb_.AddElement<int32_t>(AVATAR_GAME_DATA_REPLY::VT_COLOSSEUMGRADEID, colosseumGradeId, 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(AVATAR_GAME_DATA_REPLY::VT_KID, kId, 0);
  }
  explicit AVATAR_GAME_DATA_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_GAME_DATA_REPLYBuilder &operator=(const AVATAR_GAME_DATA_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_GAME_DATA_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> CreateAVATAR_GAME_DATA_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7656,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::SELECTIVE_TUTORIAL> selectiveTutorial = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> dailyQuestStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>> achieveStatus = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UNLOCK_LIST> unlockList = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> towerStatus = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EVENT_ATTENDANCE> chart = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MINE> guild_mine = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::INVENTORY> inventory = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::AVATAR> avatar = 0,
    int32_t colosseumGradeId = 0,
    int32_t kId = 0) {
  AVATAR_GAME_DATA_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_colosseumGradeId(colosseumGradeId);
  builder_.add_avatar(avatar);
  builder_.add_inventory(inventory);
  builder_.add_guild_mine(guild_mine);
  builder_.add_chart(chart);
  builder_.add_towerStatus(towerStatus);
  builder_.add_unlockList(unlockList);
  builder_.add_achieveStatus(achieveStatus);
  builder_.add_dailyQuestStatus(dailyQuestStatus);
  builder_.add_selectiveTutorial(selectiveTutorial);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> CreateAVATAR_GAME_DATA_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7656,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::SELECTIVE_TUTORIAL> selectiveTutorial = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> dailyQuestStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *achieveStatus = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::UNLOCK_LIST> unlockList = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> towerStatus = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::EVENT_ATTENDANCE> chart = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MINE> guild_mine = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::INVENTORY> inventory = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::AVATAR> avatar = 0,
    int32_t colosseumGradeId = 0,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateAVATAR_GAME_DATA_REPLY(
      _fbb,
      type,
      error_info,
      is,
      selectiveTutorial,
      dailyQuestStatus,
      achieveStatus ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>(*achieveStatus) : 0,
      unlockList,
      towerStatus,
      chart,
      guild_mine,
      inventory,
      avatar,
      colosseumGradeId,
      kId);
}

flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> CreateAVATAR_GAME_DATA_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATA_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT : public flatbuffers::NativeTable {
  typedef AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::SELECTIVE_TUTORIALT> selectiveTutorial;
  AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT()
      : type(-7657),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SELECTIVETUTORIAL = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7657);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::SELECTIVE_TUTORIAL *selectiveTutorial() const {
    return GetPointer<const OVERLORD::STRUCT::SELECTIVE_TUTORIAL *>(VT_SELECTIVETUTORIAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_SELECTIVETUTORIAL) &&
           verifier.VerifyTable(selectiveTutorial()) &&
           verifier.EndTable();
  }
  AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::VT_TYPE, type, -7657);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_selectiveTutorial(flatbuffers::Offset<OVERLORD::STRUCT::SELECTIVE_TUTORIAL> selectiveTutorial) {
    fbb_.AddOffset(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::VT_SELECTIVETUTORIAL, selectiveTutorial);
  }
  explicit AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYBuilder &operator=(const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYBuilder &);
  flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7657,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::SELECTIVE_TUTORIAL> selectiveTutorial = 0) {
  AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYBuilder builder_(_fbb);
  builder_.add_selectiveTutorial(selectiveTutorial);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_INFO_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef CHANNEL_INFO_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::CHANNEL_INFOT>> channel_list;
  CHANNEL_INFO_LIST_REPLYT()
      : type(-13150),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct CHANNEL_INFO_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_INFO_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CHANNEL_LIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -13150);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>> *channel_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>> *>(VT_CHANNEL_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_CHANNEL_LIST) &&
           verifier.Verify(channel_list()) &&
           verifier.VerifyVectorOfTables(channel_list()) &&
           verifier.EndTable();
  }
  CHANNEL_INFO_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_INFO_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_INFO_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CHANNEL_INFO_LIST_REPLY::VT_TYPE, type, -13150);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(CHANNEL_INFO_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(CHANNEL_INFO_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_channel_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>>> channel_list) {
    fbb_.AddOffset(CHANNEL_INFO_LIST_REPLY::VT_CHANNEL_LIST, channel_list);
  }
  explicit CHANNEL_INFO_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_INFO_LIST_REPLYBuilder &operator=(const CHANNEL_INFO_LIST_REPLYBuilder &);
  flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> CreateCHANNEL_INFO_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -13150,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>>> channel_list = 0) {
  CHANNEL_INFO_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_channel_list(channel_list);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> CreateCHANNEL_INFO_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -13150,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>> *channel_list = nullptr) {
  return OVERLORD::RESPONSE::CreateCHANNEL_INFO_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      channel_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>>(*channel_list) : 0);
}

flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> CreateCHANNEL_INFO_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHANNEL_DETAIL_REPLYT : public flatbuffers::NativeTable {
  typedef CHANNEL_DETAIL_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::CHANNEL_DETAILT> channel_detail;
  CHANNEL_DETAIL_REPLYT()
      : type(-13151),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct CHANNEL_DETAIL_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHANNEL_DETAIL_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CHANNEL_DETAIL = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -13151);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::CHANNEL_DETAIL *channel_detail() const {
    return GetPointer<const OVERLORD::STRUCT::CHANNEL_DETAIL *>(VT_CHANNEL_DETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_CHANNEL_DETAIL) &&
           verifier.VerifyTable(channel_detail()) &&
           verifier.EndTable();
  }
  CHANNEL_DETAIL_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHANNEL_DETAIL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHANNEL_DETAIL_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAIL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHANNEL_DETAIL_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CHANNEL_DETAIL_REPLY::VT_TYPE, type, -13151);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(CHANNEL_DETAIL_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(CHANNEL_DETAIL_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_channel_detail(flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_DETAIL> channel_detail) {
    fbb_.AddOffset(CHANNEL_DETAIL_REPLY::VT_CHANNEL_DETAIL, channel_detail);
  }
  explicit CHANNEL_DETAIL_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHANNEL_DETAIL_REPLYBuilder &operator=(const CHANNEL_DETAIL_REPLYBuilder &);
  flatbuffers::Offset<CHANNEL_DETAIL_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHANNEL_DETAIL_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHANNEL_DETAIL_REPLY> CreateCHANNEL_DETAIL_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -13151,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_DETAIL> channel_detail = 0) {
  CHANNEL_DETAIL_REPLYBuilder builder_(_fbb);
  builder_.add_channel_detail(channel_detail);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<CHANNEL_DETAIL_REPLY> CreateCHANNEL_DETAIL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAIL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BILLING_TRANSACTION_CREATE_REPLYT : public flatbuffers::NativeTable {
  typedef BILLING_TRANSACTION_CREATE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAYT> kakaopay;
  std::string payload;
  std::string transaction_id;
  std::string product;
  std::string purchase_system;
  BILLING_TRANSACTION_CREATE_REPLYT()
      : type(-7800),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct BILLING_TRANSACTION_CREATE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BILLING_TRANSACTION_CREATE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_KAKAOPAY = 10,
    VT_PAYLOAD = 12,
    VT_TRANSACTION_ID = 14,
    VT_PRODUCT = 16,
    VT_PURCHASE_SYSTEM = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7800);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAY *kakaopay() const {
    return GetPointer<const OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAY *>(VT_KAKAOPAY);
  }
  const flatbuffers::String *payload() const {
    return GetPointer<const flatbuffers::String *>(VT_PAYLOAD);
  }
  const flatbuffers::String *transaction_id() const {
    return GetPointer<const flatbuffers::String *>(VT_TRANSACTION_ID);
  }
  const flatbuffers::String *product() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCT);
  }
  const flatbuffers::String *purchase_system() const {
    return GetPointer<const flatbuffers::String *>(VT_PURCHASE_SYSTEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_KAKAOPAY) &&
           verifier.VerifyTable(kakaopay()) &&
           VerifyOffset(verifier, VT_PAYLOAD) &&
           verifier.Verify(payload()) &&
           VerifyOffset(verifier, VT_TRANSACTION_ID) &&
           verifier.Verify(transaction_id()) &&
           VerifyOffset(verifier, VT_PRODUCT) &&
           verifier.Verify(product()) &&
           VerifyOffset(verifier, VT_PURCHASE_SYSTEM) &&
           verifier.Verify(purchase_system()) &&
           verifier.EndTable();
  }
  BILLING_TRANSACTION_CREATE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BILLING_TRANSACTION_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BILLING_TRANSACTION_CREATE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BILLING_TRANSACTION_CREATE_REPLY::VT_TYPE, type, -7800);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(BILLING_TRANSACTION_CREATE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_kakaopay(flatbuffers::Offset<OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAY> kakaopay) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_KAKAOPAY, kakaopay);
  }
  void add_payload(flatbuffers::Offset<flatbuffers::String> payload) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_PAYLOAD, payload);
  }
  void add_transaction_id(flatbuffers::Offset<flatbuffers::String> transaction_id) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_TRANSACTION_ID, transaction_id);
  }
  void add_product(flatbuffers::Offset<flatbuffers::String> product) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_PRODUCT, product);
  }
  void add_purchase_system(flatbuffers::Offset<flatbuffers::String> purchase_system) {
    fbb_.AddOffset(BILLING_TRANSACTION_CREATE_REPLY::VT_PURCHASE_SYSTEM, purchase_system);
  }
  explicit BILLING_TRANSACTION_CREATE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BILLING_TRANSACTION_CREATE_REPLYBuilder &operator=(const BILLING_TRANSACTION_CREATE_REPLYBuilder &);
  flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> CreateBILLING_TRANSACTION_CREATE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7800,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAY> kakaopay = 0,
    flatbuffers::Offset<flatbuffers::String> payload = 0,
    flatbuffers::Offset<flatbuffers::String> transaction_id = 0,
    flatbuffers::Offset<flatbuffers::String> product = 0,
    flatbuffers::Offset<flatbuffers::String> purchase_system = 0) {
  BILLING_TRANSACTION_CREATE_REPLYBuilder builder_(_fbb);
  builder_.add_purchase_system(purchase_system);
  builder_.add_product(product);
  builder_.add_transaction_id(transaction_id);
  builder_.add_payload(payload);
  builder_.add_kakaopay(kakaopay);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> CreateBILLING_TRANSACTION_CREATE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7800,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAY> kakaopay = 0,
    const char *payload = nullptr,
    const char *transaction_id = nullptr,
    const char *product = nullptr,
    const char *purchase_system = nullptr) {
  return OVERLORD::RESPONSE::CreateBILLING_TRANSACTION_CREATE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      kakaopay,
      payload ? _fbb.CreateString(payload) : 0,
      transaction_id ? _fbb.CreateString(transaction_id) : 0,
      product ? _fbb.CreateString(product) : 0,
      purchase_system ? _fbb.CreateString(purchase_system) : 0);
}

flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> CreateBILLING_TRANSACTION_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct BILLING_TRANSACTION_SUCCESS_REPLYT : public flatbuffers::NativeTable {
  typedef BILLING_TRANSACTION_SUCCESS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::string receipt;
  std::string purchase_system;
  BILLING_TRANSACTION_SUCCESS_REPLYT()
      : type(-7801),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct BILLING_TRANSACTION_SUCCESS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BILLING_TRANSACTION_SUCCESS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_RECEIPT = 12,
    VT_PURCHASE_SYSTEM = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -7801);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::String *receipt() const {
    return GetPointer<const flatbuffers::String *>(VT_RECEIPT);
  }
  const flatbuffers::String *purchase_system() const {
    return GetPointer<const flatbuffers::String *>(VT_PURCHASE_SYSTEM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_RECEIPT) &&
           verifier.Verify(receipt()) &&
           VerifyOffset(verifier, VT_PURCHASE_SYSTEM) &&
           verifier.Verify(purchase_system()) &&
           verifier.EndTable();
  }
  BILLING_TRANSACTION_SUCCESS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(BILLING_TRANSACTION_SUCCESS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct BILLING_TRANSACTION_SUCCESS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(BILLING_TRANSACTION_SUCCESS_REPLY::VT_TYPE, type, -7801);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(BILLING_TRANSACTION_SUCCESS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS_REPLY::VT_UPDATE, update);
  }
  void add_receipt(flatbuffers::Offset<flatbuffers::String> receipt) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS_REPLY::VT_RECEIPT, receipt);
  }
  void add_purchase_system(flatbuffers::Offset<flatbuffers::String> purchase_system) {
    fbb_.AddOffset(BILLING_TRANSACTION_SUCCESS_REPLY::VT_PURCHASE_SYSTEM, purchase_system);
  }
  explicit BILLING_TRANSACTION_SUCCESS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BILLING_TRANSACTION_SUCCESS_REPLYBuilder &operator=(const BILLING_TRANSACTION_SUCCESS_REPLYBuilder &);
  flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> CreateBILLING_TRANSACTION_SUCCESS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7801,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::String> receipt = 0,
    flatbuffers::Offset<flatbuffers::String> purchase_system = 0) {
  BILLING_TRANSACTION_SUCCESS_REPLYBuilder builder_(_fbb);
  builder_.add_purchase_system(purchase_system);
  builder_.add_receipt(receipt);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> CreateBILLING_TRANSACTION_SUCCESS_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -7801,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const char *receipt = nullptr,
    const char *purchase_system = nullptr) {
  return OVERLORD::RESPONSE::CreateBILLING_TRANSACTION_SUCCESS_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      receipt ? _fbb.CreateString(receipt) : 0,
      purchase_system ? _fbb.CreateString(purchase_system) : 0);
}

flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> CreateBILLING_TRANSACTION_SUCCESS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST> colosseumStatus;
  COLOSSEUM_STATUS_REPLYT()
      : type(-10450),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COLOSSEUM_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_COLOSSEUMSTATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10450);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::COLOSSEUM_STATUS *colosseumStatus() const {
    return GetPointer<const OVERLORD::STRUCT::COLOSSEUM_STATUS *>(VT_COLOSSEUMSTATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_COLOSSEUMSTATUS) &&
           verifier.VerifyTable(colosseumStatus()) &&
           verifier.EndTable();
  }
  COLOSSEUM_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_STATUS_REPLY::VT_TYPE, type, -10450);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COLOSSEUM_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COLOSSEUM_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_colosseumStatus(flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus) {
    fbb_.AddOffset(COLOSSEUM_STATUS_REPLY::VT_COLOSSEUMSTATUS, colosseumStatus);
  }
  explicit COLOSSEUM_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_STATUS_REPLYBuilder &operator=(const COLOSSEUM_STATUS_REPLYBuilder &);
  flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> CreateCOLOSSEUM_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10450,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus = 0) {
  COLOSSEUM_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_colosseumStatus(colosseumStatus);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> CreateCOLOSSEUM_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_PLAY_RESULT_REPLYT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_PLAY_RESULT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST> colosseumStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  bool isWin;
  COLOSSEUM_PLAY_RESULT_REPLYT()
      : type(-10451),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isWin(false) {
  }
};

struct COLOSSEUM_PLAY_RESULT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_PLAY_RESULT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_COLOSSEUMSTATUS = 12,
    VT_REWARDS = 14,
    VT_ISWIN = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10451);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::COLOSSEUM_STATUS *colosseumStatus() const {
    return GetPointer<const OVERLORD::STRUCT::COLOSSEUM_STATUS *>(VT_COLOSSEUMSTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_COLOSSEUMSTATUS) &&
           verifier.VerifyTable(colosseumStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           verifier.EndTable();
  }
  COLOSSEUM_PLAY_RESULT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_PLAY_RESULT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_PLAY_RESULT_REPLY::VT_TYPE, type, -10451);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COLOSSEUM_PLAY_RESULT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT_REPLY::VT_UPDATE, update);
  }
  void add_colosseumStatus(flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT_REPLY::VT_COLOSSEUMSTATUS, colosseumStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(COLOSSEUM_PLAY_RESULT_REPLY::VT_REWARDS, rewards);
  }
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(COLOSSEUM_PLAY_RESULT_REPLY::VT_ISWIN, static_cast<uint8_t>(isWin), 0);
  }
  explicit COLOSSEUM_PLAY_RESULT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_PLAY_RESULT_REPLYBuilder &operator=(const COLOSSEUM_PLAY_RESULT_REPLYBuilder &);
  flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> CreateCOLOSSEUM_PLAY_RESULT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10451,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    bool isWin = false) {
  COLOSSEUM_PLAY_RESULT_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_colosseumStatus(colosseumStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isWin(isWin);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> CreateCOLOSSEUM_PLAY_RESULT_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10451,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    bool isWin = false) {
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_PLAY_RESULT_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      colosseumStatus,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      isWin);
}

flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> CreateCOLOSSEUM_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_SEASON_DONE_REPLYT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_SEASON_DONE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST> colosseumStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> gradeRewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rankRewards;
  COLOSSEUM_SEASON_DONE_REPLYT()
      : type(-10452),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COLOSSEUM_SEASON_DONE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_SEASON_DONE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_COLOSSEUMSTATUS = 12,
    VT_GRADEREWARDS = 14,
    VT_RANKREWARDS = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10452);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::COLOSSEUM_STATUS *colosseumStatus() const {
    return GetPointer<const OVERLORD::STRUCT::COLOSSEUM_STATUS *>(VT_COLOSSEUMSTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *gradeRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_GRADEREWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rankRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_RANKREWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_COLOSSEUMSTATUS) &&
           verifier.VerifyTable(colosseumStatus()) &&
           VerifyOffset(verifier, VT_GRADEREWARDS) &&
           verifier.Verify(gradeRewards()) &&
           verifier.VerifyVectorOfTables(gradeRewards()) &&
           VerifyOffset(verifier, VT_RANKREWARDS) &&
           verifier.Verify(rankRewards()) &&
           verifier.VerifyVectorOfTables(rankRewards()) &&
           verifier.EndTable();
  }
  COLOSSEUM_SEASON_DONE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_SEASON_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_SEASON_DONE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_SEASON_DONE_REPLY::VT_TYPE, type, -10452);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COLOSSEUM_SEASON_DONE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE_REPLY::VT_UPDATE, update);
  }
  void add_colosseumStatus(flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE_REPLY::VT_COLOSSEUMSTATUS, colosseumStatus);
  }
  void add_gradeRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> gradeRewards) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE_REPLY::VT_GRADEREWARDS, gradeRewards);
  }
  void add_rankRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rankRewards) {
    fbb_.AddOffset(COLOSSEUM_SEASON_DONE_REPLY::VT_RANKREWARDS, rankRewards);
  }
  explicit COLOSSEUM_SEASON_DONE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_SEASON_DONE_REPLYBuilder &operator=(const COLOSSEUM_SEASON_DONE_REPLYBuilder &);
  flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> CreateCOLOSSEUM_SEASON_DONE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10452,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> gradeRewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rankRewards = 0) {
  COLOSSEUM_SEASON_DONE_REPLYBuilder builder_(_fbb);
  builder_.add_rankRewards(rankRewards);
  builder_.add_gradeRewards(gradeRewards);
  builder_.add_colosseumStatus(colosseumStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> CreateCOLOSSEUM_SEASON_DONE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10452,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_STATUS> colosseumStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *gradeRewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rankRewards = nullptr) {
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_SEASON_DONE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      colosseumStatus,
      gradeRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*gradeRewards) : 0,
      rankRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rankRewards) : 0);
}

flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> CreateCOLOSSEUM_SEASON_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COLOSSEUM_RANKING_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef COLOSSEUM_RANKING_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_RANK_USERT>> rankingList;
  COLOSSEUM_RANKING_LIST_REPLYT()
      : type(-10453),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COLOSSEUM_RANKING_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COLOSSEUM_RANKING_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_RANKINGLIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10453);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>> *rankingList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>> *>(VT_RANKINGLIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_RANKINGLIST) &&
           verifier.Verify(rankingList()) &&
           verifier.VerifyVectorOfTables(rankingList()) &&
           verifier.EndTable();
  }
  COLOSSEUM_RANKING_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COLOSSEUM_RANKING_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COLOSSEUM_RANKING_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COLOSSEUM_RANKING_LIST_REPLY::VT_TYPE, type, -10453);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COLOSSEUM_RANKING_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_rankingList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>>> rankingList) {
    fbb_.AddOffset(COLOSSEUM_RANKING_LIST_REPLY::VT_RANKINGLIST, rankingList);
  }
  explicit COLOSSEUM_RANKING_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COLOSSEUM_RANKING_LIST_REPLYBuilder &operator=(const COLOSSEUM_RANKING_LIST_REPLYBuilder &);
  flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> CreateCOLOSSEUM_RANKING_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10453,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>>> rankingList = 0) {
  COLOSSEUM_RANKING_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_rankingList(rankingList);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> CreateCOLOSSEUM_RANKING_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10453,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>> *rankingList = nullptr) {
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_RANKING_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      rankingList ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>>(*rankingList) : 0);
}

flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> CreateCOLOSSEUM_RANKING_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_WRITE_HERO_REPLYT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_WRITE_HERO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET> article;
  COMMUNITY_ARTICLE_WRITE_HERO_REPLYT()
      : type(-11100),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COMMUNITY_ARTICLE_WRITE_HERO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_WRITE_HERO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ARTICLE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11100);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::COMMUNITY_ARTICLE *article() const {
    return GetPointer<const OVERLORD::STRUCT::COMMUNITY_ARTICLE *>(VT_ARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_ARTICLE) &&
           verifier.VerifyTable(article()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_WRITE_HERO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_WRITE_HERO_REPLY::VT_TYPE, type, -11100);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COMMUNITY_ARTICLE_WRITE_HERO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_article(flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE> article) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_WRITE_HERO_REPLY::VT_ARTICLE, article);
  }
  explicit COMMUNITY_ARTICLE_WRITE_HERO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_WRITE_HERO_REPLYBuilder &operator=(const COMMUNITY_ARTICLE_WRITE_HERO_REPLYBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_WRITE_HERO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11100,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE> article = 0) {
  COMMUNITY_ARTICLE_WRITE_HERO_REPLYBuilder builder_(_fbb);
  builder_.add_article(article);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_WRITE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_DELETE_HERO_REPLYT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_DELETE_HERO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool success;
  COMMUNITY_ARTICLE_DELETE_HERO_REPLYT()
      : type(-11101),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        success(true) {
  }
};

struct COMMUNITY_ARTICLE_DELETE_HERO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_DELETE_HERO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SUCCESS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11101);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_DELETE_HERO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_DELETE_HERO_REPLY::VT_TYPE, type, -11101);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_DELETE_HERO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COMMUNITY_ARTICLE_DELETE_HERO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(COMMUNITY_ARTICLE_DELETE_HERO_REPLY::VT_SUCCESS, static_cast<uint8_t>(success), 1);
  }
  explicit COMMUNITY_ARTICLE_DELETE_HERO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_DELETE_HERO_REPLYBuilder &operator=(const COMMUNITY_ARTICLE_DELETE_HERO_REPLYBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_DELETE_HERO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11101,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool success = true) {
  COMMUNITY_ARTICLE_DELETE_HERO_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_success(success);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_DELETE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_LIST_HERO_REPLYT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_LIST_HERO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET>> articleList;
  COMMUNITY_ARTICLE_LIST_HERO_REPLYT()
      : type(-11102),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COMMUNITY_ARTICLE_LIST_HERO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_LIST_HERO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ARTICLELIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11102);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>> *articleList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>> *>(VT_ARTICLELIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_ARTICLELIST) &&
           verifier.Verify(articleList()) &&
           verifier.VerifyVectorOfTables(articleList()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_LIST_HERO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_LIST_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_LIST_HERO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_LIST_HERO_REPLY::VT_TYPE, type, -11102);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COMMUNITY_ARTICLE_LIST_HERO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_articleList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>>> articleList) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_LIST_HERO_REPLY::VT_ARTICLELIST, articleList);
  }
  explicit COMMUNITY_ARTICLE_LIST_HERO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_LIST_HERO_REPLYBuilder &operator=(const COMMUNITY_ARTICLE_LIST_HERO_REPLYBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>>> articleList = 0) {
  COMMUNITY_ARTICLE_LIST_HERO_REPLYBuilder builder_(_fbb);
  builder_.add_articleList(articleList);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>> *articleList = nullptr) {
  return OVERLORD::RESPONSE::CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(
      _fbb,
      type,
      error_info,
      is,
      articleList ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>>(*articleList) : 0);
}

flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct COMMUNITY_ARTICLE_VOTE_HERO_REPLYT : public flatbuffers::NativeTable {
  typedef COMMUNITY_ARTICLE_VOTE_HERO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET> article;
  COMMUNITY_ARTICLE_VOTE_HERO_REPLYT()
      : type(-11103),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct COMMUNITY_ARTICLE_VOTE_HERO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef COMMUNITY_ARTICLE_VOTE_HERO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ARTICLE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11103);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::COMMUNITY_ARTICLE *article() const {
    return GetPointer<const OVERLORD::STRUCT::COMMUNITY_ARTICLE *>(VT_ARTICLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_ARTICLE) &&
           verifier.VerifyTable(article()) &&
           verifier.EndTable();
  }
  COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct COMMUNITY_ARTICLE_VOTE_HERO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(COMMUNITY_ARTICLE_VOTE_HERO_REPLY::VT_TYPE, type, -11103);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(COMMUNITY_ARTICLE_VOTE_HERO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_article(flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE> article) {
    fbb_.AddOffset(COMMUNITY_ARTICLE_VOTE_HERO_REPLY::VT_ARTICLE, article);
  }
  explicit COMMUNITY_ARTICLE_VOTE_HERO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  COMMUNITY_ARTICLE_VOTE_HERO_REPLYBuilder &operator=(const COMMUNITY_ARTICLE_VOTE_HERO_REPLYBuilder &);
  flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_VOTE_HERO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11103,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE> article = 0) {
  COMMUNITY_ARTICLE_VOTE_HERO_REPLYBuilder builder_(_fbb);
  builder_.add_article(article);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_VOTE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CONTENT_RESET_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef CONTENT_RESET_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t contentResetCount;
  CONTENT_RESET_STATUS_REPLYT()
      : type(-15650),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        contentResetCount(0) {
  }
};

struct CONTENT_RESET_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONTENT_RESET_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CONTENTRESETCOUNT = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -15650);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t contentResetCount() const {
    return GetField<int32_t>(VT_CONTENTRESETCOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_CONTENTRESETCOUNT) &&
           verifier.EndTable();
  }
  CONTENT_RESET_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CONTENT_RESET_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CONTENT_RESET_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CONTENT_RESET_STATUS_REPLY::VT_TYPE, type, -15650);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(CONTENT_RESET_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(CONTENT_RESET_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_contentResetCount(int32_t contentResetCount) {
    fbb_.AddElement<int32_t>(CONTENT_RESET_STATUS_REPLY::VT_CONTENTRESETCOUNT, contentResetCount, 0);
  }
  explicit CONTENT_RESET_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CONTENT_RESET_STATUS_REPLYBuilder &operator=(const CONTENT_RESET_STATUS_REPLYBuilder &);
  flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> CreateCONTENT_RESET_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -15650,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t contentResetCount = 0) {
  CONTENT_RESET_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_contentResetCount(contentResetCount);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> CreateCONTENT_RESET_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CONTENT_RESET_REPLYT : public flatbuffers::NativeTable {
  typedef CONTENT_RESET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  CONTENT_RESET_REPLYT()
      : type(-15651),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct CONTENT_RESET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CONTENT_RESET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -15651);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  CONTENT_RESET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CONTENT_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CONTENT_RESET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CONTENT_RESET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CONTENT_RESET_REPLY::VT_TYPE, type, -15651);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(CONTENT_RESET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(CONTENT_RESET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(CONTENT_RESET_REPLY::VT_UPDATE, update);
  }
  explicit CONTENT_RESET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CONTENT_RESET_REPLYBuilder &operator=(const CONTENT_RESET_REPLYBuilder &);
  flatbuffers::Offset<CONTENT_RESET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CONTENT_RESET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<CONTENT_RESET_REPLY> CreateCONTENT_RESET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -15651,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  CONTENT_RESET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<CONTENT_RESET_REPLY> CreateCONTENT_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ATTENDANCE_GET_REPLYT : public flatbuffers::NativeTable {
  typedef ATTENDANCE_GET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::EVENT_ATTENDANCET> chart;
  int32_t kId;
  ATTENDANCE_GET_REPLYT()
      : type(-5750),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct ATTENDANCE_GET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ATTENDANCE_GET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CHART = 10,
    VT_KID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5750);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::EVENT_ATTENDANCE *chart() const {
    return GetPointer<const OVERLORD::STRUCT::EVENT_ATTENDANCE *>(VT_CHART);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_CHART) &&
           verifier.VerifyTable(chart()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  ATTENDANCE_GET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ATTENDANCE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ATTENDANCE_GET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ATTENDANCE_GET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(ATTENDANCE_GET_REPLY::VT_TYPE, type, -5750);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(ATTENDANCE_GET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(ATTENDANCE_GET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_chart(flatbuffers::Offset<OVERLORD::STRUCT::EVENT_ATTENDANCE> chart) {
    fbb_.AddOffset(ATTENDANCE_GET_REPLY::VT_CHART, chart);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ATTENDANCE_GET_REPLY::VT_KID, kId, 0);
  }
  explicit ATTENDANCE_GET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ATTENDANCE_GET_REPLYBuilder &operator=(const ATTENDANCE_GET_REPLYBuilder &);
  flatbuffers::Offset<ATTENDANCE_GET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ATTENDANCE_GET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ATTENDANCE_GET_REPLY> CreateATTENDANCE_GET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5750,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::EVENT_ATTENDANCE> chart = 0,
    int32_t kId = 0) {
  ATTENDANCE_GET_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_chart(chart);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<ATTENDANCE_GET_REPLY> CreateATTENDANCE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CREATE_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CREATE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_CREATE_REPLYT()
      : type(-5050),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_CREATE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CREATE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_GUILD_INFO = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5050);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_CREATE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CREATE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CREATE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CREATE_REPLY::VT_TYPE, type, -5050);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CREATE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CREATE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_CREATE_REPLY::VT_UPDATE, update);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_CREATE_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_CREATE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CREATE_REPLYBuilder &operator=(const GUILD_CREATE_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CREATE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CREATE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CREATE_REPLY> CreateGUILD_CREATE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5050,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_CREATE_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_CREATE_REPLY> CreateGUILD_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CLOSE_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CLOSE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool success;
  GUILD_CLOSE_REPLYT()
      : type(-5051),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        success(true) {
  }
};

struct GUILD_CLOSE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CLOSE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SUCCESS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5051);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
  GUILD_CLOSE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CLOSE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CLOSE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CLOSE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CLOSE_REPLY::VT_TYPE, type, -5051);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CLOSE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CLOSE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(GUILD_CLOSE_REPLY::VT_SUCCESS, static_cast<uint8_t>(success), 1);
  }
  explicit GUILD_CLOSE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CLOSE_REPLYBuilder &operator=(const GUILD_CLOSE_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CLOSE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CLOSE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CLOSE_REPLY> CreateGUILD_CLOSE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5051,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool success = true) {
  GUILD_CLOSE_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_success(success);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_CLOSE_REPLY> CreateGUILD_CLOSE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_GET_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_GET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_MINET> guild_mine;
  GUILD_GET_REPLYT()
      : type(-5052),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_GET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_GET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_MINE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5052);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_MINE *guild_mine() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_MINE *>(VT_GUILD_MINE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_MINE) &&
           verifier.VerifyTable(guild_mine()) &&
           verifier.EndTable();
  }
  GUILD_GET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_GET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_GET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_GET_REPLY::VT_TYPE, type, -5052);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_GET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_GET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_mine(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MINE> guild_mine) {
    fbb_.AddOffset(GUILD_GET_REPLY::VT_GUILD_MINE, guild_mine);
  }
  explicit GUILD_GET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_GET_REPLYBuilder &operator=(const GUILD_GET_REPLYBuilder &);
  flatbuffers::Offset<GUILD_GET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_GET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_GET_REPLY> CreateGUILD_GET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5052,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MINE> guild_mine = 0) {
  GUILD_GET_REPLYBuilder builder_(_fbb);
  builder_.add_guild_mine(guild_mine);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_GET_REPLY> CreateGUILD_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_GET_GUEST_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_GET_GUEST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>> guild_member_list;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_GET_GUEST_REPLYT()
      : type(-5053),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_GET_GUEST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_GET_GUEST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_MEMBER_LIST = 10,
    VT_GUILD_INFO = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5053);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *guild_member_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *>(VT_GUILD_MEMBER_LIST);
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_MEMBER_LIST) &&
           verifier.Verify(guild_member_list()) &&
           verifier.VerifyVectorOfTables(guild_member_list()) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_GET_GUEST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_GET_GUEST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_GET_GUEST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUEST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_GET_GUEST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_GET_GUEST_REPLY::VT_TYPE, type, -5053);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_GET_GUEST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_GET_GUEST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_member_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>> guild_member_list) {
    fbb_.AddOffset(GUILD_GET_GUEST_REPLY::VT_GUILD_MEMBER_LIST, guild_member_list);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_GET_GUEST_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_GET_GUEST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_GET_GUEST_REPLYBuilder &operator=(const GUILD_GET_GUEST_REPLYBuilder &);
  flatbuffers::Offset<GUILD_GET_GUEST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_GET_GUEST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_GET_GUEST_REPLY> CreateGUILD_GET_GUEST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5053,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>> guild_member_list = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_GET_GUEST_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_guild_member_list(guild_member_list);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_GET_GUEST_REPLY> CreateGUILD_GET_GUEST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5053,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *guild_member_list = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  return OVERLORD::RESPONSE::CreateGUILD_GET_GUEST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      guild_member_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>(*guild_member_list) : 0,
      guild_info);
}

flatbuffers::Offset<GUILD_GET_GUEST_REPLY> CreateGUILD_GET_GUEST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUEST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>> guild_member_list;
  GUILD_MEMBER_LIST_REPLYT()
      : type(-5054),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_MEMBER_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_MEMBER_LIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5054);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *guild_member_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *>(VT_GUILD_MEMBER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_MEMBER_LIST) &&
           verifier.Verify(guild_member_list()) &&
           verifier.VerifyVectorOfTables(guild_member_list()) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_LIST_REPLY::VT_TYPE, type, -5054);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_MEMBER_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_MEMBER_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_member_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>> guild_member_list) {
    fbb_.AddOffset(GUILD_MEMBER_LIST_REPLY::VT_GUILD_MEMBER_LIST, guild_member_list);
  }
  explicit GUILD_MEMBER_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_LIST_REPLYBuilder &operator=(const GUILD_MEMBER_LIST_REPLYBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> CreateGUILD_MEMBER_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5054,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>> guild_member_list = 0) {
  GUILD_MEMBER_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_guild_member_list(guild_member_list);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> CreateGUILD_MEMBER_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5054,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> *guild_member_list = nullptr) {
  return OVERLORD::RESPONSE::CreateGUILD_MEMBER_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      guild_member_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>>(*guild_member_list) : 0);
}

flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> CreateGUILD_MEMBER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_AWAITERT>> guild_awaiter_list;
  GUILD_AWAITER_LIST_REPLYT()
      : type(-5055),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_AWAITER_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_AWAITER_LIST = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5055);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>> *guild_awaiter_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>> *>(VT_GUILD_AWAITER_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_AWAITER_LIST) &&
           verifier.Verify(guild_awaiter_list()) &&
           verifier.VerifyVectorOfTables(guild_awaiter_list()) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_LIST_REPLY::VT_TYPE, type, -5055);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_AWAITER_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_AWAITER_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_awaiter_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>>> guild_awaiter_list) {
    fbb_.AddOffset(GUILD_AWAITER_LIST_REPLY::VT_GUILD_AWAITER_LIST, guild_awaiter_list);
  }
  explicit GUILD_AWAITER_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_LIST_REPLYBuilder &operator=(const GUILD_AWAITER_LIST_REPLYBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> CreateGUILD_AWAITER_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5055,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>>> guild_awaiter_list = 0) {
  GUILD_AWAITER_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_guild_awaiter_list(guild_awaiter_list);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> CreateGUILD_AWAITER_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5055,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>> *guild_awaiter_list = nullptr) {
  return OVERLORD::RESPONSE::CreateGUILD_AWAITER_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      guild_awaiter_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>>(*guild_awaiter_list) : 0);
}

flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> CreateGUILD_AWAITER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_ACCEPT_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_ACCEPT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t target_kId;
  GUILD_AWAITER_ACCEPT_REPLYT()
      : type(-5056),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        target_kId(0) {
  }
};

struct GUILD_AWAITER_ACCEPT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_ACCEPT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TARGET_KID = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5056);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_ACCEPT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_ACCEPT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_ACCEPT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_ACCEPT_REPLY::VT_TYPE, type, -5056);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_AWAITER_ACCEPT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_AWAITER_ACCEPT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_ACCEPT_REPLY::VT_TARGET_KID, target_kId, 0);
  }
  explicit GUILD_AWAITER_ACCEPT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_ACCEPT_REPLYBuilder &operator=(const GUILD_AWAITER_ACCEPT_REPLYBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> CreateGUILD_AWAITER_ACCEPT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5056,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t target_kId = 0) {
  GUILD_AWAITER_ACCEPT_REPLYBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> CreateGUILD_AWAITER_ACCEPT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_AWAITER_CANCEL_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_AWAITER_CANCEL_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t guild_id;
  GUILD_AWAITER_CANCEL_REPLYT()
      : type(-5057),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        guild_id(0) {
  }
};

struct GUILD_AWAITER_CANCEL_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_AWAITER_CANCEL_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_ID = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5057);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_AWAITER_CANCEL_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_AWAITER_CANCEL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCEL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_AWAITER_CANCEL_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_CANCEL_REPLY::VT_TYPE, type, -5057);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_AWAITER_CANCEL_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_AWAITER_CANCEL_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_AWAITER_CANCEL_REPLY::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_AWAITER_CANCEL_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_AWAITER_CANCEL_REPLYBuilder &operator=(const GUILD_AWAITER_CANCEL_REPLYBuilder &);
  flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> CreateGUILD_AWAITER_CANCEL_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5057,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t guild_id = 0) {
  GUILD_AWAITER_CANCEL_REPLYBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> CreateGUILD_AWAITER_CANCEL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCEL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_FIND_NAME_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_FIND_NAME_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<int32_t> awaiting_guild_ids;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>> guild_list;
  GUILD_FIND_NAME_REPLYT()
      : type(-5058),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_FIND_NAME_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_FIND_NAME_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AWAITING_GUILD_IDS = 10,
    VT_GUILD_LIST = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5058);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<int32_t> *awaiting_guild_ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AWAITING_GUILD_IDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *guild_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *>(VT_GUILD_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_AWAITING_GUILD_IDS) &&
           verifier.Verify(awaiting_guild_ids()) &&
           VerifyOffset(verifier, VT_GUILD_LIST) &&
           verifier.Verify(guild_list()) &&
           verifier.VerifyVectorOfTables(guild_list()) &&
           verifier.EndTable();
  }
  GUILD_FIND_NAME_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_FIND_NAME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_FIND_NAME_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_FIND_NAME_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_FIND_NAME_REPLY::VT_TYPE, type, -5058);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_FIND_NAME_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_FIND_NAME_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_awaiting_guild_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> awaiting_guild_ids) {
    fbb_.AddOffset(GUILD_FIND_NAME_REPLY::VT_AWAITING_GUILD_IDS, awaiting_guild_ids);
  }
  void add_guild_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>> guild_list) {
    fbb_.AddOffset(GUILD_FIND_NAME_REPLY::VT_GUILD_LIST, guild_list);
  }
  explicit GUILD_FIND_NAME_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_FIND_NAME_REPLYBuilder &operator=(const GUILD_FIND_NAME_REPLYBuilder &);
  flatbuffers::Offset<GUILD_FIND_NAME_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_FIND_NAME_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_FIND_NAME_REPLY> CreateGUILD_FIND_NAME_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5058,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> awaiting_guild_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>> guild_list = 0) {
  GUILD_FIND_NAME_REPLYBuilder builder_(_fbb);
  builder_.add_guild_list(guild_list);
  builder_.add_awaiting_guild_ids(awaiting_guild_ids);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_FIND_NAME_REPLY> CreateGUILD_FIND_NAME_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5058,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<int32_t> *awaiting_guild_ids = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *guild_list = nullptr) {
  return OVERLORD::RESPONSE::CreateGUILD_FIND_NAME_REPLY(
      _fbb,
      type,
      error_info,
      is,
      awaiting_guild_ids ? _fbb.CreateVector<int32_t>(*awaiting_guild_ids) : 0,
      guild_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>(*guild_list) : 0);
}

flatbuffers::Offset<GUILD_FIND_NAME_REPLY> CreateGUILD_FIND_NAME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CHANGE_NAME_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CHANGE_NAME_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_CHANGE_NAME_REPLYT()
      : type(-5059),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_CHANGE_NAME_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CHANGE_NAME_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_GUILD_INFO = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5059);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_CHANGE_NAME_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CHANGE_NAME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CHANGE_NAME_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CHANGE_NAME_REPLY::VT_TYPE, type, -5059);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CHANGE_NAME_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CHANGE_NAME_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_CHANGE_NAME_REPLY::VT_UPDATE, update);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_CHANGE_NAME_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_CHANGE_NAME_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CHANGE_NAME_REPLYBuilder &operator=(const GUILD_CHANGE_NAME_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> CreateGUILD_CHANGE_NAME_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5059,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_CHANGE_NAME_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> CreateGUILD_CHANGE_NAME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_DESC_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_DESC_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_EDIT_DESC_REPLYT()
      : type(-5060),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_EDIT_DESC_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_DESC_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_INFO = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5060);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_EDIT_DESC_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_DESC_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESC_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_DESC_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_DESC_REPLY::VT_TYPE, type, -5060);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_EDIT_DESC_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_EDIT_DESC_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_EDIT_DESC_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_EDIT_DESC_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_DESC_REPLYBuilder &operator=(const GUILD_EDIT_DESC_REPLYBuilder &);
  flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_DESC_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> CreateGUILD_EDIT_DESC_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5060,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_EDIT_DESC_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> CreateGUILD_EDIT_DESC_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESC_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_NOTICE_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_NOTICE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_EDIT_NOTICE_REPLYT()
      : type(-5061),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_EDIT_NOTICE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_NOTICE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_INFO = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5061);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_EDIT_NOTICE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_NOTICE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_NOTICE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_NOTICE_REPLY::VT_TYPE, type, -5061);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_EDIT_NOTICE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_EDIT_NOTICE_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_EDIT_NOTICE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_NOTICE_REPLYBuilder &operator=(const GUILD_EDIT_NOTICE_REPLYBuilder &);
  flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> CreateGUILD_EDIT_NOTICE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5061,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_EDIT_NOTICE_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> CreateGUILD_EDIT_NOTICE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_EDIT_AUTO_GRADE_UP_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_EDIT_AUTO_GRADE_UP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_EDIT_AUTO_GRADE_UP_REPLYT()
      : type(-5062),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_EDIT_AUTO_GRADE_UP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_EDIT_AUTO_GRADE_UP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_INFO = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5062);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_EDIT_AUTO_GRADE_UP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_EDIT_AUTO_GRADE_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_EDIT_AUTO_GRADE_UP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_EDIT_AUTO_GRADE_UP_REPLY::VT_TYPE, type, -5062);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_EDIT_AUTO_GRADE_UP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_EDIT_AUTO_GRADE_UP_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_EDIT_AUTO_GRADE_UP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_EDIT_AUTO_GRADE_UP_REPLYBuilder &operator=(const GUILD_EDIT_AUTO_GRADE_UP_REPLYBuilder &);
  flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> CreateGUILD_EDIT_AUTO_GRADE_UP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5062,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_EDIT_AUTO_GRADE_UP_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> CreateGUILD_EDIT_AUTO_GRADE_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_JOIN_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_JOIN_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool auto_grade_up;
  int32_t guild_id;
  GUILD_JOIN_REPLYT()
      : type(-5063),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        auto_grade_up(false),
        guild_id(0) {
  }
};

struct GUILD_JOIN_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_JOIN_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AUTO_GRADE_UP = 10,
    VT_GUILD_ID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5063);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool auto_grade_up() const {
    return GetField<uint8_t>(VT_AUTO_GRADE_UP, 0) != 0;
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_GRADE_UP) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_JOIN_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_JOIN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_JOIN_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_JOIN_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_JOIN_REPLY::VT_TYPE, type, -5063);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_JOIN_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_JOIN_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_auto_grade_up(bool auto_grade_up) {
    fbb_.AddElement<uint8_t>(GUILD_JOIN_REPLY::VT_AUTO_GRADE_UP, static_cast<uint8_t>(auto_grade_up), 0);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_JOIN_REPLY::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_JOIN_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_JOIN_REPLYBuilder &operator=(const GUILD_JOIN_REPLYBuilder &);
  flatbuffers::Offset<GUILD_JOIN_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_JOIN_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_JOIN_REPLY> CreateGUILD_JOIN_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5063,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool auto_grade_up = false,
    int32_t guild_id = 0) {
  GUILD_JOIN_REPLYBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_auto_grade_up(auto_grade_up);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_JOIN_REPLY> CreateGUILD_JOIN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_JOIN_AUTO_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_JOIN_AUTO_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool auto_grade_up;
  int32_t guild_id;
  GUILD_JOIN_AUTO_REPLYT()
      : type(-5064),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        auto_grade_up(false),
        guild_id(0) {
  }
};

struct GUILD_JOIN_AUTO_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_JOIN_AUTO_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AUTO_GRADE_UP = 10,
    VT_GUILD_ID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5064);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool auto_grade_up() const {
    return GetField<uint8_t>(VT_AUTO_GRADE_UP, 0) != 0;
  }
  int32_t guild_id() const {
    return GetField<int32_t>(VT_GUILD_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_AUTO_GRADE_UP) &&
           VerifyField<int32_t>(verifier, VT_GUILD_ID) &&
           verifier.EndTable();
  }
  GUILD_JOIN_AUTO_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_JOIN_AUTO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_JOIN_AUTO_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_JOIN_AUTO_REPLY::VT_TYPE, type, -5064);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_JOIN_AUTO_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_JOIN_AUTO_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_auto_grade_up(bool auto_grade_up) {
    fbb_.AddElement<uint8_t>(GUILD_JOIN_AUTO_REPLY::VT_AUTO_GRADE_UP, static_cast<uint8_t>(auto_grade_up), 0);
  }
  void add_guild_id(int32_t guild_id) {
    fbb_.AddElement<int32_t>(GUILD_JOIN_AUTO_REPLY::VT_GUILD_ID, guild_id, 0);
  }
  explicit GUILD_JOIN_AUTO_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_JOIN_AUTO_REPLYBuilder &operator=(const GUILD_JOIN_AUTO_REPLYBuilder &);
  flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> CreateGUILD_JOIN_AUTO_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5064,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool auto_grade_up = false,
    int32_t guild_id = 0) {
  GUILD_JOIN_AUTO_REPLYBuilder builder_(_fbb);
  builder_.add_guild_id(guild_id);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_auto_grade_up(auto_grade_up);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> CreateGUILD_JOIN_AUTO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_GRADE_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_GRADE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT> target_member;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT> guild_member;
  GUILD_MEMBER_GRADE_REPLYT()
      : type(-5065),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_MEMBER_GRADE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_GRADE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TARGET_MEMBER = 10,
    VT_GUILD_MEMBER = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5065);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_MEMBER *target_member() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_MEMBER *>(VT_TARGET_MEMBER);
  }
  const OVERLORD::STRUCT::GUILD_MEMBER *guild_member() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_MEMBER *>(VT_GUILD_MEMBER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_TARGET_MEMBER) &&
           verifier.VerifyTable(target_member()) &&
           VerifyOffset(verifier, VT_GUILD_MEMBER) &&
           verifier.VerifyTable(guild_member()) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_GRADE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_GRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_GRADE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_GRADE_REPLY::VT_TYPE, type, -5065);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_MEMBER_GRADE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_target_member(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> target_member) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE_REPLY::VT_TARGET_MEMBER, target_member);
  }
  void add_guild_member(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> guild_member) {
    fbb_.AddOffset(GUILD_MEMBER_GRADE_REPLY::VT_GUILD_MEMBER, guild_member);
  }
  explicit GUILD_MEMBER_GRADE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_GRADE_REPLYBuilder &operator=(const GUILD_MEMBER_GRADE_REPLYBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> CreateGUILD_MEMBER_GRADE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5065,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> target_member = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> guild_member = 0) {
  GUILD_MEMBER_GRADE_REPLYBuilder builder_(_fbb);
  builder_.add_guild_member(guild_member);
  builder_.add_target_member(target_member);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> CreateGUILD_MEMBER_GRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_MEMBER_KICK_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_MEMBER_KICK_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t target_kId;
  GUILD_MEMBER_KICK_REPLYT()
      : type(-5066),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        target_kId(0) {
  }
};

struct GUILD_MEMBER_KICK_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_MEMBER_KICK_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TARGET_KID = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5066);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t target_kId() const {
    return GetField<int32_t>(VT_TARGET_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_TARGET_KID) &&
           verifier.EndTable();
  }
  GUILD_MEMBER_KICK_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_MEMBER_KICK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_MEMBER_KICK_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_KICK_REPLY::VT_TYPE, type, -5066);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_MEMBER_KICK_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_MEMBER_KICK_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_target_kId(int32_t target_kId) {
    fbb_.AddElement<int32_t>(GUILD_MEMBER_KICK_REPLY::VT_TARGET_KID, target_kId, 0);
  }
  explicit GUILD_MEMBER_KICK_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_MEMBER_KICK_REPLYBuilder &operator=(const GUILD_MEMBER_KICK_REPLYBuilder &);
  flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> CreateGUILD_MEMBER_KICK_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5066,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t target_kId = 0) {
  GUILD_MEMBER_KICK_REPLYBuilder builder_(_fbb);
  builder_.add_target_kId(target_kId);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> CreateGUILD_MEMBER_KICK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTION_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTION_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT> guild_member;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  GUILD_CONTRIBUTION_REPLYT()
      : type(-5067),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        contributionType(OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE_NOTHING) {
  }
};

struct GUILD_CONTRIBUTION_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTION_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CONTRIBUTIONTYPE = 10,
    VT_UPDATE = 12,
    VT_GUILD_MEMBER = 14,
    VT_GUILD_INFO = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5067);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType() const {
    return static_cast<OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE>(GetField<int8_t>(VT_CONTRIBUTIONTYPE, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::GUILD_MEMBER *guild_member() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_MEMBER *>(VT_GUILD_MEMBER);
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int8_t>(verifier, VT_CONTRIBUTIONTYPE) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_GUILD_MEMBER) &&
           verifier.VerifyTable(guild_member()) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTION_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTION_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTION_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTION_REPLY::VT_TYPE, type, -5067);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTION_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_contributionType(OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTION_REPLY::VT_CONTRIBUTIONTYPE, static_cast<int8_t>(contributionType), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_REPLY::VT_UPDATE, update);
  }
  void add_guild_member(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> guild_member) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_REPLY::VT_GUILD_MEMBER, guild_member);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_REPLY::VT_GUILD_INFO, guild_info);
  }
  explicit GUILD_CONTRIBUTION_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTION_REPLYBuilder &operator=(const GUILD_CONTRIBUTION_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> CreateGUILD_CONTRIBUTION_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5067,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType = OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE_NOTHING,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER> guild_member = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0) {
  GUILD_CONTRIBUTION_REPLYBuilder builder_(_fbb);
  builder_.add_guild_info(guild_info);
  builder_.add_guild_member(guild_member);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_contributionType(contributionType);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> CreateGUILD_CONTRIBUTION_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTE_RANKING_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTE_RANKING_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<int32_t> awaiting_guild_ids;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>> guild_list;
  GUILD_CONTRIBUTE_RANKING_REPLYT()
      : type(-5068),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_CONTRIBUTE_RANKING_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTE_RANKING_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AWAITING_GUILD_IDS = 10,
    VT_GUILD_LIST = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5068);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<int32_t> *awaiting_guild_ids() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AWAITING_GUILD_IDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *guild_list() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *>(VT_GUILD_LIST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_AWAITING_GUILD_IDS) &&
           verifier.Verify(awaiting_guild_ids()) &&
           VerifyOffset(verifier, VT_GUILD_LIST) &&
           verifier.Verify(guild_list()) &&
           verifier.VerifyVectorOfTables(guild_list()) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTE_RANKING_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTE_RANKING_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKING_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTE_RANKING_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTE_RANKING_REPLY::VT_TYPE, type, -5068);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTE_RANKING_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_awaiting_guild_ids(flatbuffers::Offset<flatbuffers::Vector<int32_t>> awaiting_guild_ids) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING_REPLY::VT_AWAITING_GUILD_IDS, awaiting_guild_ids);
  }
  void add_guild_list(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>> guild_list) {
    fbb_.AddOffset(GUILD_CONTRIBUTE_RANKING_REPLY::VT_GUILD_LIST, guild_list);
  }
  explicit GUILD_CONTRIBUTE_RANKING_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTE_RANKING_REPLYBuilder &operator=(const GUILD_CONTRIBUTE_RANKING_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> CreateGUILD_CONTRIBUTE_RANKING_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5068,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> awaiting_guild_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>> guild_list = 0) {
  GUILD_CONTRIBUTE_RANKING_REPLYBuilder builder_(_fbb);
  builder_.add_guild_list(guild_list);
  builder_.add_awaiting_guild_ids(awaiting_guild_ids);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> CreateGUILD_CONTRIBUTE_RANKING_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5068,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<int32_t> *awaiting_guild_ids = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> *guild_list = nullptr) {
  return OVERLORD::RESPONSE::CreateGUILD_CONTRIBUTE_RANKING_REPLY(
      _fbb,
      type,
      error_info,
      is,
      awaiting_guild_ids ? _fbb.CreateVector<int32_t>(*awaiting_guild_ids) : 0,
      guild_list ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>>(*guild_list) : 0);
}

flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> CreateGUILD_CONTRIBUTE_RANKING_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKING_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_CONTRIBUTION_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_CONTRIBUTION_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType;
  OVERLORD::ENUM::REWARDABLE_STATUS contributable;
  GUILD_CONTRIBUTION_STATUS_REPLYT()
      : type(-5069),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        contributionType(OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE_NOTHING),
        contributable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  }
};

struct GUILD_CONTRIBUTION_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_CONTRIBUTION_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_CONTRIBUTIONTYPE = 10,
    VT_CONTRIBUTABLE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5069);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType() const {
    return static_cast<OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE>(GetField<int8_t>(VT_CONTRIBUTIONTYPE, 0));
  }
  OVERLORD::ENUM::REWARDABLE_STATUS contributable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_CONTRIBUTABLE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int8_t>(verifier, VT_CONTRIBUTIONTYPE) &&
           VerifyField<int8_t>(verifier, VT_CONTRIBUTABLE) &&
           verifier.EndTable();
  }
  GUILD_CONTRIBUTION_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_CONTRIBUTION_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_CONTRIBUTION_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_CONTRIBUTION_STATUS_REPLY::VT_TYPE, type, -5069);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_CONTRIBUTION_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTION_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_contributionType(OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTION_STATUS_REPLY::VT_CONTRIBUTIONTYPE, static_cast<int8_t>(contributionType), 0);
  }
  void add_contributable(OVERLORD::ENUM::REWARDABLE_STATUS contributable) {
    fbb_.AddElement<int8_t>(GUILD_CONTRIBUTION_STATUS_REPLY::VT_CONTRIBUTABLE, static_cast<int8_t>(contributable), 0);
  }
  explicit GUILD_CONTRIBUTION_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_CONTRIBUTION_STATUS_REPLYBuilder &operator=(const GUILD_CONTRIBUTION_STATUS_REPLYBuilder &);
  flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> CreateGUILD_CONTRIBUTION_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5069,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE contributionType = OVERLORD::ENUM::GUILD_CONTRIBUTION_TYPE_NOTHING,
    OVERLORD::ENUM::REWARDABLE_STATUS contributable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  GUILD_CONTRIBUTION_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_contributable(contributable);
  builder_.add_contributionType(contributionType);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> CreateGUILD_CONTRIBUTION_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t previousWeeklyCount;
  int32_t weeklyTimeLeft;
  int32_t weeklyCount;
  OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable;
  OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable;
  GUILD_ATTENDANCE_STATUS_REPLYT()
      : type(-5070),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        previousWeeklyCount(0),
        weeklyTimeLeft(0),
        weeklyCount(0),
        weeklyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY),
        dailyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  }
};

struct GUILD_ATTENDANCE_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_PREVIOUSWEEKLYCOUNT = 10,
    VT_WEEKLYTIMELEFT = 12,
    VT_WEEKLYCOUNT = 14,
    VT_WEEKLYREWARDABLE = 16,
    VT_DAILYREWARDABLE = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5070);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t previousWeeklyCount() const {
    return GetField<int32_t>(VT_PREVIOUSWEEKLYCOUNT, 0);
  }
  int32_t weeklyTimeLeft() const {
    return GetField<int32_t>(VT_WEEKLYTIMELEFT, 0);
  }
  int32_t weeklyCount() const {
    return GetField<int32_t>(VT_WEEKLYCOUNT, 0);
  }
  OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_WEEKLYREWARDABLE, 0));
  }
  OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_DAILYREWARDABLE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_PREVIOUSWEEKLYCOUNT) &&
           VerifyField<int32_t>(verifier, VT_WEEKLYTIMELEFT) &&
           VerifyField<int32_t>(verifier, VT_WEEKLYCOUNT) &&
           VerifyField<int8_t>(verifier, VT_WEEKLYREWARDABLE) &&
           VerifyField<int8_t>(verifier, VT_DAILYREWARDABLE) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_TYPE, type, -5070);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_ATTENDANCE_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_previousWeeklyCount(int32_t previousWeeklyCount) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_PREVIOUSWEEKLYCOUNT, previousWeeklyCount, 0);
  }
  void add_weeklyTimeLeft(int32_t weeklyTimeLeft) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_WEEKLYTIMELEFT, weeklyTimeLeft, 0);
  }
  void add_weeklyCount(int32_t weeklyCount) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_WEEKLYCOUNT, weeklyCount, 0);
  }
  void add_weeklyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_WEEKLYREWARDABLE, static_cast<int8_t>(weeklyRewardable), 0);
  }
  void add_dailyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_STATUS_REPLY::VT_DAILYREWARDABLE, static_cast<int8_t>(dailyRewardable), 0);
  }
  explicit GUILD_ATTENDANCE_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_STATUS_REPLYBuilder &operator=(const GUILD_ATTENDANCE_STATUS_REPLYBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> CreateGUILD_ATTENDANCE_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5070,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t previousWeeklyCount = 0,
    int32_t weeklyTimeLeft = 0,
    int32_t weeklyCount = 0,
    OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY,
    OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  GUILD_ATTENDANCE_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_weeklyCount(weeklyCount);
  builder_.add_weeklyTimeLeft(weeklyTimeLeft);
  builder_.add_previousWeeklyCount(previousWeeklyCount);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_dailyRewardable(dailyRewardable);
  builder_.add_weeklyRewardable(weeklyRewardable);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> CreateGUILD_ATTENDANCE_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_DAILY_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_DAILY_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  int32_t weeklyCount;
  OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable;
  GUILD_ATTENDANCE_DAILY_REWARD_REPLYT()
      : type(-5071),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        weeklyCount(0),
        dailyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  }
};

struct GUILD_ATTENDANCE_DAILY_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_DAILY_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_WEEKLYCOUNT = 14,
    VT_DAILYREWARDABLE = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5071);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  int32_t weeklyCount() const {
    return GetField<int32_t>(VT_WEEKLYCOUNT, 0);
  }
  OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_DAILYREWARDABLE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<int32_t>(verifier, VT_WEEKLYCOUNT) &&
           VerifyField<int8_t>(verifier, VT_DAILYREWARDABLE) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_DAILY_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_TYPE, type, -5071);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_weeklyCount(int32_t weeklyCount) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_WEEKLYCOUNT, weeklyCount, 0);
  }
  void add_dailyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_DAILY_REWARD_REPLY::VT_DAILYREWARDABLE, static_cast<int8_t>(dailyRewardable), 0);
  }
  explicit GUILD_ATTENDANCE_DAILY_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_DAILY_REWARD_REPLYBuilder &operator=(const GUILD_ATTENDANCE_DAILY_REWARD_REPLYBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5071,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    int32_t weeklyCount = 0,
    OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  GUILD_ATTENDANCE_DAILY_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_weeklyCount(weeklyCount);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_dailyRewardable(dailyRewardable);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5071,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    int32_t weeklyCount = 0,
    OVERLORD::ENUM::REWARDABLE_STATUS dailyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  return OVERLORD::RESPONSE::CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      weeklyCount,
      dailyRewardable);
}

flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable;
  GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT()
      : type(-5072),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        weeklyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  }
};

struct GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_WEEKLYREWARDABLE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5072);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable() const {
    return static_cast<OVERLORD::ENUM::REWARDABLE_STATUS>(GetField<int8_t>(VT_WEEKLYREWARDABLE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<int8_t>(verifier, VT_WEEKLYREWARDABLE) &&
           verifier.EndTable();
  }
  GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_TYPE, type, -5072);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_weeklyRewardable(OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable) {
    fbb_.AddElement<int8_t>(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::VT_WEEKLYREWARDABLE, static_cast<int8_t>(weeklyRewardable), 0);
  }
  explicit GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYBuilder &operator=(const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYBuilder &);
  flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5072,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_weeklyRewardable(weeklyRewardable);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5072,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    OVERLORD::ENUM::REWARDABLE_STATUS weeklyRewardable = OVERLORD::ENUM::REWARDABLE_STATUS_NOT_READY) {
  return OVERLORD::RESPONSE::CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      weeklyRewardable);
}

flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>> requests;
  GUILD_RUNE_STATUS_REPLYT()
      : type(-5073),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GUILD_RUNE_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_REQUESTS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5073);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *>(VT_REQUESTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.Verify(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           verifier.EndTable();
  }
  GUILD_RUNE_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_STATUS_REPLY::VT_TYPE, type, -5073);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_RUNE_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_RUNE_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests) {
    fbb_.AddOffset(GUILD_RUNE_STATUS_REPLY::VT_REQUESTS, requests);
  }
  explicit GUILD_RUNE_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_STATUS_REPLYBuilder &operator=(const GUILD_RUNE_STATUS_REPLYBuilder &);
  flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> CreateGUILD_RUNE_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5073,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests = 0) {
  GUILD_RUNE_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_requests(requests);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> CreateGUILD_RUNE_STATUS_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5073,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests = nullptr) {
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_STATUS_REPLY(
      _fbb,
      type,
      error_info,
      is,
      requests ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>(*requests) : 0);
}

flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> CreateGUILD_RUNE_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_REQUEST_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_REQUEST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>> requests;
  int32_t kId;
  GUILD_RUNE_REQUEST_REPLYT()
      : type(-5074),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GUILD_RUNE_REQUEST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_REQUEST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_REQUESTS = 10,
    VT_KID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5074);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *>(VT_REQUESTS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.Verify(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GUILD_RUNE_REQUEST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_REQUEST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUEST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_REQUEST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUEST_REPLY::VT_TYPE, type, -5074);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_RUNE_REQUEST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests) {
    fbb_.AddOffset(GUILD_RUNE_REQUEST_REPLY::VT_REQUESTS, requests);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_REQUEST_REPLY::VT_KID, kId, 0);
  }
  explicit GUILD_RUNE_REQUEST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_REQUEST_REPLYBuilder &operator=(const GUILD_RUNE_REQUEST_REPLYBuilder &);
  flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> CreateGUILD_RUNE_REQUEST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5074,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests = 0,
    int32_t kId = 0) {
  GUILD_RUNE_REQUEST_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_requests(requests);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> CreateGUILD_RUNE_REQUEST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5074,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_REQUEST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      requests ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>(*requests) : 0,
      kId);
}

flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> CreateGUILD_RUNE_REQUEST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUEST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_SUPPORT_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_SUPPORT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>> requests;
  int32_t kId;
  GUILD_RUNE_SUPPORT_REPLYT()
      : type(-5075),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GUILD_RUNE_SUPPORT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_SUPPORT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_REQUESTS = 14,
    VT_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5075);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *>(VT_REQUESTS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.Verify(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GUILD_RUNE_SUPPORT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_SUPPORT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_SUPPORT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_SUPPORT_REPLY::VT_TYPE, type, -5075);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_RUNE_SUPPORT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT_REPLY::VT_REWARDS, rewards);
  }
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests) {
    fbb_.AddOffset(GUILD_RUNE_SUPPORT_REPLY::VT_REQUESTS, requests);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_SUPPORT_REPLY::VT_KID, kId, 0);
  }
  explicit GUILD_RUNE_SUPPORT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_SUPPORT_REPLYBuilder &operator=(const GUILD_RUNE_SUPPORT_REPLYBuilder &);
  flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> CreateGUILD_RUNE_SUPPORT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5075,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests = 0,
    int32_t kId = 0) {
  GUILD_RUNE_SUPPORT_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_requests(requests);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> CreateGUILD_RUNE_SUPPORT_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5075,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_SUPPORT_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      requests ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>(*requests) : 0,
      kId);
}

flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> CreateGUILD_RUNE_SUPPORT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_RUNE_GET_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_RUNE_GET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>> requests;
  int32_t kId;
  GUILD_RUNE_GET_REPLYT()
      : type(-5076),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GUILD_RUNE_GET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_RUNE_GET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_REQUESTS = 14,
    VT_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5076);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *>(VT_REQUESTS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_REQUESTS) &&
           verifier.Verify(requests()) &&
           verifier.VerifyVectorOfTables(requests()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GUILD_RUNE_GET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_RUNE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_RUNE_GET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_RUNE_GET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_GET_REPLY::VT_TYPE, type, -5076);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_RUNE_GET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_RUNE_GET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GUILD_RUNE_GET_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GUILD_RUNE_GET_REPLY::VT_REWARDS, rewards);
  }
  void add_requests(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests) {
    fbb_.AddOffset(GUILD_RUNE_GET_REPLY::VT_REQUESTS, requests);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_RUNE_GET_REPLY::VT_KID, kId, 0);
  }
  explicit GUILD_RUNE_GET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_RUNE_GET_REPLYBuilder &operator=(const GUILD_RUNE_GET_REPLYBuilder &);
  flatbuffers::Offset<GUILD_RUNE_GET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_RUNE_GET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_RUNE_GET_REPLY> CreateGUILD_RUNE_GET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5076,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>> requests = 0,
    int32_t kId = 0) {
  GUILD_RUNE_GET_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_requests(requests);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_RUNE_GET_REPLY> CreateGUILD_RUNE_GET_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5076,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> *requests = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_GET_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      requests ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>>(*requests) : 0,
      kId);
}

flatbuffers::Offset<GUILD_RUNE_GET_REPLY> CreateGUILD_RUNE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_HISTORY_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_HISTORY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::GUILD_HISTORYT>> historyList;
  int32_t kId;
  GUILD_HISTORY_REPLYT()
      : type(-5077),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GUILD_HISTORY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_HISTORY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_HISTORYLIST = 10,
    VT_KID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5077);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>> *historyList() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>> *>(VT_HISTORYLIST);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_HISTORYLIST) &&
           verifier.Verify(historyList()) &&
           verifier.VerifyVectorOfTables(historyList()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GUILD_HISTORY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_HISTORY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_HISTORY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_HISTORY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_HISTORY_REPLY::VT_TYPE, type, -5077);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_HISTORY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_HISTORY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_historyList(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>>> historyList) {
    fbb_.AddOffset(GUILD_HISTORY_REPLY::VT_HISTORYLIST, historyList);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_HISTORY_REPLY::VT_KID, kId, 0);
  }
  explicit GUILD_HISTORY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_HISTORY_REPLYBuilder &operator=(const GUILD_HISTORY_REPLYBuilder &);
  flatbuffers::Offset<GUILD_HISTORY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_HISTORY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_HISTORY_REPLY> CreateGUILD_HISTORY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5077,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>>> historyList = 0,
    int32_t kId = 0) {
  GUILD_HISTORY_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_historyList(historyList);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GUILD_HISTORY_REPLY> CreateGUILD_HISTORY_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5077,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>> *historyList = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGUILD_HISTORY_REPLY(
      _fbb,
      type,
      error_info,
      is,
      historyList ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>>(*historyList) : 0,
      kId);
}

flatbuffers::Offset<GUILD_HISTORY_REPLY> CreateGUILD_HISTORY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GUILD_LEVEL_UP_REPLYT : public flatbuffers::NativeTable {
  typedef GUILD_LEVEL_UP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT> guild_info;
  int32_t kId;
  GUILD_LEVEL_UP_REPLYT()
      : type(-5078),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GUILD_LEVEL_UP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GUILD_LEVEL_UP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_GUILD_INFO = 10,
    VT_KID = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -5078);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::GUILD_INFO *guild_info() const {
    return GetPointer<const OVERLORD::STRUCT::GUILD_INFO *>(VT_GUILD_INFO);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_GUILD_INFO) &&
           verifier.VerifyTable(guild_info()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GUILD_LEVEL_UP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GUILD_LEVEL_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GUILD_LEVEL_UP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GUILD_LEVEL_UP_REPLY::VT_TYPE, type, -5078);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GUILD_LEVEL_UP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GUILD_LEVEL_UP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_guild_info(flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info) {
    fbb_.AddOffset(GUILD_LEVEL_UP_REPLY::VT_GUILD_INFO, guild_info);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GUILD_LEVEL_UP_REPLY::VT_KID, kId, 0);
  }
  explicit GUILD_LEVEL_UP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GUILD_LEVEL_UP_REPLYBuilder &operator=(const GUILD_LEVEL_UP_REPLYBuilder &);
  flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GUILD_LEVEL_UP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> CreateGUILD_LEVEL_UP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -5078,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO> guild_info = 0,
    int32_t kId = 0) {
  GUILD_LEVEL_UP_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_guild_info(guild_info);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> CreateGUILD_LEVEL_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_UPGRADE_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_UPGRADE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_UPGRADE_REPLYT()
      : type(-11200),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_UPGRADE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_UPGRADE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11200);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_UPGRADE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_UPGRADE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_UPGRADE_REPLY::VT_TYPE, type, -11200);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_UPGRADE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_UPGRADE_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_UPGRADE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_UPGRADE_REPLYBuilder &operator=(const INVENTORY_HERO_UPGRADE_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> CreateINVENTORY_HERO_UPGRADE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11200,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_UPGRADE_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> CreateINVENTORY_HERO_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_LEVELUP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_LEVELUP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_LEVELUP_REPLYT()
      : type(-11201),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_LEVELUP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_LEVELUP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11201);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_LEVELUP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_LEVELUP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_LEVELUP_REPLY::VT_TYPE, type, -11201);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_LEVELUP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_LEVELUP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_LEVELUP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_LEVELUP_REPLYBuilder &operator=(const INVENTORY_HERO_LEVELUP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> CreateINVENTORY_HERO_LEVELUP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11201,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_LEVELUP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> CreateINVENTORY_HERO_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_GRIND_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_GRIND_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_GRIND_REPLYT()
      : type(-11202),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_GRIND_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_GRIND_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_REWARDS = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11202);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_GRIND_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_GRIND_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRIND_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_GRIND_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_GRIND_REPLY::VT_TYPE, type, -11202);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_GRIND_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND_REPLY::VT_REWARDS, rewards);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_GRIND_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_GRIND_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_GRIND_REPLYBuilder &operator=(const INVENTORY_HERO_GRIND_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> CreateINVENTORY_HERO_GRIND_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11202,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_GRIND_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_rewards(rewards);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> CreateINVENTORY_HERO_GRIND_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11202,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_GRIND_REPLY(
      _fbb,
      type,
      error_info,
      is,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      update);
}

flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> CreateINVENTORY_HERO_GRIND_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRIND_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_EQUIP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_EQUIP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_EQUIP_REPLYT()
      : type(-11203),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_EQUIP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_EQUIP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11203);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_EQUIP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_EQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_EQUIP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_EQUIP_REPLY::VT_TYPE, type, -11203);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_EQUIP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_EQUIP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_EQUIP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_EQUIP_REPLYBuilder &operator=(const INVENTORY_HERO_EQUIP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> CreateINVENTORY_HERO_EQUIP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11203,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_EQUIP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> CreateINVENTORY_HERO_EQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_UNEQUIP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_UNEQUIP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_UNEQUIP_REPLYT()
      : type(-11204),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_UNEQUIP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_UNEQUIP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11204);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_UNEQUIP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_UNEQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_UNEQUIP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_UNEQUIP_REPLY::VT_TYPE, type, -11204);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_UNEQUIP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_UNEQUIP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_UNEQUIP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_UNEQUIP_REPLYBuilder &operator=(const INVENTORY_HERO_UNEQUIP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> CreateINVENTORY_HERO_UNEQUIP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11204,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_UNEQUIP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> CreateINVENTORY_HERO_UNEQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_GRIND_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_GRIND_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_ITEM_GRIND_REPLYT()
      : type(-11205),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_ITEM_GRIND_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_GRIND_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_REWARDS = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11205);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_GRIND_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_GRIND_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRIND_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_GRIND_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_GRIND_REPLY::VT_TYPE, type, -11205);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_GRIND_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND_REPLY::VT_REWARDS, rewards);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_GRIND_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_ITEM_GRIND_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_GRIND_REPLYBuilder &operator=(const INVENTORY_ITEM_GRIND_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> CreateINVENTORY_ITEM_GRIND_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11205,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_ITEM_GRIND_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_rewards(rewards);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> CreateINVENTORY_ITEM_GRIND_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11205,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_GRIND_REPLY(
      _fbb,
      type,
      error_info,
      is,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      update);
}

flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> CreateINVENTORY_ITEM_GRIND_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRIND_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_EQUIP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_EQUIP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_RUNE_EQUIP_REPLYT()
      : type(-11206),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_RUNE_EQUIP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_EQUIP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11206);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_EQUIP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_EQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_EQUIP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_EQUIP_REPLY::VT_TYPE, type, -11206);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_RUNE_EQUIP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_RUNE_EQUIP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_RUNE_EQUIP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_EQUIP_REPLYBuilder &operator=(const INVENTORY_RUNE_EQUIP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> CreateINVENTORY_RUNE_EQUIP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11206,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_RUNE_EQUIP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> CreateINVENTORY_RUNE_EQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_UNEQUIP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_UNEQUIP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_RUNE_UNEQUIP_REPLYT()
      : type(-11207),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_RUNE_UNEQUIP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_UNEQUIP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11207);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_UNEQUIP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_UNEQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_UNEQUIP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_UNEQUIP_REPLY::VT_TYPE, type, -11207);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_RUNE_UNEQUIP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_RUNE_UNEQUIP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_RUNE_UNEQUIP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_UNEQUIP_REPLYBuilder &operator=(const INVENTORY_RUNE_UNEQUIP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> CreateINVENTORY_RUNE_UNEQUIP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11207,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_RUNE_UNEQUIP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> CreateINVENTORY_RUNE_UNEQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_RUNE_MAKE_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_RUNE_MAKE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_RUNE_MAKE_REPLYT()
      : type(-11208),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_RUNE_MAKE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_RUNE_MAKE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11208);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_RUNE_MAKE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_RUNE_MAKE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_RUNE_MAKE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_RUNE_MAKE_REPLY::VT_TYPE, type, -11208);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_RUNE_MAKE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_RUNE_MAKE_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_RUNE_MAKE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_RUNE_MAKE_REPLYBuilder &operator=(const INVENTORY_RUNE_MAKE_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> CreateINVENTORY_RUNE_MAKE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11208,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_RUNE_MAKE_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> CreateINVENTORY_RUNE_MAKE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_LEVELUP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_LEVELUP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool isLucky;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_ITEM_LEVELUP_REPLYT()
      : type(-11209),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isLucky(false) {
  }
};

struct INVENTORY_ITEM_LEVELUP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_LEVELUP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ISLUCKY = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11209);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool isLucky() const {
    return GetField<uint8_t>(VT_ISLUCKY, 0) != 0;
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_ISLUCKY) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_LEVELUP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_LEVELUP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_LEVELUP_REPLY::VT_TYPE, type, -11209);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_LEVELUP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_isLucky(bool isLucky) {
    fbb_.AddElement<uint8_t>(INVENTORY_ITEM_LEVELUP_REPLY::VT_ISLUCKY, static_cast<uint8_t>(isLucky), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_LEVELUP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_ITEM_LEVELUP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_LEVELUP_REPLYBuilder &operator=(const INVENTORY_ITEM_LEVELUP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> CreateINVENTORY_ITEM_LEVELUP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11209,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool isLucky = false,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_ITEM_LEVELUP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isLucky(isLucky);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> CreateINVENTORY_ITEM_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_ENCHANT_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_ENCHANT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  int32_t affectedEnchant;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_ITEM_ENCHANT_REPLYT()
      : type(-11210),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        affectedEnchant(0) {
  }
};

struct INVENTORY_ITEM_ENCHANT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_ENCHANT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_AFFECTEDENCHANT = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11210);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  int32_t affectedEnchant() const {
    return GetField<int32_t>(VT_AFFECTEDENCHANT, 0);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<int32_t>(verifier, VT_AFFECTEDENCHANT) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_ENCHANT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_ENCHANT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_ENCHANT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_ENCHANT_REPLY::VT_TYPE, type, -11210);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_ENCHANT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_affectedEnchant(int32_t affectedEnchant) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_ENCHANT_REPLY::VT_AFFECTEDENCHANT, affectedEnchant, 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_ENCHANT_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_ITEM_ENCHANT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_ENCHANT_REPLYBuilder &operator=(const INVENTORY_ITEM_ENCHANT_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> CreateINVENTORY_ITEM_ENCHANT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11210,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    int32_t affectedEnchant = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_ITEM_ENCHANT_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_affectedEnchant(affectedEnchant);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> CreateINVENTORY_ITEM_ENCHANT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_HERO_LOCK_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_HERO_LOCK_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_ITEM_HERO_LOCK_REPLYT()
      : type(-11211),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_ITEM_HERO_LOCK_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_HERO_LOCK_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11211);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_HERO_LOCK_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_HERO_LOCK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_HERO_LOCK_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_HERO_LOCK_REPLY::VT_TYPE, type, -11211);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_HERO_LOCK_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_HERO_LOCK_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_ITEM_HERO_LOCK_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_HERO_LOCK_REPLYBuilder &operator=(const INVENTORY_ITEM_HERO_LOCK_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> CreateINVENTORY_ITEM_HERO_LOCK_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11211,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_ITEM_HERO_LOCK_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> CreateINVENTORY_ITEM_HERO_LOCK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_SKILL_LEVELUP_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_SKILL_LEVELUP_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_SKILL_LEVELUP_REPLYT()
      : type(-11212),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_SKILL_LEVELUP_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_SKILL_LEVELUP_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11212);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_SKILL_LEVELUP_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_SKILL_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_SKILL_LEVELUP_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_SKILL_LEVELUP_REPLY::VT_TYPE, type, -11212);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_SKILL_LEVELUP_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_SKILL_LEVELUP_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_SKILL_LEVELUP_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_SKILL_LEVELUP_REPLYBuilder &operator=(const INVENTORY_HERO_SKILL_LEVELUP_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> CreateINVENTORY_HERO_SKILL_LEVELUP_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11212,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_SKILL_LEVELUP_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> CreateINVENTORY_HERO_SKILL_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_ENCHANT_CONSUME_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_ENCHANT_CONSUME_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<bool> spiritResult;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_ENCHANT_CONSUME_REPLYT()
      : type(-11213),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_ENCHANT_CONSUME_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_ENCHANT_CONSUME_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SPIRITRESULT = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11213);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<uint8_t> *spiritResult() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_SPIRITRESULT);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_SPIRITRESULT) &&
           verifier.Verify(spiritResult()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_ENCHANT_CONSUME_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_ENCHANT_CONSUME_REPLY::VT_TYPE, type, -11213);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_ENCHANT_CONSUME_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_spiritResult(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> spiritResult) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME_REPLY::VT_SPIRITRESULT, spiritResult);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_CONSUME_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_ENCHANT_CONSUME_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_ENCHANT_CONSUME_REPLYBuilder &operator=(const INVENTORY_HERO_ENCHANT_CONSUME_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11213,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> spiritResult = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_ENCHANT_CONSUME_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_spiritResult(spiritResult);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11213,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<uint8_t> *spiritResult = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(
      _fbb,
      type,
      error_info,
      is,
      spiritResult ? _fbb.CreateVector<uint8_t>(*spiritResult) : 0,
      update);
}

flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_HERO_ENCHANT_STAT_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_HERO_ENCHANT_STAT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_HERO_ENCHANT_STAT_REPLYT()
      : type(-11214),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_HERO_ENCHANT_STAT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_HERO_ENCHANT_STAT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11214);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_HERO_ENCHANT_STAT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_HERO_ENCHANT_STAT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STAT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_HERO_ENCHANT_STAT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_HERO_ENCHANT_STAT_REPLY::VT_TYPE, type, -11214);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_HERO_ENCHANT_STAT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_HERO_ENCHANT_STAT_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_HERO_ENCHANT_STAT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_HERO_ENCHANT_STAT_REPLYBuilder &operator=(const INVENTORY_HERO_ENCHANT_STAT_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> CreateINVENTORY_HERO_ENCHANT_STAT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11214,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_HERO_ENCHANT_STAT_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> CreateINVENTORY_HERO_ENCHANT_STAT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STAT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_SELL_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_SELL_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  INVENTORY_SELL_REPLYT()
      : type(-11215),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_SELL_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_SELL_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11215);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  INVENTORY_SELL_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_SELL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_SELL_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_SELL_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_SELL_REPLY::VT_TYPE, type, -11215);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_SELL_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_SELL_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_SELL_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(INVENTORY_SELL_REPLY::VT_REWARDS, rewards);
  }
  explicit INVENTORY_SELL_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_SELL_REPLYBuilder &operator=(const INVENTORY_SELL_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_SELL_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_SELL_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_SELL_REPLY> CreateINVENTORY_SELL_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11215,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  INVENTORY_SELL_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_SELL_REPLY> CreateINVENTORY_SELL_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11215,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateINVENTORY_SELL_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<INVENTORY_SELL_REPLY> CreateINVENTORY_SELL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_UPGRADE_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_UPGRADE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  bool isSuccess;
  INVENTORY_ITEM_UPGRADE_REPLYT()
      : type(-11216),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isSuccess(false) {
  }
};

struct INVENTORY_ITEM_UPGRADE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_UPGRADE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_ISSUCCESS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11216);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool isSuccess() const {
    return GetField<uint8_t>(VT_ISSUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<uint8_t>(verifier, VT_ISSUCCESS) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_UPGRADE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_UPGRADE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_UPGRADE_REPLY::VT_TYPE, type, -11216);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_UPGRADE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(INVENTORY_ITEM_UPGRADE_REPLY::VT_REWARDS, rewards);
  }
  void add_isSuccess(bool isSuccess) {
    fbb_.AddElement<uint8_t>(INVENTORY_ITEM_UPGRADE_REPLY::VT_ISSUCCESS, static_cast<uint8_t>(isSuccess), 0);
  }
  explicit INVENTORY_ITEM_UPGRADE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_UPGRADE_REPLYBuilder &operator=(const INVENTORY_ITEM_UPGRADE_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> CreateINVENTORY_ITEM_UPGRADE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11216,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    bool isSuccess = false) {
  INVENTORY_ITEM_UPGRADE_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isSuccess(isSuccess);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> CreateINVENTORY_ITEM_UPGRADE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11216,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    bool isSuccess = false) {
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_UPGRADE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      isSuccess);
}

flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> CreateINVENTORY_ITEM_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_ITEM_OPTION_RESET_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_ITEM_OPTION_RESET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_ITEM_OPTION_RESET_REPLYT()
      : type(-11217),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_ITEM_OPTION_RESET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_ITEM_OPTION_RESET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11217);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_ITEM_OPTION_RESET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_ITEM_OPTION_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_ITEM_OPTION_RESET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_ITEM_OPTION_RESET_REPLY::VT_TYPE, type, -11217);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_ITEM_OPTION_RESET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_ITEM_OPTION_RESET_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_ITEM_OPTION_RESET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_ITEM_OPTION_RESET_REPLYBuilder &operator=(const INVENTORY_ITEM_OPTION_RESET_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> CreateINVENTORY_ITEM_OPTION_RESET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11217,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_ITEM_OPTION_RESET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> CreateINVENTORY_ITEM_OPTION_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_TIMETREASURE_GET_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_TIMETREASURE_GET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  INVENTORY_TIMETREASURE_GET_REPLYT()
      : type(-11218),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_TIMETREASURE_GET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_TIMETREASURE_GET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11218);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  INVENTORY_TIMETREASURE_GET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_TIMETREASURE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_TIMETREASURE_GET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_TIMETREASURE_GET_REPLY::VT_TYPE, type, -11218);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_TIMETREASURE_GET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(INVENTORY_TIMETREASURE_GET_REPLY::VT_REWARDS, rewards);
  }
  explicit INVENTORY_TIMETREASURE_GET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_TIMETREASURE_GET_REPLYBuilder &operator=(const INVENTORY_TIMETREASURE_GET_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> CreateINVENTORY_TIMETREASURE_GET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11218,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  INVENTORY_TIMETREASURE_GET_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> CreateINVENTORY_TIMETREASURE_GET_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11218,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateINVENTORY_TIMETREASURE_GET_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> CreateINVENTORY_TIMETREASURE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct INVENTORY_UPGRADE_REPLYT : public flatbuffers::NativeTable {
  typedef INVENTORY_UPGRADE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  INVENTORY_UPGRADE_REPLYT()
      : type(-11219),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct INVENTORY_UPGRADE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef INVENTORY_UPGRADE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -11219);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  INVENTORY_UPGRADE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(INVENTORY_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct INVENTORY_UPGRADE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(INVENTORY_UPGRADE_REPLY::VT_TYPE, type, -11219);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(INVENTORY_UPGRADE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(INVENTORY_UPGRADE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(INVENTORY_UPGRADE_REPLY::VT_UPDATE, update);
  }
  explicit INVENTORY_UPGRADE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  INVENTORY_UPGRADE_REPLYBuilder &operator=(const INVENTORY_UPGRADE_REPLYBuilder &);
  flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<INVENTORY_UPGRADE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> CreateINVENTORY_UPGRADE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -11219,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  INVENTORY_UPGRADE_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> CreateINVENTORY_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIFT_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef GIFT_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::MAILT>> mails;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::MAILT>> news;
  int32_t mailsize;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  int32_t kId;
  GIFT_LIST_REPLYT()
      : type(-8600),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        mailsize(0),
        kId(0) {
  }
};

struct GIFT_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIFT_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MAILS = 10,
    VT_NEWS = 12,
    VT_MAILSIZE = 14,
    VT_UPDATE = 16,
    VT_KID = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8600);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *mails() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *>(VT_MAILS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *news() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *>(VT_NEWS);
  }
  int32_t mailsize() const {
    return GetField<int32_t>(VT_MAILSIZE, 0);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MAILS) &&
           verifier.Verify(mails()) &&
           verifier.VerifyVectorOfTables(mails()) &&
           VerifyOffset(verifier, VT_NEWS) &&
           verifier.Verify(news()) &&
           verifier.VerifyVectorOfTables(news()) &&
           VerifyField<int32_t>(verifier, VT_MAILSIZE) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GIFT_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIFT_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIFT_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIFT_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIFT_LIST_REPLY::VT_TYPE, type, -8600);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GIFT_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GIFT_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_mails(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> mails) {
    fbb_.AddOffset(GIFT_LIST_REPLY::VT_MAILS, mails);
  }
  void add_news(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> news) {
    fbb_.AddOffset(GIFT_LIST_REPLY::VT_NEWS, news);
  }
  void add_mailsize(int32_t mailsize) {
    fbb_.AddElement<int32_t>(GIFT_LIST_REPLY::VT_MAILSIZE, mailsize, 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GIFT_LIST_REPLY::VT_UPDATE, update);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GIFT_LIST_REPLY::VT_KID, kId, 0);
  }
  explicit GIFT_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIFT_LIST_REPLYBuilder &operator=(const GIFT_LIST_REPLYBuilder &);
  flatbuffers::Offset<GIFT_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIFT_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIFT_LIST_REPLY> CreateGIFT_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8600,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> mails = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> news = 0,
    int32_t mailsize = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    int32_t kId = 0) {
  GIFT_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_update(update);
  builder_.add_mailsize(mailsize);
  builder_.add_news(news);
  builder_.add_mails(mails);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIFT_LIST_REPLY> CreateGIFT_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8600,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *mails = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *news = nullptr,
    int32_t mailsize = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGIFT_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      mails ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>(*mails) : 0,
      news ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>(*news) : 0,
      mailsize,
      update,
      kId);
}

flatbuffers::Offset<GIFT_LIST_REPLY> CreateGIFT_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIFT_OPEN_REPLYT : public flatbuffers::NativeTable {
  typedef GIFT_OPEN_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::vector<std::string> mailUDs;
  int32_t kId;
  GIFT_OPEN_REPLYT()
      : type(-8601),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GIFT_OPEN_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIFT_OPEN_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_MAILUDS = 14,
    VT_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8601);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mailUDs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_MAILUDS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_MAILUDS) &&
           verifier.Verify(mailUDs()) &&
           verifier.VerifyVectorOfStrings(mailUDs()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GIFT_OPEN_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIFT_OPEN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIFT_OPEN_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPEN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIFT_OPEN_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIFT_OPEN_REPLY::VT_TYPE, type, -8601);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GIFT_OPEN_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GIFT_OPEN_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GIFT_OPEN_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GIFT_OPEN_REPLY::VT_REWARDS, rewards);
  }
  void add_mailUDs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUDs) {
    fbb_.AddOffset(GIFT_OPEN_REPLY::VT_MAILUDS, mailUDs);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GIFT_OPEN_REPLY::VT_KID, kId, 0);
  }
  explicit GIFT_OPEN_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIFT_OPEN_REPLYBuilder &operator=(const GIFT_OPEN_REPLYBuilder &);
  flatbuffers::Offset<GIFT_OPEN_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIFT_OPEN_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIFT_OPEN_REPLY> CreateGIFT_OPEN_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8601,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> mailUDs = 0,
    int32_t kId = 0) {
  GIFT_OPEN_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_mailUDs(mailUDs);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIFT_OPEN_REPLY> CreateGIFT_OPEN_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8601,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *mailUDs = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGIFT_OPEN_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      mailUDs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*mailUDs) : 0,
      kId);
}

flatbuffers::Offset<GIFT_OPEN_REPLY> CreateGIFT_OPEN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPEN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SPECIAL_GIFT_LIST_REPLYT : public flatbuffers::NativeTable {
  typedef SPECIAL_GIFT_LIST_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::MAILT>> mails;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::MAILT>> news;
  int32_t mailsize;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  int32_t kId;
  SPECIAL_GIFT_LIST_REPLYT()
      : type(-8602),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        mailsize(0),
        kId(0) {
  }
};

struct SPECIAL_GIFT_LIST_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPECIAL_GIFT_LIST_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MAILS = 10,
    VT_NEWS = 12,
    VT_MAILSIZE = 14,
    VT_UPDATE = 16,
    VT_KID = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8602);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *mails() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *>(VT_MAILS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *news() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *>(VT_NEWS);
  }
  int32_t mailsize() const {
    return GetField<int32_t>(VT_MAILSIZE, 0);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MAILS) &&
           verifier.Verify(mails()) &&
           verifier.VerifyVectorOfTables(mails()) &&
           VerifyOffset(verifier, VT_NEWS) &&
           verifier.Verify(news()) &&
           verifier.VerifyVectorOfTables(news()) &&
           VerifyField<int32_t>(verifier, VT_MAILSIZE) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  SPECIAL_GIFT_LIST_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SPECIAL_GIFT_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SPECIAL_GIFT_LIST_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST_REPLY::VT_TYPE, type, -8602);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SPECIAL_GIFT_LIST_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_mails(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> mails) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST_REPLY::VT_MAILS, mails);
  }
  void add_news(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> news) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST_REPLY::VT_NEWS, news);
  }
  void add_mailsize(int32_t mailsize) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST_REPLY::VT_MAILSIZE, mailsize, 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SPECIAL_GIFT_LIST_REPLY::VT_UPDATE, update);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_LIST_REPLY::VT_KID, kId, 0);
  }
  explicit SPECIAL_GIFT_LIST_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SPECIAL_GIFT_LIST_REPLYBuilder &operator=(const SPECIAL_GIFT_LIST_REPLYBuilder &);
  flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> CreateSPECIAL_GIFT_LIST_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8602,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> mails = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>> news = 0,
    int32_t mailsize = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    int32_t kId = 0) {
  SPECIAL_GIFT_LIST_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_update(update);
  builder_.add_mailsize(mailsize);
  builder_.add_news(news);
  builder_.add_mails(mails);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> CreateSPECIAL_GIFT_LIST_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8602,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *mails = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> *news = nullptr,
    int32_t mailsize = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateSPECIAL_GIFT_LIST_REPLY(
      _fbb,
      type,
      error_info,
      is,
      mails ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>(*mails) : 0,
      news ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>>(*news) : 0,
      mailsize,
      update,
      kId);
}

flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> CreateSPECIAL_GIFT_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SPECIAL_GIFT_OPEN_REPLYT : public flatbuffers::NativeTable {
  typedef SPECIAL_GIFT_OPEN_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::string mailUD;
  int32_t kId;
  SPECIAL_GIFT_OPEN_REPLYT()
      : type(-8603),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct SPECIAL_GIFT_OPEN_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SPECIAL_GIFT_OPEN_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_MAILUD = 14,
    VT_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8603);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const flatbuffers::String *mailUD() const {
    return GetPointer<const flatbuffers::String *>(VT_MAILUD);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_MAILUD) &&
           verifier.Verify(mailUD()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  SPECIAL_GIFT_OPEN_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SPECIAL_GIFT_OPEN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPEN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SPECIAL_GIFT_OPEN_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_OPEN_REPLY::VT_TYPE, type, -8603);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SPECIAL_GIFT_OPEN_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN_REPLY::VT_REWARDS, rewards);
  }
  void add_mailUD(flatbuffers::Offset<flatbuffers::String> mailUD) {
    fbb_.AddOffset(SPECIAL_GIFT_OPEN_REPLY::VT_MAILUD, mailUD);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(SPECIAL_GIFT_OPEN_REPLY::VT_KID, kId, 0);
  }
  explicit SPECIAL_GIFT_OPEN_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SPECIAL_GIFT_OPEN_REPLYBuilder &operator=(const SPECIAL_GIFT_OPEN_REPLYBuilder &);
  flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> CreateSPECIAL_GIFT_OPEN_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8603,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<flatbuffers::String> mailUD = 0,
    int32_t kId = 0) {
  SPECIAL_GIFT_OPEN_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_mailUD(mailUD);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> CreateSPECIAL_GIFT_OPEN_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8603,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    const char *mailUD = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateSPECIAL_GIFT_OPEN_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      mailUD ? _fbb.CreateString(mailUD) : 0,
      kId);
}

flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> CreateSPECIAL_GIFT_OPEN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPEN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef MIRROR_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST> mirror_status;
  MIRROR_STATUS_REPLYT()
      : type(-6950),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct MIRROR_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MIRROR_STATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6950);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::MIRROR_STATUS *mirror_status() const {
    return GetPointer<const OVERLORD::STRUCT::MIRROR_STATUS *>(VT_MIRROR_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MIRROR_STATUS) &&
           verifier.VerifyTable(mirror_status()) &&
           verifier.EndTable();
  }
  MIRROR_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_STATUS_REPLY::VT_TYPE, type, -6950);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(MIRROR_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(MIRROR_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_mirror_status(flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status) {
    fbb_.AddOffset(MIRROR_STATUS_REPLY::VT_MIRROR_STATUS, mirror_status);
  }
  explicit MIRROR_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_STATUS_REPLYBuilder &operator=(const MIRROR_STATUS_REPLYBuilder &);
  flatbuffers::Offset<MIRROR_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_STATUS_REPLY> CreateMIRROR_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6950,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status = 0) {
  MIRROR_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_mirror_status(mirror_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<MIRROR_STATUS_REPLY> CreateMIRROR_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_PLAY_START_REPLYT : public flatbuffers::NativeTable {
  typedef MIRROR_PLAY_START_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::string playUD;
  MIRROR_PLAY_START_REPLYT()
      : type(-6951),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct MIRROR_PLAY_START_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_PLAY_START_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_PLAYUD = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6951);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           verifier.EndTable();
  }
  MIRROR_PLAY_START_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_PLAY_START_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_PLAY_START_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_START_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_PLAY_START_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_PLAY_START_REPLY::VT_TYPE, type, -6951);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(MIRROR_PLAY_START_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(MIRROR_PLAY_START_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(MIRROR_PLAY_START_REPLY::VT_UPDATE, update);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(MIRROR_PLAY_START_REPLY::VT_PLAYUD, playUD);
  }
  explicit MIRROR_PLAY_START_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_PLAY_START_REPLYBuilder &operator=(const MIRROR_PLAY_START_REPLYBuilder &);
  flatbuffers::Offset<MIRROR_PLAY_START_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_PLAY_START_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_PLAY_START_REPLY> CreateMIRROR_PLAY_START_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6951,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::String> playUD = 0) {
  MIRROR_PLAY_START_REPLYBuilder builder_(_fbb);
  builder_.add_playUD(playUD);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_PLAY_START_REPLY> CreateMIRROR_PLAY_START_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6951,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const char *playUD = nullptr) {
  return OVERLORD::RESPONSE::CreateMIRROR_PLAY_START_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      playUD ? _fbb.CreateString(playUD) : 0);
}

flatbuffers::Offset<MIRROR_PLAY_START_REPLY> CreateMIRROR_PLAY_START_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_START_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_PLAY_DONE_REPLYT : public flatbuffers::NativeTable {
  typedef MIRROR_PLAY_DONE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST> mirror_status;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  MIRROR_PLAY_DONE_REPLYT()
      : type(-6952),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct MIRROR_PLAY_DONE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_PLAY_DONE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MIRROR_STATUS = 10,
    VT_UPDATE = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6952);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::MIRROR_STATUS *mirror_status() const {
    return GetPointer<const OVERLORD::STRUCT::MIRROR_STATUS *>(VT_MIRROR_STATUS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MIRROR_STATUS) &&
           verifier.VerifyTable(mirror_status()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  MIRROR_PLAY_DONE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_PLAY_DONE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_PLAY_DONE_REPLY::VT_TYPE, type, -6952);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(MIRROR_PLAY_DONE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(MIRROR_PLAY_DONE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_mirror_status(flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status) {
    fbb_.AddOffset(MIRROR_PLAY_DONE_REPLY::VT_MIRROR_STATUS, mirror_status);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(MIRROR_PLAY_DONE_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(MIRROR_PLAY_DONE_REPLY::VT_REWARDS, rewards);
  }
  explicit MIRROR_PLAY_DONE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_PLAY_DONE_REPLYBuilder &operator=(const MIRROR_PLAY_DONE_REPLYBuilder &);
  flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> CreateMIRROR_PLAY_DONE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6952,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  MIRROR_PLAY_DONE_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_mirror_status(mirror_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> CreateMIRROR_PLAY_DONE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6952,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateMIRROR_PLAY_DONE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      mirror_status,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> CreateMIRROR_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_RESET_REPLYT : public flatbuffers::NativeTable {
  typedef MIRROR_RESET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST> mirror_status;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  MIRROR_RESET_REPLYT()
      : type(-6953),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct MIRROR_RESET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_RESET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MIRROR_STATUS = 10,
    VT_UPDATE = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6953);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::MIRROR_STATUS *mirror_status() const {
    return GetPointer<const OVERLORD::STRUCT::MIRROR_STATUS *>(VT_MIRROR_STATUS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MIRROR_STATUS) &&
           verifier.VerifyTable(mirror_status()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  MIRROR_RESET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_RESET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_RESET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_RESET_REPLY::VT_TYPE, type, -6953);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(MIRROR_RESET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(MIRROR_RESET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_mirror_status(flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status) {
    fbb_.AddOffset(MIRROR_RESET_REPLY::VT_MIRROR_STATUS, mirror_status);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(MIRROR_RESET_REPLY::VT_UPDATE, update);
  }
  explicit MIRROR_RESET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_RESET_REPLYBuilder &operator=(const MIRROR_RESET_REPLYBuilder &);
  flatbuffers::Offset<MIRROR_RESET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_RESET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_RESET_REPLY> CreateMIRROR_RESET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6953,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::MIRROR_STATUS> mirror_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  MIRROR_RESET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_mirror_status(mirror_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<MIRROR_RESET_REPLY> CreateMIRROR_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MIRROR_DEFENSE_DECK_SET_REPLYT : public flatbuffers::NativeTable {
  typedef MIRROR_DEFENSE_DECK_SET_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  MIRROR_DEFENSE_DECK_SET_REPLYT()
      : type(-6954),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct MIRROR_DEFENSE_DECK_SET_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MIRROR_DEFENSE_DECK_SET_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6954);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  MIRROR_DEFENSE_DECK_SET_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MIRROR_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MIRROR_DEFENSE_DECK_SET_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(MIRROR_DEFENSE_DECK_SET_REPLY::VT_TYPE, type, -6954);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(MIRROR_DEFENSE_DECK_SET_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(MIRROR_DEFENSE_DECK_SET_REPLY::VT_UPDATE, update);
  }
  explicit MIRROR_DEFENSE_DECK_SET_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MIRROR_DEFENSE_DECK_SET_REPLYBuilder &operator=(const MIRROR_DEFENSE_DECK_SET_REPLYBuilder &);
  flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> CreateMIRROR_DEFENSE_DECK_SET_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6954,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  MIRROR_DEFENSE_DECK_SET_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> CreateMIRROR_DEFENSE_DECK_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GIVE_ACHIEVE_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef GIVE_ACHIEVE_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::ACHIEVE_STATUST>> achieveStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  int32_t kId;
  GIVE_ACHIEVE_REWARD_REPLYT()
      : type(-8100),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        kId(0) {
  }
};

struct GIVE_ACHIEVE_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GIVE_ACHIEVE_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_ACHIEVESTATUS = 12,
    VT_REWARDS = 14,
    VT_KID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8100);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *achieveStatus() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *>(VT_ACHIEVESTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ACHIEVESTATUS) &&
           verifier.Verify(achieveStatus()) &&
           verifier.VerifyVectorOfTables(achieveStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           verifier.EndTable();
  }
  GIVE_ACHIEVE_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GIVE_ACHIEVE_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GIVE_ACHIEVE_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GIVE_ACHIEVE_REWARD_REPLY::VT_TYPE, type, -8100);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GIVE_ACHIEVE_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_achieveStatus(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>> achieveStatus) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD_REPLY::VT_ACHIEVESTATUS, achieveStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(GIVE_ACHIEVE_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(GIVE_ACHIEVE_REWARD_REPLY::VT_KID, kId, 0);
  }
  explicit GIVE_ACHIEVE_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GIVE_ACHIEVE_REWARD_REPLYBuilder &operator=(const GIVE_ACHIEVE_REWARD_REPLYBuilder &);
  flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> CreateGIVE_ACHIEVE_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8100,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>> achieveStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    int32_t kId = 0) {
  GIVE_ACHIEVE_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_kId(kId);
  builder_.add_rewards(rewards);
  builder_.add_achieveStatus(achieveStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> CreateGIVE_ACHIEVE_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8100,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> *achieveStatus = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    int32_t kId = 0) {
  return OVERLORD::RESPONSE::CreateGIVE_ACHIEVE_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      achieveStatus ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>>(*achieveStatus) : 0,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      kId);
}

flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> CreateGIVE_ACHIEVE_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST> daily_quest_status;
  DAILY_QUEST_STATUS_REPLYT()
      : type(-8101),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct DAILY_QUEST_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_DAILY_QUEST_STATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8101);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::DAILY_QUEST_STATUS *daily_quest_status() const {
    return GetPointer<const OVERLORD::STRUCT::DAILY_QUEST_STATUS *>(VT_DAILY_QUEST_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_DAILY_QUEST_STATUS) &&
           verifier.VerifyTable(daily_quest_status()) &&
           verifier.EndTable();
  }
  DAILY_QUEST_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_STATUS_REPLY::VT_TYPE, type, -8101);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(DAILY_QUEST_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(DAILY_QUEST_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_daily_quest_status(flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status) {
    fbb_.AddOffset(DAILY_QUEST_STATUS_REPLY::VT_DAILY_QUEST_STATUS, daily_quest_status);
  }
  explicit DAILY_QUEST_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_STATUS_REPLYBuilder &operator=(const DAILY_QUEST_STATUS_REPLYBuilder &);
  flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> CreateDAILY_QUEST_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8101,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status = 0) {
  DAILY_QUEST_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_daily_quest_status(daily_quest_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> CreateDAILY_QUEST_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DAILY_QUEST_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef DAILY_QUEST_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST> daily_quest_status;
  DAILY_QUEST_REWARD_REPLYT()
      : type(-8102),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct DAILY_QUEST_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DAILY_QUEST_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_REWARDS = 12,
    VT_DAILY_QUEST_STATUS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8102);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const OVERLORD::STRUCT::DAILY_QUEST_STATUS *daily_quest_status() const {
    return GetPointer<const OVERLORD::STRUCT::DAILY_QUEST_STATUS *>(VT_DAILY_QUEST_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_DAILY_QUEST_STATUS) &&
           verifier.VerifyTable(daily_quest_status()) &&
           verifier.EndTable();
  }
  DAILY_QUEST_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DAILY_QUEST_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DAILY_QUEST_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(DAILY_QUEST_REWARD_REPLY::VT_TYPE, type, -8102);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(DAILY_QUEST_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(DAILY_QUEST_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(DAILY_QUEST_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(DAILY_QUEST_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_daily_quest_status(flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status) {
    fbb_.AddOffset(DAILY_QUEST_REWARD_REPLY::VT_DAILY_QUEST_STATUS, daily_quest_status);
  }
  explicit DAILY_QUEST_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DAILY_QUEST_REWARD_REPLYBuilder &operator=(const DAILY_QUEST_REWARD_REPLYBuilder &);
  flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> CreateDAILY_QUEST_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status = 0) {
  DAILY_QUEST_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_daily_quest_status(daily_quest_status);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> CreateDAILY_QUEST_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::DAILY_QUEST_STATUS> daily_quest_status = 0) {
  return OVERLORD::RESPONSE::CreateDAILY_QUEST_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      daily_quest_status);
}

flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> CreateDAILY_QUEST_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_USER_DATA_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_USER_DATA_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::SHOP_USER_DATAT> shopUserData;
  SHOP_USER_DATA_REPLYT()
      : type(-4150),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_USER_DATA_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_USER_DATA_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_SHOPUSERDATA = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4150);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::SHOP_USER_DATA *shopUserData() const {
    return GetPointer<const OVERLORD::STRUCT::SHOP_USER_DATA *>(VT_SHOPUSERDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_SHOPUSERDATA) &&
           verifier.VerifyTable(shopUserData()) &&
           verifier.EndTable();
  }
  SHOP_USER_DATA_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_USER_DATA_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_USER_DATA_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATA_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_USER_DATA_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_USER_DATA_REPLY::VT_TYPE, type, -4150);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_USER_DATA_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_USER_DATA_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_shopUserData(flatbuffers::Offset<OVERLORD::STRUCT::SHOP_USER_DATA> shopUserData) {
    fbb_.AddOffset(SHOP_USER_DATA_REPLY::VT_SHOPUSERDATA, shopUserData);
  }
  explicit SHOP_USER_DATA_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_USER_DATA_REPLYBuilder &operator=(const SHOP_USER_DATA_REPLYBuilder &);
  flatbuffers::Offset<SHOP_USER_DATA_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_USER_DATA_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_USER_DATA_REPLY> CreateSHOP_USER_DATA_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4150,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_USER_DATA> shopUserData = 0) {
  SHOP_USER_DATA_REPLYBuilder builder_(_fbb);
  builder_.add_shopUserData(shopUserData);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<SHOP_USER_DATA_REPLY> CreateSHOP_USER_DATA_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATA_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_BUY_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_BUY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::SHOP_USER_DATAT> shopUserData;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDSETT>> rewardSet;
  std::string productId;
  SHOP_BUY_REPLYT()
      : type(-4151),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_BUY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_BUY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_SHOPUSERDATA = 12,
    VT_REWARDSET = 14,
    VT_PRODUCTID = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4151);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::SHOP_USER_DATA *shopUserData() const {
    return GetPointer<const OVERLORD::STRUCT::SHOP_USER_DATA *>(VT_SHOPUSERDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>> *rewardSet() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>> *>(VT_REWARDSET);
  }
  const flatbuffers::String *productId() const {
    return GetPointer<const flatbuffers::String *>(VT_PRODUCTID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_SHOPUSERDATA) &&
           verifier.VerifyTable(shopUserData()) &&
           VerifyOffset(verifier, VT_REWARDSET) &&
           verifier.Verify(rewardSet()) &&
           verifier.VerifyVectorOfTables(rewardSet()) &&
           VerifyOffset(verifier, VT_PRODUCTID) &&
           verifier.Verify(productId()) &&
           verifier.EndTable();
  }
  SHOP_BUY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_BUY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_BUY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_BUY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_BUY_REPLY::VT_TYPE, type, -4151);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_BUY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_BUY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SHOP_BUY_REPLY::VT_UPDATE, update);
  }
  void add_shopUserData(flatbuffers::Offset<OVERLORD::STRUCT::SHOP_USER_DATA> shopUserData) {
    fbb_.AddOffset(SHOP_BUY_REPLY::VT_SHOPUSERDATA, shopUserData);
  }
  void add_rewardSet(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>>> rewardSet) {
    fbb_.AddOffset(SHOP_BUY_REPLY::VT_REWARDSET, rewardSet);
  }
  void add_productId(flatbuffers::Offset<flatbuffers::String> productId) {
    fbb_.AddOffset(SHOP_BUY_REPLY::VT_PRODUCTID, productId);
  }
  explicit SHOP_BUY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_BUY_REPLYBuilder &operator=(const SHOP_BUY_REPLYBuilder &);
  flatbuffers::Offset<SHOP_BUY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_BUY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_BUY_REPLY> CreateSHOP_BUY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4151,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_USER_DATA> shopUserData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>>> rewardSet = 0,
    flatbuffers::Offset<flatbuffers::String> productId = 0) {
  SHOP_BUY_REPLYBuilder builder_(_fbb);
  builder_.add_productId(productId);
  builder_.add_rewardSet(rewardSet);
  builder_.add_shopUserData(shopUserData);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_BUY_REPLY> CreateSHOP_BUY_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4151,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_USER_DATA> shopUserData = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>> *rewardSet = nullptr,
    const char *productId = nullptr) {
  return OVERLORD::RESPONSE::CreateSHOP_BUY_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      shopUserData,
      rewardSet ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>>(*rewardSet) : 0,
      productId ? _fbb.CreateString(productId) : 0);
}

flatbuffers::Offset<SHOP_BUY_REPLY> CreateSHOP_BUY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_CHARACTER_SUMMON_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_CHARACTER_SUMMON_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> extraRewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> summonRewards;
  SHOP_CHARACTER_SUMMON_REPLYT()
      : type(-4152),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_CHARACTER_SUMMON_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_CHARACTER_SUMMON_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_EXTRAREWARDS = 12,
    VT_SUMMONREWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4152);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *extraRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_EXTRAREWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *summonRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_SUMMONREWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_EXTRAREWARDS) &&
           verifier.Verify(extraRewards()) &&
           verifier.VerifyVectorOfTables(extraRewards()) &&
           VerifyOffset(verifier, VT_SUMMONREWARDS) &&
           verifier.Verify(summonRewards()) &&
           verifier.VerifyVectorOfTables(summonRewards()) &&
           verifier.EndTable();
  }
  SHOP_CHARACTER_SUMMON_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_CHARACTER_SUMMON_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMON_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_CHARACTER_SUMMON_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_CHARACTER_SUMMON_REPLY::VT_TYPE, type, -4152);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_CHARACTER_SUMMON_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON_REPLY::VT_UPDATE, update);
  }
  void add_extraRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> extraRewards) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON_REPLY::VT_EXTRAREWARDS, extraRewards);
  }
  void add_summonRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> summonRewards) {
    fbb_.AddOffset(SHOP_CHARACTER_SUMMON_REPLY::VT_SUMMONREWARDS, summonRewards);
  }
  explicit SHOP_CHARACTER_SUMMON_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_CHARACTER_SUMMON_REPLYBuilder &operator=(const SHOP_CHARACTER_SUMMON_REPLYBuilder &);
  flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> CreateSHOP_CHARACTER_SUMMON_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4152,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> extraRewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> summonRewards = 0) {
  SHOP_CHARACTER_SUMMON_REPLYBuilder builder_(_fbb);
  builder_.add_summonRewards(summonRewards);
  builder_.add_extraRewards(extraRewards);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> CreateSHOP_CHARACTER_SUMMON_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4152,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *extraRewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *summonRewards = nullptr) {
  return OVERLORD::RESPONSE::CreateSHOP_CHARACTER_SUMMON_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      extraRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*extraRewards) : 0,
      summonRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*summonRewards) : 0);
}

flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> CreateSHOP_CHARACTER_SUMMON_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMON_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST> status;
  SHOP_FLOORSHOP_STATUS_REPLYT()
      : type(-4153),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_FLOORSHOP_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_STATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4153);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *status() const {
    return GetPointer<const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_STATUS_REPLY::VT_TYPE, type, -4153);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_FLOORSHOP_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_status(flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status) {
    fbb_.AddOffset(SHOP_FLOORSHOP_STATUS_REPLY::VT_STATUS, status);
  }
  explicit SHOP_FLOORSHOP_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_STATUS_REPLYBuilder &operator=(const SHOP_FLOORSHOP_STATUS_REPLYBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> CreateSHOP_FLOORSHOP_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4153,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status = 0) {
  SHOP_FLOORSHOP_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> CreateSHOP_FLOORSHOP_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_BUY_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_BUY_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST> status;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  SHOP_FLOORSHOP_BUY_REPLYT()
      : type(-4154),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_FLOORSHOP_BUY_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_BUY_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_STATUS = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4154);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *status() const {
    return GetPointer<const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *>(VT_STATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_BUY_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_BUY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_BUY_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_BUY_REPLY::VT_TYPE, type, -4154);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_FLOORSHOP_BUY_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY_REPLY::VT_UPDATE, update);
  }
  void add_status(flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY_REPLY::VT_STATUS, status);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(SHOP_FLOORSHOP_BUY_REPLY::VT_REWARDS, rewards);
  }
  explicit SHOP_FLOORSHOP_BUY_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_BUY_REPLYBuilder &operator=(const SHOP_FLOORSHOP_BUY_REPLYBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> CreateSHOP_FLOORSHOP_BUY_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4154,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  SHOP_FLOORSHOP_BUY_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_status(status);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> CreateSHOP_FLOORSHOP_BUY_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4154,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateSHOP_FLOORSHOP_BUY_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      status,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> CreateSHOP_FLOORSHOP_BUY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SHOP_FLOORSHOP_OPEN_SLOT_REPLYT : public flatbuffers::NativeTable {
  typedef SHOP_FLOORSHOP_OPEN_SLOT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST> status;
  SHOP_FLOORSHOP_OPEN_SLOT_REPLYT()
      : type(-4155),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct SHOP_FLOORSHOP_OPEN_SLOT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SHOP_FLOORSHOP_OPEN_SLOT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_STATUS = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -4155);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *status() const {
    return GetPointer<const OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS *>(VT_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyTable(status()) &&
           verifier.EndTable();
  }
  SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SHOP_FLOORSHOP_OPEN_SLOT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(SHOP_FLOORSHOP_OPEN_SLOT_REPLY::VT_TYPE, type, -4155);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(SHOP_FLOORSHOP_OPEN_SLOT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT_REPLY::VT_UPDATE, update);
  }
  void add_status(flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status) {
    fbb_.AddOffset(SHOP_FLOORSHOP_OPEN_SLOT_REPLY::VT_STATUS, status);
  }
  explicit SHOP_FLOORSHOP_OPEN_SLOT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SHOP_FLOORSHOP_OPEN_SLOT_REPLYBuilder &operator=(const SHOP_FLOORSHOP_OPEN_SLOT_REPLYBuilder &);
  flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> CreateSHOP_FLOORSHOP_OPEN_SLOT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -4155,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUS> status = 0) {
  SHOP_FLOORSHOP_OPEN_SLOT_REPLYBuilder builder_(_fbb);
  builder_.add_status(status);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> CreateSHOP_FLOORSHOP_OPEN_SLOT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  TOWER_STATUS_REPLYT()
      : type(-6100),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TOWER_STATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6100);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           verifier.EndTable();
  }
  TOWER_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_STATUS_REPLY::VT_TYPE, type, -6100);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_STATUS_REPLY::VT_TOWER_STATUS, tower_status);
  }
  explicit TOWER_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_STATUS_REPLYBuilder &operator=(const TOWER_STATUS_REPLYBuilder &);
  flatbuffers::Offset<TOWER_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_STATUS_REPLY> CreateTOWER_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6100,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0) {
  TOWER_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_tower_status(tower_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<TOWER_STATUS_REPLY> CreateTOWER_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_PLAY_START_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_PLAY_START_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::string playUD;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> dropRewards;
  TOWER_PLAY_START_REPLYT()
      : type(-6101),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_PLAY_START_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_PLAY_START_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_PLAYUD = 12,
    VT_DROPREWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6101);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::String *playUD() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYUD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *dropRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_DROPREWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_PLAYUD) &&
           verifier.Verify(playUD()) &&
           VerifyOffset(verifier, VT_DROPREWARDS) &&
           verifier.Verify(dropRewards()) &&
           verifier.VerifyVectorOfTables(dropRewards()) &&
           verifier.EndTable();
  }
  TOWER_PLAY_START_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_PLAY_START_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_PLAY_START_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_START_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_PLAY_START_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_START_REPLY::VT_TYPE, type, -6101);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_PLAY_START_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_PLAY_START_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_PLAY_START_REPLY::VT_UPDATE, update);
  }
  void add_playUD(flatbuffers::Offset<flatbuffers::String> playUD) {
    fbb_.AddOffset(TOWER_PLAY_START_REPLY::VT_PLAYUD, playUD);
  }
  void add_dropRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> dropRewards) {
    fbb_.AddOffset(TOWER_PLAY_START_REPLY::VT_DROPREWARDS, dropRewards);
  }
  explicit TOWER_PLAY_START_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_PLAY_START_REPLYBuilder &operator=(const TOWER_PLAY_START_REPLYBuilder &);
  flatbuffers::Offset<TOWER_PLAY_START_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_PLAY_START_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_PLAY_START_REPLY> CreateTOWER_PLAY_START_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6101,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::String> playUD = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> dropRewards = 0) {
  TOWER_PLAY_START_REPLYBuilder builder_(_fbb);
  builder_.add_dropRewards(dropRewards);
  builder_.add_playUD(playUD);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_PLAY_START_REPLY> CreateTOWER_PLAY_START_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6101,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const char *playUD = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *dropRewards = nullptr) {
  return OVERLORD::RESPONSE::CreateTOWER_PLAY_START_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      playUD ? _fbb.CreateString(playUD) : 0,
      dropRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*dropRewards) : 0);
}

flatbuffers::Offset<TOWER_PLAY_START_REPLY> CreateTOWER_PLAY_START_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_START_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_PLAY_DONE_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_PLAY_DONE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> questRewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> clearRewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> dropRewards;
  TOWER_PLAY_DONE_REPLYT()
      : type(-6102),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_PLAY_DONE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_PLAY_DONE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TOWER_STATUS = 10,
    VT_UPDATE = 12,
    VT_QUESTREWARDS = 14,
    VT_CLEARREWARDS = 16,
    VT_DROPREWARDS = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6102);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *questRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_QUESTREWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *clearRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_CLEARREWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *dropRewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_DROPREWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_QUESTREWARDS) &&
           verifier.Verify(questRewards()) &&
           verifier.VerifyVectorOfTables(questRewards()) &&
           VerifyOffset(verifier, VT_CLEARREWARDS) &&
           verifier.Verify(clearRewards()) &&
           verifier.VerifyVectorOfTables(clearRewards()) &&
           VerifyOffset(verifier, VT_DROPREWARDS) &&
           verifier.Verify(dropRewards()) &&
           verifier.VerifyVectorOfTables(dropRewards()) &&
           verifier.EndTable();
  }
  TOWER_PLAY_DONE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_PLAY_DONE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_PLAY_DONE_REPLY::VT_TYPE, type, -6102);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_PLAY_DONE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_TOWER_STATUS, tower_status);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_UPDATE, update);
  }
  void add_questRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> questRewards) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_QUESTREWARDS, questRewards);
  }
  void add_clearRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> clearRewards) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_CLEARREWARDS, clearRewards);
  }
  void add_dropRewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> dropRewards) {
    fbb_.AddOffset(TOWER_PLAY_DONE_REPLY::VT_DROPREWARDS, dropRewards);
  }
  explicit TOWER_PLAY_DONE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_PLAY_DONE_REPLYBuilder &operator=(const TOWER_PLAY_DONE_REPLYBuilder &);
  flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_PLAY_DONE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> CreateTOWER_PLAY_DONE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> questRewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> clearRewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> dropRewards = 0) {
  TOWER_PLAY_DONE_REPLYBuilder builder_(_fbb);
  builder_.add_dropRewards(dropRewards);
  builder_.add_clearRewards(clearRewards);
  builder_.add_questRewards(questRewards);
  builder_.add_update(update);
  builder_.add_tower_status(tower_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> CreateTOWER_PLAY_DONE_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6102,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *questRewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *clearRewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *dropRewards = nullptr) {
  return OVERLORD::RESPONSE::CreateTOWER_PLAY_DONE_REPLY(
      _fbb,
      type,
      error_info,
      is,
      tower_status,
      update,
      questRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*questRewards) : 0,
      clearRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*clearRewards) : 0,
      dropRewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*dropRewards) : 0);
}

flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> CreateTOWER_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_TREASURE_BOX_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_TREASURE_BOX_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  TOWER_TREASURE_BOX_REPLYT()
      : type(-6103),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_TREASURE_BOX_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_TREASURE_BOX_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_TOWER_STATUS = 10,
    VT_UPDATE = 12,
    VT_REWARDS = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6103);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           verifier.EndTable();
  }
  TOWER_TREASURE_BOX_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_TREASURE_BOX_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOX_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_TREASURE_BOX_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_TREASURE_BOX_REPLY::VT_TYPE, type, -6103);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_TREASURE_BOX_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_TREASURE_BOX_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_TREASURE_BOX_REPLY::VT_TOWER_STATUS, tower_status);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_TREASURE_BOX_REPLY::VT_UPDATE, update);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(TOWER_TREASURE_BOX_REPLY::VT_REWARDS, rewards);
  }
  explicit TOWER_TREASURE_BOX_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_TREASURE_BOX_REPLYBuilder &operator=(const TOWER_TREASURE_BOX_REPLYBuilder &);
  flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> CreateTOWER_TREASURE_BOX_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6103,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0) {
  TOWER_TREASURE_BOX_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_update(update);
  builder_.add_tower_status(tower_status);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> CreateTOWER_TREASURE_BOX_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6103,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr) {
  return OVERLORD::RESPONSE::CreateTOWER_TREASURE_BOX_REPLY(
      _fbb,
      type,
      error_info,
      is,
      tower_status,
      update,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0);
}

flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> CreateTOWER_TREASURE_BOX_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOX_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_BOSS_PLAY_CHECK_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_BOSS_PLAY_CHECK_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool isValid;
  TOWER_BOSS_PLAY_CHECK_REPLYT()
      : type(-6104),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isValid(true) {
  }
};

struct TOWER_BOSS_PLAY_CHECK_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_BOSS_PLAY_CHECK_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ISVALID = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6104);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool isValid() const {
    return GetField<uint8_t>(VT_ISVALID, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_ISVALID) &&
           verifier.EndTable();
  }
  TOWER_BOSS_PLAY_CHECK_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_BOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_BOSS_PLAY_CHECK_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_BOSS_PLAY_CHECK_REPLY::VT_TYPE, type, -6104);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_CHECK_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_BOSS_PLAY_CHECK_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_isValid(bool isValid) {
    fbb_.AddElement<uint8_t>(TOWER_BOSS_PLAY_CHECK_REPLY::VT_ISVALID, static_cast<uint8_t>(isValid), 1);
  }
  explicit TOWER_BOSS_PLAY_CHECK_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_BOSS_PLAY_CHECK_REPLYBuilder &operator=(const TOWER_BOSS_PLAY_CHECK_REPLYBuilder &);
  flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> CreateTOWER_BOSS_PLAY_CHECK_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6104,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool isValid = true) {
  TOWER_BOSS_PLAY_CHECK_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isValid(isValid);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> CreateTOWER_BOSS_PLAY_CHECK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_BOSS_PLAY_RESULT_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_BOSS_PLAY_RESULT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  int32_t playTime;
  OVERLORD::ENUM::PLAY_CLEAR_GRADE clearGrade;
  TOWER_BOSS_PLAY_RESULT_REPLYT()
      : type(-6105),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        playTime(0),
        clearGrade(OVERLORD::ENUM::PLAY_CLEAR_GRADE_CLEAR_FAILED) {
  }
};

struct TOWER_BOSS_PLAY_RESULT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_BOSS_PLAY_RESULT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_TOWER_STATUS = 12,
    VT_REWARDS = 14,
    VT_PLAYTIME = 16,
    VT_CLEARGRADE = 18
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6105);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  int32_t playTime() const {
    return GetField<int32_t>(VT_PLAYTIME, 0);
  }
  OVERLORD::ENUM::PLAY_CLEAR_GRADE clearGrade() const {
    return static_cast<OVERLORD::ENUM::PLAY_CLEAR_GRADE>(GetField<int8_t>(VT_CLEARGRADE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<int32_t>(verifier, VT_PLAYTIME) &&
           VerifyField<int8_t>(verifier, VT_CLEARGRADE) &&
           verifier.EndTable();
  }
  TOWER_BOSS_PLAY_RESULT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_BOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_BOSS_PLAY_RESULT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_BOSS_PLAY_RESULT_REPLY::VT_TYPE, type, -6105);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_BOSS_PLAY_RESULT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT_REPLY::VT_UPDATE, update);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT_REPLY::VT_TOWER_STATUS, tower_status);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(TOWER_BOSS_PLAY_RESULT_REPLY::VT_REWARDS, rewards);
  }
  void add_playTime(int32_t playTime) {
    fbb_.AddElement<int32_t>(TOWER_BOSS_PLAY_RESULT_REPLY::VT_PLAYTIME, playTime, 0);
  }
  void add_clearGrade(OVERLORD::ENUM::PLAY_CLEAR_GRADE clearGrade) {
    fbb_.AddElement<int8_t>(TOWER_BOSS_PLAY_RESULT_REPLY::VT_CLEARGRADE, static_cast<int8_t>(clearGrade), 0);
  }
  explicit TOWER_BOSS_PLAY_RESULT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_BOSS_PLAY_RESULT_REPLYBuilder &operator=(const TOWER_BOSS_PLAY_RESULT_REPLYBuilder &);
  flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> CreateTOWER_BOSS_PLAY_RESULT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6105,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    int32_t playTime = 0,
    OVERLORD::ENUM::PLAY_CLEAR_GRADE clearGrade = OVERLORD::ENUM::PLAY_CLEAR_GRADE_CLEAR_FAILED) {
  TOWER_BOSS_PLAY_RESULT_REPLYBuilder builder_(_fbb);
  builder_.add_playTime(playTime);
  builder_.add_rewards(rewards);
  builder_.add_tower_status(tower_status);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_clearGrade(clearGrade);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> CreateTOWER_BOSS_PLAY_RESULT_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6105,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    int32_t playTime = 0,
    OVERLORD::ENUM::PLAY_CLEAR_GRADE clearGrade = OVERLORD::ENUM::PLAY_CLEAR_GRADE_CLEAR_FAILED) {
  return OVERLORD::RESPONSE::CreateTOWER_BOSS_PLAY_RESULT_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      tower_status,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      playTime,
      clearGrade);
}

flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> CreateTOWER_BOSS_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_FLOOR_MISSION_ACTIVE_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_FLOOR_MISSION_ACTIVE_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  TOWER_FLOOR_MISSION_ACTIVE_REPLYT()
      : type(-6106),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_FLOOR_MISSION_ACTIVE_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_FLOOR_MISSION_ACTIVE_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_TOWER_STATUS = 12
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6106);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           verifier.EndTable();
  }
  TOWER_FLOOR_MISSION_ACTIVE_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_FLOOR_MISSION_ACTIVE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_FLOOR_MISSION_ACTIVE_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_FLOOR_MISSION_ACTIVE_REPLY::VT_TYPE, type, -6106);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_FLOOR_MISSION_ACTIVE_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE_REPLY::VT_UPDATE, update);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_ACTIVE_REPLY::VT_TOWER_STATUS, tower_status);
  }
  explicit TOWER_FLOOR_MISSION_ACTIVE_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_FLOOR_MISSION_ACTIVE_REPLYBuilder &operator=(const TOWER_FLOOR_MISSION_ACTIVE_REPLYBuilder &);
  flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> CreateTOWER_FLOOR_MISSION_ACTIVE_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6106,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0) {
  TOWER_FLOOR_MISSION_ACTIVE_REPLYBuilder builder_(_fbb);
  builder_.add_tower_status(tower_status);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> CreateTOWER_FLOOR_MISSION_ACTIVE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TOWER_FLOOR_MISSION_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef TOWER_FLOOR_MISSION_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> complete_rewards;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST> tower_status;
  TOWER_FLOOR_MISSION_REWARD_REPLYT()
      : type(-6107),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TOWER_FLOOR_MISSION_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TOWER_FLOOR_MISSION_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_COMPLETE_REWARDS = 10,
    VT_REWARDS = 12,
    VT_UPDATE = 14,
    VT_TOWER_STATUS = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -6107);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *complete_rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_COMPLETE_REWARDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::TOWER_STATUS *tower_status() const {
    return GetPointer<const OVERLORD::STRUCT::TOWER_STATUS *>(VT_TOWER_STATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_COMPLETE_REWARDS) &&
           verifier.Verify(complete_rewards()) &&
           verifier.VerifyVectorOfTables(complete_rewards()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_TOWER_STATUS) &&
           verifier.VerifyTable(tower_status()) &&
           verifier.EndTable();
  }
  TOWER_FLOOR_MISSION_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TOWER_FLOOR_MISSION_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TOWER_FLOOR_MISSION_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_TYPE, type, -6107);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_complete_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> complete_rewards) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_COMPLETE_REWARDS, complete_rewards);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_UPDATE, update);
  }
  void add_tower_status(flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status) {
    fbb_.AddOffset(TOWER_FLOOR_MISSION_REWARD_REPLY::VT_TOWER_STATUS, tower_status);
  }
  explicit TOWER_FLOOR_MISSION_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TOWER_FLOOR_MISSION_REWARD_REPLYBuilder &operator=(const TOWER_FLOOR_MISSION_REWARD_REPLYBuilder &);
  flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> CreateTOWER_FLOOR_MISSION_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6107,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> complete_rewards = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0) {
  TOWER_FLOOR_MISSION_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_tower_status(tower_status);
  builder_.add_update(update);
  builder_.add_rewards(rewards);
  builder_.add_complete_rewards(complete_rewards);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> CreateTOWER_FLOOR_MISSION_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -6107,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *complete_rewards = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TOWER_STATUS> tower_status = 0) {
  return OVERLORD::RESPONSE::CreateTOWER_FLOOR_MISSION_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      complete_rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*complete_rewards) : 0,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      update,
      tower_status);
}

flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> CreateTOWER_FLOOR_MISSION_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TREASURE_GET_REWARD_REPLYT : public flatbuffers::NativeTable {
  typedef TREASURE_GET_REWARD_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  std::unique_ptr<OVERLORD::STRUCT::TREASURET> treasure;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  TREASURE_GET_REWARD_REPLYT()
      : type(-8850),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct TREASURE_GET_REWARD_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TREASURE_GET_REWARD_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_REWARDS = 10,
    VT_TREASURE = 12,
    VT_UPDATE = 14
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -8850);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  const OVERLORD::STRUCT::TREASURE *treasure() const {
    return GetPointer<const OVERLORD::STRUCT::TREASURE *>(VT_TREASURE);
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyOffset(verifier, VT_TREASURE) &&
           verifier.VerifyTable(treasure()) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           verifier.EndTable();
  }
  TREASURE_GET_REWARD_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TREASURE_GET_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TREASURE_GET_REWARD_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(TREASURE_GET_REWARD_REPLY::VT_TYPE, type, -8850);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(TREASURE_GET_REWARD_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(TREASURE_GET_REWARD_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(TREASURE_GET_REWARD_REPLY::VT_REWARDS, rewards);
  }
  void add_treasure(flatbuffers::Offset<OVERLORD::STRUCT::TREASURE> treasure) {
    fbb_.AddOffset(TREASURE_GET_REWARD_REPLY::VT_TREASURE, treasure);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(TREASURE_GET_REWARD_REPLY::VT_UPDATE, update);
  }
  explicit TREASURE_GET_REWARD_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TREASURE_GET_REWARD_REPLYBuilder &operator=(const TREASURE_GET_REWARD_REPLYBuilder &);
  flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TREASURE_GET_REWARD_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> CreateTREASURE_GET_REWARD_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8850,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::TREASURE> treasure = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  TREASURE_GET_REWARD_REPLYBuilder builder_(_fbb);
  builder_.add_update(update);
  builder_.add_treasure(treasure);
  builder_.add_rewards(rewards);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> CreateTREASURE_GET_REWARD_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -8850,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    flatbuffers::Offset<OVERLORD::STRUCT::TREASURE> treasure = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0) {
  return OVERLORD::RESPONSE::CreateTREASURE_GET_REWARD_REPLY(
      _fbb,
      type,
      error_info,
      is,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      treasure,
      update);
}

flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> CreateTREASURE_GET_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GET_TARGET_SERVER_REPLYT : public flatbuffers::NativeTable {
  typedef GET_TARGET_SERVER_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::string manifestBuildNumber;
  std::string tcpServerPort;
  std::string tcpServerHost;
  std::string cdn;
  std::string serverHost;
  std::string env;
  GET_TARGET_SERVER_REPLYT()
      : type(-17450),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct GET_TARGET_SERVER_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GET_TARGET_SERVER_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_MANIFESTBUILDNUMBER = 10,
    VT_TCPSERVERPORT = 12,
    VT_TCPSERVERHOST = 14,
    VT_CDN = 16,
    VT_SERVERHOST = 18,
    VT_ENV = 20
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -17450);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const flatbuffers::String *manifestBuildNumber() const {
    return GetPointer<const flatbuffers::String *>(VT_MANIFESTBUILDNUMBER);
  }
  const flatbuffers::String *tcpServerPort() const {
    return GetPointer<const flatbuffers::String *>(VT_TCPSERVERPORT);
  }
  const flatbuffers::String *tcpServerHost() const {
    return GetPointer<const flatbuffers::String *>(VT_TCPSERVERHOST);
  }
  const flatbuffers::String *cdn() const {
    return GetPointer<const flatbuffers::String *>(VT_CDN);
  }
  const flatbuffers::String *serverHost() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVERHOST);
  }
  const flatbuffers::String *env() const {
    return GetPointer<const flatbuffers::String *>(VT_ENV);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_MANIFESTBUILDNUMBER) &&
           verifier.Verify(manifestBuildNumber()) &&
           VerifyOffset(verifier, VT_TCPSERVERPORT) &&
           verifier.Verify(tcpServerPort()) &&
           VerifyOffset(verifier, VT_TCPSERVERHOST) &&
           verifier.Verify(tcpServerHost()) &&
           VerifyOffset(verifier, VT_CDN) &&
           verifier.Verify(cdn()) &&
           VerifyOffset(verifier, VT_SERVERHOST) &&
           verifier.Verify(serverHost()) &&
           VerifyOffset(verifier, VT_ENV) &&
           verifier.Verify(env()) &&
           verifier.EndTable();
  }
  GET_TARGET_SERVER_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GET_TARGET_SERVER_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<GET_TARGET_SERVER_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVER_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GET_TARGET_SERVER_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(GET_TARGET_SERVER_REPLY::VT_TYPE, type, -17450);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(GET_TARGET_SERVER_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_manifestBuildNumber(flatbuffers::Offset<flatbuffers::String> manifestBuildNumber) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_MANIFESTBUILDNUMBER, manifestBuildNumber);
  }
  void add_tcpServerPort(flatbuffers::Offset<flatbuffers::String> tcpServerPort) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_TCPSERVERPORT, tcpServerPort);
  }
  void add_tcpServerHost(flatbuffers::Offset<flatbuffers::String> tcpServerHost) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_TCPSERVERHOST, tcpServerHost);
  }
  void add_cdn(flatbuffers::Offset<flatbuffers::String> cdn) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_CDN, cdn);
  }
  void add_serverHost(flatbuffers::Offset<flatbuffers::String> serverHost) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_SERVERHOST, serverHost);
  }
  void add_env(flatbuffers::Offset<flatbuffers::String> env) {
    fbb_.AddOffset(GET_TARGET_SERVER_REPLY::VT_ENV, env);
  }
  explicit GET_TARGET_SERVER_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GET_TARGET_SERVER_REPLYBuilder &operator=(const GET_TARGET_SERVER_REPLYBuilder &);
  flatbuffers::Offset<GET_TARGET_SERVER_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GET_TARGET_SERVER_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<GET_TARGET_SERVER_REPLY> CreateGET_TARGET_SERVER_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -17450,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<flatbuffers::String> manifestBuildNumber = 0,
    flatbuffers::Offset<flatbuffers::String> tcpServerPort = 0,
    flatbuffers::Offset<flatbuffers::String> tcpServerHost = 0,
    flatbuffers::Offset<flatbuffers::String> cdn = 0,
    flatbuffers::Offset<flatbuffers::String> serverHost = 0,
    flatbuffers::Offset<flatbuffers::String> env = 0) {
  GET_TARGET_SERVER_REPLYBuilder builder_(_fbb);
  builder_.add_env(env);
  builder_.add_serverHost(serverHost);
  builder_.add_cdn(cdn);
  builder_.add_tcpServerHost(tcpServerHost);
  builder_.add_tcpServerPort(tcpServerPort);
  builder_.add_manifestBuildNumber(manifestBuildNumber);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<GET_TARGET_SERVER_REPLY> CreateGET_TARGET_SERVER_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -17450,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    const char *manifestBuildNumber = nullptr,
    const char *tcpServerPort = nullptr,
    const char *tcpServerHost = nullptr,
    const char *cdn = nullptr,
    const char *serverHost = nullptr,
    const char *env = nullptr) {
  return OVERLORD::RESPONSE::CreateGET_TARGET_SERVER_REPLY(
      _fbb,
      type,
      error_info,
      is,
      manifestBuildNumber ? _fbb.CreateString(manifestBuildNumber) : 0,
      tcpServerPort ? _fbb.CreateString(tcpServerPort) : 0,
      tcpServerHost ? _fbb.CreateString(tcpServerHost) : 0,
      cdn ? _fbb.CreateString(cdn) : 0,
      serverHost ? _fbb.CreateString(serverHost) : 0,
      env ? _fbb.CreateString(env) : 0);
}

flatbuffers::Offset<GET_TARGET_SERVER_REPLY> CreateGET_TARGET_SERVER_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVER_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_STATUS_REPLYT : public flatbuffers::NativeTable {
  typedef WORLDBOSS_STATUS_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::WORLDBOSS_STATUST> worldbossStatus;
  WORLDBOSS_STATUS_REPLYT()
      : type(-10850),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL) {
  }
};

struct WORLDBOSS_STATUS_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_STATUS_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_WORLDBOSSSTATUS = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10850);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::WORLDBOSS_STATUS *worldbossStatus() const {
    return GetPointer<const OVERLORD::STRUCT::WORLDBOSS_STATUS *>(VT_WORLDBOSSSTATUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_WORLDBOSSSTATUS) &&
           verifier.VerifyTable(worldbossStatus()) &&
           verifier.EndTable();
  }
  WORLDBOSS_STATUS_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_STATUS_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_STATUS_REPLY::VT_TYPE, type, -10850);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(WORLDBOSS_STATUS_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(WORLDBOSS_STATUS_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_worldbossStatus(flatbuffers::Offset<OVERLORD::STRUCT::WORLDBOSS_STATUS> worldbossStatus) {
    fbb_.AddOffset(WORLDBOSS_STATUS_REPLY::VT_WORLDBOSSSTATUS, worldbossStatus);
  }
  explicit WORLDBOSS_STATUS_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_STATUS_REPLYBuilder &operator=(const WORLDBOSS_STATUS_REPLYBuilder &);
  flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_STATUS_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> CreateWORLDBOSS_STATUS_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10850,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::WORLDBOSS_STATUS> worldbossStatus = 0) {
  WORLDBOSS_STATUS_REPLYBuilder builder_(_fbb);
  builder_.add_worldbossStatus(worldbossStatus);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> CreateWORLDBOSS_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_PLAY_CHECK_REPLYT : public flatbuffers::NativeTable {
  typedef WORLDBOSS_PLAY_CHECK_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  bool isValid;
  WORLDBOSS_PLAY_CHECK_REPLYT()
      : type(-10851),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isValid(true) {
  }
};

struct WORLDBOSS_PLAY_CHECK_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_PLAY_CHECK_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_ISVALID = 10
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10851);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  bool isValid() const {
    return GetField<uint8_t>(VT_ISVALID, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyField<uint8_t>(verifier, VT_ISVALID) &&
           verifier.EndTable();
  }
  WORLDBOSS_PLAY_CHECK_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_PLAY_CHECK_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_PLAY_CHECK_REPLY::VT_TYPE, type, -10851);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(WORLDBOSS_PLAY_CHECK_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(WORLDBOSS_PLAY_CHECK_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_isValid(bool isValid) {
    fbb_.AddElement<uint8_t>(WORLDBOSS_PLAY_CHECK_REPLY::VT_ISVALID, static_cast<uint8_t>(isValid), 1);
  }
  explicit WORLDBOSS_PLAY_CHECK_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_PLAY_CHECK_REPLYBuilder &operator=(const WORLDBOSS_PLAY_CHECK_REPLYBuilder &);
  flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> CreateWORLDBOSS_PLAY_CHECK_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10851,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    bool isValid = true) {
  WORLDBOSS_PLAY_CHECK_REPLYBuilder builder_(_fbb);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isValid(isValid);
  builder_.add_is(is);
  return builder_.Finish();
}

flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> CreateWORLDBOSS_PLAY_CHECK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WORLDBOSS_PLAY_RESULT_REPLYT : public flatbuffers::NativeTable {
  typedef WORLDBOSS_PLAY_RESULT_REPLY TableType;
  int32_t type;
  std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT> error_info;
  OVERLORD::ENUM::CRUD is;
  std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT> update;
  std::unique_ptr<OVERLORD::STRUCT::WORLDBOSS_STATUST> worldbossStatus;
  std::vector<std::unique_ptr<OVERLORD::STRUCT::REWARDT>> rewards;
  bool isWin;
  WORLDBOSS_PLAY_RESULT_REPLYT()
      : type(-10852),
        is(OVERLORD::ENUM::CRUD_CRUD_FAIL),
        isWin(false) {
  }
};

struct WORLDBOSS_PLAY_RESULT_REPLY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WORLDBOSS_PLAY_RESULT_REPLYT NativeTableType;
  enum {
    VT_TYPE = 4,
    VT_ERROR_INFO = 6,
    VT_IS = 8,
    VT_UPDATE = 10,
    VT_WORLDBOSSSTATUS = 12,
    VT_REWARDS = 14,
    VT_ISWIN = 16
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, -10852);
  }
  const OVERLORD::STRUCT::ERROR_INFO *error_info() const {
    return GetPointer<const OVERLORD::STRUCT::ERROR_INFO *>(VT_ERROR_INFO);
  }
  OVERLORD::ENUM::CRUD is() const {
    return static_cast<OVERLORD::ENUM::CRUD>(GetField<int8_t>(VT_IS, 0));
  }
  const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *update() const {
    return GetPointer<const OVERLORD::STRUCT::UPDATE_PACKET_SLIM *>(VT_UPDATE);
  }
  const OVERLORD::STRUCT::WORLDBOSS_STATUS *worldbossStatus() const {
    return GetPointer<const OVERLORD::STRUCT::WORLDBOSS_STATUS *>(VT_WORLDBOSSSTATUS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *>(VT_REWARDS);
  }
  bool isWin() const {
    return GetField<uint8_t>(VT_ISWIN, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_ERROR_INFO) &&
           verifier.VerifyTable(error_info()) &&
           VerifyField<int8_t>(verifier, VT_IS) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_WORLDBOSSSTATUS) &&
           verifier.VerifyTable(worldbossStatus()) &&
           VerifyOffset(verifier, VT_REWARDS) &&
           verifier.Verify(rewards()) &&
           verifier.VerifyVectorOfTables(rewards()) &&
           VerifyField<uint8_t>(verifier, VT_ISWIN) &&
           verifier.EndTable();
  }
  WORLDBOSS_PLAY_RESULT_REPLYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WORLDBOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WORLDBOSS_PLAY_RESULT_REPLYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(WORLDBOSS_PLAY_RESULT_REPLY::VT_TYPE, type, -10852);
  }
  void add_error_info(flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT_REPLY::VT_ERROR_INFO, error_info);
  }
  void add_is(OVERLORD::ENUM::CRUD is) {
    fbb_.AddElement<int8_t>(WORLDBOSS_PLAY_RESULT_REPLY::VT_IS, static_cast<int8_t>(is), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT_REPLY::VT_UPDATE, update);
  }
  void add_worldbossStatus(flatbuffers::Offset<OVERLORD::STRUCT::WORLDBOSS_STATUS> worldbossStatus) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT_REPLY::VT_WORLDBOSSSTATUS, worldbossStatus);
  }
  void add_rewards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards) {
    fbb_.AddOffset(WORLDBOSS_PLAY_RESULT_REPLY::VT_REWARDS, rewards);
  }
  void add_isWin(bool isWin) {
    fbb_.AddElement<uint8_t>(WORLDBOSS_PLAY_RESULT_REPLY::VT_ISWIN, static_cast<uint8_t>(isWin), 0);
  }
  explicit WORLDBOSS_PLAY_RESULT_REPLYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WORLDBOSS_PLAY_RESULT_REPLYBuilder &operator=(const WORLDBOSS_PLAY_RESULT_REPLYBuilder &);
  flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY>(end);
    return o;
  }
};

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> CreateWORLDBOSS_PLAY_RESULT_REPLY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10852,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::WORLDBOSS_STATUS> worldbossStatus = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>> rewards = 0,
    bool isWin = false) {
  WORLDBOSS_PLAY_RESULT_REPLYBuilder builder_(_fbb);
  builder_.add_rewards(rewards);
  builder_.add_worldbossStatus(worldbossStatus);
  builder_.add_update(update);
  builder_.add_error_info(error_info);
  builder_.add_type(type);
  builder_.add_isWin(isWin);
  builder_.add_is(is);
  return builder_.Finish();
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> CreateWORLDBOSS_PLAY_RESULT_REPLYDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = -10852,
    flatbuffers::Offset<OVERLORD::STRUCT::ERROR_INFO> error_info = 0,
    OVERLORD::ENUM::CRUD is = OVERLORD::ENUM::CRUD_CRUD_FAIL,
    flatbuffers::Offset<OVERLORD::STRUCT::UPDATE_PACKET_SLIM> update = 0,
    flatbuffers::Offset<OVERLORD::STRUCT::WORLDBOSS_STATUS> worldbossStatus = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> *rewards = nullptr,
    bool isWin = false) {
  return OVERLORD::RESPONSE::CreateWORLDBOSS_PLAY_RESULT_REPLY(
      _fbb,
      type,
      error_info,
      is,
      update,
      worldbossStatus,
      rewards ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>>(*rewards) : 0,
      isWin);
}

flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> CreateWORLDBOSS_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

}  // namespace RESPONSE

namespace STRUCT {

inline DECKST *DECKS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DECKST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DECKS::UnPackTo(DECKST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = campaignThree(); if (_e) { _o->campaignThree.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->campaignThree[_i] = _e->Get(_i)->str(); } } };
  { auto _e = campaignOne(); if (_e) { _o->campaignOne.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->campaignOne[_i] = _e->Get(_i)->str(); } } };
  { auto _e = mirror(); if (_e) { _o->mirror.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mirror[_i] = _e->Get(_i)->str(); } } };
  { auto _e = arena(); if (_e) { _o->arena.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->arena[_i] = _e->Get(_i)->str(); } } };
  { auto _e = defense(); if (_e) { _o->defense.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->defense[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<DECKS> DECKS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DECKST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDECKS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DECKS> CreateDECKS(flatbuffers::FlatBufferBuilder &_fbb, const DECKST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DECKST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _campaignThree = _o->campaignThree.size() ? _fbb.CreateVectorOfStrings(_o->campaignThree) : 0;
  auto _campaignOne = _o->campaignOne.size() ? _fbb.CreateVectorOfStrings(_o->campaignOne) : 0;
  auto _mirror = _o->mirror.size() ? _fbb.CreateVectorOfStrings(_o->mirror) : 0;
  auto _arena = _o->arena.size() ? _fbb.CreateVectorOfStrings(_o->arena) : 0;
  auto _defense = _o->defense.size() ? _fbb.CreateVectorOfStrings(_o->defense) : 0;
  return OVERLORD::STRUCT::CreateDECKS(
      _fbb,
      _campaignThree,
      _campaignOne,
      _mirror,
      _arena,
      _defense);
}

inline AVATART *AVATAR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATART();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR::UnPackTo(AVATART *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = now(); if (_e) _o->now = _e->str(); };
  { auto _e = ability(); if (_e) { _o->ability.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ability[_i] = _e->Get(_i); } } };
  { auto _e = icon(); _o->icon = _e; };
}

inline flatbuffers::Offset<AVATAR> AVATAR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATART* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR> CreateAVATAR(flatbuffers::FlatBufferBuilder &_fbb, const AVATART *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATART* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _exp = _o->exp;
  auto _now = _o->now.empty() ? 0 : _fbb.CreateString(_o->now);
  auto _ability = _o->ability.size() ? _fbb.CreateVector(_o->ability) : 0;
  auto _icon = _o->icon;
  return OVERLORD::STRUCT::CreateAVATAR(
      _fbb,
      _kId,
      _nick,
      _level,
      _exp,
      _now,
      _ability,
      _icon);
}

inline HEROT *HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO::UnPackTo(HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = equipedItemUDs(); if (_e) { _o->equipedItemUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->equipedItemUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = skills(); if (_e) { _o->skills.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->skills[_i] = _e->Get(_i); } } };
  { auto _e = enchantStat(); if (_e) { _o->enchantStat.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enchantStat[_i] = _e->Get(_i); } } };
  { auto _e = enchantPoint(); _o->enchantPoint = _e; };
  { auto _e = locked(); _o->locked = _e; };
}

inline flatbuffers::Offset<HERO> HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO> CreateHERO(flatbuffers::FlatBufferBuilder &_fbb, const HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  auto _exp = _o->exp;
  auto _equipedItemUDs = _o->equipedItemUDs.size() ? _fbb.CreateVectorOfStrings(_o->equipedItemUDs) : 0;
  auto _skills = _o->skills.size() ? _fbb.CreateVector(_o->skills) : 0;
  auto _enchantStat = _o->enchantStat.size() ? _fbb.CreateVector(_o->enchantStat) : 0;
  auto _enchantPoint = _o->enchantPoint;
  auto _locked = _o->locked;
  return OVERLORD::STRUCT::CreateHERO(
      _fbb,
      _heroUD,
      _heroId,
      _level,
      _exp,
      _equipedItemUDs,
      _skills,
      _enchantStat,
      _enchantPoint,
      _locked);
}

inline HERO_CONFIGT *HERO_CONFIG::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_CONFIGT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_CONFIG::UnPackTo(HERO_CONFIGT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = contents(); _o->contents = _e; };
  { auto _e = preferTarget(); _o->preferTarget = _e; };
  { auto _e = skills(); if (_e) { _o->skills.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->skills[_i] = _e->Get(_i) != 0; } } };
}

inline flatbuffers::Offset<HERO_CONFIG> HERO_CONFIG::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_CONFIGT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_CONFIG(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_CONFIG> CreateHERO_CONFIG(flatbuffers::FlatBufferBuilder &_fbb, const HERO_CONFIGT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_CONFIGT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _contents = _o->contents;
  auto _preferTarget = _o->preferTarget;
  auto _skills = _o->skills.size() ? _fbb.CreateVector(_o->skills) : 0;
  return OVERLORD::STRUCT::CreateHERO_CONFIG(
      _fbb,
      _heroUD,
      _contents,
      _preferTarget,
      _skills);
}

inline ITEM_OPTIONT *ITEM_OPTION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ITEM_OPTIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ITEM_OPTION::UnPackTo(ITEM_OPTIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = idx(); _o->idx = _e; };
  { auto _e = factor(); _o->factor = _e; };
}

inline flatbuffers::Offset<ITEM_OPTION> ITEM_OPTION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateITEM_OPTION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ITEM_OPTION> CreateITEM_OPTION(flatbuffers::FlatBufferBuilder &_fbb, const ITEM_OPTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ITEM_OPTIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _idx = _o->idx;
  auto _factor = _o->factor;
  return OVERLORD::STRUCT::CreateITEM_OPTION(
      _fbb,
      _idx,
      _factor);
}

inline ITEMT *ITEM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ITEMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ITEM::UnPackTo(ITEMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = enchant(); _o->enchant = _e; };
  { auto _e = enchantLocked(); _o->enchantLocked = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = options(); if (_e) { _o->options.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->options[_i] = std::unique_ptr<ITEM_OPTIONT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = runes(); if (_e) { _o->runes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->runes[_i] = _e->Get(_i)->str(); } } };
  { auto _e = equipedHeroUD(); if (_e) _o->equipedHeroUD = _e->str(); };
  { auto _e = locked(); _o->locked = _e; };
}

inline flatbuffers::Offset<ITEM> ITEM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateITEM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ITEM> CreateITEM(flatbuffers::FlatBufferBuilder &_fbb, const ITEMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ITEMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _enchant = _o->enchant;
  auto _enchantLocked = _o->enchantLocked;
  auto _level = _o->level;
  auto _exp = _o->exp;
  auto _options = _o->options.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM_OPTION>> (_o->options.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM_OPTION(*__va->__fbb, __va->__o->options[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _runes = _o->runes.size() ? _fbb.CreateVectorOfStrings(_o->runes) : 0;
  auto _equipedHeroUD = _o->equipedHeroUD.empty() ? 0 : _fbb.CreateString(_o->equipedHeroUD);
  auto _locked = _o->locked;
  return OVERLORD::STRUCT::CreateITEM(
      _fbb,
      _itemUD,
      _itemId,
      _enchant,
      _enchantLocked,
      _level,
      _exp,
      _options,
      _runes,
      _equipedHeroUD,
      _locked);
}

inline REWARDT *REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REWARD::UnPackTo(REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = rewardId(); if (_e) _o->rewardId = _e->str(); };
  { auto _e = amt(); _o->amt = _e; };
  { auto _e = prob(); _o->prob = _e; };
}

inline flatbuffers::Offset<REWARD> REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REWARD> CreateREWARD(flatbuffers::FlatBufferBuilder &_fbb, const REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _rewardId = _o->rewardId.empty() ? 0 : _fbb.CreateString(_o->rewardId);
  auto _amt = _o->amt;
  auto _prob = _o->prob;
  return OVERLORD::STRUCT::CreateREWARD(
      _fbb,
      _type,
      _rewardId,
      _amt,
      _prob);
}

inline REWARDSETT *REWARDSET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REWARDSETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REWARDSET::UnPackTo(REWARDSETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<REWARDSET> REWARDSET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REWARDSETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREWARDSET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REWARDSET> CreateREWARDSET(flatbuffers::FlatBufferBuilder &_fbb, const REWARDSETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REWARDSETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateREWARDSET(
      _fbb,
      _rewards);
}

inline PLAY_DECKT *PLAY_DECK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PLAY_DECKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PLAY_DECK::UnPackTo(PLAY_DECKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deckUD(); if (_e) _o->deckUD = _e->str(); };
  { auto _e = pno(); _o->pno = _e; };
  { auto _e = formation(); _o->formation = _e; };
  { auto _e = heroUDs(); if (_e) { _o->heroUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = power(); _o->power = _e; };
}

inline flatbuffers::Offset<PLAY_DECK> PLAY_DECK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_DECKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePLAY_DECK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PLAY_DECK> CreatePLAY_DECK(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_DECKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PLAY_DECKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deckUD = _o->deckUD.empty() ? 0 : _fbb.CreateString(_o->deckUD);
  auto _pno = _o->pno;
  auto _formation = _o->formation;
  auto _heroUDs = _o->heroUDs.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs) : 0;
  auto _power = _o->power;
  return OVERLORD::STRUCT::CreatePLAY_DECK(
      _fbb,
      _deckUD,
      _pno,
      _formation,
      _heroUDs,
      _power);
}

inline EQUIPED_HEROT *EQUIPED_HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EQUIPED_HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EQUIPED_HERO::UnPackTo(EQUIPED_HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = equipedItems(); if (_e) { _o->equipedItems.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->equipedItems[_i] = std::unique_ptr<ITEMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = skills(); if (_e) { _o->skills.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->skills[_i] = _e->Get(_i); } } };
  { auto _e = enchantStat(); if (_e) { _o->enchantStat.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enchantStat[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<EQUIPED_HERO> EQUIPED_HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EQUIPED_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEQUIPED_HERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EQUIPED_HERO> CreateEQUIPED_HERO(flatbuffers::FlatBufferBuilder &_fbb, const EQUIPED_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EQUIPED_HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  auto _equipedItems = _o->equipedItems.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM>> (_o->equipedItems.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM(*__va->__fbb, __va->__o->equipedItems[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _skills = _o->skills.size() ? _fbb.CreateVector(_o->skills) : 0;
  auto _enchantStat = _o->enchantStat.size() ? _fbb.CreateVector(_o->enchantStat) : 0;
  return OVERLORD::STRUCT::CreateEQUIPED_HERO(
      _fbb,
      _heroUD,
      _heroId,
      _level,
      _equipedItems,
      _skills,
      _enchantStat);
}

inline HERO_SNIPPETT *HERO_SNIPPET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_SNIPPETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_SNIPPET::UnPackTo(HERO_SNIPPETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<HERO_SNIPPET> HERO_SNIPPET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SNIPPETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_SNIPPET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_SNIPPET> CreateHERO_SNIPPET(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SNIPPETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_SNIPPETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _grade = _o->grade;
  auto _level = _o->level;
  return OVERLORD::STRUCT::CreateHERO_SNIPPET(
      _fbb,
      _heroUD,
      _heroId,
      _grade,
      _level);
}

inline RAID_STAGET *RAID_STAGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RAID_STAGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RAID_STAGE::UnPackTo(RAID_STAGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = boss(); if (_e) _o->boss = _e->str(); };
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
  { auto _e = modes(); if (_e) { _o->modes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->modes[_i] = _e->Get(_i); } } };
  { auto _e = left(); _o->left = _e; };
  { auto _e = ds(); if (_e) { _o->ds.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ds[_i] = _e->Get(_i); } } };
  { auto _e = de(); if (_e) { _o->de.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->de[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<RAID_STAGE> RAID_STAGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRAID_STAGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RAID_STAGE> CreateRAID_STAGE(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RAID_STAGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _boss = _o->boss.empty() ? 0 : _fbb.CreateString(_o->boss);
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  auto _modes = _o->modes.size() ? _fbb.CreateVector(_o->modes) : 0;
  auto _left = _o->left;
  auto _ds = _o->ds.size() ? _fbb.CreateVector(_o->ds) : 0;
  auto _de = _o->de.size() ? _fbb.CreateVector(_o->de) : 0;
  return OVERLORD::STRUCT::CreateRAID_STAGE(
      _fbb,
      _boss,
      _stageId,
      _modes,
      _left,
      _ds,
      _de);
}

inline RAID_STAGE_PLAYT *RAID_STAGE_PLAY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new RAID_STAGE_PLAYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void RAID_STAGE_PLAY::UnPackTo(RAID_STAGE_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
  { auto _e = c(); _o->c = _e; };
  { auto _e = m(); _o->m = _e; };
}

inline flatbuffers::Offset<RAID_STAGE_PLAY> RAID_STAGE_PLAY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGE_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRAID_STAGE_PLAY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RAID_STAGE_PLAY> CreateRAID_STAGE_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const RAID_STAGE_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RAID_STAGE_PLAYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  auto _c = _o->c;
  auto _m = _o->m;
  return OVERLORD::STRUCT::CreateRAID_STAGE_PLAY(
      _fbb,
      _stageId,
      _c,
      _m);
}

inline EPISODET *EPISODE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EPISODET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EPISODE::UnPackTo(EPISODET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = episodeId(); if (_e) _o->episodeId = _e->str(); };
  { auto _e = max(); _o->max = _e; };
  { auto _e = trial(); _o->trial = _e; };
  { auto _e = stages(); if (_e) { _o->stages.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->stages[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<EPISODE> EPISODE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EPISODET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEPISODE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EPISODE> CreateEPISODE(flatbuffers::FlatBufferBuilder &_fbb, const EPISODET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EPISODET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _episodeId = _o->episodeId.empty() ? 0 : _fbb.CreateString(_o->episodeId);
  auto _max = _o->max;
  auto _trial = _o->trial;
  auto _stages = _o->stages.size() ? _fbb.CreateVector(_o->stages) : 0;
  return OVERLORD::STRUCT::CreateEPISODE(
      _fbb,
      _episodeId,
      _max,
      _trial,
      _stages);
}

inline CHAPTERT *CHAPTER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAPTERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAPTER::UnPackTo(CHAPTERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chapterId(); if (_e) _o->chapterId = _e->str(); };
  { auto _e = stars(); _o->stars = _e; };
  { auto _e = clears(); _o->clears = _e; };
  { auto _e = episodes(); if (_e) { _o->episodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->episodes[_i] = std::unique_ptr<EPISODET>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<CHAPTER> CHAPTER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAPTERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAPTER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAPTER> CreateCHAPTER(flatbuffers::FlatBufferBuilder &_fbb, const CHAPTERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAPTERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chapterId = _o->chapterId.empty() ? 0 : _fbb.CreateString(_o->chapterId);
  auto _stars = _o->stars;
  auto _clears = _o->clears;
  auto _episodes = _o->episodes.size() ? _fbb.CreateVector<flatbuffers::Offset<EPISODE>> (_o->episodes.size(), [](size_t i, _VectorArgs *__va) { return CreateEPISODE(*__va->__fbb, __va->__o->episodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateCHAPTER(
      _fbb,
      _chapterId,
      _stars,
      _clears,
      _episodes);
}

inline ACHIEVE_STATUST *ACHIEVE_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACHIEVE_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACHIEVE_STATUS::UnPackTo(ACHIEVE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = srl(); _o->srl = _e; };
  { auto _e = amt(); _o->amt = _e; };
  { auto _e = passed_level(); _o->passed_level = _e; };
  { auto _e = unlocked(); _o->unlocked = _e; };
}

inline flatbuffers::Offset<ACHIEVE_STATUS> ACHIEVE_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACHIEVE_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACHIEVE_STATUS> CreateACHIEVE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACHIEVE_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _srl = _o->srl;
  auto _amt = _o->amt;
  auto _passed_level = _o->passed_level;
  auto _unlocked = _o->unlocked;
  return OVERLORD::STRUCT::CreateACHIEVE_STATUS(
      _fbb,
      _type,
      _srl,
      _amt,
      _passed_level,
      _unlocked);
}

inline ACHIEVE_UPDATET *ACHIEVE_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACHIEVE_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACHIEVE_UPDATE::UnPackTo(ACHIEVE_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = srl(); _o->srl = _e; };
  { auto _e = amt(); _o->amt = _e; };
  { auto _e = passed_level(); _o->passed_level = _e; };
  { auto _e = unlocked(); _o->unlocked = _e; };
}

inline flatbuffers::Offset<ACHIEVE_UPDATE> ACHIEVE_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACHIEVE_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACHIEVE_UPDATE> CreateACHIEVE_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACHIEVE_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACHIEVE_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _srl = _o->srl;
  auto _amt = _o->amt;
  auto _passed_level = _o->passed_level;
  auto _unlocked = _o->unlocked;
  return OVERLORD::STRUCT::CreateACHIEVE_UPDATE(
      _fbb,
      _type,
      _srl,
      _amt,
      _passed_level,
      _unlocked);
}

inline ERROR_INFOT *ERROR_INFO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ERROR_INFOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ERROR_INFO::UnPackTo(ERROR_INFOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = code(); if (_e) _o->code = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = desc(); if (_e) { _o->desc.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->desc[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<ERROR_INFO> ERROR_INFO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ERROR_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateERROR_INFO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ERROR_INFO> CreateERROR_INFO(flatbuffers::FlatBufferBuilder &_fbb, const ERROR_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ERROR_INFOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _desc = _o->desc.size() ? _fbb.CreateVectorOfStrings(_o->desc) : 0;
  return OVERLORD::STRUCT::CreateERROR_INFO(
      _fbb,
      _code,
      _name,
      _desc);
}

inline MAILT *MAIL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MAILT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MAIL::UnPackTo(MAILT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mailUD(); if (_e) _o->mailUD = _e->str(); };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = from(); if (_e) _o->from = _e->str(); };
  { auto _e = subject(); if (_e) _o->subject = _e->str(); };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
  { auto _e = created(); if (_e) _o->created = _e->str(); };
  { auto _e = expire(); if (_e) _o->expire = _e->str(); };
  { auto _e = attach(); if (_e) { _o->attach.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->attach[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = isNew(); _o->isNew = _e; };
}

inline flatbuffers::Offset<MAIL> MAIL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MAILT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMAIL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MAIL> CreateMAIL(flatbuffers::FlatBufferBuilder &_fbb, const MAILT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MAILT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mailUD = _o->mailUD.empty() ? 0 : _fbb.CreateString(_o->mailUD);
  auto _kId = _o->kId;
  auto _from = _o->from.empty() ? 0 : _fbb.CreateString(_o->from);
  auto _subject = _o->subject.empty() ? 0 : _fbb.CreateString(_o->subject);
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _created = _o->created.empty() ? 0 : _fbb.CreateString(_o->created);
  auto _expire = _o->expire.empty() ? 0 : _fbb.CreateString(_o->expire);
  auto _attach = _o->attach.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->attach.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->attach[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _isNew = _o->isNew;
  return OVERLORD::STRUCT::CreateMAIL(
      _fbb,
      _mailUD,
      _kId,
      _from,
      _subject,
      _desc,
      _created,
      _expire,
      _attach,
      _isNew);
}

inline PDT *PD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD::UnPackTo(PDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = sublevel(); _o->sublevel = _e; };
  { auto _e = exp(); _o->exp = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = shards(); _o->shards = _e; };
  { auto _e = ticket(); _o->ticket = _e; };
  { auto _e = chip(); _o->chip = _e; };
  { auto _e = gp(); _o->gp = _e; };
  { auto _e = cp(); _o->cp = _e; };
  { auto _e = ap(); _o->ap = _e; };
  { auto _e = dp(); _o->dp = _e; };
  { auto _e = defWin(); _o->defWin = _e; };
  { auto _e = defCnt(); _o->defCnt = _e; };
  { auto _e = lock(); _o->lock = _e; };
}

inline flatbuffers::Offset<PD> PD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD> CreatePD(flatbuffers::FlatBufferBuilder &_fbb, const PDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _level = _o->level;
  auto _sublevel = _o->sublevel;
  auto _exp = _o->exp;
  auto _type = _o->type;
  auto _shards = _o->shards;
  auto _ticket = _o->ticket;
  auto _chip = _o->chip;
  auto _gp = _o->gp;
  auto _cp = _o->cp;
  auto _ap = _o->ap;
  auto _dp = _o->dp;
  auto _defWin = _o->defWin;
  auto _defCnt = _o->defCnt;
  auto _lock = _o->lock;
  return OVERLORD::STRUCT::CreatePD(
      _fbb,
      _kId,
      _name,
      _level,
      _sublevel,
      _exp,
      _type,
      _shards,
      _ticket,
      _chip,
      _gp,
      _cp,
      _ap,
      _dp,
      _defWin,
      _defCnt,
      _lock);
}

inline PD_CHRONICLET *PD_CHRONICLE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_CHRONICLET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_CHRONICLE::UnPackTo(PD_CHRONICLET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = when(); if (_e) _o->when = _e->str(); };
  { auto _e = msg(); if (_e) _o->msg = _e->str(); };
}

inline flatbuffers::Offset<PD_CHRONICLE> PD_CHRONICLE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_CHRONICLET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_CHRONICLE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_CHRONICLE> CreatePD_CHRONICLE(flatbuffers::FlatBufferBuilder &_fbb, const PD_CHRONICLET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_CHRONICLET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _when = _o->when.empty() ? 0 : _fbb.CreateString(_o->when);
  auto _msg = _o->msg.empty() ? 0 : _fbb.CreateString(_o->msg);
  return OVERLORD::STRUCT::CreatePD_CHRONICLE(
      _fbb,
      _when,
      _msg);
}

inline PD_DEFENCET *PD_DEFENCE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_DEFENCET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_DEFENCE::UnPackTo(PD_DEFENCET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = defeated(); _o->defeated = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = chip(); _o->chip = _e; };
  { auto _e = gp(); _o->gp = _e; };
  { auto _e = dp(); _o->dp = _e; };
  { auto _e = deadHeros(); if (_e) { _o->deadHeros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->deadHeros[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<PD_DEFENCE> PD_DEFENCE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_DEFENCET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_DEFENCE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_DEFENCE> CreatePD_DEFENCE(flatbuffers::FlatBufferBuilder &_fbb, const PD_DEFENCET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_DEFENCET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _defeated = _o->defeated;
  auto _level = _o->level;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _chip = _o->chip;
  auto _gp = _o->gp;
  auto _dp = _o->dp;
  auto _deadHeros = _o->deadHeros.size() ? _fbb.CreateVectorOfStrings(_o->deadHeros) : 0;
  return OVERLORD::STRUCT::CreatePD_DEFENCE(
      _fbb,
      _defeated,
      _level,
      _nick,
      _guild,
      _chip,
      _gp,
      _dp,
      _deadHeros);
}

inline PD_SNIPPETT *PD_SNIPPET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_SNIPPETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_SNIPPET::UnPackTo(PD_SNIPPETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = defWin(); _o->defWin = _e; };
  { auto _e = defCnt(); _o->defCnt = _e; };
  { auto _e = rank(); _o->rank = _e; };
}

inline flatbuffers::Offset<PD_SNIPPET> PD_SNIPPET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_SNIPPETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_SNIPPET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_SNIPPET> CreatePD_SNIPPET(flatbuffers::FlatBufferBuilder &_fbb, const PD_SNIPPETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_SNIPPETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _defWin = _o->defWin;
  auto _defCnt = _o->defCnt;
  auto _rank = _o->rank;
  return OVERLORD::STRUCT::CreatePD_SNIPPET(
      _fbb,
      _kId,
      _name,
      _level,
      _guild,
      _defWin,
      _defCnt,
      _rank);
}

inline PD_MINIONT *PD_MINION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_MINIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_MINION::UnPackTo(PD_MINIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = UD(); if (_e) _o->UD = _e->str(); };
  { auto _e = mId(); if (_e) _o->mId = _e->str(); };
  { auto _e = mType(); _o->mType = _e; };
  { auto _e = level(); _o->level = _e; };
  { auto _e = left(); _o->left = _e; };
}

inline flatbuffers::Offset<PD_MINION> PD_MINION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_MINION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_MINION> CreatePD_MINION(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_MINIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _UD = _o->UD.empty() ? 0 : _fbb.CreateString(_o->UD);
  auto _mId = _o->mId.empty() ? 0 : _fbb.CreateString(_o->mId);
  auto _mType = _o->mType;
  auto _level = _o->level;
  auto _left = _o->left;
  return OVERLORD::STRUCT::CreatePD_MINION(
      _fbb,
      _UD,
      _mId,
      _mType,
      _level,
      _left);
}

inline PD_MINION_INVENT *PD_MINION_INVEN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_MINION_INVENT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_MINION_INVEN::UnPackTo(PD_MINION_INVENT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = supplied(); if (_e) { _o->supplied.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->supplied[_i] = std::unique_ptr<PD_MINIONT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = purchased(); if (_e) { _o->purchased.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->purchased[_i] = std::unique_ptr<PD_MINIONT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<PD_MINION_INVEN> PD_MINION_INVEN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINION_INVENT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_MINION_INVEN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_MINION_INVEN> CreatePD_MINION_INVEN(flatbuffers::FlatBufferBuilder &_fbb, const PD_MINION_INVENT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_MINION_INVENT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _supplied = _o->supplied.size() ? _fbb.CreateVector<flatbuffers::Offset<PD_MINION>> (_o->supplied.size(), [](size_t i, _VectorArgs *__va) { return CreatePD_MINION(*__va->__fbb, __va->__o->supplied[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _purchased = _o->purchased.size() ? _fbb.CreateVector<flatbuffers::Offset<PD_MINION>> (_o->purchased.size(), [](size_t i, _VectorArgs *__va) { return CreatePD_MINION(*__va->__fbb, __va->__o->purchased[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreatePD_MINION_INVEN(
      _fbb,
      _supplied,
      _purchased);
}

inline PD_TARGETT *PD_TARGET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_TARGETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_TARGET::UnPackTo(PD_TARGETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = avatar(); if (_e) _o->avatar = std::unique_ptr<AVATART>(_e->UnPack(_resolver)); };
  { auto _e = heros(); if (_e) { _o->heros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros[_i] = std::unique_ptr<EQUIPED_HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = minions(); if (_e) _o->minions = std::unique_ptr<PD_MINION_INVENT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<PD_TARGET> PD_TARGET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_TARGETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_TARGET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_TARGET> CreatePD_TARGET(flatbuffers::FlatBufferBuilder &_fbb, const PD_TARGETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_TARGETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _avatar = _o->avatar ? CreateAVATAR(_fbb, _o->avatar.get(), _rehasher) : 0;
  auto _heros = _o->heros.size() ? _fbb.CreateVector<flatbuffers::Offset<EQUIPED_HERO>> (_o->heros.size(), [](size_t i, _VectorArgs *__va) { return CreateEQUIPED_HERO(*__va->__fbb, __va->__o->heros[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _minions = _o->minions ? CreatePD_MINION_INVEN(_fbb, _o->minions.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreatePD_TARGET(
      _fbb,
      _kId,
      _avatar,
      _heros,
      _minions);
}

inline PD_TREASURENPCT *PD_TREASURENPC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PD_TREASURENPCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PD_TREASURENPC::UnPackTo(PD_TREASURENPCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mId(); if (_e) _o->mId = _e->str(); };
  { auto _e = room(); _o->room = _e; };
}

inline flatbuffers::Offset<PD_TREASURENPC> PD_TREASURENPC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PD_TREASURENPCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePD_TREASURENPC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PD_TREASURENPC> CreatePD_TREASURENPC(flatbuffers::FlatBufferBuilder &_fbb, const PD_TREASURENPCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PD_TREASURENPCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mId = _o->mId.empty() ? 0 : _fbb.CreateString(_o->mId);
  auto _room = _o->room;
  return OVERLORD::STRUCT::CreatePD_TREASURENPC(
      _fbb,
      _mId,
      _room);
}

inline SHOP_PRODUCT_STATUST *SHOP_PRODUCT_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_PRODUCT_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_PRODUCT_STATUS::UnPackTo(SHOP_PRODUCT_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = productId(); if (_e) _o->productId = _e->str(); };
  { auto _e = buyCount(); _o->buyCount = _e; };
  { auto _e = coolTime(); _o->coolTime = _e; };
}

inline flatbuffers::Offset<SHOP_PRODUCT_STATUS> SHOP_PRODUCT_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_PRODUCT_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_PRODUCT_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_PRODUCT_STATUS> CreateSHOP_PRODUCT_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_PRODUCT_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_PRODUCT_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _productId = _o->productId.empty() ? 0 : _fbb.CreateString(_o->productId);
  auto _buyCount = _o->buyCount;
  auto _coolTime = _o->coolTime;
  return OVERLORD::STRUCT::CreateSHOP_PRODUCT_STATUS(
      _fbb,
      _productId,
      _buyCount,
      _coolTime);
}

inline SHOP_USER_DATAT *SHOP_USER_DATA::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_USER_DATAT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_USER_DATA::UnPackTo(SHOP_USER_DATAT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = productStatus(); if (_e) { _o->productStatus.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->productStatus[_i] = std::unique_ptr<SHOP_PRODUCT_STATUST>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SHOP_USER_DATA> SHOP_USER_DATA::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_USER_DATA(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_USER_DATAT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _productStatus = _o->productStatus.size() ? _fbb.CreateVector<flatbuffers::Offset<SHOP_PRODUCT_STATUS>> (_o->productStatus.size(), [](size_t i, _VectorArgs *__va) { return CreateSHOP_PRODUCT_STATUS(*__va->__fbb, __va->__o->productStatus[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateSHOP_USER_DATA(
      _fbb,
      _kId,
      _productStatus);
}

inline GUILD_INFOT *GUILD_INFO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_INFOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_INFO::UnPackTo(GUILD_INFOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = guild_id(); _o->guild_id = _e; };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = point_rank(); _o->point_rank = _e; };
  { auto _e = gold(); _o->gold = _e; };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
  { auto _e = notice(); if (_e) _o->notice = _e->str(); };
  { auto _e = create_date(); if (_e) _o->create_date = _e->str(); };
  { auto _e = member_count(); _o->member_count = _e; };
  { auto _e = member_limit(); _o->member_limit = _e; };
  { auto _e = auto_grade_up(); _o->auto_grade_up = _e; };
}

inline flatbuffers::Offset<GUILD_INFO> GUILD_INFO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_INFO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_INFO> CreateGUILD_INFO(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_INFOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _guild_id = _o->guild_id;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _level = _o->level;
  auto _point = _o->point;
  auto _point_rank = _o->point_rank;
  auto _gold = _o->gold;
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _notice = _o->notice.empty() ? 0 : _fbb.CreateString(_o->notice);
  auto _create_date = _o->create_date.empty() ? 0 : _fbb.CreateString(_o->create_date);
  auto _member_count = _o->member_count;
  auto _member_limit = _o->member_limit;
  auto _auto_grade_up = _o->auto_grade_up;
  return OVERLORD::STRUCT::CreateGUILD_INFO(
      _fbb,
      _guild_id,
      _name,
      _level,
      _point,
      _point_rank,
      _gold,
      _desc,
      _notice,
      _create_date,
      _member_count,
      _member_limit,
      _auto_grade_up);
}

inline GUILD_MEMBERT *GUILD_MEMBER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER::UnPackTo(GUILD_MEMBERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = guild_id(); _o->guild_id = _e; };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = join_date(); if (_e) _o->join_date = _e->str(); };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = last_update(); _o->last_update = _e; };
}

inline flatbuffers::Offset<GUILD_MEMBER> GUILD_MEMBER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER> CreateGUILD_MEMBER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _guild_id = _o->guild_id;
  auto _grade = _o->grade;
  auto _point = _o->point;
  auto _join_date = _o->join_date.empty() ? 0 : _fbb.CreateString(_o->join_date);
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _last_update = _o->last_update;
  return OVERLORD::STRUCT::CreateGUILD_MEMBER(
      _fbb,
      _kId,
      _guild_id,
      _grade,
      _point,
      _join_date,
      _nick,
      _level,
      _last_update);
}

inline GUILD_AWAITERT *GUILD_AWAITER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER::UnPackTo(GUILD_AWAITERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = elapsedSec(); _o->elapsedSec = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER> GUILD_AWAITER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER> CreateGUILD_AWAITER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _elapsedSec = _o->elapsedSec;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  return OVERLORD::STRUCT::CreateGUILD_AWAITER(
      _fbb,
      _kId,
      _elapsedSec,
      _nick,
      _level);
}

inline GUILD_HISTORYT *GUILD_HISTORY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_HISTORYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_HISTORY::UnPackTo(GUILD_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = target_kId(); _o->target_kId = _e; };
  { auto _e = target_nick(); if (_e) _o->target_nick = _e->str(); };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = time(); if (_e) _o->time = _e->str(); };
}

inline flatbuffers::Offset<GUILD_HISTORY> GUILD_HISTORY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_HISTORY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_HISTORYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _target_kId = _o->target_kId;
  auto _target_nick = _o->target_nick.empty() ? 0 : _fbb.CreateString(_o->target_nick);
  auto _grade = _o->grade;
  auto _time = _o->time.empty() ? 0 : _fbb.CreateString(_o->time);
  return OVERLORD::STRUCT::CreateGUILD_HISTORY(
      _fbb,
      _type,
      _kId,
      _nick,
      _target_kId,
      _target_nick,
      _grade,
      _time);
}

inline GUILD_RAID_CHALLENGET *GUILD_RAID_CHALLENGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RAID_CHALLENGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RAID_CHALLENGE::UnPackTo(GUILD_RAID_CHALLENGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = trial(); _o->trial = _e; };
  { auto _e = spawn(); _o->spawn = _e; };
  { auto _e = leftSec(); _o->leftSec = _e; };
}

inline flatbuffers::Offset<GUILD_RAID_CHALLENGE> GUILD_RAID_CHALLENGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAID_CHALLENGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RAID_CHALLENGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RAID_CHALLENGE> CreateGUILD_RAID_CHALLENGE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAID_CHALLENGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RAID_CHALLENGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _trial = _o->trial;
  auto _spawn = _o->spawn;
  auto _leftSec = _o->leftSec;
  return OVERLORD::STRUCT::CreateGUILD_RAID_CHALLENGE(
      _fbb,
      _kId,
      _nick,
      _trial,
      _spawn,
      _leftSec);
}

inline GUILD_RAIDT *GUILD_RAID::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RAIDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RAID::UnPackTo(GUILD_RAIDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = isOpen(); _o->isOpen = _e; };
  { auto _e = left(); _o->left = _e; };
  { auto _e = captain(); if (_e) _o->captain = _e->str(); };
  { auto _e = members(); _o->members = _e; };
  { auto _e = boss(); if (_e) { _o->boss.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->boss[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<GUILD_RAID> GUILD_RAID::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAIDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RAID(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RAID> CreateGUILD_RAID(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RAIDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RAIDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _grade = _o->grade;
  auto _isOpen = _o->isOpen;
  auto _left = _o->left;
  auto _captain = _o->captain.empty() ? 0 : _fbb.CreateString(_o->captain);
  auto _members = _o->members;
  auto _boss = _o->boss.size() ? _fbb.CreateVectorOfStrings(_o->boss) : 0;
  return OVERLORD::STRUCT::CreateGUILD_RAID(
      _fbb,
      _modId,
      _grade,
      _isOpen,
      _left,
      _captain,
      _members,
      _boss);
}

inline GUILD_MINET *GUILD_MINE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MINET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MINE::UnPackTo(GUILD_MINET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<GUILD_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = guild_member(); if (_e) _o->guild_member = std::unique_ptr<GUILD_MEMBERT>(_e->UnPack(_resolver)); };
  { auto _e = guild_master(); if (_e) _o->guild_master = std::unique_ptr<GUILD_MEMBERT>(_e->UnPack(_resolver)); };
  { auto _e = guild_exist(); _o->guild_exist = _e; };
  { auto _e = isActiveAttendance(); _o->isActiveAttendance = _e; };
  { auto _e = isActiveContribute(); _o->isActiveContribute = _e; };
}

inline flatbuffers::Offset<GUILD_MINE> GUILD_MINE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MINET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MINE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MINE> CreateGUILD_MINE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MINET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MINET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  auto _guild_member = _o->guild_member ? CreateGUILD_MEMBER(_fbb, _o->guild_member.get(), _rehasher) : 0;
  auto _guild_master = _o->guild_master ? CreateGUILD_MEMBER(_fbb, _o->guild_master.get(), _rehasher) : 0;
  auto _guild_exist = _o->guild_exist;
  auto _isActiveAttendance = _o->isActiveAttendance;
  auto _isActiveContribute = _o->isActiveContribute;
  return OVERLORD::STRUCT::CreateGUILD_MINE(
      _fbb,
      _guild_info,
      _guild_member,
      _guild_master,
      _guild_exist,
      _isActiveAttendance,
      _isActiveContribute);
}

inline CHANNEL_EVENTT *CHANNEL_EVENT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_EVENTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_EVENT::UnPackTo(CHANNEL_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eventType(); _o->eventType = _e; };
  { auto _e = value(); _o->value = _e; };
  { auto _e = open(); if (_e) _o->open = _e->str(); };
  { auto _e = close(); if (_e) _o->close = _e->str(); };
}

inline flatbuffers::Offset<CHANNEL_EVENT> CHANNEL_EVENT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_EVENT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_EVENT> CreateCHANNEL_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_EVENTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eventType = _o->eventType;
  auto _value = _o->value;
  auto _open = _o->open.empty() ? 0 : _fbb.CreateString(_o->open);
  auto _close = _o->close.empty() ? 0 : _fbb.CreateString(_o->close);
  return OVERLORD::STRUCT::CreateCHANNEL_EVENT(
      _fbb,
      _eventType,
      _value,
      _open,
      _close);
}

inline CHANNEL_FEATURET *CHANNEL_FEATURE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_FEATURET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_FEATURE::UnPackTo(CHANNEL_FEATURET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eventType(); _o->eventType = _e; };
  { auto _e = value(); _o->value = _e; };
}

inline flatbuffers::Offset<CHANNEL_FEATURE> CHANNEL_FEATURE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_FEATURET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_FEATURE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_FEATURE> CreateCHANNEL_FEATURE(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_FEATURET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_FEATURET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eventType = _o->eventType;
  auto _value = _o->value;
  return OVERLORD::STRUCT::CreateCHANNEL_FEATURE(
      _fbb,
      _eventType,
      _value);
}

inline CHANNEL_GUILDT *CHANNEL_GUILD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_GUILDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_GUILD::UnPackTo(CHANNEL_GUILDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = count(); _o->count = _e; };
}

inline flatbuffers::Offset<CHANNEL_GUILD> CHANNEL_GUILD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_GUILDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_GUILD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_GUILD> CreateCHANNEL_GUILD(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_GUILDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_GUILDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _count = _o->count;
  return OVERLORD::STRUCT::CreateCHANNEL_GUILD(
      _fbb,
      _name,
      _count);
}

inline CHANNEL_DETAILT *CHANNEL_DETAIL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_DETAILT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_DETAIL::UnPackTo(CHANNEL_DETAILT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = limit_lv(); _o->limit_lv = _e; };
  { auto _e = guild_only(); _o->guild_only = _e; };
  { auto _e = owner_guild(); if (_e) _o->owner_guild = _e->str(); };
  { auto _e = count_current(); _o->count_current = _e; };
  { auto _e = count_max(); _o->count_max = _e; };
  { auto _e = guildList(); if (_e) { _o->guildList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guildList[_i] = std::unique_ptr<CHANNEL_GUILDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
  { auto _e = feature(); if (_e) { _o->feature.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->feature[_i] = std::unique_ptr<CHANNEL_FEATURET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = event(); if (_e) { _o->event.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->event[_i] = std::unique_ptr<CHANNEL_EVENTT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = map_name(); if (_e) _o->map_name = _e->str(); };
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CHANNEL_DETAIL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_DETAIL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_DETAILT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _limit_lv = _o->limit_lv;
  auto _guild_only = _o->guild_only;
  auto _owner_guild = _o->owner_guild.empty() ? 0 : _fbb.CreateString(_o->owner_guild);
  auto _count_current = _o->count_current;
  auto _count_max = _o->count_max;
  auto _guildList = _o->guildList.size() ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_GUILD>> (_o->guildList.size(), [](size_t i, _VectorArgs *__va) { return CreateCHANNEL_GUILD(*__va->__fbb, __va->__o->guildList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _feature = _o->feature.size() ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_FEATURE>> (_o->feature.size(), [](size_t i, _VectorArgs *__va) { return CreateCHANNEL_FEATURE(*__va->__fbb, __va->__o->feature[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _event = _o->event.size() ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_EVENT>> (_o->event.size(), [](size_t i, _VectorArgs *__va) { return CreateCHANNEL_EVENT(*__va->__fbb, __va->__o->event[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _map_name = _o->map_name.empty() ? 0 : _fbb.CreateString(_o->map_name);
  return OVERLORD::STRUCT::CreateCHANNEL_DETAIL(
      _fbb,
      _limit_lv,
      _guild_only,
      _owner_guild,
      _count_current,
      _count_max,
      _guildList,
      _desc,
      _feature,
      _event,
      _map_name);
}

inline CHANNEL_INFOT *CHANNEL_INFO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_INFOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_INFO::UnPackTo(CHANNEL_INFOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = no(); _o->no = _e; };
  { auto _e = ip(); if (_e) _o->ip = _e->str(); };
  { auto _e = port(); _o->port = _e; };
  { auto _e = enter_current(); _o->enter_current = _e; };
  { auto _e = enter_max(); _o->enter_max = _e; };
  { auto _e = owner_guild_name(); if (_e) _o->owner_guild_name = _e->str(); };
  { auto _e = event_current(); if (_e) { _o->event_current.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->event_current[_i] = std::unique_ptr<CHANNEL_EVENTT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<CHANNEL_INFO> CHANNEL_INFO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_INFO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_INFO> CreateCHANNEL_INFO(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_INFOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _no = _o->no;
  auto _ip = _o->ip.empty() ? 0 : _fbb.CreateString(_o->ip);
  auto _port = _o->port;
  auto _enter_current = _o->enter_current;
  auto _enter_max = _o->enter_max;
  auto _owner_guild_name = _o->owner_guild_name.empty() ? 0 : _fbb.CreateString(_o->owner_guild_name);
  auto _event_current = _o->event_current.size() ? _fbb.CreateVector<flatbuffers::Offset<CHANNEL_EVENT>> (_o->event_current.size(), [](size_t i, _VectorArgs *__va) { return CreateCHANNEL_EVENT(*__va->__fbb, __va->__o->event_current[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateCHANNEL_INFO(
      _fbb,
      _no,
      _ip,
      _port,
      _enter_current,
      _enter_max,
      _owner_guild_name,
      _event_current);
}

inline PLAY_CLEAR_GRADE_STATUST *PLAY_CLEAR_GRADE_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new PLAY_CLEAR_GRADE_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void PLAY_CLEAR_GRADE_STATUS::UnPackTo(PLAY_CLEAR_GRADE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
  { auto _e = clearGrade(); _o->clearGrade = _e; };
}

inline flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> PLAY_CLEAR_GRADE_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_CLEAR_GRADE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePLAY_CLEAR_GRADE_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<PLAY_CLEAR_GRADE_STATUS> CreatePLAY_CLEAR_GRADE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const PLAY_CLEAR_GRADE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PLAY_CLEAR_GRADE_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  auto _clearGrade = _o->clearGrade;
  return OVERLORD::STRUCT::CreatePLAY_CLEAR_GRADE_STATUS(
      _fbb,
      _stageId,
      _clearGrade);
}

inline GUILD_RUNE_REQUESTERT *GUILD_RUNE_REQUESTER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_REQUESTERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_REQUESTER::UnPackTo(GUILD_RUNE_REQUESTERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = timeLeft(); _o->timeLeft = _e; };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = maxAmount(); _o->maxAmount = _e; };
  { auto _e = currentAmount(); _o->currentAmount = _e; };
  { auto _e = gettable(); _o->gettable = _e; };
}

inline flatbuffers::Offset<GUILD_RUNE_REQUESTER> GUILD_RUNE_REQUESTER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_REQUESTER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_REQUESTER> CreateGUILD_RUNE_REQUESTER(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_REQUESTERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _timeLeft = _o->timeLeft;
  auto _grade = _o->grade;
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _maxAmount = _o->maxAmount;
  auto _currentAmount = _o->currentAmount;
  auto _gettable = _o->gettable;
  return OVERLORD::STRUCT::CreateGUILD_RUNE_REQUESTER(
      _fbb,
      _kId,
      _nick,
      _timeLeft,
      _grade,
      _heroId,
      _maxAmount,
      _currentAmount,
      _gettable);
}

inline CAMPAIGN_QUEST_STATUST *CAMPAIGN_QUEST_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CAMPAIGN_QUEST_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CAMPAIGN_QUEST_STATUS::UnPackTo(CAMPAIGN_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = questId(); if (_e) _o->questId = _e->str(); };
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
  { auto _e = value(); _o->value = _e; };
  { auto _e = trial(); _o->trial = _e; };
}

inline flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> CAMPAIGN_QUEST_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCAMPAIGN_QUEST_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CAMPAIGN_QUEST_STATUS> CreateCAMPAIGN_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CAMPAIGN_QUEST_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _questId = _o->questId.empty() ? 0 : _fbb.CreateString(_o->questId);
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  auto _value = _o->value;
  auto _trial = _o->trial;
  return OVERLORD::STRUCT::CreateCAMPAIGN_QUEST_STATUS(
      _fbb,
      _questId,
      _stageId,
      _value,
      _trial);
}

inline CAMPAIGN_QUESTT *CAMPAIGN_QUEST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CAMPAIGN_QUESTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CAMPAIGN_QUEST::UnPackTo(CAMPAIGN_QUESTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = std::unique_ptr<CAMPAIGN_QUEST_STATUST>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rewardable(); _o->rewardable = _e; };
  { auto _e = rewardKey(); if (_e) _o->rewardKey = _e->str(); };
}

inline flatbuffers::Offset<CAMPAIGN_QUEST> CAMPAIGN_QUEST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCAMPAIGN_QUEST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CAMPAIGN_QUEST> CreateCAMPAIGN_QUEST(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_QUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CAMPAIGN_QUESTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _list = _o->list.size() ? _fbb.CreateVector<flatbuffers::Offset<CAMPAIGN_QUEST_STATUS>> (_o->list.size(), [](size_t i, _VectorArgs *__va) { return CreateCAMPAIGN_QUEST_STATUS(*__va->__fbb, __va->__o->list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rewardable = _o->rewardable;
  auto _rewardKey = _o->rewardKey.empty() ? 0 : _fbb.CreateString(_o->rewardKey);
  return OVERLORD::STRUCT::CreateCAMPAIGN_QUEST(
      _fbb,
      _list,
      _rewardable,
      _rewardKey);
}

inline CAMPAIGN_STATUST *CAMPAIGN_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CAMPAIGN_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CAMPAIGN_STATUS::UnPackTo(CAMPAIGN_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = clearGrades(); if (_e) { _o->clearGrades.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearGrades[_i] = _e->Get(_i); } } };
  { auto _e = episodeRewardStatus(); if (_e) { _o->episodeRewardStatus.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->episodeRewardStatus[_i] = _e->Get(_i); } } };
  { auto _e = dailyClearGrades(); if (_e) { _o->dailyClearGrades.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dailyClearGrades[_i] = _e->Get(_i); } } };
  { auto _e = dailyTicket(); if (_e) { _o->dailyTicket.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dailyTicket[_i] = _e->Get(_i); } } };
  { auto _e = dailyOpenCards(); if (_e) { _o->dailyOpenCards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dailyOpenCards[_i] = _e->Get(_i)->str(); } } };
  { auto _e = Elite_1(); if (_e) _o->Elite_1 = std::unique_ptr<CAMPAIGN_QUESTT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CAMPAIGN_STATUS> CAMPAIGN_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCAMPAIGN_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CAMPAIGN_STATUS> CreateCAMPAIGN_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CAMPAIGN_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CAMPAIGN_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _clearGrades = _o->clearGrades.size() ? _fbb.CreateVector(_o->clearGrades) : 0;
  auto _episodeRewardStatus = _o->episodeRewardStatus.size() ? _fbb.CreateVector(_o->episodeRewardStatus) : 0;
  auto _dailyClearGrades = _o->dailyClearGrades.size() ? _fbb.CreateVector(_o->dailyClearGrades) : 0;
  auto _dailyTicket = _o->dailyTicket.size() ? _fbb.CreateVector(_o->dailyTicket) : 0;
  auto _dailyOpenCards = _o->dailyOpenCards.size() ? _fbb.CreateVectorOfStrings(_o->dailyOpenCards) : 0;
  auto _Elite_1 = _o->Elite_1 ? CreateCAMPAIGN_QUEST(_fbb, _o->Elite_1.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreateCAMPAIGN_STATUS(
      _fbb,
      _clearGrades,
      _episodeRewardStatus,
      _dailyClearGrades,
      _dailyTicket,
      _dailyOpenCards,
      _Elite_1);
}

inline COMMUNITY_ARTICLET *COMMUNITY_ARTICLE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE::UnPackTo(COMMUNITY_ARTICLET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = articleId(); if (_e) _o->articleId = _e->str(); };
  { auto _e = category(); if (_e) _o->category = _e->str(); };
  { auto _e = contents(); if (_e) _o->contents = _e->str(); };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = time(); if (_e) _o->time = _e->str(); };
  { auto _e = up(); _o->up = _e; };
  { auto _e = down(); _o->down = _e; };
  { auto _e = point(); _o->point = _e; };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE> COMMUNITY_ARTICLE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE> CreateCOMMUNITY_ARTICLE(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _articleId = _o->articleId.empty() ? 0 : _fbb.CreateString(_o->articleId);
  auto _category = _o->category.empty() ? 0 : _fbb.CreateString(_o->category);
  auto _contents = _o->contents.empty() ? 0 : _fbb.CreateString(_o->contents);
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _time = _o->time.empty() ? 0 : _fbb.CreateString(_o->time);
  auto _up = _o->up;
  auto _down = _o->down;
  auto _point = _o->point;
  return OVERLORD::STRUCT::CreateCOMMUNITY_ARTICLE(
      _fbb,
      _articleId,
      _category,
      _contents,
      _kId,
      _nick,
      _time,
      _up,
      _down,
      _point);
}

inline EVENT_ATTENDANCET *EVENT_ATTENDANCE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new EVENT_ATTENDANCET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void EVENT_ATTENDANCE::UnPackTo(EVENT_ATTENDANCET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = attId(); if (_e) _o->attId = _e->str(); };
  { auto _e = days(); if (_e) { _o->days.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->days[_i] = _e->Get(_i); } } };
  { auto _e = stamp(); _o->stamp = _e; };
}

inline flatbuffers::Offset<EVENT_ATTENDANCE> EVENT_ATTENDANCE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EVENT_ATTENDANCET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEVENT_ATTENDANCE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EVENT_ATTENDANCE> CreateEVENT_ATTENDANCE(flatbuffers::FlatBufferBuilder &_fbb, const EVENT_ATTENDANCET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EVENT_ATTENDANCET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _attId = _o->attId.empty() ? 0 : _fbb.CreateString(_o->attId);
  auto _days = _o->days.size() ? _fbb.CreateVector(_o->days) : 0;
  auto _stamp = _o->stamp;
  return OVERLORD::STRUCT::CreateEVENT_ATTENDANCE(
      _fbb,
      _attId,
      _days,
      _stamp);
}

inline INVENTORYT *INVENTORY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY::UnPackTo(INVENTORYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = currency1(); if (_e) { _o->currency1.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency1[_i] = _e->Get(_i); } } };
  { auto _e = currency2(); if (_e) { _o->currency2.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency2[_i] = _e->Get(_i); } } };
  { auto _e = currency3(); if (_e) { _o->currency3.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency3[_i] = _e->Get(_i); } } };
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<ITEMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = heros(); if (_e) { _o->heros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros[_i] = std::unique_ptr<HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mailN(); _o->mailN = _e; };
  { auto _e = mailTag(); _o->mailTag = _e; };
  { auto _e = decks(); if (_e) _o->decks = std::unique_ptr<DECKST>(_e->UnPack(_resolver)); };
  { auto _e = tut(); _o->tut = _e; };
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<INVENTORY> INVENTORY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY> CreateINVENTORY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _currency1 = _o->currency1.size() ? _fbb.CreateVector(_o->currency1) : 0;
  auto _currency2 = _o->currency2.size() ? _fbb.CreateVector(_o->currency2) : 0;
  auto _currency3 = _o->currency3.size() ? _fbb.CreateVector(_o->currency3) : 0;
  auto _items = _o->items.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _heros = _o->heros.size() ? _fbb.CreateVector<flatbuffers::Offset<HERO>> (_o->heros.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO(*__va->__fbb, __va->__o->heros[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mailN = _o->mailN;
  auto _mailTag = _o->mailTag;
  auto _decks = _o->decks ? CreateDECKS(_fbb, _o->decks.get(), _rehasher) : 0;
  auto _tut = _o->tut;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  return OVERLORD::STRUCT::CreateINVENTORY(
      _fbb,
      _currency1,
      _currency2,
      _currency3,
      _items,
      _heros,
      _mailN,
      _mailTag,
      _decks,
      _tut,
      _size);
}

inline INVENTORY_UPDATET *INVENTORY_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_UPDATE::UnPackTo(INVENTORY_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = currency1(); if (_e) { _o->currency1.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency1[_i] = _e->Get(_i); } } };
  { auto _e = currency2(); if (_e) { _o->currency2.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency2[_i] = _e->Get(_i); } } };
  { auto _e = currency3(); if (_e) { _o->currency3.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency3[_i] = _e->Get(_i); } } };
  { auto _e = items_update(); if (_e) { _o->items_update.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items_update[_i] = std::unique_ptr<ITEMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = items_delete(); if (_e) { _o->items_delete.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items_delete[_i] = _e->Get(_i)->str(); } } };
  { auto _e = heros_update(); if (_e) { _o->heros_update.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros_update[_i] = std::unique_ptr<HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = heros_delete(); if (_e) { _o->heros_delete.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros_delete[_i] = _e->Get(_i)->str(); } } };
  { auto _e = mailN(); _o->mailN = _e; };
  { auto _e = mailTag(); _o->mailTag = _e; };
  { auto _e = decks(); if (_e) _o->decks = std::unique_ptr<DECKST>(_e->UnPack(_resolver)); };
  { auto _e = tut(); _o->tut = _e; };
  { auto _e = size(); if (_e) { _o->size.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->size[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<INVENTORY_UPDATE> INVENTORY_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_UPDATE> CreateINVENTORY_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _currency1 = _o->currency1.size() ? _fbb.CreateVector(_o->currency1) : 0;
  auto _currency2 = _o->currency2.size() ? _fbb.CreateVector(_o->currency2) : 0;
  auto _currency3 = _o->currency3.size() ? _fbb.CreateVector(_o->currency3) : 0;
  auto _items_update = _o->items_update.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM>> (_o->items_update.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM(*__va->__fbb, __va->__o->items_update[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _items_delete = _o->items_delete.size() ? _fbb.CreateVectorOfStrings(_o->items_delete) : 0;
  auto _heros_update = _o->heros_update.size() ? _fbb.CreateVector<flatbuffers::Offset<HERO>> (_o->heros_update.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO(*__va->__fbb, __va->__o->heros_update[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _heros_delete = _o->heros_delete.size() ? _fbb.CreateVectorOfStrings(_o->heros_delete) : 0;
  auto _mailN = _o->mailN;
  auto _mailTag = _o->mailTag;
  auto _decks = _o->decks ? CreateDECKS(_fbb, _o->decks.get(), _rehasher) : 0;
  auto _tut = _o->tut;
  auto _size = _o->size.size() ? _fbb.CreateVector(_o->size) : 0;
  return OVERLORD::STRUCT::CreateINVENTORY_UPDATE(
      _fbb,
      _currency1,
      _currency2,
      _currency3,
      _items_update,
      _items_delete,
      _heros_update,
      _heros_delete,
      _mailN,
      _mailTag,
      _decks,
      _tut,
      _size);
}

inline INVENTORY_CURRENCYT *INVENTORY_CURRENCY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_CURRENCYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_CURRENCY::UnPackTo(INVENTORY_CURRENCYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = currency1(); if (_e) { _o->currency1.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->currency1[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<INVENTORY_CURRENCY> INVENTORY_CURRENCY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_CURRENCYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_CURRENCY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_CURRENCY> CreateINVENTORY_CURRENCY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_CURRENCYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_CURRENCYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _currency1 = _o->currency1.size() ? _fbb.CreateVector(_o->currency1) : 0;
  return OVERLORD::STRUCT::CreateINVENTORY_CURRENCY(
      _fbb,
      _currency1);
}

inline INVENTORY_EQUIPEDT *INVENTORY_EQUIPED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_EQUIPEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_EQUIPED::UnPackTo(INVENTORY_EQUIPEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = items(); if (_e) { _o->items.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->items[_i] = std::unique_ptr<ITEMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = heros(); if (_e) { _o->heros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros[_i] = std::unique_ptr<HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = decks(); if (_e) _o->decks = std::unique_ptr<DECKST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_EQUIPED> INVENTORY_EQUIPED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_EQUIPEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_EQUIPED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_EQUIPED> CreateINVENTORY_EQUIPED(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_EQUIPEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_EQUIPEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _items = _o->items.size() ? _fbb.CreateVector<flatbuffers::Offset<ITEM>> (_o->items.size(), [](size_t i, _VectorArgs *__va) { return CreateITEM(*__va->__fbb, __va->__o->items[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _heros = _o->heros.size() ? _fbb.CreateVector<flatbuffers::Offset<HERO>> (_o->heros.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO(*__va->__fbb, __va->__o->heros[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _decks = _o->decks ? CreateDECKS(_fbb, _o->decks.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreateINVENTORY_EQUIPED(
      _fbb,
      _items,
      _heros,
      _decks);
}

inline UNLOCK_NOTIFYT *UNLOCK_NOTIFY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UNLOCK_NOTIFYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UNLOCK_NOTIFY::UnPackTo(UNLOCK_NOTIFYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = notify(); if (_e) { _o->notify.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->notify[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<UNLOCK_NOTIFY> UNLOCK_NOTIFY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_NOTIFYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUNLOCK_NOTIFY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UNLOCK_NOTIFY> CreateUNLOCK_NOTIFY(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_NOTIFYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UNLOCK_NOTIFYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _notify = _o->notify.size() ? _fbb.CreateVector(_o->notify) : 0;
  return OVERLORD::STRUCT::CreateUNLOCK_NOTIFY(
      _fbb,
      _notify);
}

inline UNLOCK_LISTT *UNLOCK_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UNLOCK_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UNLOCK_LIST::UnPackTo(UNLOCK_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = list(); if (_e) { _o->list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->list[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<UNLOCK_LIST> UNLOCK_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUNLOCK_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UNLOCK_LIST> CreateUNLOCK_LIST(flatbuffers::FlatBufferBuilder &_fbb, const UNLOCK_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UNLOCK_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _list = _o->list.size() ? _fbb.CreateVector(_o->list) : 0;
  return OVERLORD::STRUCT::CreateUNLOCK_LIST(
      _fbb,
      _list);
}

inline DAILY_QUEST_STATUST *DAILY_QUEST_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_STATUS::UnPackTo(DAILY_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = score(); _o->score = _e; };
  { auto _e = rewardable(); if (_e) { _o->rewardable.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewardable[_i] = _e->Get(_i); } } };
  { auto _e = clearcount(); if (_e) { _o->clearcount.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearcount[_i] = _e->Get(_i); } } };
  { auto _e = timeleft(); _o->timeleft = _e; };
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> DAILY_QUEST_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _score = _o->score;
  auto _rewardable = _o->rewardable.size() ? _fbb.CreateVector(_o->rewardable) : 0;
  auto _clearcount = _o->clearcount.size() ? _fbb.CreateVector(_o->clearcount) : 0;
  auto _timeleft = _o->timeleft;
  return OVERLORD::STRUCT::CreateDAILY_QUEST_STATUS(
      _fbb,
      _score,
      _rewardable,
      _clearcount,
      _timeleft);
}

inline DAILY_QUEST_UPDATET *DAILY_QUEST_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_UPDATE::UnPackTo(DAILY_QUEST_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = score(); _o->score = _e; };
  { auto _e = rewardable(); if (_e) { _o->rewardable.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewardable[_i] = _e->Get(_i); } } };
  { auto _e = clearcount(); if (_e) { _o->clearcount.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearcount[_i] = _e->Get(_i); } } };
  { auto _e = timeleft(); _o->timeleft = _e; };
}

inline flatbuffers::Offset<DAILY_QUEST_UPDATE> DAILY_QUEST_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_UPDATE> CreateDAILY_QUEST_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _score = _o->score;
  auto _rewardable = _o->rewardable.size() ? _fbb.CreateVector(_o->rewardable) : 0;
  auto _clearcount = _o->clearcount.size() ? _fbb.CreateVector(_o->clearcount) : 0;
  auto _timeleft = _o->timeleft;
  return OVERLORD::STRUCT::CreateDAILY_QUEST_UPDATE(
      _fbb,
      _score,
      _rewardable,
      _clearcount,
      _timeleft);
}

inline REALTIME_USER_BASIC_INFOT *REALTIME_USER_BASIC_INFO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REALTIME_USER_BASIC_INFOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REALTIME_USER_BASIC_INFO::UnPackTo(REALTIME_USER_BASIC_INFOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<REALTIME_USER_BASIC_INFO> REALTIME_USER_BASIC_INFO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_USER_BASIC_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREALTIME_USER_BASIC_INFO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REALTIME_USER_BASIC_INFO> CreateREALTIME_USER_BASIC_INFO(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_USER_BASIC_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REALTIME_USER_BASIC_INFOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _guild_id = _o->guild_id;
  return OVERLORD::STRUCT::CreateREALTIME_USER_BASIC_INFO(
      _fbb,
      _kId,
      _nick,
      _level,
      _guild,
      _guild_id);
}

inline REALTIME_COLOSSEUM_STATUST *REALTIME_COLOSSEUM_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REALTIME_COLOSSEUM_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REALTIME_COLOSSEUM_STATUS::UnPackTo(REALTIME_COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = league(); _o->league = _e; };
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = power(); _o->power = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = rPoint(); _o->rPoint = _e; };
  { auto _e = win(); _o->win = _e; };
  { auto _e = lose(); _o->lose = _e; };
  { auto _e = contWin(); _o->contWin = _e; };
}

inline flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> REALTIME_COLOSSEUM_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREALTIME_COLOSSEUM_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REALTIME_COLOSSEUM_STATUS> CreateREALTIME_COLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REALTIME_COLOSSEUM_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _league = _o->league;
  auto _rank = _o->rank;
  auto _power = _o->power;
  auto _point = _o->point;
  auto _rPoint = _o->rPoint;
  auto _win = _o->win;
  auto _lose = _o->lose;
  auto _contWin = _o->contWin;
  return OVERLORD::STRUCT::CreateREALTIME_COLOSSEUM_STATUS(
      _fbb,
      _league,
      _rank,
      _power,
      _point,
      _rPoint,
      _win,
      _lose,
      _contWin);
}

inline HERO_SHOP_PRODUCTT *HERO_SHOP_PRODUCT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_SHOP_PRODUCTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_SHOP_PRODUCT::UnPackTo(HERO_SHOP_PRODUCTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = productId(); if (_e) _o->productId = _e->str(); };
  { auto _e = currencyType(); if (_e) _o->currencyType = _e->str(); };
  { auto _e = price(); _o->price = _e; };
  { auto _e = priceTotal(); _o->priceTotal = _e; };
  { auto _e = primeCostPrice(); _o->primeCostPrice = _e; };
  { auto _e = primeCostTotalPrice(); _o->primeCostTotalPrice = _e; };
  { auto _e = maxQuantity(); _o->maxQuantity = _e; };
  { auto _e = remainQuantity(); _o->remainQuantity = _e; };
}

inline flatbuffers::Offset<HERO_SHOP_PRODUCT> HERO_SHOP_PRODUCT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PRODUCTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_SHOP_PRODUCT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_SHOP_PRODUCT> CreateHERO_SHOP_PRODUCT(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PRODUCTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_SHOP_PRODUCTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _productId = _o->productId.empty() ? 0 : _fbb.CreateString(_o->productId);
  auto _currencyType = _o->currencyType.empty() ? 0 : _fbb.CreateString(_o->currencyType);
  auto _price = _o->price;
  auto _priceTotal = _o->priceTotal;
  auto _primeCostPrice = _o->primeCostPrice;
  auto _primeCostTotalPrice = _o->primeCostTotalPrice;
  auto _maxQuantity = _o->maxQuantity;
  auto _remainQuantity = _o->remainQuantity;
  return OVERLORD::STRUCT::CreateHERO_SHOP_PRODUCT(
      _fbb,
      _productId,
      _currencyType,
      _price,
      _priceTotal,
      _primeCostPrice,
      _primeCostTotalPrice,
      _maxQuantity,
      _remainQuantity);
}

inline HERO_SHOP_PANELT *HERO_SHOP_PANEL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_SHOP_PANELT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_SHOP_PANEL::UnPackTo(HERO_SHOP_PANELT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = panelId(); if (_e) _o->panelId = _e->str(); };
  { auto _e = resetCurrencyType(); if (_e) _o->resetCurrencyType = _e->str(); };
  { auto _e = resetPrice(); _o->resetPrice = _e; };
  { auto _e = resetRemainCount(); _o->resetRemainCount = _e; };
  { auto _e = timer(); _o->timer = _e; };
  { auto _e = productList(); if (_e) { _o->productList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->productList[_i] = std::unique_ptr<HERO_SHOP_PRODUCTT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = synergyId(); if (_e) _o->synergyId = _e->str(); };
}

inline flatbuffers::Offset<HERO_SHOP_PANEL> HERO_SHOP_PANEL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PANELT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_SHOP_PANEL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_SHOP_PANEL> CreateHERO_SHOP_PANEL(flatbuffers::FlatBufferBuilder &_fbb, const HERO_SHOP_PANELT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_SHOP_PANELT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _panelId = _o->panelId.empty() ? 0 : _fbb.CreateString(_o->panelId);
  auto _resetCurrencyType = _o->resetCurrencyType.empty() ? 0 : _fbb.CreateString(_o->resetCurrencyType);
  auto _resetPrice = _o->resetPrice;
  auto _resetRemainCount = _o->resetRemainCount;
  auto _timer = _o->timer;
  auto _productList = _o->productList.size() ? _fbb.CreateVector<flatbuffers::Offset<HERO_SHOP_PRODUCT>> (_o->productList.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO_SHOP_PRODUCT(*__va->__fbb, __va->__o->productList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _synergyId = _o->synergyId.empty() ? 0 : _fbb.CreateString(_o->synergyId);
  return OVERLORD::STRUCT::CreateHERO_SHOP_PANEL(
      _fbb,
      _panelId,
      _resetCurrencyType,
      _resetPrice,
      _resetRemainCount,
      _timer,
      _productList,
      _synergyId);
}

inline ROA_QUESTT *ROA_QUEST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROA_QUESTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROA_QUEST::UnPackTo(ROA_QUESTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = quest(); _o->quest = _e; };
  { auto _e = max(); _o->max = _e; };
  { auto _e = now(); _o->now = _e; };
  { auto _e = rewardKey(); if (_e) _o->rewardKey = _e->str(); };
  { auto _e = rewarded(); _o->rewarded = _e; };
  { auto _e = complete(); _o->complete = _e; };
}

inline flatbuffers::Offset<ROA_QUEST> ROA_QUEST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_QUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROA_QUEST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROA_QUEST> CreateROA_QUEST(flatbuffers::FlatBufferBuilder &_fbb, const ROA_QUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROA_QUESTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _quest = _o->quest;
  auto _max = _o->max;
  auto _now = _o->now;
  auto _rewardKey = _o->rewardKey.empty() ? 0 : _fbb.CreateString(_o->rewardKey);
  auto _rewarded = _o->rewarded;
  auto _complete = _o->complete;
  return OVERLORD::STRUCT::CreateROA_QUEST(
      _fbb,
      _quest,
      _max,
      _now,
      _rewardKey,
      _rewarded,
      _complete);
}

inline ROA_CHAPTER_QUESTST *ROA_CHAPTER_QUESTS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROA_CHAPTER_QUESTST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROA_CHAPTER_QUESTS::UnPackTo(ROA_CHAPTER_QUESTST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = day(); _o->day = _e; };
  { auto _e = quests(); if (_e) { _o->quests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->quests[_i] = std::unique_ptr<ROA_QUESTT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ROA_CHAPTER_QUESTS> ROA_CHAPTER_QUESTS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_CHAPTER_QUESTST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROA_CHAPTER_QUESTS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROA_CHAPTER_QUESTS> CreateROA_CHAPTER_QUESTS(flatbuffers::FlatBufferBuilder &_fbb, const ROA_CHAPTER_QUESTST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROA_CHAPTER_QUESTST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _day = _o->day;
  auto _quests = _o->quests.size() ? _fbb.CreateVector<flatbuffers::Offset<ROA_QUEST>> (_o->quests.size(), [](size_t i, _VectorArgs *__va) { return CreateROA_QUEST(*__va->__fbb, __va->__o->quests[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateROA_CHAPTER_QUESTS(
      _fbb,
      _day,
      _quests);
}

inline ROA_ADVENTURET *ROA_ADVENTURE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ROA_ADVENTURET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ROA_ADVENTURE::UnPackTo(ROA_ADVENTURET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = chapter(); _o->chapter = _e; };
  { auto _e = day(); _o->day = _e; };
  { auto _e = rewardKey(); if (_e) _o->rewardKey = _e->str(); };
  { auto _e = rewarded(); _o->rewarded = _e; };
  { auto _e = complete(); _o->complete = _e; };
  { auto _e = days(); if (_e) { _o->days.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->days[_i] = std::unique_ptr<ROA_CHAPTER_QUESTST>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ROA_ADVENTURE> ROA_ADVENTURE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ROA_ADVENTURET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateROA_ADVENTURE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ROA_ADVENTURE> CreateROA_ADVENTURE(flatbuffers::FlatBufferBuilder &_fbb, const ROA_ADVENTURET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ROA_ADVENTURET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _chapter = _o->chapter;
  auto _day = _o->day;
  auto _rewardKey = _o->rewardKey.empty() ? 0 : _fbb.CreateString(_o->rewardKey);
  auto _rewarded = _o->rewarded;
  auto _complete = _o->complete;
  auto _days = _o->days.size() ? _fbb.CreateVector<flatbuffers::Offset<ROA_CHAPTER_QUESTS>> (_o->days.size(), [](size_t i, _VectorArgs *__va) { return CreateROA_CHAPTER_QUESTS(*__va->__fbb, __va->__o->days[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateROA_ADVENTURE(
      _fbb,
      _chapter,
      _day,
      _rewardKey,
      _rewarded,
      _complete,
      _days);
}

inline BILLING_PREPARE_KAKAOPAYT *BILLING_PREPARE_KAKAOPAY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BILLING_PREPARE_KAKAOPAYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BILLING_PREPARE_KAKAOPAY::UnPackTo(BILLING_PREPARE_KAKAOPAYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tid(); if (_e) _o->tid = _e->str(); };
  { auto _e = next_redirect_app_url(); if (_e) _o->next_redirect_app_url = _e->str(); };
  { auto _e = next_redirect_mobile_url(); if (_e) _o->next_redirect_mobile_url = _e->str(); };
  { auto _e = next_redirect_pc_url(); if (_e) _o->next_redirect_pc_url = _e->str(); };
  { auto _e = android_app_scheme(); if (_e) _o->android_app_scheme = _e->str(); };
  { auto _e = ios_app_scheme(); if (_e) _o->ios_app_scheme = _e->str(); };
}

inline flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> BILLING_PREPARE_KAKAOPAY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_PREPARE_KAKAOPAYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBILLING_PREPARE_KAKAOPAY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BILLING_PREPARE_KAKAOPAY> CreateBILLING_PREPARE_KAKAOPAY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_PREPARE_KAKAOPAYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BILLING_PREPARE_KAKAOPAYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tid = _o->tid.empty() ? 0 : _fbb.CreateString(_o->tid);
  auto _next_redirect_app_url = _o->next_redirect_app_url.empty() ? 0 : _fbb.CreateString(_o->next_redirect_app_url);
  auto _next_redirect_mobile_url = _o->next_redirect_mobile_url.empty() ? 0 : _fbb.CreateString(_o->next_redirect_mobile_url);
  auto _next_redirect_pc_url = _o->next_redirect_pc_url.empty() ? 0 : _fbb.CreateString(_o->next_redirect_pc_url);
  auto _android_app_scheme = _o->android_app_scheme.empty() ? 0 : _fbb.CreateString(_o->android_app_scheme);
  auto _ios_app_scheme = _o->ios_app_scheme.empty() ? 0 : _fbb.CreateString(_o->ios_app_scheme);
  return OVERLORD::STRUCT::CreateBILLING_PREPARE_KAKAOPAY(
      _fbb,
      _tid,
      _next_redirect_app_url,
      _next_redirect_mobile_url,
      _next_redirect_pc_url,
      _android_app_scheme,
      _ios_app_scheme);
}

inline REALTIME_REWARDT *REALTIME_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REALTIME_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REALTIME_REWARD::UnPackTo(REALTIME_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<REALTIME_REWARD> REALTIME_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREALTIME_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REALTIME_REWARD> CreateREALTIME_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REALTIME_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateREALTIME_REWARD(
      _fbb,
      _rewards);
}

inline REALTIME_BG_REWARDT *REALTIME_BG_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REALTIME_BG_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REALTIME_BG_REWARD::UnPackTo(REALTIME_BG_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = pouch(); if (_e) { _o->pouch.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->pouch[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rank(); if (_e) { _o->rank.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rank[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<REALTIME_BG_REWARD> REALTIME_BG_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_BG_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREALTIME_BG_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REALTIME_BG_REWARD> CreateREALTIME_BG_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const REALTIME_BG_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REALTIME_BG_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _pouch = _o->pouch.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->pouch.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->pouch[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rank = _o->rank.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->rank.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rank[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateREALTIME_BG_REWARD(
      _fbb,
      _pouch,
      _rank);
}

inline ACCOUNT_RECORDT *ACCOUNT_RECORD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_RECORDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_RECORD::UnPackTo(ACCOUNT_RECORDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); };
  { auto _e = winCount(); _o->winCount = _e; };
  { auto _e = totalCount(); _o->totalCount = _e; };
}

inline flatbuffers::Offset<ACCOUNT_RECORD> ACCOUNT_RECORD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_RECORDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_RECORD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_RECORD> CreateACCOUNT_RECORD(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_RECORDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_RECORDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _winCount = _o->winCount;
  auto _totalCount = _o->totalCount;
  return OVERLORD::STRUCT::CreateACCOUNT_RECORD(
      _fbb,
      _name,
      _winCount,
      _totalCount);
}

inline HERO_USAGET *HERO_USAGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_USAGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_USAGE::UnPackTo(HERO_USAGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = GradeID(); if (_e) _o->GradeID = _e->str(); };
  { auto _e = count(); _o->count = _e; };
}

inline flatbuffers::Offset<HERO_USAGE> HERO_USAGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_USAGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_USAGE> CreateHERO_USAGE(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_USAGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _GradeID = _o->GradeID.empty() ? 0 : _fbb.CreateString(_o->GradeID);
  auto _count = _o->count;
  return OVERLORD::STRUCT::CreateHERO_USAGE(
      _fbb,
      _GradeID,
      _count);
}

inline HERO_USAGE_TABT *HERO_USAGE_TAB::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new HERO_USAGE_TABT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void HERO_USAGE_TAB::UnPackTo(HERO_USAGE_TABT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = tab(); _o->tab = _e; };
  { auto _e = usages(); if (_e) { _o->usages.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->usages[_i] = std::unique_ptr<HERO_USAGET>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<HERO_USAGE_TAB> HERO_USAGE_TAB::Pack(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGE_TABT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateHERO_USAGE_TAB(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<HERO_USAGE_TAB> CreateHERO_USAGE_TAB(flatbuffers::FlatBufferBuilder &_fbb, const HERO_USAGE_TABT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const HERO_USAGE_TABT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _tab = _o->tab;
  auto _usages = _o->usages.size() ? _fbb.CreateVector<flatbuffers::Offset<HERO_USAGE>> (_o->usages.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO_USAGE(*__va->__fbb, __va->__o->usages[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateHERO_USAGE_TAB(
      _fbb,
      _tab,
      _usages);
}

inline CRUSADER_HERO_HPT *CRUSADER_HERO_HP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CRUSADER_HERO_HPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CRUSADER_HERO_HP::UnPackTo(CRUSADER_HERO_HPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = hp(); _o->hp = _e; };
}

inline flatbuffers::Offset<CRUSADER_HERO_HP> CRUSADER_HERO_HP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CRUSADER_HERO_HPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCRUSADER_HERO_HP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CRUSADER_HERO_HP> CreateCRUSADER_HERO_HP(flatbuffers::FlatBufferBuilder &_fbb, const CRUSADER_HERO_HPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CRUSADER_HERO_HPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _hp = _o->hp;
  return OVERLORD::STRUCT::CreateCRUSADER_HERO_HP(
      _fbb,
      _heroUD,
      _hp);
}

inline TREASURET *TREASURE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TREASURET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TREASURE::UnPackTo(TREASURET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = treasureId(); if (_e) _o->treasureId = _e->str(); };
  { auto _e = left(); _o->left = _e; };
  { auto _e = key(); _o->key = _e; };
}

inline flatbuffers::Offset<TREASURE> TREASURE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTREASURE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TREASURE> CreateTREASURE(flatbuffers::FlatBufferBuilder &_fbb, const TREASURET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TREASURET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _treasureId = _o->treasureId.empty() ? 0 : _fbb.CreateString(_o->treasureId);
  auto _left = _o->left;
  auto _key = _o->key;
  return OVERLORD::STRUCT::CreateTREASURE(
      _fbb,
      _treasureId,
      _left,
      _key);
}

inline BG_USERT *BG_USER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BG_USERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BG_USER::UnPackTo(BG_USERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = rank(); _o->rank = _e; };
}

inline flatbuffers::Offset<BG_USER> BG_USER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BG_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBG_USER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BG_USER> CreateBG_USER(flatbuffers::FlatBufferBuilder &_fbb, const BG_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BG_USERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _point = _o->point;
  auto _rank = _o->rank;
  return OVERLORD::STRUCT::CreateBG_USER(
      _fbb,
      _kId,
      _nick,
      _level,
      _point,
      _rank);
}

inline FLOOR_QUEST_STATUST *FLOOR_QUEST_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FLOOR_QUEST_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FLOOR_QUEST_STATUS::UnPackTo(FLOOR_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = questId(); _o->questId = _e; };
  { auto _e = progress(); _o->progress = _e; };
}

inline flatbuffers::Offset<FLOOR_QUEST_STATUS> FLOOR_QUEST_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFLOOR_QUEST_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FLOOR_QUEST_STATUS> CreateFLOOR_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FLOOR_QUEST_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _questId = _o->questId;
  auto _progress = _o->progress;
  return OVERLORD::STRUCT::CreateFLOOR_QUEST_STATUS(
      _fbb,
      _questId,
      _progress);
}

inline FLOOR_MISSIONT *FLOOR_MISSION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FLOOR_MISSIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FLOOR_MISSION::UnPackTo(FLOOR_MISSIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
  { auto _e = cls(); _o->cls = _e; };
  { auto _e = rewardAmt(); _o->rewardAmt = _e; };
  { auto _e = goal(); _o->goal = _e; };
  { auto _e = current(); _o->current = _e; };
}

inline flatbuffers::Offset<FLOOR_MISSION> FLOOR_MISSION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFLOOR_MISSION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FLOOR_MISSION> CreateFLOOR_MISSION(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FLOOR_MISSIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  auto _cls = _o->cls;
  auto _rewardAmt = _o->rewardAmt;
  auto _goal = _o->goal;
  auto _current = _o->current;
  return OVERLORD::STRUCT::CreateFLOOR_MISSION(
      _fbb,
      _id,
      _stageId,
      _cls,
      _rewardAmt,
      _goal,
      _current);
}

inline FLOOR_MISSION_STATUST *FLOOR_MISSION_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new FLOOR_MISSION_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void FLOOR_MISSION_STATUS::UnPackTo(FLOOR_MISSION_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = floor(); _o->floor = _e; };
  { auto _e = missions(); if (_e) { _o->missions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->missions[_i] = std::unique_ptr<FLOOR_MISSIONT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = step(); _o->step = _e; };
  { auto _e = timeleft(); _o->timeleft = _e; };
}

inline flatbuffers::Offset<FLOOR_MISSION_STATUS> FLOOR_MISSION_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSION_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFLOOR_MISSION_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<FLOOR_MISSION_STATUS> CreateFLOOR_MISSION_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const FLOOR_MISSION_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const FLOOR_MISSION_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _floor = _o->floor;
  auto _missions = _o->missions.size() ? _fbb.CreateVector<flatbuffers::Offset<FLOOR_MISSION>> (_o->missions.size(), [](size_t i, _VectorArgs *__va) { return CreateFLOOR_MISSION(*__va->__fbb, __va->__o->missions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _step = _o->step;
  auto _timeleft = _o->timeleft;
  return OVERLORD::STRUCT::CreateFLOOR_MISSION_STATUS(
      _fbb,
      _floor,
      _missions,
      _step,
      _timeleft);
}

inline TOWER_STATUST *TOWER_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_STATUS::UnPackTo(TOWER_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = currentFloor(); _o->currentFloor = _e; };
  { auto _e = clearGrades(); if (_e) { _o->clearGrades.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearGrades[_i] = _e->Get(_i); } } };
  { auto _e = raidClearGrades(); if (_e) { _o->raidClearGrades.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->raidClearGrades[_i] = _e->Get(_i); } } };
  { auto _e = treasureBoxes(); if (_e) { _o->treasureBoxes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->treasureBoxes[_i] = _e->Get(_i) != 0; } } };
  { auto _e = floorQuestStatus(); if (_e) _o->floorQuestStatus = std::unique_ptr<FLOOR_QUEST_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = floorMissionStatus(); if (_e) _o->floorMissionStatus = std::unique_ptr<FLOOR_MISSION_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TOWER_STATUS> TOWER_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _currentFloor = _o->currentFloor;
  auto _clearGrades = _o->clearGrades.size() ? _fbb.CreateVector(_o->clearGrades) : 0;
  auto _raidClearGrades = _o->raidClearGrades.size() ? _fbb.CreateVector(_o->raidClearGrades) : 0;
  auto _treasureBoxes = _o->treasureBoxes.size() ? _fbb.CreateVector(_o->treasureBoxes) : 0;
  auto _floorQuestStatus = _o->floorQuestStatus ? CreateFLOOR_QUEST_STATUS(_fbb, _o->floorQuestStatus.get(), _rehasher) : 0;
  auto _floorMissionStatus = _o->floorMissionStatus ? CreateFLOOR_MISSION_STATUS(_fbb, _o->floorMissionStatus.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreateTOWER_STATUS(
      _fbb,
      _currentFloor,
      _clearGrades,
      _raidClearGrades,
      _treasureBoxes,
      _floorQuestStatus,
      _floorMissionStatus);
}

inline BATTLE_USERT *BATTLE_USER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BATTLE_USERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BATTLE_USER::UnPackTo(BATTLE_USERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = ability(); if (_e) { _o->ability.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->ability[_i] = _e->Get(_i); } } };
  { auto _e = icon(); _o->icon = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = heros(); if (_e) { _o->heros.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heros[_i] = std::unique_ptr<EQUIPED_HEROT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = decks(); if (_e) _o->decks = std::unique_ptr<DECKST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<BATTLE_USER> BATTLE_USER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BATTLE_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBATTLE_USER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BATTLE_USER> CreateBATTLE_USER(flatbuffers::FlatBufferBuilder &_fbb, const BATTLE_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BATTLE_USERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _ability = _o->ability.size() ? _fbb.CreateVector(_o->ability) : 0;
  auto _icon = _o->icon;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _heros = _o->heros.size() ? _fbb.CreateVector<flatbuffers::Offset<EQUIPED_HERO>> (_o->heros.size(), [](size_t i, _VectorArgs *__va) { return CreateEQUIPED_HERO(*__va->__fbb, __va->__o->heros[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _decks = _o->decks ? CreateDECKS(_fbb, _o->decks.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreateBATTLE_USER(
      _fbb,
      _kId,
      _nick,
      _level,
      _ability,
      _icon,
      _guild,
      _heros,
      _decks);
}

inline ARENA_HISTORYT *ARENA_HISTORY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_HISTORYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_HISTORY::UnPackTo(ARENA_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = isDefense(); _o->isDefense = _e; };
  { auto _e = isWin(); _o->isWin = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = heroIDs(); if (_e) { _o->heroIDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroIDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = power(); _o->power = _e; };
  { auto _e = deltaPoint(); _o->deltaPoint = _e; };
}

inline flatbuffers::Offset<ARENA_HISTORY> ARENA_HISTORY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_HISTORY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_HISTORY> CreateARENA_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_HISTORYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _isDefense = _o->isDefense;
  auto _isWin = _o->isWin;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _heroIDs = _o->heroIDs.size() ? _fbb.CreateVectorOfStrings(_o->heroIDs) : 0;
  auto _power = _o->power;
  auto _deltaPoint = _o->deltaPoint;
  return OVERLORD::STRUCT::CreateARENA_HISTORY(
      _fbb,
      _kId,
      _isDefense,
      _isWin,
      _nick,
      _level,
      _guild,
      _heroIDs,
      _power,
      _deltaPoint);
}

inline ARENA_STATUST *ARENA_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_STATUS::UnPackTo(ARENA_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seasonEnd(); _o->seasonEnd = _e; };
  { auto _e = seasonLeft(); _o->seasonLeft = _e; };
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = rankPosition(); _o->rankPosition = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = history(); if (_e) { _o->history.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->history[_i] = std::unique_ptr<ARENA_HISTORYT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = defenseRewardEnabled(); _o->defenseRewardEnabled = _e; };
  { auto _e = defenseCount(); _o->defenseCount = _e; };
  { auto _e = defenseCountMax(); _o->defenseCountMax = _e; };
  { auto _e = defenseLeftTime(); _o->defenseLeftTime = _e; };
}

inline flatbuffers::Offset<ARENA_STATUS> ARENA_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seasonEnd = _o->seasonEnd;
  auto _seasonLeft = _o->seasonLeft;
  auto _rank = _o->rank;
  auto _rankPosition = _o->rankPosition;
  auto _point = _o->point;
  auto _history = _o->history.size() ? _fbb.CreateVector<flatbuffers::Offset<ARENA_HISTORY>> (_o->history.size(), [](size_t i, _VectorArgs *__va) { return CreateARENA_HISTORY(*__va->__fbb, __va->__o->history[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _defenseRewardEnabled = _o->defenseRewardEnabled;
  auto _defenseCount = _o->defenseCount;
  auto _defenseCountMax = _o->defenseCountMax;
  auto _defenseLeftTime = _o->defenseLeftTime;
  return OVERLORD::STRUCT::CreateARENA_STATUS(
      _fbb,
      _seasonEnd,
      _seasonLeft,
      _rank,
      _rankPosition,
      _point,
      _history,
      _defenseRewardEnabled,
      _defenseCount,
      _defenseCountMax,
      _defenseLeftTime);
}

inline ARENA_RANK_USERT *ARENA_RANK_USER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_RANK_USERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_RANK_USER::UnPackTo(ARENA_RANK_USERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = power(); _o->power = _e; };
}

inline flatbuffers::Offset<ARENA_RANK_USER> ARENA_RANK_USER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANK_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_RANK_USER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_RANK_USER> CreateARENA_RANK_USER(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANK_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_RANK_USERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _rank = _o->rank;
  auto _point = _o->point;
  auto _power = _o->power;
  return OVERLORD::STRUCT::CreateARENA_RANK_USER(
      _fbb,
      _nick,
      _level,
      _guild,
      _rank,
      _point,
      _power);
}

inline MIRROR_HERO_HPT *MIRROR_HERO_HP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_HERO_HPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_HERO_HP::UnPackTo(MIRROR_HERO_HPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = hp(); _o->hp = _e; };
}

inline flatbuffers::Offset<MIRROR_HERO_HP> MIRROR_HERO_HP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_HERO_HPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_HERO_HP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_HERO_HP> CreateMIRROR_HERO_HP(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_HERO_HPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_HERO_HPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _hp = _o->hp;
  return OVERLORD::STRUCT::CreateMIRROR_HERO_HP(
      _fbb,
      _heroUD,
      _hp);
}

inline MIRRORT *MIRROR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRRORT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR::UnPackTo(MIRRORT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mirrorUD(); if (_e) _o->mirrorUD = _e->str(); };
  { auto _e = mirrorType(); _o->mirrorType = _e; };
  { auto _e = user(); if (_e) _o->user = std::unique_ptr<BATTLE_USERT>(_e->UnPack(_resolver)); };
  { auto _e = hpList(); if (_e) { _o->hpList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->hpList[_i] = _e->Get(_i); } } };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<MIRROR> MIRROR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRRORT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR> CreateMIRROR(flatbuffers::FlatBufferBuilder &_fbb, const MIRRORT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRRORT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mirrorUD = _o->mirrorUD.empty() ? 0 : _fbb.CreateString(_o->mirrorUD);
  auto _mirrorType = _o->mirrorType;
  auto _user = _o->user ? CreateBATTLE_USER(_fbb, _o->user.get(), _rehasher) : 0;
  auto _hpList = _o->hpList.size() ? _fbb.CreateVector(_o->hpList) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateMIRROR(
      _fbb,
      _mirrorUD,
      _mirrorType,
      _user,
      _hpList,
      _rewards);
}

inline MIRROR_STATUST *MIRROR_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_STATUS::UnPackTo(MIRROR_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = mirrors(); if (_e) { _o->mirrors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mirrors[_i] = std::unique_ptr<MIRRORT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = resetLeftTime(); _o->resetLeftTime = _e; };
  { auto _e = heroHPs(); if (_e) { _o->heroHPs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroHPs[_i] = std::unique_ptr<MIRROR_HERO_HPT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<MIRROR_STATUS> MIRROR_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _mirrors = _o->mirrors.size() ? _fbb.CreateVector<flatbuffers::Offset<MIRROR>> (_o->mirrors.size(), [](size_t i, _VectorArgs *__va) { return CreateMIRROR(*__va->__fbb, __va->__o->mirrors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _resetLeftTime = _o->resetLeftTime;
  auto _heroHPs = _o->heroHPs.size() ? _fbb.CreateVector<flatbuffers::Offset<MIRROR_HERO_HP>> (_o->heroHPs.size(), [](size_t i, _VectorArgs *__va) { return CreateMIRROR_HERO_HP(*__va->__fbb, __va->__o->heroHPs[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateMIRROR_STATUS(
      _fbb,
      _mirrors,
      _resetLeftTime,
      _heroHPs);
}

inline COLOSSEUM_HISTORYT *COLOSSEUM_HISTORY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_HISTORYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_HISTORY::UnPackTo(COLOSSEUM_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = gradeId(); _o->gradeId = _e; };
  { auto _e = isWin(); _o->isWin = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = heroIDs(); if (_e) { _o->heroIDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroIDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = power(); _o->power = _e; };
  { auto _e = deltaPoint(); _o->deltaPoint = _e; };
  { auto _e = playType(); _o->playType = _e; };
}

inline flatbuffers::Offset<COLOSSEUM_HISTORY> COLOSSEUM_HISTORY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_HISTORY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_HISTORY> CreateCOLOSSEUM_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_HISTORYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _gradeId = _o->gradeId;
  auto _isWin = _o->isWin;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _heroIDs = _o->heroIDs.size() ? _fbb.CreateVectorOfStrings(_o->heroIDs) : 0;
  auto _power = _o->power;
  auto _deltaPoint = _o->deltaPoint;
  auto _playType = _o->playType;
  return OVERLORD::STRUCT::CreateCOLOSSEUM_HISTORY(
      _fbb,
      _kId,
      _gradeId,
      _isWin,
      _nick,
      _level,
      _guild,
      _heroIDs,
      _power,
      _deltaPoint,
      _playType);
}

inline COLOSSEUM_STATUST *COLOSSEUM_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_STATUS::UnPackTo(COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = seasonEnd(); _o->seasonEnd = _e; };
  { auto _e = seasonLeft(); _o->seasonLeft = _e; };
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = gradeId(); _o->gradeId = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = history(); if (_e) { _o->history.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->history[_i] = std::unique_ptr<COLOSSEUM_HISTORYT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = win(); _o->win = _e; };
  { auto _e = lose(); _o->lose = _e; };
  { auto _e = continuous_win(); _o->continuous_win = _e; };
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> COLOSSEUM_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _seasonEnd = _o->seasonEnd;
  auto _seasonLeft = _o->seasonLeft;
  auto _rank = _o->rank;
  auto _gradeId = _o->gradeId;
  auto _point = _o->point;
  auto _history = _o->history.size() ? _fbb.CreateVector<flatbuffers::Offset<COLOSSEUM_HISTORY>> (_o->history.size(), [](size_t i, _VectorArgs *__va) { return CreateCOLOSSEUM_HISTORY(*__va->__fbb, __va->__o->history[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _win = _o->win;
  auto _lose = _o->lose;
  auto _continuous_win = _o->continuous_win;
  return OVERLORD::STRUCT::CreateCOLOSSEUM_STATUS(
      _fbb,
      _seasonEnd,
      _seasonLeft,
      _rank,
      _gradeId,
      _point,
      _history,
      _win,
      _lose,
      _continuous_win);
}

inline COLOSSEUM_RANK_USERT *COLOSSEUM_RANK_USER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_RANK_USERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_RANK_USER::UnPackTo(COLOSSEUM_RANK_USERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = guild(); if (_e) _o->guild = _e->str(); };
  { auto _e = rank(); _o->rank = _e; };
  { auto _e = point(); _o->point = _e; };
}

inline flatbuffers::Offset<COLOSSEUM_RANK_USER> COLOSSEUM_RANK_USER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANK_USERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_RANK_USER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_RANK_USER> CreateCOLOSSEUM_RANK_USER(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANK_USERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_RANK_USERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _level = _o->level;
  auto _guild = _o->guild.empty() ? 0 : _fbb.CreateString(_o->guild);
  auto _rank = _o->rank;
  auto _point = _o->point;
  return OVERLORD::STRUCT::CreateCOLOSSEUM_RANK_USER(
      _fbb,
      _nick,
      _level,
      _guild,
      _rank,
      _point);
}

inline SHOP_FLOORSHOP_SLOTT *SHOP_FLOORSHOP_SLOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_SLOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_SLOT::UnPackTo(SHOP_FLOORSHOP_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slotId(); _o->slotId = _e; };
  { auto _e = state(); _o->state = _e; };
  { auto _e = openGem(); _o->openGem = _e; };
  { auto _e = type(); _o->type = _e; };
  { auto _e = rewardId(); if (_e) _o->rewardId = _e->str(); };
  { auto _e = amt(); _o->amt = _e; };
  { auto _e = currencyType(); if (_e) _o->currencyType = _e->str(); };
  { auto _e = price(); _o->price = _e; };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> SHOP_FLOORSHOP_SLOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_SLOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_SLOT> CreateSHOP_FLOORSHOP_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_SLOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slotId = _o->slotId;
  auto _state = _o->state;
  auto _openGem = _o->openGem;
  auto _type = _o->type;
  auto _rewardId = _o->rewardId.empty() ? 0 : _fbb.CreateString(_o->rewardId);
  auto _amt = _o->amt;
  auto _currencyType = _o->currencyType.empty() ? 0 : _fbb.CreateString(_o->currencyType);
  auto _price = _o->price;
  return OVERLORD::STRUCT::CreateSHOP_FLOORSHOP_SLOT(
      _fbb,
      _slotId,
      _state,
      _openGem,
      _type,
      _rewardId,
      _amt,
      _currencyType,
      _price);
}

inline SHOP_FLOORSHOP_STATUST *SHOP_FLOORSHOP_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_STATUS::UnPackTo(SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shopId(); _o->shopId = _e; };
  { auto _e = timeLeft(); _o->timeLeft = _e; };
  { auto _e = slots(); if (_e) { _o->slots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->slots[_i] = std::unique_ptr<SHOP_FLOORSHOP_SLOTT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> SHOP_FLOORSHOP_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shopId = _o->shopId;
  auto _timeLeft = _o->timeLeft;
  auto _slots = _o->slots.size() ? _fbb.CreateVector<flatbuffers::Offset<SHOP_FLOORSHOP_SLOT>> (_o->slots.size(), [](size_t i, _VectorArgs *__va) { return CreateSHOP_FLOORSHOP_SLOT(*__va->__fbb, __va->__o->slots[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateSHOP_FLOORSHOP_STATUS(
      _fbb,
      _shopId,
      _timeLeft,
      _slots);
}

inline WORLDBOSS_STATUST *WORLDBOSS_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_STATUS::UnPackTo(WORLDBOSS_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = clearGrades(); if (_e) { _o->clearGrades.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearGrades[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> WORLDBOSS_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _clearGrades = _o->clearGrades.size() ? _fbb.CreateVector(_o->clearGrades) : 0;
  return OVERLORD::STRUCT::CreateWORLDBOSS_STATUS(
      _fbb,
      _clearGrades);
}

inline SELECTIVE_TUTORIALT *SELECTIVE_TUTORIAL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SELECTIVE_TUTORIALT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SELECTIVE_TUTORIAL::UnPackTo(SELECTIVE_TUTORIALT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = flags(); if (_e) { _o->flags.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->flags[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<SELECTIVE_TUTORIAL> SELECTIVE_TUTORIAL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SELECTIVE_TUTORIALT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSELECTIVE_TUTORIAL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SELECTIVE_TUTORIAL> CreateSELECTIVE_TUTORIAL(flatbuffers::FlatBufferBuilder &_fbb, const SELECTIVE_TUTORIALT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SELECTIVE_TUTORIALT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _flags = _o->flags.size() ? _fbb.CreateVector(_o->flags) : 0;
  return OVERLORD::STRUCT::CreateSELECTIVE_TUTORIAL(
      _fbb,
      _flags);
}

inline UPDATE_PACKETT *UPDATE_PACKET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UPDATE_PACKETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UPDATE_PACKET::UnPackTo(UPDATE_PACKETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = avatar(); if (_e) _o->avatar = std::unique_ptr<AVATART>(_e->UnPack(_resolver)); };
  { auto _e = inventoryUpdate(); if (_e) _o->inventoryUpdate = std::unique_ptr<INVENTORY_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = rewardLength(); _o->rewardLength = _e; };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<REWARDSETT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<UPDATE_PACKET> UPDATE_PACKET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPDATE_PACKET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPDATE_PACKET> CreateUPDATE_PACKET(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPDATE_PACKETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _avatar = _o->avatar ? CreateAVATAR(_fbb, _o->avatar.get(), _rehasher) : 0;
  auto _inventoryUpdate = _o->inventoryUpdate ? CreateINVENTORY_UPDATE(_fbb, _o->inventoryUpdate.get(), _rehasher) : 0;
  auto _rewardLength = _o->rewardLength;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<REWARDSET>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARDSET(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::STRUCT::CreateUPDATE_PACKET(
      _fbb,
      _avatar,
      _inventoryUpdate,
      _rewardLength,
      _rewards);
}

inline UPDATE_PACKET_SLIMT *UPDATE_PACKET_SLIM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new UPDATE_PACKET_SLIMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void UPDATE_PACKET_SLIM::UnPackTo(UPDATE_PACKET_SLIMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = avatar(); if (_e) _o->avatar = std::unique_ptr<AVATART>(_e->UnPack(_resolver)); };
  { auto _e = inventoryUpdate(); if (_e) _o->inventoryUpdate = std::unique_ptr<INVENTORY_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = unlockNotify(); if (_e) _o->unlockNotify = std::unique_ptr<UNLOCK_NOTIFYT>(_e->UnPack(_resolver)); };
  { auto _e = achieveUpdate(); if (_e) { _o->achieveUpdate.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->achieveUpdate[_i] = std::unique_ptr<ACHIEVE_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = dailyQuestUpdate(); if (_e) _o->dailyQuestUpdate = std::unique_ptr<DAILY_QUEST_UPDATET>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<UPDATE_PACKET_SLIM> UPDATE_PACKET_SLIM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKET_SLIMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUPDATE_PACKET_SLIM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UPDATE_PACKET_SLIM> CreateUPDATE_PACKET_SLIM(flatbuffers::FlatBufferBuilder &_fbb, const UPDATE_PACKET_SLIMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UPDATE_PACKET_SLIMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _avatar = _o->avatar ? CreateAVATAR(_fbb, _o->avatar.get(), _rehasher) : 0;
  auto _inventoryUpdate = _o->inventoryUpdate ? CreateINVENTORY_UPDATE(_fbb, _o->inventoryUpdate.get(), _rehasher) : 0;
  auto _unlockNotify = _o->unlockNotify ? CreateUNLOCK_NOTIFY(_fbb, _o->unlockNotify.get(), _rehasher) : 0;
  auto _achieveUpdate = _o->achieveUpdate.size() ? _fbb.CreateVector<flatbuffers::Offset<ACHIEVE_UPDATE>> (_o->achieveUpdate.size(), [](size_t i, _VectorArgs *__va) { return CreateACHIEVE_UPDATE(*__va->__fbb, __va->__o->achieveUpdate[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _dailyQuestUpdate = _o->dailyQuestUpdate ? CreateDAILY_QUEST_UPDATE(_fbb, _o->dailyQuestUpdate.get(), _rehasher) : 0;
  return OVERLORD::STRUCT::CreateUPDATE_PACKET_SLIM(
      _fbb,
      _avatar,
      _inventoryUpdate,
      _unlockNotify,
      _achieveUpdate,
      _dailyQuestUpdate);
}

}  // namespace STRUCT

namespace REQUEST {

inline LOGINT *LOGIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LOGINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LOGIN::UnPackTo(LOGINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = flag(); _o->flag = _e; };
}

inline flatbuffers::Offset<LOGIN> LOGIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LOGINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLOGIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LOGIN> CreateLOGIN(flatbuffers::FlatBufferBuilder &_fbb, const LOGINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LOGINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _flag = _o->flag;
  return OVERLORD::REQUEST::CreateLOGIN(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _flag);
}

inline ACCOUNT_CREATET *ACCOUNT_CREATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_CREATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_CREATE::UnPackTo(ACCOUNT_CREATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = language(); _o->language = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
}

inline flatbuffers::Offset<ACCOUNT_CREATE> ACCOUNT_CREATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_CREATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_CREATE> CreateACCOUNT_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_CREATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _language = _o->language;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  return OVERLORD::REQUEST::CreateACCOUNT_CREATE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _language,
      _nick);
}

inline ACCOUNT_REMOVET *ACCOUNT_REMOVE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_REMOVET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_REMOVE::UnPackTo(ACCOUNT_REMOVET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ACCOUNT_REMOVE> ACCOUNT_REMOVE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_REMOVE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_REMOVE> CreateACCOUNT_REMOVE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_REMOVET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateACCOUNT_REMOVE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline INIT_CLIENT_KEYT *INIT_CLIENT_KEY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INIT_CLIENT_KEYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INIT_CLIENT_KEY::UnPackTo(INIT_CLIENT_KEYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = pwd(); if (_e) _o->pwd = _e->str(); };
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = redirect_uri(); if (_e) _o->redirect_uri = _e->str(); };
  { auto _e = access_token(); if (_e) _o->access_token = _e->str(); };
  { auto _e = code(); if (_e) _o->code = _e->str(); };
  { auto _e = publisher(); if (_e) _o->publisher = _e->str(); };
}

inline flatbuffers::Offset<INIT_CLIENT_KEY> INIT_CLIENT_KEY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINIT_CLIENT_KEY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INIT_CLIENT_KEY> CreateINIT_CLIENT_KEY(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INIT_CLIENT_KEYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _pwd = _o->pwd.empty() ? 0 : _fbb.CreateString(_o->pwd);
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _redirect_uri = _o->redirect_uri.empty() ? 0 : _fbb.CreateString(_o->redirect_uri);
  auto _access_token = _o->access_token.empty() ? 0 : _fbb.CreateString(_o->access_token);
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _publisher = _o->publisher.empty() ? 0 : _fbb.CreateString(_o->publisher);
  return OVERLORD::REQUEST::CreateINIT_CLIENT_KEY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _pwd,
      _id,
      _redirect_uri,
      _access_token,
      _code,
      _publisher);
}

inline ADD_REFER_PUBLISHERT *ADD_REFER_PUBLISHER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ADD_REFER_PUBLISHERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ADD_REFER_PUBLISHER::UnPackTo(ADD_REFER_PUBLISHERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = pwd(); if (_e) _o->pwd = _e->str(); };
  { auto _e = id(); if (_e) _o->id = _e->str(); };
  { auto _e = redirect_uri(); if (_e) _o->redirect_uri = _e->str(); };
  { auto _e = access_token(); if (_e) _o->access_token = _e->str(); };
  { auto _e = code(); if (_e) _o->code = _e->str(); };
  { auto _e = publisher(); if (_e) _o->publisher = _e->str(); };
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER> ADD_REFER_PUBLISHER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateADD_REFER_PUBLISHER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER> CreateADD_REFER_PUBLISHER(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ADD_REFER_PUBLISHERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _pwd = _o->pwd.empty() ? 0 : _fbb.CreateString(_o->pwd);
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  auto _redirect_uri = _o->redirect_uri.empty() ? 0 : _fbb.CreateString(_o->redirect_uri);
  auto _access_token = _o->access_token.empty() ? 0 : _fbb.CreateString(_o->access_token);
  auto _code = _o->code.empty() ? 0 : _fbb.CreateString(_o->code);
  auto _publisher = _o->publisher.empty() ? 0 : _fbb.CreateString(_o->publisher);
  return OVERLORD::REQUEST::CreateADD_REFER_PUBLISHER(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _pwd,
      _id,
      _redirect_uri,
      _access_token,
      _code,
      _publisher);
}

inline GET_REFER_LISTT *GET_REFER_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GET_REFER_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GET_REFER_LIST::UnPackTo(GET_REFER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GET_REFER_LIST> GET_REFER_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGET_REFER_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GET_REFER_LIST> CreateGET_REFER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GET_REFER_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGET_REFER_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline ACCOUNT_CHANGE_LANGUAGET *ACCOUNT_CHANGE_LANGUAGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_CHANGE_LANGUAGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_CHANGE_LANGUAGE::UnPackTo(ACCOUNT_CHANGE_LANGUAGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = language(); _o->language = _e; };
}

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> ACCOUNT_CHANGE_LANGUAGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_CHANGE_LANGUAGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE> CreateACCOUNT_CHANGE_LANGUAGE(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_CHANGE_LANGUAGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _language = _o->language;
  return OVERLORD::REQUEST::CreateACCOUNT_CHANGE_LANGUAGE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _language);
}

inline CLIENT_SDK_ACTIONT *CLIENT_SDK_ACTION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CLIENT_SDK_ACTIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CLIENT_SDK_ACTION::UnPackTo(CLIENT_SDK_ACTIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = flag(); _o->flag = _e; };
}

inline flatbuffers::Offset<CLIENT_SDK_ACTION> CLIENT_SDK_ACTION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCLIENT_SDK_ACTION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CLIENT_SDK_ACTION> CreateCLIENT_SDK_ACTION(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CLIENT_SDK_ACTIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _flag = _o->flag;
  return OVERLORD::REQUEST::CreateCLIENT_SDK_ACTION(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _flag);
}

inline ARENA_STATUST *ARENA_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_STATUS::UnPackTo(ARENA_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ARENA_STATUS> ARENA_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_STATUS> CreateARENA_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateARENA_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline ARENA_TARGET_INFOT *ARENA_TARGET_INFO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_TARGET_INFOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_TARGET_INFO::UnPackTo(ARENA_TARGET_INFOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = refresh(); _o->refresh = _e; };
}

inline flatbuffers::Offset<ARENA_TARGET_INFO> ARENA_TARGET_INFO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_TARGET_INFO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_TARGET_INFO> CreateARENA_TARGET_INFO(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_TARGET_INFOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _refresh = _o->refresh;
  return OVERLORD::REQUEST::CreateARENA_TARGET_INFO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _refresh);
}

inline ARENA_PLAYT *ARENA_PLAY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_PLAYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_PLAY::UnPackTo(ARENA_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = target_power(); _o->target_power = _e; };
  { auto _e = power(); _o->power = _e; };
  { auto _e = heroUDs(); if (_e) { _o->heroUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<ARENA_PLAY> ARENA_PLAY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_PLAY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_PLAY> CreateARENA_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_PLAYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _target_power = _o->target_power;
  auto _power = _o->power;
  auto _heroUDs = _o->heroUDs.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs) : 0;
  auto _target_kId = _o->target_kId;
  return OVERLORD::REQUEST::CreateARENA_PLAY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _target_power,
      _power,
      _heroUDs,
      _target_kId);
}

inline ARENA_PLAY_DONET *ARENA_PLAY_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_PLAY_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_PLAY_DONE::UnPackTo(ARENA_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = isWin(); _o->isWin = _e; };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
}

inline flatbuffers::Offset<ARENA_PLAY_DONE> ARENA_PLAY_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_PLAY_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_PLAY_DONE> CreateARENA_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_PLAY_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _isWin = _o->isWin;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  return OVERLORD::REQUEST::CreateARENA_PLAY_DONE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _isWin,
      _playUD);
}

inline ARENA_DEFENSE_REWARDT *ARENA_DEFENSE_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_DEFENSE_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_DEFENSE_REWARD::UnPackTo(ARENA_DEFENSE_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD> ARENA_DEFENSE_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_DEFENSE_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD> CreateARENA_DEFENSE_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_DEFENSE_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateARENA_DEFENSE_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline ARENA_SEASON_DONET *ARENA_SEASON_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_SEASON_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_SEASON_DONE::UnPackTo(ARENA_SEASON_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ARENA_SEASON_DONE> ARENA_SEASON_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_SEASON_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_SEASON_DONE> CreateARENA_SEASON_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_SEASON_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateARENA_SEASON_DONE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline ARENA_RANKING_LISTT *ARENA_RANKING_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_RANKING_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_RANKING_LIST::UnPackTo(ARENA_RANKING_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ARENA_RANKING_LIST> ARENA_RANKING_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_RANKING_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_RANKING_LIST> CreateARENA_RANKING_LIST(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_RANKING_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateARENA_RANKING_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline ARENA_DEFENSE_DECK_SETT *ARENA_DEFENSE_DECK_SET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_DEFENSE_DECK_SETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_DEFENSE_DECK_SET::UnPackTo(ARENA_DEFENSE_DECK_SETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = defense(); if (_e) { _o->defense.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->defense[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> ARENA_DEFENSE_DECK_SET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_DEFENSE_DECK_SET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET> CreateARENA_DEFENSE_DECK_SET(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_DEFENSE_DECK_SETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _defense = _o->defense.size() ? _fbb.CreateVectorOfStrings(_o->defense) : 0;
  return OVERLORD::REQUEST::CreateARENA_DEFENSE_DECK_SET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _defense);
}

inline AVATAR_ABILITY_UPT *AVATAR_ABILITY_UP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ABILITY_UPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ABILITY_UP::UnPackTo(AVATAR_ABILITY_UPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = point(); _o->point = _e; };
  { auto _e = abilityIndex(); _o->abilityIndex = _e; };
}

inline flatbuffers::Offset<AVATAR_ABILITY_UP> AVATAR_ABILITY_UP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ABILITY_UP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ABILITY_UP> CreateAVATAR_ABILITY_UP(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ABILITY_UPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _point = _o->point;
  auto _abilityIndex = _o->abilityIndex;
  return OVERLORD::REQUEST::CreateAVATAR_ABILITY_UP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _point,
      _abilityIndex);
}

inline AVATAR_ABILITY_RESETT *AVATAR_ABILITY_RESET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ABILITY_RESETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ABILITY_RESET::UnPackTo(AVATAR_ABILITY_RESETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<AVATAR_ABILITY_RESET> AVATAR_ABILITY_RESET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ABILITY_RESET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ABILITY_RESET> CreateAVATAR_ABILITY_RESET(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ABILITY_RESETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateAVATAR_ABILITY_RESET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline AVATAR_ICON_LISTT *AVATAR_ICON_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ICON_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ICON_LIST::UnPackTo(AVATAR_ICON_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<AVATAR_ICON_LIST> AVATAR_ICON_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ICON_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ICON_LIST> CreateAVATAR_ICON_LIST(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ICON_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateAVATAR_ICON_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline AVATAR_ICON_SETT *AVATAR_ICON_SET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ICON_SETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ICON_SET::UnPackTo(AVATAR_ICON_SETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = icon(); _o->icon = _e; };
}

inline flatbuffers::Offset<AVATAR_ICON_SET> AVATAR_ICON_SET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ICON_SET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ICON_SET> CreateAVATAR_ICON_SET(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ICON_SETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _icon = _o->icon;
  return OVERLORD::REQUEST::CreateAVATAR_ICON_SET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _icon);
}

inline AVATAR_PROFILET *AVATAR_PROFILE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_PROFILET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_PROFILE::UnPackTo(AVATAR_PROFILET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<AVATAR_PROFILE> AVATAR_PROFILE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_PROFILE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_PROFILE> CreateAVATAR_PROFILE(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_PROFILET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateAVATAR_PROFILE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline AVATAR_LOBBYT *AVATAR_LOBBY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_LOBBYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_LOBBY::UnPackTo(AVATAR_LOBBYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<AVATAR_LOBBY> AVATAR_LOBBY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_LOBBY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_LOBBY> CreateAVATAR_LOBBY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_LOBBYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateAVATAR_LOBBY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline AVATAR_GAME_DATAT *AVATAR_GAME_DATA::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_GAME_DATAT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_GAME_DATA::UnPackTo(AVATAR_GAME_DATAT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<AVATAR_GAME_DATA> AVATAR_GAME_DATA::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_GAME_DATA(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_GAME_DATA> CreateAVATAR_GAME_DATA(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_GAME_DATAT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateAVATAR_GAME_DATA(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline AVATAR_SELECTIVE_TUTORIAL_UPDATET *AVATAR_SELECTIVE_TUTORIAL_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_SELECTIVE_TUTORIAL_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_SELECTIVE_TUTORIAL_UPDATE::UnPackTo(AVATAR_SELECTIVE_TUTORIAL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = value(); _o->value = _e; };
  { auto _e = idx(); _o->idx = _e; };
}

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> AVATAR_SELECTIVE_TUTORIAL_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_SELECTIVE_TUTORIAL_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _value = _o->value;
  auto _idx = _o->idx;
  return OVERLORD::REQUEST::CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _value,
      _idx);
}

inline CHANNEL_INFO_LISTT *CHANNEL_INFO_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_INFO_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_INFO_LIST::UnPackTo(CHANNEL_INFO_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST> CHANNEL_INFO_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_INFO_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST> CreateCHANNEL_INFO_LIST(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_INFO_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateCHANNEL_INFO_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline CHANNEL_DETAILT *CHANNEL_DETAIL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_DETAILT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_DETAIL::UnPackTo(CHANNEL_DETAILT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = no(); _o->no = _e; };
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CHANNEL_DETAIL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_DETAIL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_DETAIL> CreateCHANNEL_DETAIL(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAILT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_DETAILT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _no = _o->no;
  return OVERLORD::REQUEST::CreateCHANNEL_DETAIL(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _no);
}

inline BILLING_TRANSACTION_CREATET *BILLING_TRANSACTION_CREATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BILLING_TRANSACTION_CREATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BILLING_TRANSACTION_CREATE::UnPackTo(BILLING_TRANSACTION_CREATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = redirect(); if (_e) _o->redirect = _e->str(); };
  { auto _e = product(); if (_e) _o->product = _e->str(); };
  { auto _e = purchase_system(); if (_e) _o->purchase_system = _e->str(); };
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE> BILLING_TRANSACTION_CREATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBILLING_TRANSACTION_CREATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE> CreateBILLING_TRANSACTION_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BILLING_TRANSACTION_CREATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _redirect = _o->redirect.empty() ? 0 : _fbb.CreateString(_o->redirect);
  auto _product = _o->product.empty() ? 0 : _fbb.CreateString(_o->product);
  auto _purchase_system = _o->purchase_system.empty() ? 0 : _fbb.CreateString(_o->purchase_system);
  return OVERLORD::REQUEST::CreateBILLING_TRANSACTION_CREATE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _redirect,
      _product,
      _purchase_system);
}

inline BILLING_TRANSACTION_SUCCESST *BILLING_TRANSACTION_SUCCESS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BILLING_TRANSACTION_SUCCESST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BILLING_TRANSACTION_SUCCESS::UnPackTo(BILLING_TRANSACTION_SUCCESST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = transaction_id(); if (_e) _o->transaction_id = _e->str(); };
  { auto _e = product(); if (_e) _o->product = _e->str(); };
  { auto _e = receipt(); if (_e) _o->receipt = _e->str(); };
  { auto _e = purchase_system(); if (_e) _o->purchase_system = _e->str(); };
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> BILLING_TRANSACTION_SUCCESS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBILLING_TRANSACTION_SUCCESS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS> CreateBILLING_TRANSACTION_SUCCESS(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BILLING_TRANSACTION_SUCCESST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _transaction_id = _o->transaction_id.empty() ? 0 : _fbb.CreateString(_o->transaction_id);
  auto _product = _o->product.empty() ? 0 : _fbb.CreateString(_o->product);
  auto _receipt = _o->receipt.empty() ? 0 : _fbb.CreateString(_o->receipt);
  auto _purchase_system = _o->purchase_system.empty() ? 0 : _fbb.CreateString(_o->purchase_system);
  return OVERLORD::REQUEST::CreateBILLING_TRANSACTION_SUCCESS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _transaction_id,
      _product,
      _receipt,
      _purchase_system);
}

inline COLOSSEUM_STATUST *COLOSSEUM_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_STATUS::UnPackTo(COLOSSEUM_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> COLOSSEUM_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_STATUS> CreateCOLOSSEUM_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateCOLOSSEUM_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline COLOSSEUM_PLAY_RESULTT *COLOSSEUM_PLAY_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_PLAY_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_PLAY_RESULT::UnPackTo(COLOSSEUM_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = roomKey(); if (_e) _o->roomKey = _e->str(); };
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> COLOSSEUM_PLAY_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_PLAY_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT> CreateCOLOSSEUM_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_PLAY_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _roomKey = _o->roomKey.empty() ? 0 : _fbb.CreateString(_o->roomKey);
  return OVERLORD::REQUEST::CreateCOLOSSEUM_PLAY_RESULT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _roomKey);
}

inline COLOSSEUM_SEASON_DONET *COLOSSEUM_SEASON_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_SEASON_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_SEASON_DONE::UnPackTo(COLOSSEUM_SEASON_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE> COLOSSEUM_SEASON_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_SEASON_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE> CreateCOLOSSEUM_SEASON_DONE(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_SEASON_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateCOLOSSEUM_SEASON_DONE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline COLOSSEUM_RANKING_LISTT *COLOSSEUM_RANKING_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_RANKING_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_RANKING_LIST::UnPackTo(COLOSSEUM_RANKING_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST> COLOSSEUM_RANKING_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_RANKING_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST> CreateCOLOSSEUM_RANKING_LIST(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_RANKING_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateCOLOSSEUM_RANKING_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline COMMUNITY_ARTICLE_WRITE_HEROT *COMMUNITY_ARTICLE_WRITE_HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_WRITE_HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_WRITE_HERO::UnPackTo(COMMUNITY_ARTICLE_WRITE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = contents(); if (_e) _o->contents = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> COMMUNITY_ARTICLE_WRITE_HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_WRITE_HERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO> CreateCOMMUNITY_ARTICLE_WRITE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_WRITE_HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _contents = _o->contents.empty() ? 0 : _fbb.CreateString(_o->contents);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_WRITE_HERO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _contents,
      _heroId);
}

inline COMMUNITY_ARTICLE_DELETE_HEROT *COMMUNITY_ARTICLE_DELETE_HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_DELETE_HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_DELETE_HERO::UnPackTo(COMMUNITY_ARTICLE_DELETE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = articleId(); if (_e) _o->articleId = _e->str(); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> COMMUNITY_ARTICLE_DELETE_HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_DELETE_HERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO> CreateCOMMUNITY_ARTICLE_DELETE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_DELETE_HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _articleId = _o->articleId.empty() ? 0 : _fbb.CreateString(_o->articleId);
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_DELETE_HERO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _articleId);
}

inline COMMUNITY_ARTICLE_LIST_HEROT *COMMUNITY_ARTICLE_LIST_HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_LIST_HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_LIST_HERO::UnPackTo(COMMUNITY_ARTICLE_LIST_HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = sortType(); _o->sortType = _e; };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> COMMUNITY_ARTICLE_LIST_HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_LIST_HERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO> CreateCOMMUNITY_ARTICLE_LIST_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_LIST_HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _sortType = _o->sortType;
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_LIST_HERO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _sortType,
      _heroId);
}

inline COMMUNITY_ARTICLE_VOTE_HEROT *COMMUNITY_ARTICLE_VOTE_HERO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_VOTE_HEROT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_VOTE_HERO::UnPackTo(COMMUNITY_ARTICLE_VOTE_HEROT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = recommend(); _o->recommend = _e; };
  { auto _e = articleId(); if (_e) _o->articleId = _e->str(); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> COMMUNITY_ARTICLE_VOTE_HERO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HEROT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_VOTE_HERO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO> CreateCOMMUNITY_ARTICLE_VOTE_HERO(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HEROT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_VOTE_HEROT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _recommend = _o->recommend;
  auto _articleId = _o->articleId.empty() ? 0 : _fbb.CreateString(_o->articleId);
  return OVERLORD::REQUEST::CreateCOMMUNITY_ARTICLE_VOTE_HERO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _recommend,
      _articleId);
}

inline CONTENT_RESET_STATUST *CONTENT_RESET_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CONTENT_RESET_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CONTENT_RESET_STATUS::UnPackTo(CONTENT_RESET_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = resetKey(); if (_e) _o->resetKey = _e->str(); };
  { auto _e = resetType(); if (_e) _o->resetType = _e->str(); };
}

inline flatbuffers::Offset<CONTENT_RESET_STATUS> CONTENT_RESET_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCONTENT_RESET_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CONTENT_RESET_STATUS> CreateCONTENT_RESET_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CONTENT_RESET_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _resetKey = _o->resetKey.empty() ? 0 : _fbb.CreateString(_o->resetKey);
  auto _resetType = _o->resetType.empty() ? 0 : _fbb.CreateString(_o->resetType);
  return OVERLORD::REQUEST::CreateCONTENT_RESET_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _resetKey,
      _resetType);
}

inline CONTENT_RESETT *CONTENT_RESET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CONTENT_RESETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CONTENT_RESET::UnPackTo(CONTENT_RESETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = resetKey(); if (_e) _o->resetKey = _e->str(); };
  { auto _e = resetType(); if (_e) _o->resetType = _e->str(); };
}

inline flatbuffers::Offset<CONTENT_RESET> CONTENT_RESET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCONTENT_RESET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CONTENT_RESET> CreateCONTENT_RESET(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CONTENT_RESETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _resetKey = _o->resetKey.empty() ? 0 : _fbb.CreateString(_o->resetKey);
  auto _resetType = _o->resetType.empty() ? 0 : _fbb.CreateString(_o->resetType);
  return OVERLORD::REQUEST::CreateCONTENT_RESET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _resetKey,
      _resetType);
}

inline ATTENDANCE_GETT *ATTENDANCE_GET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ATTENDANCE_GETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ATTENDANCE_GET::UnPackTo(ATTENDANCE_GETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<ATTENDANCE_GET> ATTENDANCE_GET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateATTENDANCE_GET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ATTENDANCE_GET> CreateATTENDANCE_GET(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ATTENDANCE_GETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateATTENDANCE_GET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_CREATET *GUILD_CREATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CREATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CREATE::UnPackTo(GUILD_CREATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = auto_grade_up(); _o->auto_grade_up = _e; };
  { auto _e = notice(); if (_e) _o->notice = _e->str(); };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<GUILD_CREATE> GUILD_CREATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CREATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CREATE> CreateGUILD_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CREATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _auto_grade_up = _o->auto_grade_up;
  auto _notice = _o->notice.empty() ? 0 : _fbb.CreateString(_o->notice);
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return OVERLORD::REQUEST::CreateGUILD_CREATE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _auto_grade_up,
      _notice,
      _desc,
      _name);
}

inline GUILD_CLOSET *GUILD_CLOSE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CLOSET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CLOSE::UnPackTo(GUILD_CLOSET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_CLOSE> GUILD_CLOSE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CLOSE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CLOSE> CreateGUILD_CLOSE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CLOSET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_CLOSE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_GETT *GUILD_GET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_GETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_GET::UnPackTo(GUILD_GETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_GET> GUILD_GET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_GET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_GET> CreateGUILD_GET(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_GETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_GET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_GET_GUESTT *GUILD_GET_GUEST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_GET_GUESTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_GET_GUEST::UnPackTo(GUILD_GET_GUESTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = page(); _o->page = _e; };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_GET_GUEST> GUILD_GET_GUEST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_GET_GUEST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_GET_GUEST> CreateGUILD_GET_GUEST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_GET_GUESTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _page = _o->page;
  auto _guild_id = _o->guild_id;
  return OVERLORD::REQUEST::CreateGUILD_GET_GUEST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _page,
      _guild_id);
}

inline GUILD_MEMBER_LISTT *GUILD_MEMBER_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_LIST::UnPackTo(GUILD_MEMBER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = page(); _o->page = _e; };
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST> GUILD_MEMBER_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST> CreateGUILD_MEMBER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _page = _o->page;
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _page);
}

inline GUILD_AWAITER_LISTT *GUILD_AWAITER_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_LIST::UnPackTo(GUILD_AWAITER_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = page(); _o->page = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST> GUILD_AWAITER_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST> CreateGUILD_AWAITER_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _page = _o->page;
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _page);
}

inline GUILD_AWAITER_ACCEPTT *GUILD_AWAITER_ACCEPT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_ACCEPTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_ACCEPT::UnPackTo(GUILD_AWAITER_ACCEPTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = accept(); _o->accept = _e; };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT> GUILD_AWAITER_ACCEPT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_ACCEPT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT> CreateGUILD_AWAITER_ACCEPT(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_ACCEPTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _accept = _o->accept;
  auto _target_kId = _o->target_kId;
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_ACCEPT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _accept,
      _target_kId);
}

inline GUILD_AWAITER_CANCELT *GUILD_AWAITER_CANCEL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_CANCELT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_CANCEL::UnPackTo(GUILD_AWAITER_CANCELT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL> GUILD_AWAITER_CANCEL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCELT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_CANCEL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL> CreateGUILD_AWAITER_CANCEL(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCELT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_CANCELT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _guild_id = _o->guild_id;
  return OVERLORD::REQUEST::CreateGUILD_AWAITER_CANCEL(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _guild_id);
}

inline GUILD_FIND_NAMET *GUILD_FIND_NAME::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_FIND_NAMET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_FIND_NAME::UnPackTo(GUILD_FIND_NAMET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<GUILD_FIND_NAME> GUILD_FIND_NAME::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAMET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_FIND_NAME(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_FIND_NAME> CreateGUILD_FIND_NAME(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAMET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_FIND_NAMET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return OVERLORD::REQUEST::CreateGUILD_FIND_NAME(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _name);
}

inline GUILD_CHANGE_NAMET *GUILD_CHANGE_NAME::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CHANGE_NAMET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CHANGE_NAME::UnPackTo(GUILD_CHANGE_NAMET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = name(); if (_e) _o->name = _e->str(); };
}

inline flatbuffers::Offset<GUILD_CHANGE_NAME> GUILD_CHANGE_NAME::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAMET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CHANGE_NAME(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CHANGE_NAME> CreateGUILD_CHANGE_NAME(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAMET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CHANGE_NAMET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return OVERLORD::REQUEST::CreateGUILD_CHANGE_NAME(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _name);
}

inline GUILD_EDIT_DESCT *GUILD_EDIT_DESC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_DESCT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_DESC::UnPackTo(GUILD_EDIT_DESCT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = desc(); if (_e) _o->desc = _e->str(); };
}

inline flatbuffers::Offset<GUILD_EDIT_DESC> GUILD_EDIT_DESC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESCT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_DESC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_DESC> CreateGUILD_EDIT_DESC(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESCT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_DESCT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  return OVERLORD::REQUEST::CreateGUILD_EDIT_DESC(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _desc);
}

inline GUILD_EDIT_NOTICET *GUILD_EDIT_NOTICE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_NOTICET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_NOTICE::UnPackTo(GUILD_EDIT_NOTICET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = notice(); if (_e) _o->notice = _e->str(); };
}

inline flatbuffers::Offset<GUILD_EDIT_NOTICE> GUILD_EDIT_NOTICE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_NOTICE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_NOTICE> CreateGUILD_EDIT_NOTICE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_NOTICET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _notice = _o->notice.empty() ? 0 : _fbb.CreateString(_o->notice);
  return OVERLORD::REQUEST::CreateGUILD_EDIT_NOTICE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _notice);
}

inline GUILD_EDIT_AUTO_GRADE_UPT *GUILD_EDIT_AUTO_GRADE_UP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_AUTO_GRADE_UPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_AUTO_GRADE_UP::UnPackTo(GUILD_EDIT_AUTO_GRADE_UPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = auto_grade_up(); _o->auto_grade_up = _e; };
}

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> GUILD_EDIT_AUTO_GRADE_UP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_AUTO_GRADE_UP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP> CreateGUILD_EDIT_AUTO_GRADE_UP(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_AUTO_GRADE_UPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _auto_grade_up = _o->auto_grade_up;
  return OVERLORD::REQUEST::CreateGUILD_EDIT_AUTO_GRADE_UP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _auto_grade_up);
}

inline GUILD_JOINT *GUILD_JOIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_JOINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_JOIN::UnPackTo(GUILD_JOINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_JOIN> GUILD_JOIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_JOIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_JOIN> CreateGUILD_JOIN(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_JOINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _guild_id = _o->guild_id;
  return OVERLORD::REQUEST::CreateGUILD_JOIN(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _guild_id);
}

inline GUILD_JOIN_AUTOT *GUILD_JOIN_AUTO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_JOIN_AUTOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_JOIN_AUTO::UnPackTo(GUILD_JOIN_AUTOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_JOIN_AUTO> GUILD_JOIN_AUTO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_JOIN_AUTO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_JOIN_AUTO> CreateGUILD_JOIN_AUTO(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_JOIN_AUTOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_JOIN_AUTO(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_MEMBER_GRADET *GUILD_MEMBER_GRADE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_GRADET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_GRADE::UnPackTo(GUILD_MEMBER_GRADET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = grade(); _o->grade = _e; };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<GUILD_MEMBER_GRADE> GUILD_MEMBER_GRADE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_GRADE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_GRADE> CreateGUILD_MEMBER_GRADE(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_GRADET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _grade = _o->grade;
  auto _target_kId = _o->target_kId;
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_GRADE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _grade,
      _target_kId);
}

inline GUILD_MEMBER_KICKT *GUILD_MEMBER_KICK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_KICKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_KICK::UnPackTo(GUILD_MEMBER_KICKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<GUILD_MEMBER_KICK> GUILD_MEMBER_KICK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_KICK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_KICK> CreateGUILD_MEMBER_KICK(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_KICKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _target_kId = _o->target_kId;
  return OVERLORD::REQUEST::CreateGUILD_MEMBER_KICK(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _target_kId);
}

inline GUILD_CONTRIBUTIONT *GUILD_CONTRIBUTION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTION::UnPackTo(GUILD_CONTRIBUTIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = contributionType(); _o->contributionType = _e; };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION> GUILD_CONTRIBUTION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION> CreateGUILD_CONTRIBUTION(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _contributionType = _o->contributionType;
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTION(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _contributionType);
}

inline GUILD_CONTRIBUTE_RANKINGT *GUILD_CONTRIBUTE_RANKING::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTE_RANKINGT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTE_RANKING::UnPackTo(GUILD_CONTRIBUTE_RANKINGT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = page(); _o->page = _e; };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> GUILD_CONTRIBUTE_RANKING::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKINGT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTE_RANKING(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING> CreateGUILD_CONTRIBUTE_RANKING(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKINGT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTE_RANKINGT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _page = _o->page;
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTE_RANKING(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _page);
}

inline GUILD_CONTRIBUTION_STATUST *GUILD_CONTRIBUTION_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTION_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTION_STATUS::UnPackTo(GUILD_CONTRIBUTION_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> GUILD_CONTRIBUTION_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTION_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS> CreateGUILD_CONTRIBUTION_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTION_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_CONTRIBUTION_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_ATTENDANCE_STATUST *GUILD_ATTENDANCE_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_STATUS::UnPackTo(GUILD_ATTENDANCE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> GUILD_ATTENDANCE_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS> CreateGUILD_ATTENDANCE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_ATTENDANCE_DAILY_REWARDT *GUILD_ATTENDANCE_DAILY_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_DAILY_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_DAILY_REWARD::UnPackTo(GUILD_ATTENDANCE_DAILY_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> GUILD_ATTENDANCE_DAILY_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_DAILY_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD> CreateGUILD_ATTENDANCE_DAILY_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_DAILY_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_DAILY_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_ATTENDANCE_WEEKLY_REWARDT *GUILD_ATTENDANCE_WEEKLY_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_WEEKLY_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_WEEKLY_REWARD::UnPackTo(GUILD_ATTENDANCE_WEEKLY_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> GUILD_ATTENDANCE_WEEKLY_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_WEEKLY_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD> CreateGUILD_ATTENDANCE_WEEKLY_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_WEEKLY_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_ATTENDANCE_WEEKLY_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_RUNE_STATUST *GUILD_RUNE_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_STATUS::UnPackTo(GUILD_RUNE_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS> GUILD_RUNE_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS> CreateGUILD_RUNE_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_RUNE_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_RUNE_REQUESTT *GUILD_RUNE_REQUEST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_REQUESTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_REQUEST::UnPackTo(GUILD_RUNE_REQUESTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST> GUILD_RUNE_REQUEST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_REQUEST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST> CreateGUILD_RUNE_REQUEST(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUESTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_REQUESTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  return OVERLORD::REQUEST::CreateGUILD_RUNE_REQUEST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _heroId);
}

inline GUILD_RUNE_SUPPORTT *GUILD_RUNE_SUPPORT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_SUPPORTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_SUPPORT::UnPackTo(GUILD_RUNE_SUPPORTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = requester_kId(); _o->requester_kId = _e; };
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT> GUILD_RUNE_SUPPORT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_SUPPORT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT> CreateGUILD_RUNE_SUPPORT(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_SUPPORTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _amount = _o->amount;
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _requester_kId = _o->requester_kId;
  return OVERLORD::REQUEST::CreateGUILD_RUNE_SUPPORT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _amount,
      _heroId,
      _requester_kId);
}

inline GUILD_RUNE_GETT *GUILD_RUNE_GET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_GETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_GET::UnPackTo(GUILD_RUNE_GETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_RUNE_GET> GUILD_RUNE_GET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_GET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_GET> CreateGUILD_RUNE_GET(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_GETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_RUNE_GET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_HISTORYT *GUILD_HISTORY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_HISTORYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_HISTORY::UnPackTo(GUILD_HISTORYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GUILD_HISTORY> GUILD_HISTORY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_HISTORY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_HISTORY> CreateGUILD_HISTORY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_HISTORYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGUILD_HISTORY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GUILD_LEVEL_UPT *GUILD_LEVEL_UP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_LEVEL_UPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_LEVEL_UP::UnPackTo(GUILD_LEVEL_UPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = level(); _o->level = _e; };
}

inline flatbuffers::Offset<GUILD_LEVEL_UP> GUILD_LEVEL_UP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_LEVEL_UP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_LEVEL_UP> CreateGUILD_LEVEL_UP(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_LEVEL_UPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _level = _o->level;
  return OVERLORD::REQUEST::CreateGUILD_LEVEL_UP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _level);
}

inline INVENTORY_HERO_UPGRADET *INVENTORY_HERO_UPGRADE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_UPGRADET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_UPGRADE::UnPackTo(INVENTORY_HERO_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = materials4(); if (_e) { _o->materials4.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->materials4[_i] = _e->Get(_i)->str(); } } };
  { auto _e = materials3(); if (_e) { _o->materials3.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->materials3[_i] = _e->Get(_i)->str(); } } };
  { auto _e = materials2(); if (_e) { _o->materials2.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->materials2[_i] = _e->Get(_i)->str(); } } };
  { auto _e = materials1(); if (_e) { _o->materials1.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->materials1[_i] = _e->Get(_i)->str(); } } };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE> INVENTORY_HERO_UPGRADE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_UPGRADE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE> CreateINVENTORY_HERO_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_UPGRADET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _materials4 = _o->materials4.size() ? _fbb.CreateVectorOfStrings(_o->materials4) : 0;
  auto _materials3 = _o->materials3.size() ? _fbb.CreateVectorOfStrings(_o->materials3) : 0;
  auto _materials2 = _o->materials2.size() ? _fbb.CreateVectorOfStrings(_o->materials2) : 0;
  auto _materials1 = _o->materials1.size() ? _fbb.CreateVectorOfStrings(_o->materials1) : 0;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_UPGRADE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _materials4,
      _materials3,
      _materials2,
      _materials1,
      _heroUD);
}

inline INVENTORY_HERO_LEVELUPT *INVENTORY_HERO_LEVELUP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_LEVELUPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_LEVELUP::UnPackTo(INVENTORY_HERO_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP> INVENTORY_HERO_LEVELUP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_LEVELUP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP> CreateINVENTORY_HERO_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_LEVELUPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _level = _o->level;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_LEVELUP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _level,
      _heroUD);
}

inline INVENTORY_HERO_GRINDT *INVENTORY_HERO_GRIND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_GRINDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_GRIND::UnPackTo(INVENTORY_HERO_GRINDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = heroUDs(); if (_e) { _o->heroUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND> INVENTORY_HERO_GRIND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRINDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_GRIND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND> CreateINVENTORY_HERO_GRIND(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRINDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_GRINDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _heroUDs = _o->heroUDs.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs) : 0;
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_GRIND(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _heroUDs);
}

inline INVENTORY_HERO_EQUIPT *INVENTORY_HERO_EQUIP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_EQUIPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_EQUIP::UnPackTo(INVENTORY_HERO_EQUIPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP> INVENTORY_HERO_EQUIP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_EQUIP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP> CreateINVENTORY_HERO_EQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_EQUIPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_EQUIP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _itemUD,
      _heroUD);
}

inline INVENTORY_HERO_UNEQUIPT *INVENTORY_HERO_UNEQUIP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_UNEQUIPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_UNEQUIP::UnPackTo(INVENTORY_HERO_UNEQUIPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> INVENTORY_HERO_UNEQUIP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_UNEQUIP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP> CreateINVENTORY_HERO_UNEQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_UNEQUIPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_UNEQUIP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _itemUD,
      _heroUD);
}

inline INVENTORY_ITEM_GRINDT *INVENTORY_ITEM_GRIND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_GRINDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_GRIND::UnPackTo(INVENTORY_ITEM_GRINDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = itemUDs(); if (_e) { _o->itemUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->itemUDs[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND> INVENTORY_ITEM_GRIND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRINDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_GRIND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND> CreateINVENTORY_ITEM_GRIND(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRINDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_GRINDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _itemUDs = _o->itemUDs.size() ? _fbb.CreateVectorOfStrings(_o->itemUDs) : 0;
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_GRIND(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _itemUDs);
}

inline INVENTORY_RUNE_EQUIPT *INVENTORY_RUNE_EQUIP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_EQUIPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_EQUIP::UnPackTo(INVENTORY_RUNE_EQUIPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = equipRunes(); if (_e) { _o->equipRunes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->equipRunes[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP> INVENTORY_RUNE_EQUIP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_EQUIP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP> CreateINVENTORY_RUNE_EQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_EQUIPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _equipRunes = _o->equipRunes.size() ? _fbb.CreateVectorOfStrings(_o->equipRunes) : 0;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_EQUIP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _equipRunes,
      _itemUD);
}

inline INVENTORY_RUNE_UNEQUIPT *INVENTORY_RUNE_UNEQUIP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_UNEQUIPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_UNEQUIP::UnPackTo(INVENTORY_RUNE_UNEQUIPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = unequipSlots(); if (_e) { _o->unequipSlots.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->unequipSlots[_i] = _e->Get(_i) != 0; } } };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> INVENTORY_RUNE_UNEQUIP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_UNEQUIP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP> CreateINVENTORY_RUNE_UNEQUIP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_UNEQUIPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _unequipSlots = _o->unequipSlots.size() ? _fbb.CreateVector(_o->unequipSlots) : 0;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_UNEQUIP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _unequipSlots,
      _itemUD);
}

inline INVENTORY_RUNE_MAKET *INVENTORY_RUNE_MAKE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_MAKET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_MAKE::UnPackTo(INVENTORY_RUNE_MAKET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = rune(); if (_e) _o->rune = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE> INVENTORY_RUNE_MAKE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_MAKE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE> CreateINVENTORY_RUNE_MAKE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_MAKET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _amount = _o->amount;
  auto _rune = _o->rune.empty() ? 0 : _fbb.CreateString(_o->rune);
  return OVERLORD::REQUEST::CreateINVENTORY_RUNE_MAKE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _amount,
      _rune);
}

inline INVENTORY_ITEM_LEVELUPT *INVENTORY_ITEM_LEVELUP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_LEVELUPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_LEVELUP::UnPackTo(INVENTORY_ITEM_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> INVENTORY_ITEM_LEVELUP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_LEVELUP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP> CreateINVENTORY_ITEM_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_LEVELUPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _amount = _o->amount;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_LEVELUP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _amount,
      _itemUD);
}

inline INVENTORY_ITEM_ENCHANTT *INVENTORY_ITEM_ENCHANT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_ENCHANTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_ENCHANT::UnPackTo(INVENTORY_ITEM_ENCHANTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = useProtection(); _o->useProtection = _e; };
  { auto _e = specialEnchant(); _o->specialEnchant = _e; };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> INVENTORY_ITEM_ENCHANT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_ENCHANT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT> CreateINVENTORY_ITEM_ENCHANT(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_ENCHANTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _useProtection = _o->useProtection;
  auto _specialEnchant = _o->specialEnchant;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_ENCHANT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _useProtection,
      _specialEnchant,
      _itemUD);
}

inline INVENTORY_ITEM_HERO_LOCKT *INVENTORY_ITEM_HERO_LOCK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_HERO_LOCKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_HERO_LOCK::UnPackTo(INVENTORY_ITEM_HERO_LOCKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = heroUDs_unlock(); if (_e) { _o->heroUDs_unlock.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs_unlock[_i] = _e->Get(_i)->str(); } } };
  { auto _e = heroUDs_lock(); if (_e) { _o->heroUDs_lock.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs_lock[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUDs_unlock(); if (_e) { _o->itemUDs_unlock.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->itemUDs_unlock[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUDs_lock(); if (_e) { _o->itemUDs_lock.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->itemUDs_lock[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> INVENTORY_ITEM_HERO_LOCK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_HERO_LOCK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK> CreateINVENTORY_ITEM_HERO_LOCK(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_HERO_LOCKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _heroUDs_unlock = _o->heroUDs_unlock.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs_unlock) : 0;
  auto _heroUDs_lock = _o->heroUDs_lock.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs_lock) : 0;
  auto _itemUDs_unlock = _o->itemUDs_unlock.size() ? _fbb.CreateVectorOfStrings(_o->itemUDs_unlock) : 0;
  auto _itemUDs_lock = _o->itemUDs_lock.size() ? _fbb.CreateVectorOfStrings(_o->itemUDs_lock) : 0;
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_HERO_LOCK(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _heroUDs_unlock,
      _heroUDs_lock,
      _itemUDs_unlock,
      _itemUDs_lock);
}

inline INVENTORY_HERO_SKILL_LEVELUPT *INVENTORY_HERO_SKILL_LEVELUP::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_SKILL_LEVELUPT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_SKILL_LEVELUP::UnPackTo(INVENTORY_HERO_SKILL_LEVELUPT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> INVENTORY_HERO_SKILL_LEVELUP::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUPT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_SKILL_LEVELUP(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP> CreateINVENTORY_HERO_SKILL_LEVELUP(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUPT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_SKILL_LEVELUPT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _slot = _o->slot;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_SKILL_LEVELUP(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _slot,
      _heroUD);
}

inline INVENTORY_HERO_ENCHANT_CONSUMET *INVENTORY_HERO_ENCHANT_CONSUME::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_ENCHANT_CONSUMET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_ENCHANT_CONSUME::UnPackTo(INVENTORY_HERO_ENCHANT_CONSUMET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = spiritUDs(); if (_e) { _o->spiritUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spiritUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> INVENTORY_HERO_ENCHANT_CONSUME::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUMET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_ENCHANT_CONSUME(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME> CreateINVENTORY_HERO_ENCHANT_CONSUME(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUMET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_ENCHANT_CONSUMET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _spiritUDs = _o->spiritUDs.size() ? _fbb.CreateVectorOfStrings(_o->spiritUDs) : 0;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_ENCHANT_CONSUME(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _spiritUDs,
      _heroUD);
}

inline INVENTORY_HERO_ENCHANT_STATT *INVENTORY_HERO_ENCHANT_STAT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_ENCHANT_STATT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_ENCHANT_STAT::UnPackTo(INVENTORY_HERO_ENCHANT_STATT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = enchantStat(); if (_e) { _o->enchantStat.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enchantStat[_i] = _e->Get(_i); } } };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> INVENTORY_HERO_ENCHANT_STAT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STATT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_ENCHANT_STAT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT> CreateINVENTORY_HERO_ENCHANT_STAT(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STATT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_ENCHANT_STATT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _enchantStat = _o->enchantStat.size() ? _fbb.CreateVector(_o->enchantStat) : 0;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  return OVERLORD::REQUEST::CreateINVENTORY_HERO_ENCHANT_STAT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _enchantStat,
      _heroUD);
}

inline INVENTORY_SELLT *INVENTORY_SELL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_SELLT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_SELL::UnPackTo(INVENTORY_SELLT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = walletQtyList(); if (_e) { _o->walletQtyList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->walletQtyList[_i] = _e->Get(_i); } } };
  { auto _e = walletIdList(); if (_e) { _o->walletIdList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->walletIdList[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUDs(); if (_e) { _o->itemUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->itemUDs[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<INVENTORY_SELL> INVENTORY_SELL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELLT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_SELL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_SELL> CreateINVENTORY_SELL(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELLT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_SELLT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _walletQtyList = _o->walletQtyList.size() ? _fbb.CreateVector(_o->walletQtyList) : 0;
  auto _walletIdList = _o->walletIdList.size() ? _fbb.CreateVectorOfStrings(_o->walletIdList) : 0;
  auto _itemUDs = _o->itemUDs.size() ? _fbb.CreateVectorOfStrings(_o->itemUDs) : 0;
  return OVERLORD::REQUEST::CreateINVENTORY_SELL(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _walletQtyList,
      _walletIdList,
      _itemUDs);
}

inline INVENTORY_ITEM_UPGRADET *INVENTORY_ITEM_UPGRADE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_UPGRADET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_UPGRADE::UnPackTo(INVENTORY_ITEM_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = material_itemUDs(); if (_e) { _o->material_itemUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->material_itemUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> INVENTORY_ITEM_UPGRADE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_UPGRADE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE> CreateINVENTORY_ITEM_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_UPGRADET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _material_itemUDs = _o->material_itemUDs.size() ? _fbb.CreateVectorOfStrings(_o->material_itemUDs) : 0;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_UPGRADE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _material_itemUDs,
      _itemUD);
}

inline INVENTORY_ITEM_OPTION_RESETT *INVENTORY_ITEM_OPTION_RESET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_OPTION_RESETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_OPTION_RESET::UnPackTo(INVENTORY_ITEM_OPTION_RESETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = material_itemUDs(); if (_e) { _o->material_itemUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->material_itemUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = itemUD(); if (_e) _o->itemUD = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> INVENTORY_ITEM_OPTION_RESET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_OPTION_RESET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET> CreateINVENTORY_ITEM_OPTION_RESET(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_OPTION_RESETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _material_itemUDs = _o->material_itemUDs.size() ? _fbb.CreateVectorOfStrings(_o->material_itemUDs) : 0;
  auto _itemUD = _o->itemUD.empty() ? 0 : _fbb.CreateString(_o->itemUD);
  return OVERLORD::REQUEST::CreateINVENTORY_ITEM_OPTION_RESET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _material_itemUDs,
      _itemUD);
}

inline INVENTORY_TIMETREASURE_GETT *INVENTORY_TIMETREASURE_GET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_TIMETREASURE_GETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_TIMETREASURE_GET::UnPackTo(INVENTORY_TIMETREASURE_GETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> INVENTORY_TIMETREASURE_GET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_TIMETREASURE_GET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET> CreateINVENTORY_TIMETREASURE_GET(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_TIMETREASURE_GETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateINVENTORY_TIMETREASURE_GET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline INVENTORY_UPGRADET *INVENTORY_UPGRADE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_UPGRADET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_UPGRADE::UnPackTo(INVENTORY_UPGRADET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = upgradeType(); _o->upgradeType = _e; };
  { auto _e = upgrade(); _o->upgrade = _e; };
}

inline flatbuffers::Offset<INVENTORY_UPGRADE> INVENTORY_UPGRADE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_UPGRADE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_UPGRADE> CreateINVENTORY_UPGRADE(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_UPGRADET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _upgradeType = _o->upgradeType;
  auto _upgrade = _o->upgrade;
  return OVERLORD::REQUEST::CreateINVENTORY_UPGRADE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _upgradeType,
      _upgrade);
}

inline GIFT_LISTT *GIFT_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIFT_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIFT_LIST::UnPackTo(GIFT_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = size(); _o->size = _e; };
  { auto _e = holds(); _o->holds = _e; };
}

inline flatbuffers::Offset<GIFT_LIST> GIFT_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIFT_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIFT_LIST> CreateGIFT_LIST(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIFT_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _size = _o->size;
  auto _holds = _o->holds;
  return OVERLORD::REQUEST::CreateGIFT_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _size,
      _holds);
}

inline GIFT_OPENT *GIFT_OPEN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIFT_OPENT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIFT_OPEN::UnPackTo(GIFT_OPENT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = mailUDs(); if (_e) { _o->mailUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mailUDs[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<GIFT_OPEN> GIFT_OPEN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIFT_OPEN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIFT_OPEN> CreateGIFT_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIFT_OPENT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _mailUDs = _o->mailUDs.size() ? _fbb.CreateVectorOfStrings(_o->mailUDs) : 0;
  return OVERLORD::REQUEST::CreateGIFT_OPEN(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _mailUDs);
}

inline SPECIAL_GIFT_LISTT *SPECIAL_GIFT_LIST::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SPECIAL_GIFT_LISTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SPECIAL_GIFT_LIST::UnPackTo(SPECIAL_GIFT_LISTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = size(); _o->size = _e; };
  { auto _e = holds(); _o->holds = _e; };
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST> SPECIAL_GIFT_LIST::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LISTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSPECIAL_GIFT_LIST(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST> CreateSPECIAL_GIFT_LIST(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LISTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SPECIAL_GIFT_LISTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _size = _o->size;
  auto _holds = _o->holds;
  return OVERLORD::REQUEST::CreateSPECIAL_GIFT_LIST(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _size,
      _holds);
}

inline SPECIAL_GIFT_OPENT *SPECIAL_GIFT_OPEN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SPECIAL_GIFT_OPENT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SPECIAL_GIFT_OPEN::UnPackTo(SPECIAL_GIFT_OPENT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = giftIdx(); _o->giftIdx = _e; };
  { auto _e = mailUD(); if (_e) { _o->mailUD.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mailUD[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN> SPECIAL_GIFT_OPEN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSPECIAL_GIFT_OPEN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN> CreateSPECIAL_GIFT_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SPECIAL_GIFT_OPENT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _giftIdx = _o->giftIdx;
  auto _mailUD = _o->mailUD.size() ? _fbb.CreateVectorOfStrings(_o->mailUD) : 0;
  return OVERLORD::REQUEST::CreateSPECIAL_GIFT_OPEN(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _giftIdx,
      _mailUD);
}

inline MIRROR_STATUST *MIRROR_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_STATUS::UnPackTo(MIRROR_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<MIRROR_STATUS> MIRROR_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_STATUS> CreateMIRROR_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateMIRROR_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline MIRROR_PLAY_STARTT *MIRROR_PLAY_START::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_PLAY_STARTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_PLAY_START::UnPackTo(MIRROR_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = heroUDs(); if (_e) { _o->heroUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = mirrorUD(); if (_e) _o->mirrorUD = _e->str(); };
}

inline flatbuffers::Offset<MIRROR_PLAY_START> MIRROR_PLAY_START::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_PLAY_START(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_PLAY_START> CreateMIRROR_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_PLAY_STARTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _heroUDs = _o->heroUDs.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs) : 0;
  auto _mirrorUD = _o->mirrorUD.empty() ? 0 : _fbb.CreateString(_o->mirrorUD);
  return OVERLORD::REQUEST::CreateMIRROR_PLAY_START(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _heroUDs,
      _mirrorUD);
}

inline MIRROR_PLAY_DONET *MIRROR_PLAY_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_PLAY_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_PLAY_DONE::UnPackTo(MIRROR_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = target_heroHPs_hp(); if (_e) { _o->target_heroHPs_hp.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->target_heroHPs_hp[_i] = _e->Get(_i); } } };
  { auto _e = heroHPs_hp(); if (_e) { _o->heroHPs_hp.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroHPs_hp[_i] = _e->Get(_i); } } };
  { auto _e = clearGrade(); _o->clearGrade = _e; };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE> MIRROR_PLAY_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_PLAY_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE> CreateMIRROR_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_PLAY_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _target_heroHPs_hp = _o->target_heroHPs_hp.size() ? _fbb.CreateVector(_o->target_heroHPs_hp) : 0;
  auto _heroHPs_hp = _o->heroHPs_hp.size() ? _fbb.CreateVector(_o->heroHPs_hp) : 0;
  auto _clearGrade = _o->clearGrade;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  return OVERLORD::REQUEST::CreateMIRROR_PLAY_DONE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _target_heroHPs_hp,
      _heroHPs_hp,
      _clearGrade,
      _playUD);
}

inline MIRROR_RESETT *MIRROR_RESET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_RESETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_RESET::UnPackTo(MIRROR_RESETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = useGem(); _o->useGem = _e; };
}

inline flatbuffers::Offset<MIRROR_RESET> MIRROR_RESET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_RESET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_RESET> CreateMIRROR_RESET(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_RESETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _useGem = _o->useGem;
  return OVERLORD::REQUEST::CreateMIRROR_RESET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _useGem);
}

inline MIRROR_DEFENSE_DECK_SETT *MIRROR_DEFENSE_DECK_SET::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_DEFENSE_DECK_SETT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_DEFENSE_DECK_SET::UnPackTo(MIRROR_DEFENSE_DECK_SETT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = defense(); if (_e) { _o->defense.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->defense[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> MIRROR_DEFENSE_DECK_SET::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SETT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_DEFENSE_DECK_SET(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET> CreateMIRROR_DEFENSE_DECK_SET(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SETT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_DEFENSE_DECK_SETT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _defense = _o->defense.size() ? _fbb.CreateVectorOfStrings(_o->defense) : 0;
  return OVERLORD::REQUEST::CreateMIRROR_DEFENSE_DECK_SET(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _defense);
}

inline GIVE_ACHIEVE_REWARDT *GIVE_ACHIEVE_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIVE_ACHIEVE_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIVE_ACHIEVE_REWARD::UnPackTo(GIVE_ACHIEVE_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = target_level(); _o->target_level = _e; };
  { auto _e = srl(); _o->srl = _e; };
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD> GIVE_ACHIEVE_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIVE_ACHIEVE_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD> CreateGIVE_ACHIEVE_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIVE_ACHIEVE_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _target_level = _o->target_level;
  auto _srl = _o->srl;
  return OVERLORD::REQUEST::CreateGIVE_ACHIEVE_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _target_level,
      _srl);
}

inline DAILY_QUEST_STATUST *DAILY_QUEST_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_STATUS::UnPackTo(DAILY_QUEST_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> DAILY_QUEST_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS> CreateDAILY_QUEST_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateDAILY_QUEST_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline DAILY_QUEST_REWARDT *DAILY_QUEST_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_REWARD::UnPackTo(DAILY_QUEST_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = idx(); _o->idx = _e; };
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD> DAILY_QUEST_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD> CreateDAILY_QUEST_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _idx = _o->idx;
  return OVERLORD::REQUEST::CreateDAILY_QUEST_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _idx);
}

inline SHOP_USER_DATAT *SHOP_USER_DATA::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_USER_DATAT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_USER_DATA::UnPackTo(SHOP_USER_DATAT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<SHOP_USER_DATA> SHOP_USER_DATA::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_USER_DATA(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_USER_DATA> CreateSHOP_USER_DATA(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATAT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_USER_DATAT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateSHOP_USER_DATA(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline SHOP_BUYT *SHOP_BUY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_BUYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_BUY::UnPackTo(SHOP_BUYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = price(); _o->price = _e; };
  { auto _e = currencyType(); if (_e) _o->currencyType = _e->str(); };
  { auto _e = amount(); _o->amount = _e; };
  { auto _e = productType(); _o->productType = _e; };
  { auto _e = productId(); if (_e) _o->productId = _e->str(); };
}

inline flatbuffers::Offset<SHOP_BUY> SHOP_BUY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_BUY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_BUY> CreateSHOP_BUY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_BUYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _price = _o->price;
  auto _currencyType = _o->currencyType.empty() ? 0 : _fbb.CreateString(_o->currencyType);
  auto _amount = _o->amount;
  auto _productType = _o->productType;
  auto _productId = _o->productId.empty() ? 0 : _fbb.CreateString(_o->productId);
  return OVERLORD::REQUEST::CreateSHOP_BUY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _price,
      _currencyType,
      _amount,
      _productType,
      _productId);
}

inline SHOP_CHARACTER_SUMMONT *SHOP_CHARACTER_SUMMON::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_CHARACTER_SUMMONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_CHARACTER_SUMMON::UnPackTo(SHOP_CHARACTER_SUMMONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = summonId(); _o->summonId = _e; };
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON> SHOP_CHARACTER_SUMMON::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_CHARACTER_SUMMON(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON> CreateSHOP_CHARACTER_SUMMON(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_CHARACTER_SUMMONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _summonId = _o->summonId;
  return OVERLORD::REQUEST::CreateSHOP_CHARACTER_SUMMON(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _summonId);
}

inline SHOP_FLOORSHOP_STATUST *SHOP_FLOORSHOP_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_STATUS::UnPackTo(SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> SHOP_FLOORSHOP_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS> CreateSHOP_FLOORSHOP_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline SHOP_FLOORSHOP_BUYT *SHOP_FLOORSHOP_BUY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_BUYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_BUY::UnPackTo(SHOP_FLOORSHOP_BUYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = slotId(); _o->slotId = _e; };
  { auto _e = shopId(); _o->shopId = _e; };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY> SHOP_FLOORSHOP_BUY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_BUY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY> CreateSHOP_FLOORSHOP_BUY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_BUYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _slotId = _o->slotId;
  auto _shopId = _o->shopId;
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_BUY(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _slotId,
      _shopId);
}

inline SHOP_FLOORSHOP_OPEN_SLOTT *SHOP_FLOORSHOP_OPEN_SLOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_OPEN_SLOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_OPEN_SLOT::UnPackTo(SHOP_FLOORSHOP_OPEN_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = slotId(); _o->slotId = _e; };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> SHOP_FLOORSHOP_OPEN_SLOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_OPEN_SLOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT> CreateSHOP_FLOORSHOP_OPEN_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_OPEN_SLOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _slotId = _o->slotId;
  return OVERLORD::REQUEST::CreateSHOP_FLOORSHOP_OPEN_SLOT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _slotId);
}

inline TOWER_STATUST *TOWER_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_STATUS::UnPackTo(TOWER_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<TOWER_STATUS> TOWER_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_STATUS> CreateTOWER_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateTOWER_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline TOWER_PLAY_STARTT *TOWER_PLAY_START::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_PLAY_STARTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_PLAY_START::UnPackTo(TOWER_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = heroUDs(); if (_e) { _o->heroUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
}

inline flatbuffers::Offset<TOWER_PLAY_START> TOWER_PLAY_START::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_PLAY_START(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_PLAY_START> CreateTOWER_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_PLAY_STARTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _heroUDs = _o->heroUDs.size() ? _fbb.CreateVectorOfStrings(_o->heroUDs) : 0;
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  return OVERLORD::REQUEST::CreateTOWER_PLAY_START(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _heroUDs,
      _stageId);
}

inline TOWER_PLAY_DONET *TOWER_PLAY_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_PLAY_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_PLAY_DONE::UnPackTo(TOWER_PLAY_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = playTime(); _o->playTime = _e; };
  { auto _e = clearGrade(); _o->clearGrade = _e; };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
}

inline flatbuffers::Offset<TOWER_PLAY_DONE> TOWER_PLAY_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_PLAY_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_PLAY_DONE> CreateTOWER_PLAY_DONE(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_PLAY_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _playTime = _o->playTime;
  auto _clearGrade = _o->clearGrade;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  return OVERLORD::REQUEST::CreateTOWER_PLAY_DONE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _playTime,
      _clearGrade,
      _playUD);
}

inline TOWER_TREASURE_BOXT *TOWER_TREASURE_BOX::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_TREASURE_BOXT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_TREASURE_BOX::UnPackTo(TOWER_TREASURE_BOXT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = boxIdx(); _o->boxIdx = _e; };
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX> TOWER_TREASURE_BOX::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOXT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_TREASURE_BOX(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX> CreateTOWER_TREASURE_BOX(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOXT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_TREASURE_BOXT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _boxIdx = _o->boxIdx;
  return OVERLORD::REQUEST::CreateTOWER_TREASURE_BOX(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _boxIdx);
}

inline TOWER_BOSS_PLAY_CHECKT *TOWER_BOSS_PLAY_CHECK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_BOSS_PLAY_CHECKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_BOSS_PLAY_CHECK::UnPackTo(TOWER_BOSS_PLAY_CHECKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = stageId(); if (_e) _o->stageId = _e->str(); };
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> TOWER_BOSS_PLAY_CHECK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_BOSS_PLAY_CHECK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK> CreateTOWER_BOSS_PLAY_CHECK(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_BOSS_PLAY_CHECKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _stageId = _o->stageId.empty() ? 0 : _fbb.CreateString(_o->stageId);
  return OVERLORD::REQUEST::CreateTOWER_BOSS_PLAY_CHECK(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _stageId);
}

inline TOWER_BOSS_PLAY_RESULTT *TOWER_BOSS_PLAY_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_BOSS_PLAY_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_BOSS_PLAY_RESULT::UnPackTo(TOWER_BOSS_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = roomKey(); if (_e) _o->roomKey = _e->str(); };
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> TOWER_BOSS_PLAY_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_BOSS_PLAY_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT> CreateTOWER_BOSS_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_BOSS_PLAY_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _roomKey = _o->roomKey.empty() ? 0 : _fbb.CreateString(_o->roomKey);
  return OVERLORD::REQUEST::CreateTOWER_BOSS_PLAY_RESULT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _roomKey);
}

inline TOWER_FLOOR_MISSION_ACTIVET *TOWER_FLOOR_MISSION_ACTIVE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_FLOOR_MISSION_ACTIVET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_FLOOR_MISSION_ACTIVE::UnPackTo(TOWER_FLOOR_MISSION_ACTIVET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = floor(); _o->floor = _e; };
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> TOWER_FLOOR_MISSION_ACTIVE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_FLOOR_MISSION_ACTIVE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE> CreateTOWER_FLOOR_MISSION_ACTIVE(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_FLOOR_MISSION_ACTIVET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _floor = _o->floor;
  return OVERLORD::REQUEST::CreateTOWER_FLOOR_MISSION_ACTIVE(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _floor);
}

inline TOWER_FLOOR_MISSION_REWARDT *TOWER_FLOOR_MISSION_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_FLOOR_MISSION_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_FLOOR_MISSION_REWARD::UnPackTo(TOWER_FLOOR_MISSION_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = id(); if (_e) _o->id = _e->str(); };
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> TOWER_FLOOR_MISSION_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_FLOOR_MISSION_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD> CreateTOWER_FLOOR_MISSION_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_FLOOR_MISSION_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _id = _o->id.empty() ? 0 : _fbb.CreateString(_o->id);
  return OVERLORD::REQUEST::CreateTOWER_FLOOR_MISSION_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _id);
}

inline TREASURE_GET_REWARDT *TREASURE_GET_REWARD::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TREASURE_GET_REWARDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TREASURE_GET_REWARD::UnPackTo(TREASURE_GET_REWARDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<TREASURE_GET_REWARD> TREASURE_GET_REWARD::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTREASURE_GET_REWARD(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TREASURE_GET_REWARD> CreateTREASURE_GET_REWARD(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TREASURE_GET_REWARDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateTREASURE_GET_REWARD(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline GET_TARGET_SERVERT *GET_TARGET_SERVER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GET_TARGET_SERVERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GET_TARGET_SERVER::UnPackTo(GET_TARGET_SERVERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<GET_TARGET_SERVER> GET_TARGET_SERVER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGET_TARGET_SERVER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GET_TARGET_SERVER> CreateGET_TARGET_SERVER(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GET_TARGET_SERVERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateGET_TARGET_SERVER(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline WORLDBOSS_STATUST *WORLDBOSS_STATUS::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_STATUST();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_STATUS::UnPackTo(WORLDBOSS_STATUST *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> WORLDBOSS_STATUS::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_STATUS(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_STATUS> CreateWORLDBOSS_STATUS(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUST *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_STATUST* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  return OVERLORD::REQUEST::CreateWORLDBOSS_STATUS(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version);
}

inline WORLDBOSS_PLAY_CHECKT *WORLDBOSS_PLAY_CHECK::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_PLAY_CHECKT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_PLAY_CHECK::UnPackTo(WORLDBOSS_PLAY_CHECKT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = worldBossStageId(); if (_e) _o->worldBossStageId = _e->str(); };
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> WORLDBOSS_PLAY_CHECK::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECKT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_PLAY_CHECK(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK> CreateWORLDBOSS_PLAY_CHECK(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECKT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_PLAY_CHECKT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _worldBossStageId = _o->worldBossStageId.empty() ? 0 : _fbb.CreateString(_o->worldBossStageId);
  return OVERLORD::REQUEST::CreateWORLDBOSS_PLAY_CHECK(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _worldBossStageId);
}

inline WORLDBOSS_PLAY_RESULTT *WORLDBOSS_PLAY_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_PLAY_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_PLAY_RESULT::UnPackTo(WORLDBOSS_PLAY_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
  { auto _e = deviceid(); if (_e) _o->deviceid = _e->str(); };
  { auto _e = protocol(); if (_e) _o->protocol = _e->str(); };
  { auto _e = version(); if (_e) _o->version = _e->str(); };
  { auto _e = roomKey(); if (_e) _o->roomKey = _e->str(); };
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> WORLDBOSS_PLAY_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_PLAY_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT> CreateWORLDBOSS_PLAY_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_PLAY_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  auto _deviceid = _o->deviceid.empty() ? 0 : _fbb.CreateString(_o->deviceid);
  auto _protocol = _o->protocol.empty() ? 0 : _fbb.CreateString(_o->protocol);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _roomKey = _o->roomKey.empty() ? 0 : _fbb.CreateString(_o->roomKey);
  return OVERLORD::REQUEST::CreateWORLDBOSS_PLAY_RESULT(
      _fbb,
      _type,
      _clientkey,
      _deviceid,
      _protocol,
      _version,
      _roomKey);
}

}  // namespace REQUEST

namespace RESPONSE {

inline LOGIN_REPLYT *LOGIN_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new LOGIN_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void LOGIN_REPLY::UnPackTo(LOGIN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = success(); _o->success = _e; };
}

inline flatbuffers::Offset<LOGIN_REPLY> LOGIN_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LOGIN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLOGIN_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LOGIN_REPLY> CreateLOGIN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const LOGIN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LOGIN_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _success = _o->success;
  return OVERLORD::RESPONSE::CreateLOGIN_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _success);
}

inline ACCOUNT_CREATE_REPLYT *ACCOUNT_CREATE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_CREATE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_CREATE_REPLY::UnPackTo(ACCOUNT_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = exists(); _o->exists = _e; };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<ACCOUNT_CREATE_REPLY> ACCOUNT_CREATE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_CREATE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_CREATE_REPLY> CreateACCOUNT_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_CREATE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _exists = _o->exists;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateACCOUNT_CREATE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _nick,
      _exists,
      _kId);
}

inline ACCOUNT_REMOVE_REPLYT *ACCOUNT_REMOVE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_REMOVE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_REMOVE_REPLY::UnPackTo(ACCOUNT_REMOVE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = exists(); _o->exists = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
}

inline flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> ACCOUNT_REMOVE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_REMOVE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_REMOVE_REPLY> CreateACCOUNT_REMOVE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_REMOVE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_REMOVE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _exists = _o->exists;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  return OVERLORD::RESPONSE::CreateACCOUNT_REMOVE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _exists,
      _nick);
}

inline INIT_CLIENT_KEY_REPLYT *INIT_CLIENT_KEY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INIT_CLIENT_KEY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INIT_CLIENT_KEY_REPLY::UnPackTo(INIT_CLIENT_KEY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
}

inline flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> INIT_CLIENT_KEY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINIT_CLIENT_KEY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INIT_CLIENT_KEY_REPLY> CreateINIT_CLIENT_KEY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INIT_CLIENT_KEY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INIT_CLIENT_KEY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  return OVERLORD::RESPONSE::CreateINIT_CLIENT_KEY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _clientkey);
}

inline ADD_REFER_PUBLISHER_REPLYT *ADD_REFER_PUBLISHER_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ADD_REFER_PUBLISHER_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ADD_REFER_PUBLISHER_REPLY::UnPackTo(ADD_REFER_PUBLISHER_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = clientkey(); if (_e) _o->clientkey = _e->str(); };
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> ADD_REFER_PUBLISHER_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHER_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateADD_REFER_PUBLISHER_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ADD_REFER_PUBLISHER_REPLY> CreateADD_REFER_PUBLISHER_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ADD_REFER_PUBLISHER_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ADD_REFER_PUBLISHER_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _clientkey = _o->clientkey.empty() ? 0 : _fbb.CreateString(_o->clientkey);
  return OVERLORD::RESPONSE::CreateADD_REFER_PUBLISHER_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _clientkey);
}

inline GET_REFER_LIST_REPLYT *GET_REFER_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GET_REFER_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GET_REFER_LIST_REPLY::UnPackTo(GET_REFER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = publisher_list(); if (_e) { _o->publisher_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->publisher_list[_i] = _e->Get(_i)->str(); } } };
}

inline flatbuffers::Offset<GET_REFER_LIST_REPLY> GET_REFER_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGET_REFER_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GET_REFER_LIST_REPLY> CreateGET_REFER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GET_REFER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GET_REFER_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _publisher_list = _o->publisher_list.size() ? _fbb.CreateVectorOfStrings(_o->publisher_list) : 0;
  return OVERLORD::RESPONSE::CreateGET_REFER_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _publisher_list);
}

inline ACCOUNT_CHANGE_LANGUAGE_REPLYT *ACCOUNT_CHANGE_LANGUAGE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACCOUNT_CHANGE_LANGUAGE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACCOUNT_CHANGE_LANGUAGE_REPLY::UnPackTo(ACCOUNT_CHANGE_LANGUAGE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = success(); _o->success = _e; };
}

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> ACCOUNT_CHANGE_LANGUAGE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACCOUNT_CHANGE_LANGUAGE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACCOUNT_CHANGE_LANGUAGE_REPLY> CreateACCOUNT_CHANGE_LANGUAGE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ACCOUNT_CHANGE_LANGUAGE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACCOUNT_CHANGE_LANGUAGE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _success = _o->success;
  return OVERLORD::RESPONSE::CreateACCOUNT_CHANGE_LANGUAGE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _success);
}

inline CLIENT_SDK_ACTION_REPLYT *CLIENT_SDK_ACTION_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CLIENT_SDK_ACTION_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CLIENT_SDK_ACTION_REPLY::UnPackTo(CLIENT_SDK_ACTION_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = avatar(); if (_e) _o->avatar = std::unique_ptr<OVERLORD::STRUCT::AVATART>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> CLIENT_SDK_ACTION_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTION_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCLIENT_SDK_ACTION_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CLIENT_SDK_ACTION_REPLY> CreateCLIENT_SDK_ACTION_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CLIENT_SDK_ACTION_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CLIENT_SDK_ACTION_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _avatar = _o->avatar ? CreateAVATAR(_fbb, _o->avatar.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCLIENT_SDK_ACTION_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _avatar);
}

inline ARENA_STATUS_REPLYT *ARENA_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_STATUS_REPLY::UnPackTo(ARENA_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = arenaStatus(); if (_e) _o->arenaStatus = std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ARENA_STATUS_REPLY> ARENA_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_STATUS_REPLY> CreateARENA_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _arenaStatus = _o->arenaStatus ? CreateARENA_STATUS(_fbb, _o->arenaStatus.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateARENA_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _arenaStatus);
}

inline ARENA_TARGET_INFO_REPLYT *ARENA_TARGET_INFO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_TARGET_INFO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_TARGET_INFO_REPLY::UnPackTo(ARENA_TARGET_INFO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = target(); if (_e) _o->target = std::unique_ptr<OVERLORD::STRUCT::BATTLE_USERT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> ARENA_TARGET_INFO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_TARGET_INFO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_TARGET_INFO_REPLY> CreateARENA_TARGET_INFO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_TARGET_INFO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_TARGET_INFO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _target = _o->target ? CreateBATTLE_USER(_fbb, _o->target.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateARENA_TARGET_INFO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _target);
}

inline ARENA_PLAY_REPLYT *ARENA_PLAY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_PLAY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_PLAY_REPLY::UnPackTo(ARENA_PLAY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
}

inline flatbuffers::Offset<ARENA_PLAY_REPLY> ARENA_PLAY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_PLAY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_PLAY_REPLY> CreateARENA_PLAY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_PLAY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  return OVERLORD::RESPONSE::CreateARENA_PLAY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _playUD);
}

inline ARENA_PLAY_DONE_REPLYT *ARENA_PLAY_DONE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_PLAY_DONE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_PLAY_DONE_REPLY::UnPackTo(ARENA_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = arenaStatus(); if (_e) _o->arenaStatus = std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> ARENA_PLAY_DONE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_PLAY_DONE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_PLAY_DONE_REPLY> CreateARENA_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_PLAY_DONE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _arenaStatus = _o->arenaStatus ? CreateARENA_STATUS(_fbb, _o->arenaStatus.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateARENA_PLAY_DONE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _arenaStatus,
      _rewards);
}

inline ARENA_DEFENSE_REWARD_REPLYT *ARENA_DEFENSE_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_DEFENSE_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_DEFENSE_REWARD_REPLY::UnPackTo(ARENA_DEFENSE_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = arenaStatus(); if (_e) _o->arenaStatus = std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> ARENA_DEFENSE_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_DEFENSE_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_DEFENSE_REWARD_REPLY> CreateARENA_DEFENSE_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_DEFENSE_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _arenaStatus = _o->arenaStatus ? CreateARENA_STATUS(_fbb, _o->arenaStatus.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateARENA_DEFENSE_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _arenaStatus,
      _rewards);
}

inline ARENA_SEASON_DONE_REPLYT *ARENA_SEASON_DONE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_SEASON_DONE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_SEASON_DONE_REPLY::UnPackTo(ARENA_SEASON_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = arenaStatus(); if (_e) _o->arenaStatus = std::unique_ptr<OVERLORD::STRUCT::ARENA_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> ARENA_SEASON_DONE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_SEASON_DONE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_SEASON_DONE_REPLY> CreateARENA_SEASON_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_SEASON_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_SEASON_DONE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _arenaStatus = _o->arenaStatus ? CreateARENA_STATUS(_fbb, _o->arenaStatus.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateARENA_SEASON_DONE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _arenaStatus,
      _rewards);
}

inline ARENA_RANKING_LIST_REPLYT *ARENA_RANKING_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_RANKING_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_RANKING_LIST_REPLY::UnPackTo(ARENA_RANKING_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = rankingList(); if (_e) { _o->rankingList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rankingList[_i] = std::unique_ptr<OVERLORD::STRUCT::ARENA_RANK_USERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> ARENA_RANKING_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_RANKING_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_RANKING_LIST_REPLY> CreateARENA_RANKING_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_RANKING_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_RANKING_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _rankingList = _o->rankingList.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ARENA_RANK_USER>> (_o->rankingList.size(), [](size_t i, _VectorArgs *__va) { return CreateARENA_RANK_USER(*__va->__fbb, __va->__o->rankingList[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateARENA_RANKING_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _rankingList);
}

inline ARENA_DEFENSE_DECK_SET_REPLYT *ARENA_DEFENSE_DECK_SET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ARENA_DEFENSE_DECK_SET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ARENA_DEFENSE_DECK_SET_REPLY::UnPackTo(ARENA_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> ARENA_DEFENSE_DECK_SET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateARENA_DEFENSE_DECK_SET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ARENA_DEFENSE_DECK_SET_REPLY> CreateARENA_DEFENSE_DECK_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ARENA_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ARENA_DEFENSE_DECK_SET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateARENA_DEFENSE_DECK_SET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline AVATAR_ABILITY_UP_REPLYT *AVATAR_ABILITY_UP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ABILITY_UP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ABILITY_UP_REPLY::UnPackTo(AVATAR_ABILITY_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> AVATAR_ABILITY_UP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ABILITY_UP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ABILITY_UP_REPLY> CreateAVATAR_ABILITY_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ABILITY_UP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_ABILITY_UP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline AVATAR_ABILITY_RESET_REPLYT *AVATAR_ABILITY_RESET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ABILITY_RESET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ABILITY_RESET_REPLY::UnPackTo(AVATAR_ABILITY_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> AVATAR_ABILITY_RESET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ABILITY_RESET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ABILITY_RESET_REPLY> CreateAVATAR_ABILITY_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ABILITY_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ABILITY_RESET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_ABILITY_RESET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline AVATAR_ICON_LIST_REPLYT *AVATAR_ICON_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ICON_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ICON_LIST_REPLY::UnPackTo(AVATAR_ICON_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = iconList(); if (_e) { _o->iconList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->iconList[_i] = _e->Get(_i); } } };
}

inline flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> AVATAR_ICON_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ICON_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ICON_LIST_REPLY> CreateAVATAR_ICON_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ICON_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _iconList = _o->iconList.size() ? _fbb.CreateVector(_o->iconList) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_ICON_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _iconList);
}

inline AVATAR_ICON_SET_REPLYT *AVATAR_ICON_SET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_ICON_SET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_ICON_SET_REPLY::UnPackTo(AVATAR_ICON_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AVATAR_ICON_SET_REPLY> AVATAR_ICON_SET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_ICON_SET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_ICON_SET_REPLY> CreateAVATAR_ICON_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_ICON_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_ICON_SET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_ICON_SET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline AVATAR_PROFILE_REPLYT *AVATAR_PROFILE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_PROFILE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_PROFILE_REPLY::UnPackTo(AVATAR_PROFILE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = heroUse(); if (_e) { _o->heroUse.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->heroUse[_i] = std::unique_ptr<OVERLORD::STRUCT::HERO_USAGE_TABT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = records(); if (_e) { _o->records.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->records[_i] = std::unique_ptr<OVERLORD::STRUCT::ACCOUNT_RECORDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<AVATAR_PROFILE_REPLY> AVATAR_PROFILE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_PROFILE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_PROFILE_REPLY> CreateAVATAR_PROFILE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_PROFILE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_PROFILE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _heroUse = _o->heroUse.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::HERO_USAGE_TAB>> (_o->heroUse.size(), [](size_t i, _VectorArgs *__va) { return CreateHERO_USAGE_TAB(*__va->__fbb, __va->__o->heroUse[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _records = _o->records.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACCOUNT_RECORD>> (_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateACCOUNT_RECORD(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateAVATAR_PROFILE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _heroUse,
      _records,
      _kId);
}

inline AVATAR_LOBBY_REPLYT *AVATAR_LOBBY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_LOBBY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_LOBBY_REPLY::UnPackTo(AVATAR_LOBBY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = daily_quest_status(); if (_e) _o->daily_quest_status = std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = treasure(); if (_e) _o->treasure = std::unique_ptr<OVERLORD::STRUCT::TREASURET>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AVATAR_LOBBY_REPLY> AVATAR_LOBBY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_LOBBY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_LOBBY_REPLY> CreateAVATAR_LOBBY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_LOBBY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_LOBBY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _daily_quest_status = _o->daily_quest_status ? CreateDAILY_QUEST_STATUS(_fbb, _o->daily_quest_status.get(), _rehasher) : 0;
  auto _treasure = _o->treasure ? CreateTREASURE(_fbb, _o->treasure.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_LOBBY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _daily_quest_status,
      _treasure,
      _update);
}

inline AVATAR_GAME_DATA_REPLYT *AVATAR_GAME_DATA_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_GAME_DATA_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_GAME_DATA_REPLY::UnPackTo(AVATAR_GAME_DATA_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = selectiveTutorial(); if (_e) _o->selectiveTutorial = std::unique_ptr<OVERLORD::STRUCT::SELECTIVE_TUTORIALT>(_e->UnPack(_resolver)); };
  { auto _e = dailyQuestStatus(); if (_e) _o->dailyQuestStatus = std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = achieveStatus(); if (_e) { _o->achieveStatus.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->achieveStatus[_i] = std::unique_ptr<OVERLORD::STRUCT::ACHIEVE_STATUST>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = unlockList(); if (_e) _o->unlockList = std::unique_ptr<OVERLORD::STRUCT::UNLOCK_LISTT>(_e->UnPack(_resolver)); };
  { auto _e = towerStatus(); if (_e) _o->towerStatus = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = chart(); if (_e) _o->chart = std::unique_ptr<OVERLORD::STRUCT::EVENT_ATTENDANCET>(_e->UnPack(_resolver)); };
  { auto _e = guild_mine(); if (_e) _o->guild_mine = std::unique_ptr<OVERLORD::STRUCT::GUILD_MINET>(_e->UnPack(_resolver)); };
  { auto _e = inventory(); if (_e) _o->inventory = std::unique_ptr<OVERLORD::STRUCT::INVENTORYT>(_e->UnPack(_resolver)); };
  { auto _e = avatar(); if (_e) _o->avatar = std::unique_ptr<OVERLORD::STRUCT::AVATART>(_e->UnPack(_resolver)); };
  { auto _e = colosseumGradeId(); _o->colosseumGradeId = _e; };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> AVATAR_GAME_DATA_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATA_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_GAME_DATA_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_GAME_DATA_REPLY> CreateAVATAR_GAME_DATA_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_GAME_DATA_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_GAME_DATA_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _selectiveTutorial = _o->selectiveTutorial ? CreateSELECTIVE_TUTORIAL(_fbb, _o->selectiveTutorial.get(), _rehasher) : 0;
  auto _dailyQuestStatus = _o->dailyQuestStatus ? CreateDAILY_QUEST_STATUS(_fbb, _o->dailyQuestStatus.get(), _rehasher) : 0;
  auto _achieveStatus = _o->achieveStatus.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> (_o->achieveStatus.size(), [](size_t i, _VectorArgs *__va) { return CreateACHIEVE_STATUS(*__va->__fbb, __va->__o->achieveStatus[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _unlockList = _o->unlockList ? CreateUNLOCK_LIST(_fbb, _o->unlockList.get(), _rehasher) : 0;
  auto _towerStatus = _o->towerStatus ? CreateTOWER_STATUS(_fbb, _o->towerStatus.get(), _rehasher) : 0;
  auto _chart = _o->chart ? CreateEVENT_ATTENDANCE(_fbb, _o->chart.get(), _rehasher) : 0;
  auto _guild_mine = _o->guild_mine ? CreateGUILD_MINE(_fbb, _o->guild_mine.get(), _rehasher) : 0;
  auto _inventory = _o->inventory ? CreateINVENTORY(_fbb, _o->inventory.get(), _rehasher) : 0;
  auto _avatar = _o->avatar ? CreateAVATAR(_fbb, _o->avatar.get(), _rehasher) : 0;
  auto _colosseumGradeId = _o->colosseumGradeId;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateAVATAR_GAME_DATA_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _selectiveTutorial,
      _dailyQuestStatus,
      _achieveStatus,
      _unlockList,
      _towerStatus,
      _chart,
      _guild_mine,
      _inventory,
      _avatar,
      _colosseumGradeId,
      _kId);
}

inline AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::UnPackTo(AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = selectiveTutorial(); if (_e) _o->selectiveTutorial = std::unique_ptr<OVERLORD::STRUCT::SELECTIVE_TUTORIALT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY> CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const AVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _selectiveTutorial = _o->selectiveTutorial ? CreateSELECTIVE_TUTORIAL(_fbb, _o->selectiveTutorial.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateAVATAR_SELECTIVE_TUTORIAL_UPDATE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _selectiveTutorial);
}

inline CHANNEL_INFO_LIST_REPLYT *CHANNEL_INFO_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_INFO_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_INFO_LIST_REPLY::UnPackTo(CHANNEL_INFO_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = channel_list(); if (_e) { _o->channel_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->channel_list[_i] = std::unique_ptr<OVERLORD::STRUCT::CHANNEL_INFOT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> CHANNEL_INFO_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_INFO_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_INFO_LIST_REPLY> CreateCHANNEL_INFO_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_INFO_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_INFO_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _channel_list = _o->channel_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::CHANNEL_INFO>> (_o->channel_list.size(), [](size_t i, _VectorArgs *__va) { return CreateCHANNEL_INFO(*__va->__fbb, __va->__o->channel_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateCHANNEL_INFO_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _channel_list);
}

inline CHANNEL_DETAIL_REPLYT *CHANNEL_DETAIL_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHANNEL_DETAIL_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHANNEL_DETAIL_REPLY::UnPackTo(CHANNEL_DETAIL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = channel_detail(); if (_e) _o->channel_detail = std::unique_ptr<OVERLORD::STRUCT::CHANNEL_DETAILT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHANNEL_DETAIL_REPLY> CHANNEL_DETAIL_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAIL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHANNEL_DETAIL_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHANNEL_DETAIL_REPLY> CreateCHANNEL_DETAIL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CHANNEL_DETAIL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHANNEL_DETAIL_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _channel_detail = _o->channel_detail ? CreateCHANNEL_DETAIL(_fbb, _o->channel_detail.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCHANNEL_DETAIL_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _channel_detail);
}

inline BILLING_TRANSACTION_CREATE_REPLYT *BILLING_TRANSACTION_CREATE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BILLING_TRANSACTION_CREATE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BILLING_TRANSACTION_CREATE_REPLY::UnPackTo(BILLING_TRANSACTION_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = kakaopay(); if (_e) _o->kakaopay = std::unique_ptr<OVERLORD::STRUCT::BILLING_PREPARE_KAKAOPAYT>(_e->UnPack(_resolver)); };
  { auto _e = payload(); if (_e) _o->payload = _e->str(); };
  { auto _e = transaction_id(); if (_e) _o->transaction_id = _e->str(); };
  { auto _e = product(); if (_e) _o->product = _e->str(); };
  { auto _e = purchase_system(); if (_e) _o->purchase_system = _e->str(); };
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> BILLING_TRANSACTION_CREATE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBILLING_TRANSACTION_CREATE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BILLING_TRANSACTION_CREATE_REPLY> CreateBILLING_TRANSACTION_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BILLING_TRANSACTION_CREATE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _kakaopay = _o->kakaopay ? CreateBILLING_PREPARE_KAKAOPAY(_fbb, _o->kakaopay.get(), _rehasher) : 0;
  auto _payload = _o->payload.empty() ? 0 : _fbb.CreateString(_o->payload);
  auto _transaction_id = _o->transaction_id.empty() ? 0 : _fbb.CreateString(_o->transaction_id);
  auto _product = _o->product.empty() ? 0 : _fbb.CreateString(_o->product);
  auto _purchase_system = _o->purchase_system.empty() ? 0 : _fbb.CreateString(_o->purchase_system);
  return OVERLORD::RESPONSE::CreateBILLING_TRANSACTION_CREATE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _kakaopay,
      _payload,
      _transaction_id,
      _product,
      _purchase_system);
}

inline BILLING_TRANSACTION_SUCCESS_REPLYT *BILLING_TRANSACTION_SUCCESS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new BILLING_TRANSACTION_SUCCESS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void BILLING_TRANSACTION_SUCCESS_REPLY::UnPackTo(BILLING_TRANSACTION_SUCCESS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = receipt(); if (_e) _o->receipt = _e->str(); };
  { auto _e = purchase_system(); if (_e) _o->purchase_system = _e->str(); };
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> BILLING_TRANSACTION_SUCCESS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateBILLING_TRANSACTION_SUCCESS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<BILLING_TRANSACTION_SUCCESS_REPLY> CreateBILLING_TRANSACTION_SUCCESS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const BILLING_TRANSACTION_SUCCESS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const BILLING_TRANSACTION_SUCCESS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _receipt = _o->receipt.empty() ? 0 : _fbb.CreateString(_o->receipt);
  auto _purchase_system = _o->purchase_system.empty() ? 0 : _fbb.CreateString(_o->purchase_system);
  return OVERLORD::RESPONSE::CreateBILLING_TRANSACTION_SUCCESS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _receipt,
      _purchase_system);
}

inline COLOSSEUM_STATUS_REPLYT *COLOSSEUM_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_STATUS_REPLY::UnPackTo(COLOSSEUM_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = colosseumStatus(); if (_e) _o->colosseumStatus = std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> COLOSSEUM_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_STATUS_REPLY> CreateCOLOSSEUM_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _colosseumStatus = _o->colosseumStatus ? CreateCOLOSSEUM_STATUS(_fbb, _o->colosseumStatus.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _colosseumStatus);
}

inline COLOSSEUM_PLAY_RESULT_REPLYT *COLOSSEUM_PLAY_RESULT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_PLAY_RESULT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_PLAY_RESULT_REPLY::UnPackTo(COLOSSEUM_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = colosseumStatus(); if (_e) _o->colosseumStatus = std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = isWin(); _o->isWin = _e; };
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> COLOSSEUM_PLAY_RESULT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_PLAY_RESULT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_PLAY_RESULT_REPLY> CreateCOLOSSEUM_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_PLAY_RESULT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _colosseumStatus = _o->colosseumStatus ? CreateCOLOSSEUM_STATUS(_fbb, _o->colosseumStatus.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _isWin = _o->isWin;
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_PLAY_RESULT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _colosseumStatus,
      _rewards,
      _isWin);
}

inline COLOSSEUM_SEASON_DONE_REPLYT *COLOSSEUM_SEASON_DONE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_SEASON_DONE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_SEASON_DONE_REPLY::UnPackTo(COLOSSEUM_SEASON_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = colosseumStatus(); if (_e) _o->colosseumStatus = std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = gradeRewards(); if (_e) { _o->gradeRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->gradeRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rankRewards(); if (_e) { _o->rankRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rankRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> COLOSSEUM_SEASON_DONE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_SEASON_DONE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_SEASON_DONE_REPLY> CreateCOLOSSEUM_SEASON_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_SEASON_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_SEASON_DONE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _colosseumStatus = _o->colosseumStatus ? CreateCOLOSSEUM_STATUS(_fbb, _o->colosseumStatus.get(), _rehasher) : 0;
  auto _gradeRewards = _o->gradeRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->gradeRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->gradeRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rankRewards = _o->rankRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rankRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rankRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_SEASON_DONE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _colosseumStatus,
      _gradeRewards,
      _rankRewards);
}

inline COLOSSEUM_RANKING_LIST_REPLYT *COLOSSEUM_RANKING_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COLOSSEUM_RANKING_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COLOSSEUM_RANKING_LIST_REPLY::UnPackTo(COLOSSEUM_RANKING_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = rankingList(); if (_e) { _o->rankingList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rankingList[_i] = std::unique_ptr<OVERLORD::STRUCT::COLOSSEUM_RANK_USERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> COLOSSEUM_RANKING_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOLOSSEUM_RANKING_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COLOSSEUM_RANKING_LIST_REPLY> CreateCOLOSSEUM_RANKING_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COLOSSEUM_RANKING_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COLOSSEUM_RANKING_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _rankingList = _o->rankingList.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::COLOSSEUM_RANK_USER>> (_o->rankingList.size(), [](size_t i, _VectorArgs *__va) { return CreateCOLOSSEUM_RANK_USER(*__va->__fbb, __va->__o->rankingList[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateCOLOSSEUM_RANKING_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _rankingList);
}

inline COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *COMMUNITY_ARTICLE_WRITE_HERO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_WRITE_HERO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_WRITE_HERO_REPLY::UnPackTo(COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = article(); if (_e) _o->article = std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> COMMUNITY_ARTICLE_WRITE_HERO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_WRITE_HERO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_WRITE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_WRITE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_WRITE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_WRITE_HERO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _article = _o->article ? CreateCOMMUNITY_ARTICLE(_fbb, _o->article.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCOMMUNITY_ARTICLE_WRITE_HERO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _article);
}

inline COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *COMMUNITY_ARTICLE_DELETE_HERO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_DELETE_HERO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_DELETE_HERO_REPLY::UnPackTo(COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = success(); _o->success = _e; };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> COMMUNITY_ARTICLE_DELETE_HERO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_DELETE_HERO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_DELETE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_DELETE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_DELETE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_DELETE_HERO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _success = _o->success;
  return OVERLORD::RESPONSE::CreateCOMMUNITY_ARTICLE_DELETE_HERO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _success);
}

inline COMMUNITY_ARTICLE_LIST_HERO_REPLYT *COMMUNITY_ARTICLE_LIST_HERO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_LIST_HERO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_LIST_HERO_REPLY::UnPackTo(COMMUNITY_ARTICLE_LIST_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = articleList(); if (_e) { _o->articleList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->articleList[_i] = std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> COMMUNITY_ARTICLE_LIST_HERO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_LIST_HERO_REPLY> CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_LIST_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_LIST_HERO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _articleList = _o->articleList.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::COMMUNITY_ARTICLE>> (_o->articleList.size(), [](size_t i, _VectorArgs *__va) { return CreateCOMMUNITY_ARTICLE(*__va->__fbb, __va->__o->articleList[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateCOMMUNITY_ARTICLE_LIST_HERO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _articleList);
}

inline COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *COMMUNITY_ARTICLE_VOTE_HERO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new COMMUNITY_ARTICLE_VOTE_HERO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void COMMUNITY_ARTICLE_VOTE_HERO_REPLY::UnPackTo(COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = article(); if (_e) _o->article = std::unique_ptr<OVERLORD::STRUCT::COMMUNITY_ARTICLET>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> COMMUNITY_ARTICLE_VOTE_HERO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HERO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCOMMUNITY_ARTICLE_VOTE_HERO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<COMMUNITY_ARTICLE_VOTE_HERO_REPLY> CreateCOMMUNITY_ARTICLE_VOTE_HERO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const COMMUNITY_ARTICLE_VOTE_HERO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const COMMUNITY_ARTICLE_VOTE_HERO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _article = _o->article ? CreateCOMMUNITY_ARTICLE(_fbb, _o->article.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCOMMUNITY_ARTICLE_VOTE_HERO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _article);
}

inline CONTENT_RESET_STATUS_REPLYT *CONTENT_RESET_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CONTENT_RESET_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CONTENT_RESET_STATUS_REPLY::UnPackTo(CONTENT_RESET_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = contentResetCount(); _o->contentResetCount = _e; };
}

inline flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> CONTENT_RESET_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCONTENT_RESET_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CONTENT_RESET_STATUS_REPLY> CreateCONTENT_RESET_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CONTENT_RESET_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _contentResetCount = _o->contentResetCount;
  return OVERLORD::RESPONSE::CreateCONTENT_RESET_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _contentResetCount);
}

inline CONTENT_RESET_REPLYT *CONTENT_RESET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CONTENT_RESET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CONTENT_RESET_REPLY::UnPackTo(CONTENT_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CONTENT_RESET_REPLY> CONTENT_RESET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCONTENT_RESET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CONTENT_RESET_REPLY> CreateCONTENT_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const CONTENT_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CONTENT_RESET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateCONTENT_RESET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline ATTENDANCE_GET_REPLYT *ATTENDANCE_GET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ATTENDANCE_GET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ATTENDANCE_GET_REPLY::UnPackTo(ATTENDANCE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = chart(); if (_e) _o->chart = std::unique_ptr<OVERLORD::STRUCT::EVENT_ATTENDANCET>(_e->UnPack(_resolver)); };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<ATTENDANCE_GET_REPLY> ATTENDANCE_GET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateATTENDANCE_GET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ATTENDANCE_GET_REPLY> CreateATTENDANCE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const ATTENDANCE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ATTENDANCE_GET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _chart = _o->chart ? CreateEVENT_ATTENDANCE(_fbb, _o->chart.get(), _rehasher) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateATTENDANCE_GET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _chart,
      _kId);
}

inline GUILD_CREATE_REPLYT *GUILD_CREATE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CREATE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CREATE_REPLY::UnPackTo(GUILD_CREATE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_CREATE_REPLY> GUILD_CREATE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CREATE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CREATE_REPLY> CreateGUILD_CREATE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CREATE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CREATE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_CREATE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _guild_info);
}

inline GUILD_CLOSE_REPLYT *GUILD_CLOSE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CLOSE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CLOSE_REPLY::UnPackTo(GUILD_CLOSE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = success(); _o->success = _e; };
}

inline flatbuffers::Offset<GUILD_CLOSE_REPLY> GUILD_CLOSE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CLOSE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CLOSE_REPLY> CreateGUILD_CLOSE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CLOSE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CLOSE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _success = _o->success;
  return OVERLORD::RESPONSE::CreateGUILD_CLOSE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _success);
}

inline GUILD_GET_REPLYT *GUILD_GET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_GET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_GET_REPLY::UnPackTo(GUILD_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_mine(); if (_e) _o->guild_mine = std::unique_ptr<OVERLORD::STRUCT::GUILD_MINET>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_GET_REPLY> GUILD_GET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_GET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_GET_REPLY> CreateGUILD_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_GET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_mine = _o->guild_mine ? CreateGUILD_MINE(_fbb, _o->guild_mine.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_GET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_mine);
}

inline GUILD_GET_GUEST_REPLYT *GUILD_GET_GUEST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_GET_GUEST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_GET_GUEST_REPLY::UnPackTo(GUILD_GET_GUEST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_member_list(); if (_e) { _o->guild_member_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guild_member_list[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_GET_GUEST_REPLY> GUILD_GET_GUEST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUEST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_GET_GUEST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_GET_GUEST_REPLY> CreateGUILD_GET_GUEST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_GET_GUEST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_GET_GUEST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_member_list = _o->guild_member_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> (_o->guild_member_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_MEMBER(*__va->__fbb, __va->__o->guild_member_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_GET_GUEST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_member_list,
      _guild_info);
}

inline GUILD_MEMBER_LIST_REPLYT *GUILD_MEMBER_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_LIST_REPLY::UnPackTo(GUILD_MEMBER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_member_list(); if (_e) { _o->guild_member_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guild_member_list[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> GUILD_MEMBER_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_LIST_REPLY> CreateGUILD_MEMBER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_member_list = _o->guild_member_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_MEMBER>> (_o->guild_member_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_MEMBER(*__va->__fbb, __va->__o->guild_member_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_MEMBER_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_member_list);
}

inline GUILD_AWAITER_LIST_REPLYT *GUILD_AWAITER_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_LIST_REPLY::UnPackTo(GUILD_AWAITER_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_awaiter_list(); if (_e) { _o->guild_awaiter_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guild_awaiter_list[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_AWAITERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> GUILD_AWAITER_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_LIST_REPLY> CreateGUILD_AWAITER_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_awaiter_list = _o->guild_awaiter_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_AWAITER>> (_o->guild_awaiter_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_AWAITER(*__va->__fbb, __va->__o->guild_awaiter_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_AWAITER_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_awaiter_list);
}

inline GUILD_AWAITER_ACCEPT_REPLYT *GUILD_AWAITER_ACCEPT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_ACCEPT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_ACCEPT_REPLY::UnPackTo(GUILD_AWAITER_ACCEPT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> GUILD_AWAITER_ACCEPT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_ACCEPT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_ACCEPT_REPLY> CreateGUILD_AWAITER_ACCEPT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_ACCEPT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_ACCEPT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _target_kId = _o->target_kId;
  return OVERLORD::RESPONSE::CreateGUILD_AWAITER_ACCEPT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _target_kId);
}

inline GUILD_AWAITER_CANCEL_REPLYT *GUILD_AWAITER_CANCEL_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_AWAITER_CANCEL_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_AWAITER_CANCEL_REPLY::UnPackTo(GUILD_AWAITER_CANCEL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> GUILD_AWAITER_CANCEL_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCEL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_AWAITER_CANCEL_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_AWAITER_CANCEL_REPLY> CreateGUILD_AWAITER_CANCEL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_AWAITER_CANCEL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_AWAITER_CANCEL_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_id = _o->guild_id;
  return OVERLORD::RESPONSE::CreateGUILD_AWAITER_CANCEL_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_id);
}

inline GUILD_FIND_NAME_REPLYT *GUILD_FIND_NAME_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_FIND_NAME_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_FIND_NAME_REPLY::UnPackTo(GUILD_FIND_NAME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = awaiting_guild_ids(); if (_e) { _o->awaiting_guild_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->awaiting_guild_ids[_i] = _e->Get(_i); } } };
  { auto _e = guild_list(); if (_e) { _o->guild_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guild_list[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GUILD_FIND_NAME_REPLY> GUILD_FIND_NAME_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_FIND_NAME_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_FIND_NAME_REPLY> CreateGUILD_FIND_NAME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_FIND_NAME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_FIND_NAME_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _awaiting_guild_ids = _o->awaiting_guild_ids.size() ? _fbb.CreateVector(_o->awaiting_guild_ids) : 0;
  auto _guild_list = _o->guild_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> (_o->guild_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_INFO(*__va->__fbb, __va->__o->guild_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_FIND_NAME_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _awaiting_guild_ids,
      _guild_list);
}

inline GUILD_CHANGE_NAME_REPLYT *GUILD_CHANGE_NAME_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CHANGE_NAME_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CHANGE_NAME_REPLY::UnPackTo(GUILD_CHANGE_NAME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> GUILD_CHANGE_NAME_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CHANGE_NAME_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CHANGE_NAME_REPLY> CreateGUILD_CHANGE_NAME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CHANGE_NAME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CHANGE_NAME_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_CHANGE_NAME_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _guild_info);
}

inline GUILD_EDIT_DESC_REPLYT *GUILD_EDIT_DESC_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_DESC_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_DESC_REPLY::UnPackTo(GUILD_EDIT_DESC_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> GUILD_EDIT_DESC_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESC_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_DESC_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_DESC_REPLY> CreateGUILD_EDIT_DESC_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_DESC_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_DESC_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_EDIT_DESC_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_info);
}

inline GUILD_EDIT_NOTICE_REPLYT *GUILD_EDIT_NOTICE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_NOTICE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_NOTICE_REPLY::UnPackTo(GUILD_EDIT_NOTICE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> GUILD_EDIT_NOTICE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_NOTICE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_NOTICE_REPLY> CreateGUILD_EDIT_NOTICE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_NOTICE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_NOTICE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_EDIT_NOTICE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_info);
}

inline GUILD_EDIT_AUTO_GRADE_UP_REPLYT *GUILD_EDIT_AUTO_GRADE_UP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_EDIT_AUTO_GRADE_UP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_EDIT_AUTO_GRADE_UP_REPLY::UnPackTo(GUILD_EDIT_AUTO_GRADE_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> GUILD_EDIT_AUTO_GRADE_UP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_EDIT_AUTO_GRADE_UP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_EDIT_AUTO_GRADE_UP_REPLY> CreateGUILD_EDIT_AUTO_GRADE_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_EDIT_AUTO_GRADE_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_EDIT_AUTO_GRADE_UP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_EDIT_AUTO_GRADE_UP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_info);
}

inline GUILD_JOIN_REPLYT *GUILD_JOIN_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_JOIN_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_JOIN_REPLY::UnPackTo(GUILD_JOIN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = auto_grade_up(); _o->auto_grade_up = _e; };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_JOIN_REPLY> GUILD_JOIN_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_JOIN_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_JOIN_REPLY> CreateGUILD_JOIN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_JOIN_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _auto_grade_up = _o->auto_grade_up;
  auto _guild_id = _o->guild_id;
  return OVERLORD::RESPONSE::CreateGUILD_JOIN_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _auto_grade_up,
      _guild_id);
}

inline GUILD_JOIN_AUTO_REPLYT *GUILD_JOIN_AUTO_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_JOIN_AUTO_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_JOIN_AUTO_REPLY::UnPackTo(GUILD_JOIN_AUTO_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = auto_grade_up(); _o->auto_grade_up = _e; };
  { auto _e = guild_id(); _o->guild_id = _e; };
}

inline flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> GUILD_JOIN_AUTO_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTO_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_JOIN_AUTO_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_JOIN_AUTO_REPLY> CreateGUILD_JOIN_AUTO_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_JOIN_AUTO_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_JOIN_AUTO_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _auto_grade_up = _o->auto_grade_up;
  auto _guild_id = _o->guild_id;
  return OVERLORD::RESPONSE::CreateGUILD_JOIN_AUTO_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _auto_grade_up,
      _guild_id);
}

inline GUILD_MEMBER_GRADE_REPLYT *GUILD_MEMBER_GRADE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_GRADE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_GRADE_REPLY::UnPackTo(GUILD_MEMBER_GRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = target_member(); if (_e) _o->target_member = std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>(_e->UnPack(_resolver)); };
  { auto _e = guild_member(); if (_e) _o->guild_member = std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> GUILD_MEMBER_GRADE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_GRADE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_GRADE_REPLY> CreateGUILD_MEMBER_GRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_GRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_GRADE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _target_member = _o->target_member ? CreateGUILD_MEMBER(_fbb, _o->target_member.get(), _rehasher) : 0;
  auto _guild_member = _o->guild_member ? CreateGUILD_MEMBER(_fbb, _o->guild_member.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_MEMBER_GRADE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _target_member,
      _guild_member);
}

inline GUILD_MEMBER_KICK_REPLYT *GUILD_MEMBER_KICK_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_MEMBER_KICK_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_MEMBER_KICK_REPLY::UnPackTo(GUILD_MEMBER_KICK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = target_kId(); _o->target_kId = _e; };
}

inline flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> GUILD_MEMBER_KICK_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_MEMBER_KICK_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_MEMBER_KICK_REPLY> CreateGUILD_MEMBER_KICK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_MEMBER_KICK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_MEMBER_KICK_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _target_kId = _o->target_kId;
  return OVERLORD::RESPONSE::CreateGUILD_MEMBER_KICK_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _target_kId);
}

inline GUILD_CONTRIBUTION_REPLYT *GUILD_CONTRIBUTION_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTION_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTION_REPLY::UnPackTo(GUILD_CONTRIBUTION_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = contributionType(); _o->contributionType = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = guild_member(); if (_e) _o->guild_member = std::unique_ptr<OVERLORD::STRUCT::GUILD_MEMBERT>(_e->UnPack(_resolver)); };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> GUILD_CONTRIBUTION_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTION_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_REPLY> CreateGUILD_CONTRIBUTION_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTION_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _contributionType = _o->contributionType;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _guild_member = _o->guild_member ? CreateGUILD_MEMBER(_fbb, _o->guild_member.get(), _rehasher) : 0;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_CONTRIBUTION_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _contributionType,
      _update,
      _guild_member,
      _guild_info);
}

inline GUILD_CONTRIBUTE_RANKING_REPLYT *GUILD_CONTRIBUTE_RANKING_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTE_RANKING_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTE_RANKING_REPLY::UnPackTo(GUILD_CONTRIBUTE_RANKING_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = awaiting_guild_ids(); if (_e) { _o->awaiting_guild_ids.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->awaiting_guild_ids[_i] = _e->Get(_i); } } };
  { auto _e = guild_list(); if (_e) { _o->guild_list.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->guild_list[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> GUILD_CONTRIBUTE_RANKING_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKING_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTE_RANKING_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTE_RANKING_REPLY> CreateGUILD_CONTRIBUTE_RANKING_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTE_RANKING_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTE_RANKING_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _awaiting_guild_ids = _o->awaiting_guild_ids.size() ? _fbb.CreateVector(_o->awaiting_guild_ids) : 0;
  auto _guild_list = _o->guild_list.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_INFO>> (_o->guild_list.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_INFO(*__va->__fbb, __va->__o->guild_list[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_CONTRIBUTE_RANKING_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _awaiting_guild_ids,
      _guild_list);
}

inline GUILD_CONTRIBUTION_STATUS_REPLYT *GUILD_CONTRIBUTION_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_CONTRIBUTION_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_CONTRIBUTION_STATUS_REPLY::UnPackTo(GUILD_CONTRIBUTION_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = contributionType(); _o->contributionType = _e; };
  { auto _e = contributable(); _o->contributable = _e; };
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> GUILD_CONTRIBUTION_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_CONTRIBUTION_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_CONTRIBUTION_STATUS_REPLY> CreateGUILD_CONTRIBUTION_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_CONTRIBUTION_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_CONTRIBUTION_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _contributionType = _o->contributionType;
  auto _contributable = _o->contributable;
  return OVERLORD::RESPONSE::CreateGUILD_CONTRIBUTION_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _contributionType,
      _contributable);
}

inline GUILD_ATTENDANCE_STATUS_REPLYT *GUILD_ATTENDANCE_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_STATUS_REPLY::UnPackTo(GUILD_ATTENDANCE_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = previousWeeklyCount(); _o->previousWeeklyCount = _e; };
  { auto _e = weeklyTimeLeft(); _o->weeklyTimeLeft = _e; };
  { auto _e = weeklyCount(); _o->weeklyCount = _e; };
  { auto _e = weeklyRewardable(); _o->weeklyRewardable = _e; };
  { auto _e = dailyRewardable(); _o->dailyRewardable = _e; };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> GUILD_ATTENDANCE_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_STATUS_REPLY> CreateGUILD_ATTENDANCE_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _previousWeeklyCount = _o->previousWeeklyCount;
  auto _weeklyTimeLeft = _o->weeklyTimeLeft;
  auto _weeklyCount = _o->weeklyCount;
  auto _weeklyRewardable = _o->weeklyRewardable;
  auto _dailyRewardable = _o->dailyRewardable;
  return OVERLORD::RESPONSE::CreateGUILD_ATTENDANCE_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _previousWeeklyCount,
      _weeklyTimeLeft,
      _weeklyCount,
      _weeklyRewardable,
      _dailyRewardable);
}

inline GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *GUILD_ATTENDANCE_DAILY_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_DAILY_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_DAILY_REWARD_REPLY::UnPackTo(GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = weeklyCount(); _o->weeklyCount = _e; };
  { auto _e = dailyRewardable(); _o->dailyRewardable = _e; };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> GUILD_ATTENDANCE_DAILY_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_DAILY_REWARD_REPLY> CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_DAILY_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_DAILY_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _weeklyCount = _o->weeklyCount;
  auto _dailyRewardable = _o->dailyRewardable;
  return OVERLORD::RESPONSE::CreateGUILD_ATTENDANCE_DAILY_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _weeklyCount,
      _dailyRewardable);
}

inline GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::UnPackTo(GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = weeklyRewardable(); _o->weeklyRewardable = _e; };
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_ATTENDANCE_WEEKLY_REWARD_REPLY> CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_ATTENDANCE_WEEKLY_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _weeklyRewardable = _o->weeklyRewardable;
  return OVERLORD::RESPONSE::CreateGUILD_ATTENDANCE_WEEKLY_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _weeklyRewardable);
}

inline GUILD_RUNE_STATUS_REPLYT *GUILD_RUNE_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_STATUS_REPLY::UnPackTo(GUILD_RUNE_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = requests(); if (_e) { _o->requests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requests[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> GUILD_RUNE_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_STATUS_REPLY> CreateGUILD_RUNE_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _requests = _o->requests.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> (_o->requests.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_RUNE_REQUESTER(*__va->__fbb, __va->__o->requests[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _requests);
}

inline GUILD_RUNE_REQUEST_REPLYT *GUILD_RUNE_REQUEST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_REQUEST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_REQUEST_REPLY::UnPackTo(GUILD_RUNE_REQUEST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = requests(); if (_e) { _o->requests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requests[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> GUILD_RUNE_REQUEST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUEST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_REQUEST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_REQUEST_REPLY> CreateGUILD_RUNE_REQUEST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_REQUEST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_REQUEST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _requests = _o->requests.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> (_o->requests.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_RUNE_REQUESTER(*__va->__fbb, __va->__o->requests[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_REQUEST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _requests,
      _kId);
}

inline GUILD_RUNE_SUPPORT_REPLYT *GUILD_RUNE_SUPPORT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_SUPPORT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_SUPPORT_REPLY::UnPackTo(GUILD_RUNE_SUPPORT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = requests(); if (_e) { _o->requests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requests[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> GUILD_RUNE_SUPPORT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_SUPPORT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_SUPPORT_REPLY> CreateGUILD_RUNE_SUPPORT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_SUPPORT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_SUPPORT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _requests = _o->requests.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> (_o->requests.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_RUNE_REQUESTER(*__va->__fbb, __va->__o->requests[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_SUPPORT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _requests,
      _kId);
}

inline GUILD_RUNE_GET_REPLYT *GUILD_RUNE_GET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_RUNE_GET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_RUNE_GET_REPLY::UnPackTo(GUILD_RUNE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = requests(); if (_e) { _o->requests.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->requests[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_RUNE_REQUESTERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GUILD_RUNE_GET_REPLY> GUILD_RUNE_GET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_RUNE_GET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_RUNE_GET_REPLY> CreateGUILD_RUNE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_RUNE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_RUNE_GET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _requests = _o->requests.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_RUNE_REQUESTER>> (_o->requests.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_RUNE_REQUESTER(*__va->__fbb, __va->__o->requests[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGUILD_RUNE_GET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _requests,
      _kId);
}

inline GUILD_HISTORY_REPLYT *GUILD_HISTORY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_HISTORY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_HISTORY_REPLY::UnPackTo(GUILD_HISTORY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = historyList(); if (_e) { _o->historyList.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->historyList[_i] = std::unique_ptr<OVERLORD::STRUCT::GUILD_HISTORYT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GUILD_HISTORY_REPLY> GUILD_HISTORY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_HISTORY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_HISTORY_REPLY> CreateGUILD_HISTORY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_HISTORY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_HISTORY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _historyList = _o->historyList.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::GUILD_HISTORY>> (_o->historyList.size(), [](size_t i, _VectorArgs *__va) { return CreateGUILD_HISTORY(*__va->__fbb, __va->__o->historyList[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGUILD_HISTORY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _historyList,
      _kId);
}

inline GUILD_LEVEL_UP_REPLYT *GUILD_LEVEL_UP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GUILD_LEVEL_UP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GUILD_LEVEL_UP_REPLY::UnPackTo(GUILD_LEVEL_UP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = guild_info(); if (_e) _o->guild_info = std::unique_ptr<OVERLORD::STRUCT::GUILD_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> GUILD_LEVEL_UP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGUILD_LEVEL_UP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GUILD_LEVEL_UP_REPLY> CreateGUILD_LEVEL_UP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GUILD_LEVEL_UP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GUILD_LEVEL_UP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _guild_info = _o->guild_info ? CreateGUILD_INFO(_fbb, _o->guild_info.get(), _rehasher) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGUILD_LEVEL_UP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _guild_info,
      _kId);
}

inline INVENTORY_HERO_UPGRADE_REPLYT *INVENTORY_HERO_UPGRADE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_UPGRADE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_UPGRADE_REPLY::UnPackTo(INVENTORY_HERO_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> INVENTORY_HERO_UPGRADE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_UPGRADE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_UPGRADE_REPLY> CreateINVENTORY_HERO_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_UPGRADE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_UPGRADE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_HERO_LEVELUP_REPLYT *INVENTORY_HERO_LEVELUP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_LEVELUP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_LEVELUP_REPLY::UnPackTo(INVENTORY_HERO_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> INVENTORY_HERO_LEVELUP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_LEVELUP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_LEVELUP_REPLY> CreateINVENTORY_HERO_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_LEVELUP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_LEVELUP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_HERO_GRIND_REPLYT *INVENTORY_HERO_GRIND_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_GRIND_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_GRIND_REPLY::UnPackTo(INVENTORY_HERO_GRIND_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> INVENTORY_HERO_GRIND_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRIND_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_GRIND_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_GRIND_REPLY> CreateINVENTORY_HERO_GRIND_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_GRIND_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_GRIND_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_GRIND_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _rewards,
      _update);
}

inline INVENTORY_HERO_EQUIP_REPLYT *INVENTORY_HERO_EQUIP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_EQUIP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_EQUIP_REPLY::UnPackTo(INVENTORY_HERO_EQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> INVENTORY_HERO_EQUIP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_EQUIP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_EQUIP_REPLY> CreateINVENTORY_HERO_EQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_EQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_EQUIP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_EQUIP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_HERO_UNEQUIP_REPLYT *INVENTORY_HERO_UNEQUIP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_UNEQUIP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_UNEQUIP_REPLY::UnPackTo(INVENTORY_HERO_UNEQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> INVENTORY_HERO_UNEQUIP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_UNEQUIP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_UNEQUIP_REPLY> CreateINVENTORY_HERO_UNEQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_UNEQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_UNEQUIP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_UNEQUIP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_ITEM_GRIND_REPLYT *INVENTORY_ITEM_GRIND_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_GRIND_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_GRIND_REPLY::UnPackTo(INVENTORY_ITEM_GRIND_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> INVENTORY_ITEM_GRIND_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRIND_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_GRIND_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_GRIND_REPLY> CreateINVENTORY_ITEM_GRIND_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_GRIND_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_GRIND_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_GRIND_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _rewards,
      _update);
}

inline INVENTORY_RUNE_EQUIP_REPLYT *INVENTORY_RUNE_EQUIP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_EQUIP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_EQUIP_REPLY::UnPackTo(INVENTORY_RUNE_EQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> INVENTORY_RUNE_EQUIP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_EQUIP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_EQUIP_REPLY> CreateINVENTORY_RUNE_EQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_EQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_EQUIP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_RUNE_EQUIP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_RUNE_UNEQUIP_REPLYT *INVENTORY_RUNE_UNEQUIP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_UNEQUIP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_UNEQUIP_REPLY::UnPackTo(INVENTORY_RUNE_UNEQUIP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> INVENTORY_RUNE_UNEQUIP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_UNEQUIP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_UNEQUIP_REPLY> CreateINVENTORY_RUNE_UNEQUIP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_UNEQUIP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_UNEQUIP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_RUNE_UNEQUIP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_RUNE_MAKE_REPLYT *INVENTORY_RUNE_MAKE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_RUNE_MAKE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_RUNE_MAKE_REPLY::UnPackTo(INVENTORY_RUNE_MAKE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> INVENTORY_RUNE_MAKE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_RUNE_MAKE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_RUNE_MAKE_REPLY> CreateINVENTORY_RUNE_MAKE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_RUNE_MAKE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_RUNE_MAKE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_RUNE_MAKE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_ITEM_LEVELUP_REPLYT *INVENTORY_ITEM_LEVELUP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_LEVELUP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_LEVELUP_REPLY::UnPackTo(INVENTORY_ITEM_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = isLucky(); _o->isLucky = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> INVENTORY_ITEM_LEVELUP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_LEVELUP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_LEVELUP_REPLY> CreateINVENTORY_ITEM_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_LEVELUP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _isLucky = _o->isLucky;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_LEVELUP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _isLucky,
      _update);
}

inline INVENTORY_ITEM_ENCHANT_REPLYT *INVENTORY_ITEM_ENCHANT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_ENCHANT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_ENCHANT_REPLY::UnPackTo(INVENTORY_ITEM_ENCHANT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = affectedEnchant(); _o->affectedEnchant = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> INVENTORY_ITEM_ENCHANT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_ENCHANT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_ENCHANT_REPLY> CreateINVENTORY_ITEM_ENCHANT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_ENCHANT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_ENCHANT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _affectedEnchant = _o->affectedEnchant;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_ENCHANT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _affectedEnchant,
      _update);
}

inline INVENTORY_ITEM_HERO_LOCK_REPLYT *INVENTORY_ITEM_HERO_LOCK_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_HERO_LOCK_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_HERO_LOCK_REPLY::UnPackTo(INVENTORY_ITEM_HERO_LOCK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> INVENTORY_ITEM_HERO_LOCK_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_HERO_LOCK_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_HERO_LOCK_REPLY> CreateINVENTORY_ITEM_HERO_LOCK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_HERO_LOCK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_HERO_LOCK_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_HERO_LOCK_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_HERO_SKILL_LEVELUP_REPLYT *INVENTORY_HERO_SKILL_LEVELUP_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_SKILL_LEVELUP_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_SKILL_LEVELUP_REPLY::UnPackTo(INVENTORY_HERO_SKILL_LEVELUP_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> INVENTORY_HERO_SKILL_LEVELUP_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUP_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_SKILL_LEVELUP_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_SKILL_LEVELUP_REPLY> CreateINVENTORY_HERO_SKILL_LEVELUP_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_SKILL_LEVELUP_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_SKILL_LEVELUP_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_SKILL_LEVELUP_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *INVENTORY_HERO_ENCHANT_CONSUME_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_ENCHANT_CONSUME_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_ENCHANT_CONSUME_REPLY::UnPackTo(INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = spiritResult(); if (_e) { _o->spiritResult.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->spiritResult[_i] = _e->Get(_i) != 0; } } };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> INVENTORY_HERO_ENCHANT_CONSUME_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUME_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_CONSUME_REPLY> CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_CONSUME_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_ENCHANT_CONSUME_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _spiritResult = _o->spiritResult.size() ? _fbb.CreateVector(_o->spiritResult) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_ENCHANT_CONSUME_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _spiritResult,
      _update);
}

inline INVENTORY_HERO_ENCHANT_STAT_REPLYT *INVENTORY_HERO_ENCHANT_STAT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_HERO_ENCHANT_STAT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_HERO_ENCHANT_STAT_REPLY::UnPackTo(INVENTORY_HERO_ENCHANT_STAT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> INVENTORY_HERO_ENCHANT_STAT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STAT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_HERO_ENCHANT_STAT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_HERO_ENCHANT_STAT_REPLY> CreateINVENTORY_HERO_ENCHANT_STAT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_HERO_ENCHANT_STAT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_HERO_ENCHANT_STAT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_HERO_ENCHANT_STAT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_SELL_REPLYT *INVENTORY_SELL_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_SELL_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_SELL_REPLY::UnPackTo(INVENTORY_SELL_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<INVENTORY_SELL_REPLY> INVENTORY_SELL_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELL_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_SELL_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_SELL_REPLY> CreateINVENTORY_SELL_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_SELL_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_SELL_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_SELL_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards);
}

inline INVENTORY_ITEM_UPGRADE_REPLYT *INVENTORY_ITEM_UPGRADE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_UPGRADE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_UPGRADE_REPLY::UnPackTo(INVENTORY_ITEM_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = isSuccess(); _o->isSuccess = _e; };
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> INVENTORY_ITEM_UPGRADE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_UPGRADE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_UPGRADE_REPLY> CreateINVENTORY_ITEM_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_UPGRADE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _isSuccess = _o->isSuccess;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_UPGRADE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _isSuccess);
}

inline INVENTORY_ITEM_OPTION_RESET_REPLYT *INVENTORY_ITEM_OPTION_RESET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_ITEM_OPTION_RESET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_ITEM_OPTION_RESET_REPLY::UnPackTo(INVENTORY_ITEM_OPTION_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> INVENTORY_ITEM_OPTION_RESET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_ITEM_OPTION_RESET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_ITEM_OPTION_RESET_REPLY> CreateINVENTORY_ITEM_OPTION_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_ITEM_OPTION_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_ITEM_OPTION_RESET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_ITEM_OPTION_RESET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline INVENTORY_TIMETREASURE_GET_REPLYT *INVENTORY_TIMETREASURE_GET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_TIMETREASURE_GET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_TIMETREASURE_GET_REPLY::UnPackTo(INVENTORY_TIMETREASURE_GET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> INVENTORY_TIMETREASURE_GET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_TIMETREASURE_GET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_TIMETREASURE_GET_REPLY> CreateINVENTORY_TIMETREASURE_GET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_TIMETREASURE_GET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_TIMETREASURE_GET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_TIMETREASURE_GET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards);
}

inline INVENTORY_UPGRADE_REPLYT *INVENTORY_UPGRADE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new INVENTORY_UPGRADE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void INVENTORY_UPGRADE_REPLY::UnPackTo(INVENTORY_UPGRADE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> INVENTORY_UPGRADE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateINVENTORY_UPGRADE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<INVENTORY_UPGRADE_REPLY> CreateINVENTORY_UPGRADE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const INVENTORY_UPGRADE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const INVENTORY_UPGRADE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateINVENTORY_UPGRADE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline GIFT_LIST_REPLYT *GIFT_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIFT_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIFT_LIST_REPLY::UnPackTo(GIFT_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = mails(); if (_e) { _o->mails.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mails[_i] = std::unique_ptr<OVERLORD::STRUCT::MAILT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = news(); if (_e) { _o->news.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->news[_i] = std::unique_ptr<OVERLORD::STRUCT::MAILT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mailsize(); _o->mailsize = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GIFT_LIST_REPLY> GIFT_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIFT_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIFT_LIST_REPLY> CreateGIFT_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIFT_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _mails = _o->mails.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> (_o->mails.size(), [](size_t i, _VectorArgs *__va) { return CreateMAIL(*__va->__fbb, __va->__o->mails[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _news = _o->news.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> (_o->news.size(), [](size_t i, _VectorArgs *__va) { return CreateMAIL(*__va->__fbb, __va->__o->news[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mailsize = _o->mailsize;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGIFT_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _mails,
      _news,
      _mailsize,
      _update,
      _kId);
}

inline GIFT_OPEN_REPLYT *GIFT_OPEN_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIFT_OPEN_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIFT_OPEN_REPLY::UnPackTo(GIFT_OPEN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mailUDs(); if (_e) { _o->mailUDs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mailUDs[_i] = _e->Get(_i)->str(); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GIFT_OPEN_REPLY> GIFT_OPEN_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPEN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIFT_OPEN_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIFT_OPEN_REPLY> CreateGIFT_OPEN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIFT_OPEN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIFT_OPEN_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mailUDs = _o->mailUDs.size() ? _fbb.CreateVectorOfStrings(_o->mailUDs) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGIFT_OPEN_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _mailUDs,
      _kId);
}

inline SPECIAL_GIFT_LIST_REPLYT *SPECIAL_GIFT_LIST_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SPECIAL_GIFT_LIST_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SPECIAL_GIFT_LIST_REPLY::UnPackTo(SPECIAL_GIFT_LIST_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = mails(); if (_e) { _o->mails.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->mails[_i] = std::unique_ptr<OVERLORD::STRUCT::MAILT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = news(); if (_e) { _o->news.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->news[_i] = std::unique_ptr<OVERLORD::STRUCT::MAILT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mailsize(); _o->mailsize = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> SPECIAL_GIFT_LIST_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LIST_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSPECIAL_GIFT_LIST_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SPECIAL_GIFT_LIST_REPLY> CreateSPECIAL_GIFT_LIST_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_LIST_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SPECIAL_GIFT_LIST_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _mails = _o->mails.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> (_o->mails.size(), [](size_t i, _VectorArgs *__va) { return CreateMAIL(*__va->__fbb, __va->__o->mails[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _news = _o->news.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::MAIL>> (_o->news.size(), [](size_t i, _VectorArgs *__va) { return CreateMAIL(*__va->__fbb, __va->__o->news[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mailsize = _o->mailsize;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateSPECIAL_GIFT_LIST_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _mails,
      _news,
      _mailsize,
      _update,
      _kId);
}

inline SPECIAL_GIFT_OPEN_REPLYT *SPECIAL_GIFT_OPEN_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SPECIAL_GIFT_OPEN_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SPECIAL_GIFT_OPEN_REPLY::UnPackTo(SPECIAL_GIFT_OPEN_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = mailUD(); if (_e) _o->mailUD = _e->str(); };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> SPECIAL_GIFT_OPEN_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPEN_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSPECIAL_GIFT_OPEN_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SPECIAL_GIFT_OPEN_REPLY> CreateSPECIAL_GIFT_OPEN_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SPECIAL_GIFT_OPEN_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SPECIAL_GIFT_OPEN_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _mailUD = _o->mailUD.empty() ? 0 : _fbb.CreateString(_o->mailUD);
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateSPECIAL_GIFT_OPEN_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _mailUD,
      _kId);
}

inline MIRROR_STATUS_REPLYT *MIRROR_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_STATUS_REPLY::UnPackTo(MIRROR_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = mirror_status(); if (_e) _o->mirror_status = std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<MIRROR_STATUS_REPLY> MIRROR_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_STATUS_REPLY> CreateMIRROR_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _mirror_status = _o->mirror_status ? CreateMIRROR_STATUS(_fbb, _o->mirror_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateMIRROR_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _mirror_status);
}

inline MIRROR_PLAY_START_REPLYT *MIRROR_PLAY_START_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_PLAY_START_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_PLAY_START_REPLY::UnPackTo(MIRROR_PLAY_START_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
}

inline flatbuffers::Offset<MIRROR_PLAY_START_REPLY> MIRROR_PLAY_START_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_START_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_PLAY_START_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_PLAY_START_REPLY> CreateMIRROR_PLAY_START_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_START_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_PLAY_START_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  return OVERLORD::RESPONSE::CreateMIRROR_PLAY_START_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _playUD);
}

inline MIRROR_PLAY_DONE_REPLYT *MIRROR_PLAY_DONE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_PLAY_DONE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_PLAY_DONE_REPLY::UnPackTo(MIRROR_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = mirror_status(); if (_e) _o->mirror_status = std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> MIRROR_PLAY_DONE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_PLAY_DONE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_PLAY_DONE_REPLY> CreateMIRROR_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_PLAY_DONE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _mirror_status = _o->mirror_status ? CreateMIRROR_STATUS(_fbb, _o->mirror_status.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateMIRROR_PLAY_DONE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _mirror_status,
      _update,
      _rewards);
}

inline MIRROR_RESET_REPLYT *MIRROR_RESET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_RESET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_RESET_REPLY::UnPackTo(MIRROR_RESET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = mirror_status(); if (_e) _o->mirror_status = std::unique_ptr<OVERLORD::STRUCT::MIRROR_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<MIRROR_RESET_REPLY> MIRROR_RESET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_RESET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_RESET_REPLY> CreateMIRROR_RESET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_RESET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_RESET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _mirror_status = _o->mirror_status ? CreateMIRROR_STATUS(_fbb, _o->mirror_status.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateMIRROR_RESET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _mirror_status,
      _update);
}

inline MIRROR_DEFENSE_DECK_SET_REPLYT *MIRROR_DEFENSE_DECK_SET_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new MIRROR_DEFENSE_DECK_SET_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void MIRROR_DEFENSE_DECK_SET_REPLY::UnPackTo(MIRROR_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> MIRROR_DEFENSE_DECK_SET_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SET_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMIRROR_DEFENSE_DECK_SET_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MIRROR_DEFENSE_DECK_SET_REPLY> CreateMIRROR_DEFENSE_DECK_SET_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const MIRROR_DEFENSE_DECK_SET_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MIRROR_DEFENSE_DECK_SET_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateMIRROR_DEFENSE_DECK_SET_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update);
}

inline GIVE_ACHIEVE_REWARD_REPLYT *GIVE_ACHIEVE_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GIVE_ACHIEVE_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GIVE_ACHIEVE_REWARD_REPLY::UnPackTo(GIVE_ACHIEVE_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = achieveStatus(); if (_e) { _o->achieveStatus.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->achieveStatus[_i] = std::unique_ptr<OVERLORD::STRUCT::ACHIEVE_STATUST>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = kId(); _o->kId = _e; };
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> GIVE_ACHIEVE_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGIVE_ACHIEVE_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GIVE_ACHIEVE_REWARD_REPLY> CreateGIVE_ACHIEVE_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GIVE_ACHIEVE_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GIVE_ACHIEVE_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _achieveStatus = _o->achieveStatus.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::ACHIEVE_STATUS>> (_o->achieveStatus.size(), [](size_t i, _VectorArgs *__va) { return CreateACHIEVE_STATUS(*__va->__fbb, __va->__o->achieveStatus[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _kId = _o->kId;
  return OVERLORD::RESPONSE::CreateGIVE_ACHIEVE_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _achieveStatus,
      _rewards,
      _kId);
}

inline DAILY_QUEST_STATUS_REPLYT *DAILY_QUEST_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_STATUS_REPLY::UnPackTo(DAILY_QUEST_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = daily_quest_status(); if (_e) _o->daily_quest_status = std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> DAILY_QUEST_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_STATUS_REPLY> CreateDAILY_QUEST_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _daily_quest_status = _o->daily_quest_status ? CreateDAILY_QUEST_STATUS(_fbb, _o->daily_quest_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateDAILY_QUEST_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _daily_quest_status);
}

inline DAILY_QUEST_REWARD_REPLYT *DAILY_QUEST_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new DAILY_QUEST_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void DAILY_QUEST_REWARD_REPLY::UnPackTo(DAILY_QUEST_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = daily_quest_status(); if (_e) _o->daily_quest_status = std::unique_ptr<OVERLORD::STRUCT::DAILY_QUEST_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> DAILY_QUEST_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDAILY_QUEST_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DAILY_QUEST_REWARD_REPLY> CreateDAILY_QUEST_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const DAILY_QUEST_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DAILY_QUEST_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _daily_quest_status = _o->daily_quest_status ? CreateDAILY_QUEST_STATUS(_fbb, _o->daily_quest_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateDAILY_QUEST_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _rewards,
      _daily_quest_status);
}

inline SHOP_USER_DATA_REPLYT *SHOP_USER_DATA_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_USER_DATA_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_USER_DATA_REPLY::UnPackTo(SHOP_USER_DATA_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = shopUserData(); if (_e) _o->shopUserData = std::unique_ptr<OVERLORD::STRUCT::SHOP_USER_DATAT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SHOP_USER_DATA_REPLY> SHOP_USER_DATA_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATA_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_USER_DATA_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_USER_DATA_REPLY> CreateSHOP_USER_DATA_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_USER_DATA_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_USER_DATA_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _shopUserData = _o->shopUserData ? CreateSHOP_USER_DATA(_fbb, _o->shopUserData.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateSHOP_USER_DATA_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _shopUserData);
}

inline SHOP_BUY_REPLYT *SHOP_BUY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_BUY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_BUY_REPLY::UnPackTo(SHOP_BUY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = shopUserData(); if (_e) _o->shopUserData = std::unique_ptr<OVERLORD::STRUCT::SHOP_USER_DATAT>(_e->UnPack(_resolver)); };
  { auto _e = rewardSet(); if (_e) { _o->rewardSet.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewardSet[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDSETT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = productId(); if (_e) _o->productId = _e->str(); };
}

inline flatbuffers::Offset<SHOP_BUY_REPLY> SHOP_BUY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_BUY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_BUY_REPLY> CreateSHOP_BUY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_BUY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_BUY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _shopUserData = _o->shopUserData ? CreateSHOP_USER_DATA(_fbb, _o->shopUserData.get(), _rehasher) : 0;
  auto _rewardSet = _o->rewardSet.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARDSET>> (_o->rewardSet.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARDSET(*__va->__fbb, __va->__o->rewardSet[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _productId = _o->productId.empty() ? 0 : _fbb.CreateString(_o->productId);
  return OVERLORD::RESPONSE::CreateSHOP_BUY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _shopUserData,
      _rewardSet,
      _productId);
}

inline SHOP_CHARACTER_SUMMON_REPLYT *SHOP_CHARACTER_SUMMON_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_CHARACTER_SUMMON_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_CHARACTER_SUMMON_REPLY::UnPackTo(SHOP_CHARACTER_SUMMON_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = extraRewards(); if (_e) { _o->extraRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extraRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = summonRewards(); if (_e) { _o->summonRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->summonRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> SHOP_CHARACTER_SUMMON_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMON_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_CHARACTER_SUMMON_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_CHARACTER_SUMMON_REPLY> CreateSHOP_CHARACTER_SUMMON_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_CHARACTER_SUMMON_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_CHARACTER_SUMMON_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _extraRewards = _o->extraRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->extraRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->extraRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _summonRewards = _o->summonRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->summonRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->summonRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateSHOP_CHARACTER_SUMMON_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _extraRewards,
      _summonRewards);
}

inline SHOP_FLOORSHOP_STATUS_REPLYT *SHOP_FLOORSHOP_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_STATUS_REPLY::UnPackTo(SHOP_FLOORSHOP_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> SHOP_FLOORSHOP_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_STATUS_REPLY> CreateSHOP_FLOORSHOP_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _status = _o->status ? CreateSHOP_FLOORSHOP_STATUS(_fbb, _o->status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateSHOP_FLOORSHOP_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _status);
}

inline SHOP_FLOORSHOP_BUY_REPLYT *SHOP_FLOORSHOP_BUY_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_BUY_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_BUY_REPLY::UnPackTo(SHOP_FLOORSHOP_BUY_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> SHOP_FLOORSHOP_BUY_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUY_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_BUY_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_BUY_REPLY> CreateSHOP_FLOORSHOP_BUY_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_BUY_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_BUY_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateSHOP_FLOORSHOP_STATUS(_fbb, _o->status.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateSHOP_FLOORSHOP_BUY_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _status,
      _rewards);
}

inline SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *SHOP_FLOORSHOP_OPEN_SLOT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new SHOP_FLOORSHOP_OPEN_SLOT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void SHOP_FLOORSHOP_OPEN_SLOT_REPLY::UnPackTo(SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = status(); if (_e) _o->status = std::unique_ptr<OVERLORD::STRUCT::SHOP_FLOORSHOP_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> SHOP_FLOORSHOP_OPEN_SLOT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSHOP_FLOORSHOP_OPEN_SLOT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SHOP_FLOORSHOP_OPEN_SLOT_REPLY> CreateSHOP_FLOORSHOP_OPEN_SLOT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const SHOP_FLOORSHOP_OPEN_SLOT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SHOP_FLOORSHOP_OPEN_SLOT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _status = _o->status ? CreateSHOP_FLOORSHOP_STATUS(_fbb, _o->status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateSHOP_FLOORSHOP_OPEN_SLOT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _status);
}

inline TOWER_STATUS_REPLYT *TOWER_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_STATUS_REPLY::UnPackTo(TOWER_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TOWER_STATUS_REPLY> TOWER_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_STATUS_REPLY> CreateTOWER_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _tower_status);
}

inline TOWER_PLAY_START_REPLYT *TOWER_PLAY_START_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_PLAY_START_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_PLAY_START_REPLY::UnPackTo(TOWER_PLAY_START_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = playUD(); if (_e) _o->playUD = _e->str(); };
  { auto _e = dropRewards(); if (_e) { _o->dropRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dropRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TOWER_PLAY_START_REPLY> TOWER_PLAY_START_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_START_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_PLAY_START_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_PLAY_START_REPLY> CreateTOWER_PLAY_START_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_START_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_PLAY_START_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _playUD = _o->playUD.empty() ? 0 : _fbb.CreateString(_o->playUD);
  auto _dropRewards = _o->dropRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->dropRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->dropRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_PLAY_START_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _playUD,
      _dropRewards);
}

inline TOWER_PLAY_DONE_REPLYT *TOWER_PLAY_DONE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_PLAY_DONE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_PLAY_DONE_REPLY::UnPackTo(TOWER_PLAY_DONE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = questRewards(); if (_e) { _o->questRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->questRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = clearRewards(); if (_e) { _o->clearRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->clearRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = dropRewards(); if (_e) { _o->dropRewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dropRewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> TOWER_PLAY_DONE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_PLAY_DONE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_PLAY_DONE_REPLY> CreateTOWER_PLAY_DONE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_PLAY_DONE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_PLAY_DONE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _questRewards = _o->questRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->questRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->questRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _clearRewards = _o->clearRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->clearRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->clearRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _dropRewards = _o->dropRewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->dropRewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->dropRewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_PLAY_DONE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _tower_status,
      _update,
      _questRewards,
      _clearRewards,
      _dropRewards);
}

inline TOWER_TREASURE_BOX_REPLYT *TOWER_TREASURE_BOX_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_TREASURE_BOX_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_TREASURE_BOX_REPLY::UnPackTo(TOWER_TREASURE_BOX_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> TOWER_TREASURE_BOX_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOX_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_TREASURE_BOX_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_TREASURE_BOX_REPLY> CreateTOWER_TREASURE_BOX_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_TREASURE_BOX_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_TREASURE_BOX_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_TREASURE_BOX_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _tower_status,
      _update,
      _rewards);
}

inline TOWER_BOSS_PLAY_CHECK_REPLYT *TOWER_BOSS_PLAY_CHECK_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_BOSS_PLAY_CHECK_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_BOSS_PLAY_CHECK_REPLY::UnPackTo(TOWER_BOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = isValid(); _o->isValid = _e; };
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> TOWER_BOSS_PLAY_CHECK_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_BOSS_PLAY_CHECK_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_CHECK_REPLY> CreateTOWER_BOSS_PLAY_CHECK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_BOSS_PLAY_CHECK_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _isValid = _o->isValid;
  return OVERLORD::RESPONSE::CreateTOWER_BOSS_PLAY_CHECK_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _isValid);
}

inline TOWER_BOSS_PLAY_RESULT_REPLYT *TOWER_BOSS_PLAY_RESULT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_BOSS_PLAY_RESULT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_BOSS_PLAY_RESULT_REPLY::UnPackTo(TOWER_BOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = playTime(); _o->playTime = _e; };
  { auto _e = clearGrade(); _o->clearGrade = _e; };
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> TOWER_BOSS_PLAY_RESULT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_BOSS_PLAY_RESULT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_BOSS_PLAY_RESULT_REPLY> CreateTOWER_BOSS_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_BOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_BOSS_PLAY_RESULT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _playTime = _o->playTime;
  auto _clearGrade = _o->clearGrade;
  return OVERLORD::RESPONSE::CreateTOWER_BOSS_PLAY_RESULT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _tower_status,
      _rewards,
      _playTime,
      _clearGrade);
}

inline TOWER_FLOOR_MISSION_ACTIVE_REPLYT *TOWER_FLOOR_MISSION_ACTIVE_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_FLOOR_MISSION_ACTIVE_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_FLOOR_MISSION_ACTIVE_REPLY::UnPackTo(TOWER_FLOOR_MISSION_ACTIVE_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> TOWER_FLOOR_MISSION_ACTIVE_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVE_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_FLOOR_MISSION_ACTIVE_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_ACTIVE_REPLY> CreateTOWER_FLOOR_MISSION_ACTIVE_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_ACTIVE_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_FLOOR_MISSION_ACTIVE_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_FLOOR_MISSION_ACTIVE_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _tower_status);
}

inline TOWER_FLOOR_MISSION_REWARD_REPLYT *TOWER_FLOOR_MISSION_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TOWER_FLOOR_MISSION_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TOWER_FLOOR_MISSION_REWARD_REPLY::UnPackTo(TOWER_FLOOR_MISSION_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = complete_rewards(); if (_e) { _o->complete_rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->complete_rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = tower_status(); if (_e) _o->tower_status = std::unique_ptr<OVERLORD::STRUCT::TOWER_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> TOWER_FLOOR_MISSION_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTOWER_FLOOR_MISSION_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TOWER_FLOOR_MISSION_REWARD_REPLY> CreateTOWER_FLOOR_MISSION_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TOWER_FLOOR_MISSION_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TOWER_FLOOR_MISSION_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _complete_rewards = _o->complete_rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->complete_rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->complete_rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _tower_status = _o->tower_status ? CreateTOWER_STATUS(_fbb, _o->tower_status.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateTOWER_FLOOR_MISSION_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _complete_rewards,
      _rewards,
      _update,
      _tower_status);
}

inline TREASURE_GET_REWARD_REPLYT *TREASURE_GET_REWARD_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new TREASURE_GET_REWARD_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void TREASURE_GET_REWARD_REPLY::UnPackTo(TREASURE_GET_REWARD_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = treasure(); if (_e) _o->treasure = std::unique_ptr<OVERLORD::STRUCT::TREASURET>(_e->UnPack(_resolver)); };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> TREASURE_GET_REWARD_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARD_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTREASURE_GET_REWARD_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TREASURE_GET_REWARD_REPLY> CreateTREASURE_GET_REWARD_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const TREASURE_GET_REWARD_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TREASURE_GET_REWARD_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _treasure = _o->treasure ? CreateTREASURE(_fbb, _o->treasure.get(), _rehasher) : 0;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateTREASURE_GET_REWARD_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _rewards,
      _treasure,
      _update);
}

inline GET_TARGET_SERVER_REPLYT *GET_TARGET_SERVER_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new GET_TARGET_SERVER_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void GET_TARGET_SERVER_REPLY::UnPackTo(GET_TARGET_SERVER_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = manifestBuildNumber(); if (_e) _o->manifestBuildNumber = _e->str(); };
  { auto _e = tcpServerPort(); if (_e) _o->tcpServerPort = _e->str(); };
  { auto _e = tcpServerHost(); if (_e) _o->tcpServerHost = _e->str(); };
  { auto _e = cdn(); if (_e) _o->cdn = _e->str(); };
  { auto _e = serverHost(); if (_e) _o->serverHost = _e->str(); };
  { auto _e = env(); if (_e) _o->env = _e->str(); };
}

inline flatbuffers::Offset<GET_TARGET_SERVER_REPLY> GET_TARGET_SERVER_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVER_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGET_TARGET_SERVER_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<GET_TARGET_SERVER_REPLY> CreateGET_TARGET_SERVER_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const GET_TARGET_SERVER_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GET_TARGET_SERVER_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _manifestBuildNumber = _o->manifestBuildNumber.empty() ? 0 : _fbb.CreateString(_o->manifestBuildNumber);
  auto _tcpServerPort = _o->tcpServerPort.empty() ? 0 : _fbb.CreateString(_o->tcpServerPort);
  auto _tcpServerHost = _o->tcpServerHost.empty() ? 0 : _fbb.CreateString(_o->tcpServerHost);
  auto _cdn = _o->cdn.empty() ? 0 : _fbb.CreateString(_o->cdn);
  auto _serverHost = _o->serverHost.empty() ? 0 : _fbb.CreateString(_o->serverHost);
  auto _env = _o->env.empty() ? 0 : _fbb.CreateString(_o->env);
  return OVERLORD::RESPONSE::CreateGET_TARGET_SERVER_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _manifestBuildNumber,
      _tcpServerPort,
      _tcpServerHost,
      _cdn,
      _serverHost,
      _env);
}

inline WORLDBOSS_STATUS_REPLYT *WORLDBOSS_STATUS_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_STATUS_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_STATUS_REPLY::UnPackTo(WORLDBOSS_STATUS_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = worldbossStatus(); if (_e) _o->worldbossStatus = std::unique_ptr<OVERLORD::STRUCT::WORLDBOSS_STATUST>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> WORLDBOSS_STATUS_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUS_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_STATUS_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_STATUS_REPLY> CreateWORLDBOSS_STATUS_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_STATUS_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_STATUS_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _worldbossStatus = _o->worldbossStatus ? CreateWORLDBOSS_STATUS(_fbb, _o->worldbossStatus.get(), _rehasher) : 0;
  return OVERLORD::RESPONSE::CreateWORLDBOSS_STATUS_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _worldbossStatus);
}

inline WORLDBOSS_PLAY_CHECK_REPLYT *WORLDBOSS_PLAY_CHECK_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_PLAY_CHECK_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_PLAY_CHECK_REPLY::UnPackTo(WORLDBOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = isValid(); _o->isValid = _e; };
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> WORLDBOSS_PLAY_CHECK_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECK_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_PLAY_CHECK_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_CHECK_REPLY> CreateWORLDBOSS_PLAY_CHECK_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_CHECK_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_PLAY_CHECK_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _isValid = _o->isValid;
  return OVERLORD::RESPONSE::CreateWORLDBOSS_PLAY_CHECK_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _isValid);
}

inline WORLDBOSS_PLAY_RESULT_REPLYT *WORLDBOSS_PLAY_RESULT_REPLY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new WORLDBOSS_PLAY_RESULT_REPLYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void WORLDBOSS_PLAY_RESULT_REPLY::UnPackTo(WORLDBOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); _o->type = _e; };
  { auto _e = error_info(); if (_e) _o->error_info = std::unique_ptr<OVERLORD::STRUCT::ERROR_INFOT>(_e->UnPack(_resolver)); };
  { auto _e = is(); _o->is = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::STRUCT::UPDATE_PACKET_SLIMT>(_e->UnPack(_resolver)); };
  { auto _e = worldbossStatus(); if (_e) _o->worldbossStatus = std::unique_ptr<OVERLORD::STRUCT::WORLDBOSS_STATUST>(_e->UnPack(_resolver)); };
  { auto _e = rewards(); if (_e) { _o->rewards.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rewards[_i] = std::unique_ptr<OVERLORD::STRUCT::REWARDT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = isWin(); _o->isWin = _e; };
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> WORLDBOSS_PLAY_RESULT_REPLY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULT_REPLYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWORLDBOSS_PLAY_RESULT_REPLY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<WORLDBOSS_PLAY_RESULT_REPLY> CreateWORLDBOSS_PLAY_RESULT_REPLY(flatbuffers::FlatBufferBuilder &_fbb, const WORLDBOSS_PLAY_RESULT_REPLYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const WORLDBOSS_PLAY_RESULT_REPLYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type;
  auto _error_info = _o->error_info ? CreateERROR_INFO(_fbb, _o->error_info.get(), _rehasher) : 0;
  auto _is = _o->is;
  auto _update = _o->update ? CreateUPDATE_PACKET_SLIM(_fbb, _o->update.get(), _rehasher) : 0;
  auto _worldbossStatus = _o->worldbossStatus ? CreateWORLDBOSS_STATUS(_fbb, _o->worldbossStatus.get(), _rehasher) : 0;
  auto _rewards = _o->rewards.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::STRUCT::REWARD>> (_o->rewards.size(), [](size_t i, _VectorArgs *__va) { return CreateREWARD(*__va->__fbb, __va->__o->rewards[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _isWin = _o->isWin;
  return OVERLORD::RESPONSE::CreateWORLDBOSS_PLAY_RESULT_REPLY(
      _fbb,
      _type,
      _error_info,
      _is,
      _update,
      _worldbossStatus,
      _rewards,
      _isWin);
}

}  // namespace RESPONSE
}  // namespace OVERLORD

#endif  // FLATBUFFERS_GENERATED_PDU_OVERLORD_RESPONSE_H_

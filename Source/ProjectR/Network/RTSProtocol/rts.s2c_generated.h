// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RTSS2C_OVERLORD_RTS_S2C_H_
#define FLATBUFFERS_GENERATED_RTSS2C_OVERLORD_RTS_S2C_H_

#include "flatbuffers/flatbuffers.h"

#include "PDU_generated.h"
#include "rts.struct_generated.h"

namespace OVERLORD {
namespace RTS {
namespace S2C {

struct ACK_AUTH;
struct ACK_AUTHT;

struct CHAT_SUBSCRIBED;
struct CHAT_SUBSCRIBEDT;

struct CHAT_UNSUBSCRIBED;
struct CHAT_UNSUBSCRIBEDT;

struct CHAT_CHANNEL_ENTER;
struct CHAT_CHANNEL_ENTERT;

struct CHAT_CHANNEL_EXIT;
struct CHAT_CHANNEL_EXITT;

struct CHAT_MESSAGE;
struct CHAT_MESSAGET;

struct ACK_MATCHED;
struct ACK_MATCHEDT;

struct ACK_PARTY_UPDATE_PUBLIC;
struct ACK_PARTY_UPDATE_PUBLICT;

struct ACK_PARTY_LEADER_SLOT;
struct ACK_PARTY_LEADER_SLOTT;

struct ACK_PARTY_PLAYER;
struct ACK_PARTY_PLAYERT;

struct ACK_PARTY_PLAYER_EXIT;
struct ACK_PARTY_PLAYER_EXITT;

struct ACK_DECK_CACHED_DONE;
struct ACK_DECK_CACHED_DONET;

struct ACK_DECK_SELECT;
struct ACK_DECK_SELECTT;

struct ACK_DECK_SELECT_READY;
struct ACK_DECK_SELECT_READYT;

struct ACK_PARTY_GO;
struct ACK_PARTY_GOT;

struct ACK_PLAY_READY;
struct ACK_PLAY_READYT;

struct ACK_MATCH_ROUND;
struct ACK_MATCH_ROUNDT;

struct REQ_CINEMATIC_PLAY;
struct REQ_CINEMATIC_PLAYT;

struct ACK_CINEMATIC_DONE;
struct ACK_CINEMATIC_DONET;

struct REQ_STEP_READY;
struct REQ_STEP_READYT;

struct ACK_STEP_GO;
struct ACK_STEP_GOT;

struct ACK_PLAY_COUNT;
struct ACK_PLAY_COUNTT;

struct ACK_PLAY_START;
struct ACK_PLAY_STARTT;

struct ACK_PLAY_TIMEOUT;
struct ACK_PLAY_TIMEOUTT;

struct ACK_PLAY_SEND_RESULT;
struct ACK_PLAY_SEND_RESULTT;

struct ACK_BT_NEW_PLAYER;
struct ACK_BT_NEW_PLAYERT;

struct ACK_BT_ACTOR_CREATE;
struct ACK_BT_ACTOR_CREATET;

struct ACK_BT_ACTOR_SPAWN;
struct ACK_BT_ACTOR_SPAWNT;

struct ACK_BT_ACTOR_DESPAWN;
struct ACK_BT_ACTOR_DESPAWNT;

struct ACK_BT_ACTOR_RESPAWN;
struct ACK_BT_ACTOR_RESPAWNT;

struct ACK_BT_DROP_CREW;
struct ACK_BT_DROP_CREWT;

struct ACK_BT_CHANGE_CREW;
struct ACK_BT_CHANGE_CREWT;

struct ACK_BT_CHANGE_SPIRIT;
struct ACK_BT_CHANGE_SPIRITT;

struct ACK_BT_ACTOR_DISAPPEAR;
struct ACK_BT_ACTOR_DISAPPEART;

struct ACK_BT_SYNC_ACTOR_UPDATE;
struct ACK_BT_SYNC_ACTOR_UPDATET;

struct ACK_BT_ACTOR_UPDATE;
struct ACK_BT_ACTOR_UPDATET;

struct ACK_BT_ATTACK_NOW;
struct ACK_BT_ATTACK_NOWT;

struct ACK_BT_ATTACK_NORMAL;
struct ACK_BT_ATTACK_NORMALT;

struct ACK_BT_SKILL_ACTIVATED;
struct ACK_BT_SKILL_ACTIVATEDT;

struct ACK_BT_SKILL_BLOCKED;
struct ACK_BT_SKILL_BLOCKEDT;

struct ACK_BT_SKILL_CASTED;
struct ACK_BT_SKILL_CASTEDT;

struct ACK_BT_SKILL_CASTED_INTERVAL;
struct ACK_BT_SKILL_CASTED_INTERVALT;

struct ACK_BT_SYNC_SKILL_UPDATE;
struct ACK_BT_SYNC_SKILL_UPDATET;

struct ACK_BT_SYNC_ACTOR_SCORE;
struct ACK_BT_SYNC_ACTOR_SCORET;

struct ACK_BT_SYNC_PLAYER_SCORE;
struct ACK_BT_SYNC_PLAYER_SCORET;

struct ACK_BT_ZONE_STATE;
struct ACK_BT_ZONE_STATET;

struct ACK_BT_ZONE_EVENT;
struct ACK_BT_ZONE_EVENTT;

struct ACK_BT_DOOR_EVENT;
struct ACK_BT_DOOR_EVENTT;

struct ACK_BT_SYNC_TIME_REMAIN;
struct ACK_BT_SYNC_TIME_REMAINT;

struct ACK_BT_ACTOR_TELEPORT;
struct ACK_BT_ACTOR_TELEPORTT;

struct ACK_BT_ACTOR_FORMATION;
struct ACK_BT_ACTOR_FORMATIONT;

struct ACK_BT_ACTOR_MEDAL_UPDATE;
struct ACK_BT_ACTOR_MEDAL_UPDATET;

struct ACK_BT_TEAM_POINT_UPDATE;
struct ACK_BT_TEAM_POINT_UPDATET;

struct ACK_COMMON_ERROR;
struct ACK_COMMON_ERRORT;

struct ACK_COST_UPDATE_AVATAR;
struct ACK_COST_UPDATE_AVATART;

struct ACK_DISCONNECTED;
struct ACK_DISCONNECTEDT;

struct ACK_DECK_SCENE_LOADED;
struct ACK_DECK_SCENE_LOADEDT;

struct ACK_CS_MATCHED;
struct ACK_CS_MATCHEDT;

struct ACK_CS_DECK_SELECT;
struct ACK_CS_DECK_SELECTT;

struct ACK_CS_DECK_TIME_REMAIN;
struct ACK_CS_DECK_TIME_REMAINT;

struct ACK_CS_DECK_SELECT_READY;
struct ACK_CS_DECK_SELECT_READYT;

struct ACK_BT_DICE_OPEN;
struct ACK_BT_DICE_OPENT;

struct ACK_BT_DICE_COUNT;
struct ACK_BT_DICE_COUNTT;

struct ACK_BT_DICE_NUM;
struct ACK_BT_DICE_NUMT;

struct ACK_BT_DICE_RESULT;
struct ACK_BT_DICE_RESULTT;

struct ACK_AUTHT : public flatbuffers::NativeTable {
  typedef ACK_AUTH TableType;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_AUTHT() {
  }
};

struct ACK_AUTH FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_AUTHT NativeTableType;
  enum {
    VT_PLAYER = 4,
    VT_ERROR = 6
  };
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_AUTHT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_AUTHT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_AUTH> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_AUTHT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_AUTHBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ACK_AUTH::VT_PLAYER, player);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_AUTH::VT_ERROR, error);
  }
  explicit ACK_AUTHBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_AUTHBuilder &operator=(const ACK_AUTHBuilder &);
  flatbuffers::Offset<ACK_AUTH> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_AUTH>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_AUTH> CreateACK_AUTH(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_AUTHBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_player(player);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_AUTH> CreateACK_AUTH(flatbuffers::FlatBufferBuilder &_fbb, const ACK_AUTHT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_SUBSCRIBEDT : public flatbuffers::NativeTable {
  typedef CHAT_SUBSCRIBED TableType;
  std::string channel;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  CHAT_SUBSCRIBEDT() {
  }
};

struct CHAT_SUBSCRIBED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_SUBSCRIBEDT NativeTableType;
  enum {
    VT_CHANNEL = 4,
    VT_ERROR = 6
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  CHAT_SUBSCRIBEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_SUBSCRIBEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_SUBSCRIBED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_SUBSCRIBEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_SUBSCRIBED::VT_CHANNEL, channel);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(CHAT_SUBSCRIBED::VT_ERROR, error);
  }
  explicit CHAT_SUBSCRIBEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_SUBSCRIBEDBuilder &operator=(const CHAT_SUBSCRIBEDBuilder &);
  flatbuffers::Offset<CHAT_SUBSCRIBED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_SUBSCRIBED>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_SUBSCRIBED> CreateCHAT_SUBSCRIBED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  CHAT_SUBSCRIBEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_channel(channel);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_SUBSCRIBED> CreateCHAT_SUBSCRIBEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateCHAT_SUBSCRIBED(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0,
      error);
}

flatbuffers::Offset<CHAT_SUBSCRIBED> CreateCHAT_SUBSCRIBED(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_UNSUBSCRIBEDT : public flatbuffers::NativeTable {
  typedef CHAT_UNSUBSCRIBED TableType;
  std::string channel;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  CHAT_UNSUBSCRIBEDT() {
  }
};

struct CHAT_UNSUBSCRIBED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_UNSUBSCRIBEDT NativeTableType;
  enum {
    VT_CHANNEL = 4,
    VT_ERROR = 6
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  CHAT_UNSUBSCRIBEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_UNSUBSCRIBEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_UNSUBSCRIBED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_UNSUBSCRIBEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_UNSUBSCRIBEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_UNSUBSCRIBED::VT_CHANNEL, channel);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(CHAT_UNSUBSCRIBED::VT_ERROR, error);
  }
  explicit CHAT_UNSUBSCRIBEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_UNSUBSCRIBEDBuilder &operator=(const CHAT_UNSUBSCRIBEDBuilder &);
  flatbuffers::Offset<CHAT_UNSUBSCRIBED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_UNSUBSCRIBED>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_UNSUBSCRIBED> CreateCHAT_UNSUBSCRIBED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  CHAT_UNSUBSCRIBEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_channel(channel);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_UNSUBSCRIBED> CreateCHAT_UNSUBSCRIBEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateCHAT_UNSUBSCRIBED(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0,
      error);
}

flatbuffers::Offset<CHAT_UNSUBSCRIBED> CreateCHAT_UNSUBSCRIBED(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_UNSUBSCRIBEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_CHANNEL_ENTERT : public flatbuffers::NativeTable {
  typedef CHAT_CHANNEL_ENTER TableType;
  int32_t kId;
  std::string nick;
  std::string channel;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  CHAT_CHANNEL_ENTERT()
      : kId(0) {
  }
};

struct CHAT_CHANNEL_ENTER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_CHANNEL_ENTERT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_CHANNEL = 8,
    VT_ERROR = 10
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  CHAT_CHANNEL_ENTERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_CHANNEL_ENTERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_CHANNEL_ENTER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_ENTERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_CHANNEL_ENTERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(CHAT_CHANNEL_ENTER::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(CHAT_CHANNEL_ENTER::VT_NICK, nick);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_CHANNEL_ENTER::VT_CHANNEL, channel);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(CHAT_CHANNEL_ENTER::VT_ERROR, error);
  }
  explicit CHAT_CHANNEL_ENTERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_CHANNEL_ENTERBuilder &operator=(const CHAT_CHANNEL_ENTERBuilder &);
  flatbuffers::Offset<CHAT_CHANNEL_ENTER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_CHANNEL_ENTER>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_CHANNEL_ENTER> CreateCHAT_CHANNEL_ENTER(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  CHAT_CHANNEL_ENTERBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_channel(channel);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_CHANNEL_ENTER> CreateCHAT_CHANNEL_ENTERDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *channel = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateCHAT_CHANNEL_ENTER(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      channel ? _fbb.CreateString(channel) : 0,
      error);
}

flatbuffers::Offset<CHAT_CHANNEL_ENTER> CreateCHAT_CHANNEL_ENTER(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_ENTERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_CHANNEL_EXITT : public flatbuffers::NativeTable {
  typedef CHAT_CHANNEL_EXIT TableType;
  int32_t kId;
  std::string nick;
  std::string channel;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  CHAT_CHANNEL_EXITT()
      : kId(0) {
  }
};

struct CHAT_CHANNEL_EXIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_CHANNEL_EXITT NativeTableType;
  enum {
    VT_KID = 4,
    VT_NICK = 6,
    VT_CHANNEL = 8,
    VT_ERROR = 10
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  CHAT_CHANNEL_EXITT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_CHANNEL_EXITT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_CHANNEL_EXIT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_CHANNEL_EXITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(CHAT_CHANNEL_EXIT::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(CHAT_CHANNEL_EXIT::VT_NICK, nick);
  }
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_CHANNEL_EXIT::VT_CHANNEL, channel);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(CHAT_CHANNEL_EXIT::VT_ERROR, error);
  }
  explicit CHAT_CHANNEL_EXITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_CHANNEL_EXITBuilder &operator=(const CHAT_CHANNEL_EXITBuilder &);
  flatbuffers::Offset<CHAT_CHANNEL_EXIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_CHANNEL_EXIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_CHANNEL_EXIT> CreateCHAT_CHANNEL_EXIT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  CHAT_CHANNEL_EXITBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_channel(channel);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_CHANNEL_EXIT> CreateCHAT_CHANNEL_EXITDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *channel = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateCHAT_CHANNEL_EXIT(
      _fbb,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      channel ? _fbb.CreateString(channel) : 0,
      error);
}

flatbuffers::Offset<CHAT_CHANNEL_EXIT> CreateCHAT_CHANNEL_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CHAT_MESSAGET : public flatbuffers::NativeTable {
  typedef CHAT_MESSAGE TableType;
  std::string channel;
  uint8_t chattype;
  int32_t kId;
  std::string nick;
  std::string message;
  std::string data;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  CHAT_MESSAGET()
      : chattype(0),
        kId(0) {
  }
};

struct CHAT_MESSAGE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHAT_MESSAGET NativeTableType;
  enum {
    VT_CHANNEL = 4,
    VT_CHATTYPE = 6,
    VT_KID = 8,
    VT_NICK = 10,
    VT_MESSAGE = 12,
    VT_DATA = 14,
    VT_ERROR = 16
  };
  const flatbuffers::String *channel() const {
    return GetPointer<const flatbuffers::String *>(VT_CHANNEL);
  }
  uint8_t chattype() const {
    return GetField<uint8_t>(VT_CHATTYPE, 0);
  }
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  const flatbuffers::String *nick() const {
    return GetPointer<const flatbuffers::String *>(VT_NICK);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CHANNEL) &&
           verifier.Verify(channel()) &&
           VerifyField<uint8_t>(verifier, VT_CHATTYPE) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyOffset(verifier, VT_NICK) &&
           verifier.Verify(nick()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.Verify(message()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  CHAT_MESSAGET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CHAT_MESSAGET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CHAT_MESSAGE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CHAT_MESSAGEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel(flatbuffers::Offset<flatbuffers::String> channel) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_CHANNEL, channel);
  }
  void add_chattype(uint8_t chattype) {
    fbb_.AddElement<uint8_t>(CHAT_MESSAGE::VT_CHATTYPE, chattype, 0);
  }
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(CHAT_MESSAGE::VT_KID, kId, 0);
  }
  void add_nick(flatbuffers::Offset<flatbuffers::String> nick) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_NICK, nick);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_MESSAGE, message);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_DATA, data);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(CHAT_MESSAGE::VT_ERROR, error);
  }
  explicit CHAT_MESSAGEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CHAT_MESSAGEBuilder &operator=(const CHAT_MESSAGEBuilder &);
  flatbuffers::Offset<CHAT_MESSAGE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHAT_MESSAGE>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> channel = 0,
    uint8_t chattype = 0,
    int32_t kId = 0,
    flatbuffers::Offset<flatbuffers::String> nick = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  CHAT_MESSAGEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_data(data);
  builder_.add_message(message);
  builder_.add_nick(nick);
  builder_.add_kId(kId);
  builder_.add_channel(channel);
  builder_.add_chattype(chattype);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *channel = nullptr,
    uint8_t chattype = 0,
    int32_t kId = 0,
    const char *nick = nullptr,
    const char *message = nullptr,
    const char *data = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateCHAT_MESSAGE(
      _fbb,
      channel ? _fbb.CreateString(channel) : 0,
      chattype,
      kId,
      nick ? _fbb.CreateString(nick) : 0,
      message ? _fbb.CreateString(message) : 0,
      data ? _fbb.CreateString(data) : 0,
      error);
}

flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_MATCHEDT : public flatbuffers::NativeTable {
  typedef ACK_MATCHED TableType;
  int32_t modType;
  std::string modId;
  int32_t partyNo;
  bool bPublic;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_MATCHEDT()
      : modType(0),
        partyNo(0),
        bPublic(false) {
  }
};

struct ACK_MATCHED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_MATCHEDT NativeTableType;
  enum {
    VT_MODTYPE = 4,
    VT_MODID = 6,
    VT_PARTYNO = 8,
    VT_BPUBLIC = 10,
    VT_ERROR = 12
  };
  int32_t modType() const {
    return GetField<int32_t>(VT_MODTYPE, 0);
  }
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  bool bPublic() const {
    return GetField<uint8_t>(VT_BPUBLIC, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODTYPE) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           VerifyField<uint8_t>(verifier, VT_BPUBLIC) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_MATCHEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_MATCHEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_MATCHED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCHEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_MATCHEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modType(int32_t modType) {
    fbb_.AddElement<int32_t>(ACK_MATCHED::VT_MODTYPE, modType, 0);
  }
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(ACK_MATCHED::VT_MODID, modId);
  }
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(ACK_MATCHED::VT_PARTYNO, partyNo, 0);
  }
  void add_bPublic(bool bPublic) {
    fbb_.AddElement<uint8_t>(ACK_MATCHED::VT_BPUBLIC, static_cast<uint8_t>(bPublic), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_MATCHED::VT_ERROR, error);
  }
  explicit ACK_MATCHEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_MATCHEDBuilder &operator=(const ACK_MATCHEDBuilder &);
  flatbuffers::Offset<ACK_MATCHED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_MATCHED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_MATCHED> CreateACK_MATCHED(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    int32_t partyNo = 0,
    bool bPublic = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_MATCHEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_partyNo(partyNo);
  builder_.add_modId(modId);
  builder_.add_modType(modType);
  builder_.add_bPublic(bPublic);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_MATCHED> CreateACK_MATCHEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    const char *modId = nullptr,
    int32_t partyNo = 0,
    bool bPublic = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_MATCHED(
      _fbb,
      modType,
      modId ? _fbb.CreateString(modId) : 0,
      partyNo,
      bPublic,
      error);
}

flatbuffers::Offset<ACK_MATCHED> CreateACK_MATCHED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCHEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PARTY_UPDATE_PUBLICT : public flatbuffers::NativeTable {
  typedef ACK_PARTY_UPDATE_PUBLIC TableType;
  int32_t partyNo;
  bool bPublic;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PARTY_UPDATE_PUBLICT()
      : partyNo(0),
        bPublic(false) {
  }
};

struct ACK_PARTY_UPDATE_PUBLIC FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PARTY_UPDATE_PUBLICT NativeTableType;
  enum {
    VT_PARTYNO = 4,
    VT_BPUBLIC = 6,
    VT_ERROR = 8
  };
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  bool bPublic() const {
    return GetField<uint8_t>(VT_BPUBLIC, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           VerifyField<uint8_t>(verifier, VT_BPUBLIC) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PARTY_UPDATE_PUBLICT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_UPDATE_PUBLICT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PARTY_UPDATE_PUBLICBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(ACK_PARTY_UPDATE_PUBLIC::VT_PARTYNO, partyNo, 0);
  }
  void add_bPublic(bool bPublic) {
    fbb_.AddElement<uint8_t>(ACK_PARTY_UPDATE_PUBLIC::VT_BPUBLIC, static_cast<uint8_t>(bPublic), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PARTY_UPDATE_PUBLIC::VT_ERROR, error);
  }
  explicit ACK_PARTY_UPDATE_PUBLICBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PARTY_UPDATE_PUBLICBuilder &operator=(const ACK_PARTY_UPDATE_PUBLICBuilder &);
  flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> CreateACK_PARTY_UPDATE_PUBLIC(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t partyNo = 0,
    bool bPublic = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PARTY_UPDATE_PUBLICBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_partyNo(partyNo);
  builder_.add_bPublic(bPublic);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> CreateACK_PARTY_UPDATE_PUBLIC(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PARTY_LEADER_SLOTT : public flatbuffers::NativeTable {
  typedef ACK_PARTY_LEADER_SLOT TableType;
  uint8_t slot;
  bool leader;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PARTY_LEADER_SLOTT()
      : slot(0),
        leader(false) {
  }
};

struct ACK_PARTY_LEADER_SLOT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PARTY_LEADER_SLOTT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_LEADER = 6,
    VT_ERROR = 8
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  bool leader() const {
    return GetField<uint8_t>(VT_LEADER, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_LEADER) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PARTY_LEADER_SLOTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PARTY_LEADER_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_LEADER_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PARTY_LEADER_SLOTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_PARTY_LEADER_SLOT::VT_SLOT, slot, 0);
  }
  void add_leader(bool leader) {
    fbb_.AddElement<uint8_t>(ACK_PARTY_LEADER_SLOT::VT_LEADER, static_cast<uint8_t>(leader), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PARTY_LEADER_SLOT::VT_ERROR, error);
  }
  explicit ACK_PARTY_LEADER_SLOTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PARTY_LEADER_SLOTBuilder &operator=(const ACK_PARTY_LEADER_SLOTBuilder &);
  flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PARTY_LEADER_SLOT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> CreateACK_PARTY_LEADER_SLOT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    bool leader = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PARTY_LEADER_SLOTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_leader(leader);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> CreateACK_PARTY_LEADER_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_LEADER_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PARTY_PLAYERT : public flatbuffers::NativeTable {
  typedef ACK_PARTY_PLAYER TableType;
  uint8_t slot;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PARTY_PLAYERT()
      : slot(0) {
  }
};

struct ACK_PARTY_PLAYER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PARTY_PLAYERT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_PLAYER = 6,
    VT_ERROR = 8
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PARTY_PLAYERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PARTY_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PARTY_PLAYER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PARTY_PLAYERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_PARTY_PLAYER::VT_SLOT, slot, 0);
  }
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ACK_PARTY_PLAYER::VT_PLAYER, player);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PARTY_PLAYER::VT_ERROR, error);
  }
  explicit ACK_PARTY_PLAYERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PARTY_PLAYERBuilder &operator=(const ACK_PARTY_PLAYERBuilder &);
  flatbuffers::Offset<ACK_PARTY_PLAYER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PARTY_PLAYER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PARTY_PLAYER> CreateACK_PARTY_PLAYER(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PARTY_PLAYERBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_player(player);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PARTY_PLAYER> CreateACK_PARTY_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PARTY_PLAYER_EXITT : public flatbuffers::NativeTable {
  typedef ACK_PARTY_PLAYER_EXIT TableType;
  uint8_t slot;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PARTY_PLAYER_EXITT()
      : slot(0) {
  }
};

struct ACK_PARTY_PLAYER_EXIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PARTY_PLAYER_EXITT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_ERROR = 6
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PARTY_PLAYER_EXITT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PARTY_PLAYER_EXITT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYER_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PARTY_PLAYER_EXITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_PARTY_PLAYER_EXIT::VT_SLOT, slot, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PARTY_PLAYER_EXIT::VT_ERROR, error);
  }
  explicit ACK_PARTY_PLAYER_EXITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PARTY_PLAYER_EXITBuilder &operator=(const ACK_PARTY_PLAYER_EXITBuilder &);
  flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> CreateACK_PARTY_PLAYER_EXIT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PARTY_PLAYER_EXITBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> CreateACK_PARTY_PLAYER_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYER_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_DECK_CACHED_DONET : public flatbuffers::NativeTable {
  typedef ACK_DECK_CACHED_DONE TableType;
  std::vector<std::unique_ptr<ACK_DECK_SELECTT>> deck;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_DECK_CACHED_DONET() {
  }
};

struct ACK_DECK_CACHED_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_DECK_CACHED_DONET NativeTableType;
  enum {
    VT_DECK = 4,
    VT_ERROR = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<ACK_DECK_SELECT>> *deck() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ACK_DECK_SELECT>> *>(VT_DECK);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DECK) &&
           verifier.Verify(deck()) &&
           verifier.VerifyVectorOfTables(deck()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_DECK_CACHED_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_DECK_CACHED_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_DECK_CACHED_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_CACHED_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_DECK_CACHED_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deck(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ACK_DECK_SELECT>>> deck) {
    fbb_.AddOffset(ACK_DECK_CACHED_DONE::VT_DECK, deck);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_DECK_CACHED_DONE::VT_ERROR, error);
  }
  explicit ACK_DECK_CACHED_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_DECK_CACHED_DONEBuilder &operator=(const ACK_DECK_CACHED_DONEBuilder &);
  flatbuffers::Offset<ACK_DECK_CACHED_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_DECK_CACHED_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_DECK_CACHED_DONE> CreateACK_DECK_CACHED_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ACK_DECK_SELECT>>> deck = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_DECK_CACHED_DONEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_deck(deck);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_DECK_CACHED_DONE> CreateACK_DECK_CACHED_DONEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ACK_DECK_SELECT>> *deck = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_DECK_CACHED_DONE(
      _fbb,
      deck ? _fbb.CreateVector<flatbuffers::Offset<ACK_DECK_SELECT>>(*deck) : 0,
      error);
}

flatbuffers::Offset<ACK_DECK_CACHED_DONE> CreateACK_DECK_CACHED_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_CACHED_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_DECK_SELECTT : public flatbuffers::NativeTable {
  typedef ACK_DECK_SELECT TableType;
  uint8_t slot;
  uint8_t crewNo;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_DECK_SELECTT()
      : slot(0),
        crewNo(0),
        level(1) {
  }
};

struct ACK_DECK_SELECT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_DECK_SELECTT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_CREWNO = 6,
    VT_HEROUD = 8,
    VT_HEROID = 10,
    VT_LEVEL = 12,
    VT_ERROR = 14
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  uint8_t crewNo() const {
    return GetField<uint8_t>(VT_CREWNO, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_CREWNO) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_DECK_SELECTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_DECK_SELECT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_DECK_SELECTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_DECK_SELECT::VT_SLOT, slot, 0);
  }
  void add_crewNo(uint8_t crewNo) {
    fbb_.AddElement<uint8_t>(ACK_DECK_SELECT::VT_CREWNO, crewNo, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(ACK_DECK_SELECT::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(ACK_DECK_SELECT::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ACK_DECK_SELECT::VT_LEVEL, level, 1);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_DECK_SELECT::VT_ERROR, error);
  }
  explicit ACK_DECK_SELECTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_DECK_SELECTBuilder &operator=(const ACK_DECK_SELECTBuilder &);
  flatbuffers::Offset<ACK_DECK_SELECT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_DECK_SELECT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_DECK_SELECT> CreateACK_DECK_SELECT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    uint8_t crewNo = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_DECK_SELECTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  builder_.add_crewNo(crewNo);
  builder_.add_slot(slot);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_DECK_SELECT> CreateACK_DECK_SELECTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 0,
    uint8_t crewNo = 0,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_DECK_SELECT(
      _fbb,
      slot,
      crewNo,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level,
      error);
}

flatbuffers::Offset<ACK_DECK_SELECT> CreateACK_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_DECK_SELECT_READYT : public flatbuffers::NativeTable {
  typedef ACK_DECK_SELECT_READY TableType;
  uint8_t slot;
  bool ready;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_DECK_SELECT_READYT()
      : slot(1),
        ready(false) {
  }
};

struct ACK_DECK_SELECT_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_DECK_SELECT_READYT NativeTableType;
  enum {
    VT_SLOT = 4,
    VT_READY = 6,
    VT_ERROR = 8
  };
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 1);
  }
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_READY) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_DECK_SELECT_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_DECK_SELECT_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_DECK_SELECT_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_DECK_SELECT_READY::VT_SLOT, slot, 1);
  }
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(ACK_DECK_SELECT_READY::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_DECK_SELECT_READY::VT_ERROR, error);
  }
  explicit ACK_DECK_SELECT_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_DECK_SELECT_READYBuilder &operator=(const ACK_DECK_SELECT_READYBuilder &);
  flatbuffers::Offset<ACK_DECK_SELECT_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_DECK_SELECT_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_DECK_SELECT_READY> CreateACK_DECK_SELECT_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t slot = 1,
    bool ready = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_DECK_SELECT_READYBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_ready(ready);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_DECK_SELECT_READY> CreateACK_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PARTY_GOT : public flatbuffers::NativeTable {
  typedef ACK_PARTY_GO TableType;
  int32_t partyNo;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PARTY_GOT()
      : partyNo(0) {
  }
};

struct ACK_PARTY_GO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PARTY_GOT NativeTableType;
  enum {
    VT_PARTYNO = 4,
    VT_ERROR = 6
  };
  int32_t partyNo() const {
    return GetField<int32_t>(VT_PARTYNO, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PARTYNO) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PARTY_GOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PARTY_GOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PARTY_GO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PARTY_GOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partyNo(int32_t partyNo) {
    fbb_.AddElement<int32_t>(ACK_PARTY_GO::VT_PARTYNO, partyNo, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PARTY_GO::VT_ERROR, error);
  }
  explicit ACK_PARTY_GOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PARTY_GOBuilder &operator=(const ACK_PARTY_GOBuilder &);
  flatbuffers::Offset<ACK_PARTY_GO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PARTY_GO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PARTY_GO> CreateACK_PARTY_GO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t partyNo = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PARTY_GOBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_partyNo(partyNo);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PARTY_GO> CreateACK_PARTY_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PLAY_READYT : public flatbuffers::NativeTable {
  typedef ACK_PLAY_READY TableType;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PLAY_READYT() {
  }
};

struct ACK_PLAY_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PLAY_READYT NativeTableType;
  enum {
    VT_ERROR = 4
  };
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PLAY_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PLAY_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PLAY_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PLAY_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PLAY_READY::VT_ERROR, error);
  }
  explicit ACK_PLAY_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PLAY_READYBuilder &operator=(const ACK_PLAY_READYBuilder &);
  flatbuffers::Offset<ACK_PLAY_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PLAY_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PLAY_READY> CreateACK_PLAY_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PLAY_READYBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PLAY_READY> CreateACK_PLAY_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_MATCH_ROUNDT : public flatbuffers::NativeTable {
  typedef ACK_MATCH_ROUND TableType;
  int32_t modType;
  std::string modId;
  std::string roomkey;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::TEAMT>> teams;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>> players;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT>> actors;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_MATCH_ROUNDT()
      : modType(0) {
  }
};

struct ACK_MATCH_ROUND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_MATCH_ROUNDT NativeTableType;
  enum {
    VT_MODTYPE = 4,
    VT_MODID = 6,
    VT_ROOMKEY = 8,
    VT_TEAMS = 10,
    VT_PLAYERS = 12,
    VT_ACTORS = 14,
    VT_ERROR = 16
  };
  int32_t modType() const {
    return GetField<int32_t>(VT_MODTYPE, 0);
  }
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *teams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *>(VT_TEAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *>(VT_PLAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *actors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *>(VT_ACTORS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODTYPE) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           VerifyOffset(verifier, VT_TEAMS) &&
           verifier.Verify(teams()) &&
           verifier.VerifyVectorOfTables(teams()) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           VerifyOffset(verifier, VT_ACTORS) &&
           verifier.Verify(actors()) &&
           verifier.VerifyVectorOfTables(actors()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_MATCH_ROUNDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_MATCH_ROUNDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_MATCH_ROUND> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCH_ROUNDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_MATCH_ROUNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modType(int32_t modType) {
    fbb_.AddElement<int32_t>(ACK_MATCH_ROUND::VT_MODTYPE, modType, 0);
  }
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_MODID, modId);
  }
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_ROOMKEY, roomkey);
  }
  void add_teams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>> teams) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_TEAMS, teams);
  }
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>> players) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_PLAYERS, players);
  }
  void add_actors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>> actors) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_ACTORS, actors);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_MATCH_ROUND::VT_ERROR, error);
  }
  explicit ACK_MATCH_ROUNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_MATCH_ROUNDBuilder &operator=(const ACK_MATCH_ROUNDBuilder &);
  flatbuffers::Offset<ACK_MATCH_ROUND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_MATCH_ROUND>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_MATCH_ROUND> CreateACK_MATCH_ROUND(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>> teams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>> players = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>> actors = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_MATCH_ROUNDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_actors(actors);
  builder_.add_players(players);
  builder_.add_teams(teams);
  builder_.add_roomkey(roomkey);
  builder_.add_modId(modId);
  builder_.add_modType(modType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_MATCH_ROUND> CreateACK_MATCH_ROUNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    const char *modId = nullptr,
    const char *roomkey = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *teams = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *players = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *actors = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_MATCH_ROUND(
      _fbb,
      modType,
      modId ? _fbb.CreateString(modId) : 0,
      roomkey ? _fbb.CreateString(roomkey) : 0,
      teams ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>(*teams) : 0,
      players ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>(*players) : 0,
      actors ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>(*actors) : 0,
      error);
}

flatbuffers::Offset<ACK_MATCH_ROUND> CreateACK_MATCH_ROUND(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCH_ROUNDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_CINEMATIC_PLAYT : public flatbuffers::NativeTable {
  typedef REQ_CINEMATIC_PLAY TableType;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  REQ_CINEMATIC_PLAYT()
      : sequence(0) {
  }
};

struct REQ_CINEMATIC_PLAY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_CINEMATIC_PLAYT NativeTableType;
  enum {
    VT_SEQUENCE = 4,
    VT_ERROR = 6
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  REQ_CINEMATIC_PLAYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_CINEMATIC_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_CINEMATIC_PLAY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CINEMATIC_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_CINEMATIC_PLAYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(REQ_CINEMATIC_PLAY::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(REQ_CINEMATIC_PLAY::VT_ERROR, error);
  }
  explicit REQ_CINEMATIC_PLAYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_CINEMATIC_PLAYBuilder &operator=(const REQ_CINEMATIC_PLAYBuilder &);
  flatbuffers::Offset<REQ_CINEMATIC_PLAY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_CINEMATIC_PLAY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_CINEMATIC_PLAY> CreateREQ_CINEMATIC_PLAY(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  REQ_CINEMATIC_PLAYBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_CINEMATIC_PLAY> CreateREQ_CINEMATIC_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CINEMATIC_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CINEMATIC_DONET : public flatbuffers::NativeTable {
  typedef ACK_CINEMATIC_DONE TableType;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_CINEMATIC_DONET()
      : sequence(0) {
  }
};

struct ACK_CINEMATIC_DONE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CINEMATIC_DONET NativeTableType;
  enum {
    VT_SEQUENCE = 4,
    VT_ERROR = 6
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_CINEMATIC_DONET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CINEMATIC_DONET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CINEMATIC_DONE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CINEMATIC_DONEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(ACK_CINEMATIC_DONE::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_CINEMATIC_DONE::VT_ERROR, error);
  }
  explicit ACK_CINEMATIC_DONEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CINEMATIC_DONEBuilder &operator=(const ACK_CINEMATIC_DONEBuilder &);
  flatbuffers::Offset<ACK_CINEMATIC_DONE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CINEMATIC_DONE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_CINEMATIC_DONEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct REQ_STEP_READYT : public flatbuffers::NativeTable {
  typedef REQ_STEP_READY TableType;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  REQ_STEP_READYT()
      : sequence(0) {
  }
};

struct REQ_STEP_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef REQ_STEP_READYT NativeTableType;
  enum {
    VT_SEQUENCE = 4,
    VT_ERROR = 6
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  REQ_STEP_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(REQ_STEP_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<REQ_STEP_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_STEP_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct REQ_STEP_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(REQ_STEP_READY::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(REQ_STEP_READY::VT_ERROR, error);
  }
  explicit REQ_STEP_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  REQ_STEP_READYBuilder &operator=(const REQ_STEP_READYBuilder &);
  flatbuffers::Offset<REQ_STEP_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<REQ_STEP_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<REQ_STEP_READY> CreateREQ_STEP_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  REQ_STEP_READYBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<REQ_STEP_READY> CreateREQ_STEP_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_STEP_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_STEP_GOT : public flatbuffers::NativeTable {
  typedef ACK_STEP_GO TableType;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_STEP_GOT()
      : sequence(0) {
  }
};

struct ACK_STEP_GO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_STEP_GOT NativeTableType;
  enum {
    VT_SEQUENCE = 4,
    VT_ERROR = 6
  };
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_STEP_GOT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_STEP_GOT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_STEP_GO> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_STEP_GOBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(ACK_STEP_GO::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_STEP_GO::VT_ERROR, error);
  }
  explicit ACK_STEP_GOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_STEP_GOBuilder &operator=(const ACK_STEP_GOBuilder &);
  flatbuffers::Offset<ACK_STEP_GO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_STEP_GO>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_STEP_GO> CreateACK_STEP_GO(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_STEP_GOBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_sequence(sequence);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_STEP_GO> CreateACK_STEP_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PLAY_COUNTT : public flatbuffers::NativeTable {
  typedef ACK_PLAY_COUNT TableType;
  int32_t count;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PLAY_COUNTT()
      : count(0) {
  }
};

struct ACK_PLAY_COUNT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PLAY_COUNTT NativeTableType;
  enum {
    VT_COUNT = 4,
    VT_ERROR = 6
  };
  int32_t count() const {
    return GetField<int32_t>(VT_COUNT, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_COUNT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PLAY_COUNTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PLAY_COUNTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PLAY_COUNT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_COUNTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PLAY_COUNTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_count(int32_t count) {
    fbb_.AddElement<int32_t>(ACK_PLAY_COUNT::VT_COUNT, count, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PLAY_COUNT::VT_ERROR, error);
  }
  explicit ACK_PLAY_COUNTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PLAY_COUNTBuilder &operator=(const ACK_PLAY_COUNTBuilder &);
  flatbuffers::Offset<ACK_PLAY_COUNT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PLAY_COUNT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PLAY_COUNT> CreateACK_PLAY_COUNT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t count = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PLAY_COUNTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_count(count);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PLAY_COUNT> CreateACK_PLAY_COUNT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_COUNTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PLAY_STARTT : public flatbuffers::NativeTable {
  typedef ACK_PLAY_START TableType;
  uint32_t frame;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PLAY_STARTT()
      : frame(0) {
  }
};

struct ACK_PLAY_START FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PLAY_STARTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ERROR = 6
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PLAY_STARTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PLAY_START> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PLAY_STARTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_PLAY_START::VT_FRAME, frame, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PLAY_START::VT_ERROR, error);
  }
  explicit ACK_PLAY_STARTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PLAY_STARTBuilder &operator=(const ACK_PLAY_STARTBuilder &);
  flatbuffers::Offset<ACK_PLAY_START> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PLAY_START>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PLAY_START> CreateACK_PLAY_START(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PLAY_STARTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PLAY_START> CreateACK_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PLAY_TIMEOUTT : public flatbuffers::NativeTable {
  typedef ACK_PLAY_TIMEOUT TableType;
  uint32_t frame;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PLAY_TIMEOUTT()
      : frame(0) {
  }
};

/////////////////////////////
struct ACK_PLAY_TIMEOUT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PLAY_TIMEOUTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ERROR = 6
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PLAY_TIMEOUTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PLAY_TIMEOUTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PLAY_TIMEOUT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_TIMEOUTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PLAY_TIMEOUTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_PLAY_TIMEOUT::VT_FRAME, frame, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PLAY_TIMEOUT::VT_ERROR, error);
  }
  explicit ACK_PLAY_TIMEOUTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PLAY_TIMEOUTBuilder &operator=(const ACK_PLAY_TIMEOUTBuilder &);
  flatbuffers::Offset<ACK_PLAY_TIMEOUT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PLAY_TIMEOUT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PLAY_TIMEOUT> CreateACK_PLAY_TIMEOUT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PLAY_TIMEOUTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_PLAY_TIMEOUT> CreateACK_PLAY_TIMEOUT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_TIMEOUTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_PLAY_SEND_RESULTT : public flatbuffers::NativeTable {
  typedef ACK_PLAY_SEND_RESULT TableType;
  uint8_t result;
  std::string json;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_PLAY_SEND_RESULTT()
      : result(0) {
  }
};

struct ACK_PLAY_SEND_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_PLAY_SEND_RESULTT NativeTableType;
  enum {
    VT_RESULT = 4,
    VT_JSON = 6,
    VT_ERROR = 8
  };
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  const flatbuffers::String *json() const {
    return GetPointer<const flatbuffers::String *>(VT_JSON);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           VerifyOffset(verifier, VT_JSON) &&
           verifier.Verify(json()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_PLAY_SEND_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_PLAY_SEND_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_PLAY_SEND_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_SEND_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_PLAY_SEND_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(ACK_PLAY_SEND_RESULT::VT_RESULT, result, 0);
  }
  void add_json(flatbuffers::Offset<flatbuffers::String> json) {
    fbb_.AddOffset(ACK_PLAY_SEND_RESULT::VT_JSON, json);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_PLAY_SEND_RESULT::VT_ERROR, error);
  }
  explicit ACK_PLAY_SEND_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_PLAY_SEND_RESULTBuilder &operator=(const ACK_PLAY_SEND_RESULTBuilder &);
  flatbuffers::Offset<ACK_PLAY_SEND_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_PLAY_SEND_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_PLAY_SEND_RESULT> CreateACK_PLAY_SEND_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    flatbuffers::Offset<flatbuffers::String> json = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_PLAY_SEND_RESULTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_json(json);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_PLAY_SEND_RESULT> CreateACK_PLAY_SEND_RESULTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t result = 0,
    const char *json = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_PLAY_SEND_RESULT(
      _fbb,
      result,
      json ? _fbb.CreateString(json) : 0,
      error);
}

flatbuffers::Offset<ACK_PLAY_SEND_RESULT> CreateACK_PLAY_SEND_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_SEND_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_NEW_PLAYERT : public flatbuffers::NativeTable {
  typedef ACK_BT_NEW_PLAYER TableType;
  uint32_t frame;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT> player;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_NEW_PLAYERT()
      : frame(0) {
  }
};

struct ACK_BT_NEW_PLAYER FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_NEW_PLAYERT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_PLAYER = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const OVERLORD::RTS::STRUCT::PLAYER *player() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER *>(VT_PLAYER);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_PLAYER) &&
           verifier.VerifyTable(player()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_NEW_PLAYERT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_NEW_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_NEW_PLAYER> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_NEW_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_NEW_PLAYERBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_NEW_PLAYER::VT_FRAME, frame, 0);
  }
  void add_player(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player) {
    fbb_.AddOffset(ACK_BT_NEW_PLAYER::VT_PLAYER, player);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_NEW_PLAYER::VT_ERROR, error);
  }
  explicit ACK_BT_NEW_PLAYERBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_NEW_PLAYERBuilder &operator=(const ACK_BT_NEW_PLAYERBuilder &);
  flatbuffers::Offset<ACK_BT_NEW_PLAYER> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_NEW_PLAYER>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_NEW_PLAYER> CreateACK_BT_NEW_PLAYER(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER> player = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_NEW_PLAYERBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_player(player);
  builder_.add_frame(frame);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_NEW_PLAYER> CreateACK_BT_NEW_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_NEW_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_CREATET : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_CREATE TableType;
  uint32_t frame;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT>> actors;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_CREATET()
      : frame(0) {
  }
};

struct ACK_BT_ACTOR_CREATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_CREATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORS = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *actors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *>(VT_ACTORS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ACTORS) &&
           verifier.Verify(actors()) &&
           verifier.VerifyVectorOfTables(actors()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_CREATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_CREATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_CREATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_CREATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_CREATE::VT_FRAME, frame, 0);
  }
  void add_actors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>> actors) {
    fbb_.AddOffset(ACK_BT_ACTOR_CREATE::VT_ACTORS, actors);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_CREATE::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_CREATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_CREATEBuilder &operator=(const ACK_BT_ACTOR_CREATEBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_CREATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_CREATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_CREATE> CreateACK_BT_ACTOR_CREATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>> actors = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_CREATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_actors(actors);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_ACTOR_CREATE> CreateACK_BT_ACTOR_CREATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> *actors = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_CREATE(
      _fbb,
      frame,
      actors ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>>(*actors) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_ACTOR_CREATE> CreateACK_BT_ACTOR_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_SPAWNT : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_SPAWN TableType;
  uint32_t frame;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>> updates;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_SPAWNT()
      : frame(0) {
  }
};

struct ACK_BT_ACTOR_SPAWN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_SPAWNT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_UPDATES = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *>(VT_UPDATES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.Verify(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_SPAWNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_SPAWNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_SPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_SPAWNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_SPAWN::VT_FRAME, frame, 0);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates) {
    fbb_.AddOffset(ACK_BT_ACTOR_SPAWN::VT_UPDATES, updates);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_SPAWN::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_SPAWNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_SPAWNBuilder &operator=(const ACK_BT_ACTOR_SPAWNBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_SPAWN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> CreateACK_BT_ACTOR_SPAWN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_SPAWNBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_updates(updates);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> CreateACK_BT_ACTOR_SPAWNDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_SPAWN(
      _fbb,
      frame,
      updates ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>(*updates) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> CreateACK_BT_ACTOR_SPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_SPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_DESPAWNT : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_DESPAWN TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_DESPAWNT()
      : frame(0),
        actorUK(0) {
  }
};

struct ACK_BT_ACTOR_DESPAWN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_DESPAWNT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_DESPAWNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_DESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_DESPAWNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_DESPAWN::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_DESPAWN::VT_ACTORUK, actorUK, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_DESPAWN::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_DESPAWNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_DESPAWNBuilder &operator=(const ACK_BT_ACTOR_DESPAWNBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> CreateACK_BT_ACTOR_DESPAWN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_DESPAWNBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> CreateACK_BT_ACTOR_DESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_RESPAWNT : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_RESPAWN TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT> actor;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_RESPAWNT()
      : frame(0),
        actorUK(0) {
  }
};

struct ACK_BT_ACTOR_RESPAWN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_RESPAWNT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ACTOR = 8,
    VT_LOCATION = 10,
    VT_DIRECTION = 12,
    VT_ERROR = 14
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::ACTOR *actor() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR *>(VT_ACTOR);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_ACTOR) &&
           verifier.VerifyTable(actor()) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_RESPAWNT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_RESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_RESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_RESPAWNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_RESPAWN::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_RESPAWN::VT_ACTORUK, actorUK, 0);
  }
  void add_actor(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR> actor) {
    fbb_.AddOffset(ACK_BT_ACTOR_RESPAWN::VT_ACTOR, actor);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(ACK_BT_ACTOR_RESPAWN::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(ACK_BT_ACTOR_RESPAWN::VT_DIRECTION, direction);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_RESPAWN::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_RESPAWNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_RESPAWNBuilder &operator=(const ACK_BT_ACTOR_RESPAWNBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> CreateACK_BT_ACTOR_RESPAWN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR> actor = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_RESPAWNBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_actor(actor);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> CreateACK_BT_ACTOR_RESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_RESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DROP_CREWT : public flatbuffers::NativeTable {
  typedef ACK_BT_DROP_CREW TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> location;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> direction;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DROP_CREWT()
      : frame(0),
        actorUK(0) {
  }
};

struct ACK_BT_DROP_CREW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DROP_CREWT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_LOCATION = 8,
    VT_DIRECTION = 10,
    VT_ERROR = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *location() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_LOCATION);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *direction() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_DIRECTION);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_LOCATION) &&
           verifier.VerifyTable(location()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyTable(direction()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DROP_CREWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DROP_CREWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DROP_CREW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DROP_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DROP_CREWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DROP_CREW::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_DROP_CREW::VT_ACTORUK, actorUK, 0);
  }
  void add_location(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location) {
    fbb_.AddOffset(ACK_BT_DROP_CREW::VT_LOCATION, location);
  }
  void add_direction(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction) {
    fbb_.AddOffset(ACK_BT_DROP_CREW::VT_DIRECTION, direction);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DROP_CREW::VT_ERROR, error);
  }
  explicit ACK_BT_DROP_CREWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DROP_CREWBuilder &operator=(const ACK_BT_DROP_CREWBuilder &);
  flatbuffers::Offset<ACK_BT_DROP_CREW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DROP_CREW>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DROP_CREW> CreateACK_BT_DROP_CREW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> location = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> direction = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DROP_CREWBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_direction(direction);
  builder_.add_location(location);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_DROP_CREW> CreateACK_BT_DROP_CREW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DROP_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_CHANGE_CREWT : public flatbuffers::NativeTable {
  typedef ACK_BT_CHANGE_CREW TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint16_t targetUK;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>> updates;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_CHANGE_CREWT()
      : frame(0),
        actorUK(0),
        targetUK(0) {
  }
};

struct ACK_BT_CHANGE_CREW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_CHANGE_CREWT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_TARGETUK = 8,
    VT_UPDATES = 10,
    VT_ERROR = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *>(VT_UPDATES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.Verify(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_CHANGE_CREWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_CHANGE_CREWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_CHANGE_CREW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_CHANGE_CREWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_CHANGE_CREW::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_CHANGE_CREW::VT_ACTORUK, actorUK, 0);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_CHANGE_CREW::VT_TARGETUK, targetUK, 0);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates) {
    fbb_.AddOffset(ACK_BT_CHANGE_CREW::VT_UPDATES, updates);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_CHANGE_CREW::VT_ERROR, error);
  }
  explicit ACK_BT_CHANGE_CREWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_CHANGE_CREWBuilder &operator=(const ACK_BT_CHANGE_CREWBuilder &);
  flatbuffers::Offset<ACK_BT_CHANGE_CREW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_CHANGE_CREW>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_CHANGE_CREW> CreateACK_BT_CHANGE_CREW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint16_t targetUK = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_CHANGE_CREWBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_updates(updates);
  builder_.add_frame(frame);
  builder_.add_targetUK(targetUK);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_CHANGE_CREW> CreateACK_BT_CHANGE_CREWDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint16_t targetUK = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_CHANGE_CREW(
      _fbb,
      frame,
      actorUK,
      targetUK,
      updates ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>(*updates) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_CHANGE_CREW> CreateACK_BT_CHANGE_CREW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_CHANGE_SPIRITT : public flatbuffers::NativeTable {
  typedef ACK_BT_CHANGE_SPIRIT TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint16_t slotOff;
  uint16_t slotOn;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_CHANGE_SPIRITT()
      : frame(0),
        actorUK(0),
        slotOff(0),
        slotOn(0) {
  }
};

struct ACK_BT_CHANGE_SPIRIT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_CHANGE_SPIRITT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_SLOTOFF = 8,
    VT_SLOTON = 10,
    VT_ERROR = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t slotOff() const {
    return GetField<uint16_t>(VT_SLOTOFF, 0);
  }
  uint16_t slotOn() const {
    return GetField<uint16_t>(VT_SLOTON, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_SLOTOFF) &&
           VerifyField<uint16_t>(verifier, VT_SLOTON) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_CHANGE_SPIRITT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_CHANGE_SPIRITT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_SPIRITT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_CHANGE_SPIRITBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_CHANGE_SPIRIT::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_CHANGE_SPIRIT::VT_ACTORUK, actorUK, 0);
  }
  void add_slotOff(uint16_t slotOff) {
    fbb_.AddElement<uint16_t>(ACK_BT_CHANGE_SPIRIT::VT_SLOTOFF, slotOff, 0);
  }
  void add_slotOn(uint16_t slotOn) {
    fbb_.AddElement<uint16_t>(ACK_BT_CHANGE_SPIRIT::VT_SLOTON, slotOn, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_CHANGE_SPIRIT::VT_ERROR, error);
  }
  explicit ACK_BT_CHANGE_SPIRITBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_CHANGE_SPIRITBuilder &operator=(const ACK_BT_CHANGE_SPIRITBuilder &);
  flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> CreateACK_BT_CHANGE_SPIRIT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint16_t slotOff = 0,
    uint16_t slotOn = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_CHANGE_SPIRITBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_slotOn(slotOn);
  builder_.add_slotOff(slotOff);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> CreateACK_BT_CHANGE_SPIRIT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_SPIRITT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_DISAPPEART : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_DISAPPEAR TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint16_t killerUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_DISAPPEART()
      : frame(0),
        actorUK(0),
        killerUK(0) {
  }
};

struct ACK_BT_ACTOR_DISAPPEAR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_DISAPPEART NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_KILLERUK = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t killerUK() const {
    return GetField<uint16_t>(VT_KILLERUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_KILLERUK) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_DISAPPEART *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_DISAPPEART *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DISAPPEART* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_DISAPPEARBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_DISAPPEAR::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_DISAPPEAR::VT_ACTORUK, actorUK, 0);
  }
  void add_killerUK(uint16_t killerUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_DISAPPEAR::VT_KILLERUK, killerUK, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_DISAPPEAR::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_DISAPPEARBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_DISAPPEARBuilder &operator=(const ACK_BT_ACTOR_DISAPPEARBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> CreateACK_BT_ACTOR_DISAPPEAR(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint16_t killerUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_DISAPPEARBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_killerUK(killerUK);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> CreateACK_BT_ACTOR_DISAPPEAR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DISAPPEART *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SYNC_ACTOR_UPDATET : public flatbuffers::NativeTable {
  typedef ACK_BT_SYNC_ACTOR_UPDATE TableType;
  uint32_t frame;
  bool force;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>> updates;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SYNC_ACTOR_UPDATET()
      : frame(0),
        force(false) {
  }
};

struct ACK_BT_SYNC_ACTOR_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SYNC_ACTOR_UPDATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_FORCE = 6,
    VT_UPDATES = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  bool force() const {
    return GetField<uint8_t>(VT_FORCE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *>(VT_UPDATES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_FORCE) &&
           VerifyOffset(verifier, VT_UPDATES) &&
           verifier.Verify(updates()) &&
           verifier.VerifyVectorOfTables(updates()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SYNC_ACTOR_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SYNC_ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SYNC_ACTOR_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SYNC_ACTOR_UPDATE::VT_FRAME, frame, 0);
  }
  void add_force(bool force) {
    fbb_.AddElement<uint8_t>(ACK_BT_SYNC_ACTOR_UPDATE::VT_FORCE, static_cast<uint8_t>(force), 0);
  }
  void add_updates(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates) {
    fbb_.AddOffset(ACK_BT_SYNC_ACTOR_UPDATE::VT_UPDATES, updates);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SYNC_ACTOR_UPDATE::VT_ERROR, error);
  }
  explicit ACK_BT_SYNC_ACTOR_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SYNC_ACTOR_UPDATEBuilder &operator=(const ACK_BT_SYNC_ACTOR_UPDATEBuilder &);
  flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> CreateACK_BT_SYNC_ACTOR_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    bool force = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>> updates = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SYNC_ACTOR_UPDATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_updates(updates);
  builder_.add_frame(frame);
  builder_.add_force(force);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> CreateACK_BT_SYNC_ACTOR_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    bool force = false,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> *updates = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_ACTOR_UPDATE(
      _fbb,
      frame,
      force,
      updates ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>>(*updates) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> CreateACK_BT_SYNC_ACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_UPDATET : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_UPDATE TableType;
  uint32_t frame;
  bool force;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET> update;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_UPDATET()
      : frame(0),
        force(false) {
  }
};

struct ACK_BT_ACTOR_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_UPDATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_FORCE = 6,
    VT_UPDATE = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  bool force() const {
    return GetField<uint8_t>(VT_FORCE, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::ACTOR_UPDATE *update() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR_UPDATE *>(VT_UPDATE);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_FORCE) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_UPDATE::VT_FRAME, frame, 0);
  }
  void add_force(bool force) {
    fbb_.AddElement<uint8_t>(ACK_BT_ACTOR_UPDATE::VT_FORCE, static_cast<uint8_t>(force), 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE> update) {
    fbb_.AddOffset(ACK_BT_ACTOR_UPDATE::VT_UPDATE, update);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_UPDATE::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_UPDATEBuilder &operator=(const ACK_BT_ACTOR_UPDATEBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> CreateACK_BT_ACTOR_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    bool force = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE> update = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_UPDATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_update(update);
  builder_.add_frame(frame);
  builder_.add_force(force);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> CreateACK_BT_ACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ATTACK_NOWT : public flatbuffers::NativeTable {
  typedef ACK_BT_ATTACK_NOW TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT> actorLocation;
  uint16_t targetUK;
  bool bAttack;
  uint8_t sequence;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ATTACK_NOWT()
      : frame(0),
        actorUK(0),
        targetUK(0),
        bAttack(false),
        sequence(0) {
  }
};

struct ACK_BT_ATTACK_NOW FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ATTACK_NOWT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ACTORLOCATION = 8,
    VT_TARGETUK = 10,
    VT_BATTACK = 12,
    VT_SEQUENCE = 14,
    VT_ERROR = 16
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_VECTOR *actorLocation() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_VECTOR *>(VT_ACTORLOCATION);
  }
  uint16_t targetUK() const {
    return GetField<uint16_t>(VT_TARGETUK, 0);
  }
  bool bAttack() const {
    return GetField<uint8_t>(VT_BATTACK, 0) != 0;
  }
  uint8_t sequence() const {
    return GetField<uint8_t>(VT_SEQUENCE, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_ACTORLOCATION) &&
           verifier.VerifyTable(actorLocation()) &&
           VerifyField<uint16_t>(verifier, VT_TARGETUK) &&
           VerifyField<uint8_t>(verifier, VT_BATTACK) &&
           VerifyField<uint8_t>(verifier, VT_SEQUENCE) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ATTACK_NOWT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ATTACK_NOWT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ATTACK_NOW> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NOWT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ATTACK_NOWBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ATTACK_NOW::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ATTACK_NOW::VT_ACTORUK, actorUK, 0);
  }
  void add_actorLocation(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation) {
    fbb_.AddOffset(ACK_BT_ATTACK_NOW::VT_ACTORLOCATION, actorLocation);
  }
  void add_targetUK(uint16_t targetUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ATTACK_NOW::VT_TARGETUK, targetUK, 0);
  }
  void add_bAttack(bool bAttack) {
    fbb_.AddElement<uint8_t>(ACK_BT_ATTACK_NOW::VT_BATTACK, static_cast<uint8_t>(bAttack), 0);
  }
  void add_sequence(uint8_t sequence) {
    fbb_.AddElement<uint8_t>(ACK_BT_ATTACK_NOW::VT_SEQUENCE, sequence, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ATTACK_NOW::VT_ERROR, error);
  }
  explicit ACK_BT_ATTACK_NOWBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ATTACK_NOWBuilder &operator=(const ACK_BT_ATTACK_NOWBuilder &);
  flatbuffers::Offset<ACK_BT_ATTACK_NOW> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ATTACK_NOW>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ATTACK_NOW> CreateACK_BT_ATTACK_NOW(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_VECTOR> actorLocation = 0,
    uint16_t targetUK = 0,
    bool bAttack = false,
    uint8_t sequence = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ATTACK_NOWBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_actorLocation(actorLocation);
  builder_.add_frame(frame);
  builder_.add_targetUK(targetUK);
  builder_.add_actorUK(actorUK);
  builder_.add_sequence(sequence);
  builder_.add_bAttack(bAttack);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ATTACK_NOW> CreateACK_BT_ATTACK_NOW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NOWT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ATTACK_NORMALT : public flatbuffers::NativeTable {
  typedef ACK_BT_ATTACK_NORMAL TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATET> targetUpdate;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ATTACK_NORMALT()
      : frame(0),
        actorUK(0) {
  }
};

struct ACK_BT_ATTACK_NORMAL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ATTACK_NORMALT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_TARGETUPDATE = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATE *targetUpdate() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATE *>(VT_TARGETUPDATE);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_TARGETUPDATE) &&
           verifier.VerifyTable(targetUpdate()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ATTACK_NORMALT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ATTACK_NORMALT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NORMALT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ATTACK_NORMALBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ATTACK_NORMAL::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ATTACK_NORMAL::VT_ACTORUK, actorUK, 0);
  }
  void add_targetUpdate(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATE> targetUpdate) {
    fbb_.AddOffset(ACK_BT_ATTACK_NORMAL::VT_TARGETUPDATE, targetUpdate);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ATTACK_NORMAL::VT_ERROR, error);
  }
  explicit ACK_BT_ATTACK_NORMALBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ATTACK_NORMALBuilder &operator=(const ACK_BT_ATTACK_NORMALBuilder &);
  flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ATTACK_NORMAL>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> CreateACK_BT_ATTACK_NORMAL(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATE> targetUpdate = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ATTACK_NORMALBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_targetUpdate(targetUpdate);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> CreateACK_BT_ATTACK_NORMAL(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NORMALT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SKILL_ACTIVATEDT : public flatbuffers::NativeTable {
  typedef ACK_BT_SKILL_ACTIVATED TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint8_t slot;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SKILL_ACTIVATEDT()
      : frame(0),
        actorUK(0),
        slot(0) {
  }
};

struct ACK_BT_SKILL_ACTIVATED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SKILL_ACTIVATEDT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_SLOT = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SKILL_ACTIVATEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SKILL_ACTIVATEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_ACTIVATEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SKILL_ACTIVATEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SKILL_ACTIVATED::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_SKILL_ACTIVATED::VT_ACTORUK, actorUK, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_ACTIVATED::VT_SLOT, slot, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SKILL_ACTIVATED::VT_ERROR, error);
  }
  explicit ACK_BT_SKILL_ACTIVATEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SKILL_ACTIVATEDBuilder &operator=(const ACK_BT_SKILL_ACTIVATEDBuilder &);
  flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> CreateACK_BT_SKILL_ACTIVATED(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SKILL_ACTIVATEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> CreateACK_BT_SKILL_ACTIVATED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_ACTIVATEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SKILL_BLOCKEDT : public flatbuffers::NativeTable {
  typedef ACK_BT_SKILL_BLOCKED TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint8_t slot;
  int32_t coolbonusMSec;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SKILL_BLOCKEDT()
      : frame(0),
        actorUK(0),
        slot(0),
        coolbonusMSec(0) {
  }
};

struct ACK_BT_SKILL_BLOCKED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SKILL_BLOCKEDT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_SLOT = 8,
    VT_COOLBONUSMSEC = 10,
    VT_ERROR = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  int32_t coolbonusMSec() const {
    return GetField<int32_t>(VT_COOLBONUSMSEC, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<int32_t>(verifier, VT_COOLBONUSMSEC) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SKILL_BLOCKEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SKILL_BLOCKEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_BLOCKEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SKILL_BLOCKEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SKILL_BLOCKED::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_SKILL_BLOCKED::VT_ACTORUK, actorUK, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_BLOCKED::VT_SLOT, slot, 0);
  }
  void add_coolbonusMSec(int32_t coolbonusMSec) {
    fbb_.AddElement<int32_t>(ACK_BT_SKILL_BLOCKED::VT_COOLBONUSMSEC, coolbonusMSec, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SKILL_BLOCKED::VT_ERROR, error);
  }
  explicit ACK_BT_SKILL_BLOCKEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SKILL_BLOCKEDBuilder &operator=(const ACK_BT_SKILL_BLOCKEDBuilder &);
  flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SKILL_BLOCKED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> CreateACK_BT_SKILL_BLOCKED(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    int32_t coolbonusMSec = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SKILL_BLOCKEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_coolbonusMSec(coolbonusMSec);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_slot(slot);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> CreateACK_BT_SKILL_BLOCKED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_BLOCKEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SKILL_CASTEDT : public flatbuffers::NativeTable {
  typedef ACK_BT_SKILL_CASTED TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint8_t slot;
  bool casting;
  std::unique_ptr<OVERLORD::RTS::STRUCT::SKILL_PIVOTT> pivot;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET> caster;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>> targets;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SKILL_CASTEDT()
      : frame(0),
        actorUK(0),
        slot(0),
        casting(false) {
  }
};

struct ACK_BT_SKILL_CASTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SKILL_CASTEDT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_SLOT = 8,
    VT_CASTING = 10,
    VT_PIVOT = 12,
    VT_CASTER = 14,
    VT_TARGETS = 16,
    VT_ERROR = 18
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  bool casting() const {
    return GetField<uint8_t>(VT_CASTING, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::SKILL_PIVOT *pivot() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::SKILL_PIVOT *>(VT_PIVOT);
  }
  const OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE *caster() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE *>(VT_CASTER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *>(VT_TARGETS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyField<uint8_t>(verifier, VT_CASTING) &&
           VerifyOffset(verifier, VT_PIVOT) &&
           verifier.VerifyTable(pivot()) &&
           VerifyOffset(verifier, VT_CASTER) &&
           verifier.VerifyTable(caster()) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SKILL_CASTEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SKILL_CASTEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SKILL_CASTED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SKILL_CASTEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SKILL_CASTED::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_SKILL_CASTED::VT_ACTORUK, actorUK, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_CASTED::VT_SLOT, slot, 0);
  }
  void add_casting(bool casting) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_CASTED::VT_CASTING, static_cast<uint8_t>(casting), 0);
  }
  void add_pivot(flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED::VT_PIVOT, pivot);
  }
  void add_caster(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED::VT_CASTER, caster);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED::VT_TARGETS, targets);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED::VT_ERROR, error);
  }
  explicit ACK_BT_SKILL_CASTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SKILL_CASTEDBuilder &operator=(const ACK_BT_SKILL_CASTEDBuilder &);
  flatbuffers::Offset<ACK_BT_SKILL_CASTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SKILL_CASTED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED> CreateACK_BT_SKILL_CASTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    bool casting = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SKILL_CASTEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_targets(targets);
  builder_.add_caster(caster);
  builder_.add_pivot(pivot);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_casting(casting);
  builder_.add_slot(slot);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED> CreateACK_BT_SKILL_CASTEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    bool casting = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_CASTED(
      _fbb,
      frame,
      actorUK,
      slot,
      casting,
      pivot,
      caster,
      targets ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>(*targets) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SKILL_CASTED> CreateACK_BT_SKILL_CASTED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SKILL_CASTED_INTERVALT : public flatbuffers::NativeTable {
  typedef ACK_BT_SKILL_CASTED_INTERVAL TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint8_t slot;
  std::unique_ptr<OVERLORD::RTS::STRUCT::SKILL_PIVOTT> pivot;
  uint8_t leftCount;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET> caster;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>> targets;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SKILL_CASTED_INTERVALT()
      : frame(0),
        actorUK(0),
        slot(0),
        leftCount(0) {
  }
};

struct ACK_BT_SKILL_CASTED_INTERVAL FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SKILL_CASTED_INTERVALT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_SLOT = 8,
    VT_PIVOT = 10,
    VT_LEFTCOUNT = 12,
    VT_CASTER = 14,
    VT_TARGETS = 16,
    VT_ERROR = 18
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t slot() const {
    return GetField<uint8_t>(VT_SLOT, 0);
  }
  const OVERLORD::RTS::STRUCT::SKILL_PIVOT *pivot() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::SKILL_PIVOT *>(VT_PIVOT);
  }
  uint8_t leftCount() const {
    return GetField<uint8_t>(VT_LEFTCOUNT, 0);
  }
  const OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE *caster() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE *>(VT_CASTER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *>(VT_TARGETS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_SLOT) &&
           VerifyOffset(verifier, VT_PIVOT) &&
           verifier.VerifyTable(pivot()) &&
           VerifyField<uint8_t>(verifier, VT_LEFTCOUNT) &&
           VerifyOffset(verifier, VT_CASTER) &&
           verifier.VerifyTable(caster()) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SKILL_CASTED_INTERVALT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SKILL_CASTED_INTERVALT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTED_INTERVALT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SKILL_CASTED_INTERVALBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SKILL_CASTED_INTERVAL::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_SKILL_CASTED_INTERVAL::VT_ACTORUK, actorUK, 0);
  }
  void add_slot(uint8_t slot) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_CASTED_INTERVAL::VT_SLOT, slot, 0);
  }
  void add_pivot(flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED_INTERVAL::VT_PIVOT, pivot);
  }
  void add_leftCount(uint8_t leftCount) {
    fbb_.AddElement<uint8_t>(ACK_BT_SKILL_CASTED_INTERVAL::VT_LEFTCOUNT, leftCount, 0);
  }
  void add_caster(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED_INTERVAL::VT_CASTER, caster);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED_INTERVAL::VT_TARGETS, targets);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SKILL_CASTED_INTERVAL::VT_ERROR, error);
  }
  explicit ACK_BT_SKILL_CASTED_INTERVALBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SKILL_CASTED_INTERVALBuilder &operator=(const ACK_BT_SKILL_CASTED_INTERVALBuilder &);
  flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> CreateACK_BT_SKILL_CASTED_INTERVAL(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot = 0,
    uint8_t leftCount = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SKILL_CASTED_INTERVALBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_targets(targets);
  builder_.add_caster(caster);
  builder_.add_pivot(pivot);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_leftCount(leftCount);
  builder_.add_slot(slot);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> CreateACK_BT_SKILL_CASTED_INTERVALDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t slot = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::SKILL_PIVOT> pivot = 0,
    uint8_t leftCount = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE> caster = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_CASTED_INTERVAL(
      _fbb,
      frame,
      actorUK,
      slot,
      pivot,
      leftCount,
      caster,
      targets ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>(*targets) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> CreateACK_BT_SKILL_CASTED_INTERVAL(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTED_INTERVALT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SYNC_SKILL_UPDATET : public flatbuffers::NativeTable {
  typedef ACK_BT_SYNC_SKILL_UPDATE TableType;
  uint32_t frame;
  uint16_t actorUK;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>> targets;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SYNC_SKILL_UPDATET()
      : frame(0),
        actorUK(0) {
  }
};

struct ACK_BT_SYNC_SKILL_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SYNC_SKILL_UPDATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_TARGETS = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *>(VT_TARGETS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_TARGETS) &&
           verifier.Verify(targets()) &&
           verifier.VerifyVectorOfTables(targets()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SYNC_SKILL_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SYNC_SKILL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_SKILL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SYNC_SKILL_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SYNC_SKILL_UPDATE::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_SYNC_SKILL_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_targets(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets) {
    fbb_.AddOffset(ACK_BT_SYNC_SKILL_UPDATE::VT_TARGETS, targets);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SYNC_SKILL_UPDATE::VT_ERROR, error);
  }
  explicit ACK_BT_SYNC_SKILL_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SYNC_SKILL_UPDATEBuilder &operator=(const ACK_BT_SYNC_SKILL_UPDATEBuilder &);
  flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> CreateACK_BT_SYNC_SKILL_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>> targets = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SYNC_SKILL_UPDATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_targets(targets);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> CreateACK_BT_SYNC_SKILL_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> *targets = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_SKILL_UPDATE(
      _fbb,
      frame,
      actorUK,
      targets ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>>(*targets) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> CreateACK_BT_SYNC_SKILL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_SKILL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SYNC_ACTOR_SCORET : public flatbuffers::NativeTable {
  typedef ACK_BT_SYNC_ACTOR_SCORE TableType;
  uint32_t frame;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>> scores;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SYNC_ACTOR_SCORET()
      : frame(0) {
  }
};

struct ACK_BT_SYNC_ACTOR_SCORE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SYNC_ACTOR_SCORET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_SCORES = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *scores() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *>(VT_SCORES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_SCORES) &&
           verifier.Verify(scores()) &&
           verifier.VerifyVectorOfTables(scores()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SYNC_ACTOR_SCORET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SYNC_ACTOR_SCORET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SYNC_ACTOR_SCOREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SYNC_ACTOR_SCORE::VT_FRAME, frame, 0);
  }
  void add_scores(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> scores) {
    fbb_.AddOffset(ACK_BT_SYNC_ACTOR_SCORE::VT_SCORES, scores);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SYNC_ACTOR_SCORE::VT_ERROR, error);
  }
  explicit ACK_BT_SYNC_ACTOR_SCOREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SYNC_ACTOR_SCOREBuilder &operator=(const ACK_BT_SYNC_ACTOR_SCOREBuilder &);
  flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> CreateACK_BT_SYNC_ACTOR_SCORE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> scores = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SYNC_ACTOR_SCOREBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_scores(scores);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> CreateACK_BT_SYNC_ACTOR_SCOREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *scores = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_ACTOR_SCORE(
      _fbb,
      frame,
      scores ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>(*scores) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> CreateACK_BT_SYNC_ACTOR_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SYNC_PLAYER_SCORET : public flatbuffers::NativeTable {
  typedef ACK_BT_SYNC_PLAYER_SCORE TableType;
  uint32_t frame;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>> scores;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SYNC_PLAYER_SCORET()
      : frame(0) {
  }
};

struct ACK_BT_SYNC_PLAYER_SCORE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SYNC_PLAYER_SCORET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_SCORES = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *scores() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *>(VT_SCORES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_SCORES) &&
           verifier.Verify(scores()) &&
           verifier.VerifyVectorOfTables(scores()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SYNC_PLAYER_SCORET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SYNC_PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SYNC_PLAYER_SCOREBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SYNC_PLAYER_SCORE::VT_FRAME, frame, 0);
  }
  void add_scores(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> scores) {
    fbb_.AddOffset(ACK_BT_SYNC_PLAYER_SCORE::VT_SCORES, scores);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SYNC_PLAYER_SCORE::VT_ERROR, error);
  }
  explicit ACK_BT_SYNC_PLAYER_SCOREBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SYNC_PLAYER_SCOREBuilder &operator=(const ACK_BT_SYNC_PLAYER_SCOREBuilder &);
  flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> CreateACK_BT_SYNC_PLAYER_SCORE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> scores = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SYNC_PLAYER_SCOREBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_scores(scores);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> CreateACK_BT_SYNC_PLAYER_SCOREDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *scores = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_PLAYER_SCORE(
      _fbb,
      frame,
      scores ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>(*scores) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> CreateACK_BT_SYNC_PLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ZONE_STATET : public flatbuffers::NativeTable {
  typedef ACK_BT_ZONE_STATE TableType;
  uint32_t frame;
  uint8_t zone;
  uint8_t event;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ZONE_STATET()
      : frame(0),
        zone(0),
        event(0) {
  }
};

struct ACK_BT_ZONE_STATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ZONE_STATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ZONE = 6,
    VT_EVENT = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint8_t zone() const {
    return GetField<uint8_t>(VT_ZONE, 0);
  }
  uint8_t event() const {
    return GetField<uint8_t>(VT_EVENT, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_ZONE) &&
           VerifyField<uint8_t>(verifier, VT_EVENT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ZONE_STATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ZONE_STATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ZONE_STATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_STATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ZONE_STATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ZONE_STATE::VT_FRAME, frame, 0);
  }
  void add_zone(uint8_t zone) {
    fbb_.AddElement<uint8_t>(ACK_BT_ZONE_STATE::VT_ZONE, zone, 0);
  }
  void add_event(uint8_t event) {
    fbb_.AddElement<uint8_t>(ACK_BT_ZONE_STATE::VT_EVENT, event, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ZONE_STATE::VT_ERROR, error);
  }
  explicit ACK_BT_ZONE_STATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ZONE_STATEBuilder &operator=(const ACK_BT_ZONE_STATEBuilder &);
  flatbuffers::Offset<ACK_BT_ZONE_STATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ZONE_STATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ZONE_STATE> CreateACK_BT_ZONE_STATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint8_t zone = 0,
    uint8_t event = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ZONE_STATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_event(event);
  builder_.add_zone(zone);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ZONE_STATE> CreateACK_BT_ZONE_STATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_STATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ZONE_EVENTT : public flatbuffers::NativeTable {
  typedef ACK_BT_ZONE_EVENT TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint8_t event;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ZONE_EVENTT()
      : frame(0),
        actorUK(0),
        event(0) {
  }
};

struct ACK_BT_ZONE_EVENT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ZONE_EVENTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_EVENT = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint8_t event() const {
    return GetField<uint8_t>(VT_EVENT, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint8_t>(verifier, VT_EVENT) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ZONE_EVENTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ZONE_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ZONE_EVENT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ZONE_EVENTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ZONE_EVENT::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ZONE_EVENT::VT_ACTORUK, actorUK, 0);
  }
  void add_event(uint8_t event) {
    fbb_.AddElement<uint8_t>(ACK_BT_ZONE_EVENT::VT_EVENT, event, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ZONE_EVENT::VT_ERROR, error);
  }
  explicit ACK_BT_ZONE_EVENTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ZONE_EVENTBuilder &operator=(const ACK_BT_ZONE_EVENTBuilder &);
  flatbuffers::Offset<ACK_BT_ZONE_EVENT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ZONE_EVENT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ZONE_EVENT> CreateACK_BT_ZONE_EVENT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint8_t event = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ZONE_EVENTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_actorUK(actorUK);
  builder_.add_event(event);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ZONE_EVENT> CreateACK_BT_ZONE_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DOOR_EVENTT : public flatbuffers::NativeTable {
  typedef ACK_BT_DOOR_EVENT TableType;
  uint32_t frame;
  uint8_t event;
  uint16_t doorId;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DOOR_EVENTT()
      : frame(0),
        event(0),
        doorId(0) {
  }
};

struct ACK_BT_DOOR_EVENT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DOOR_EVENTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_EVENT = 6,
    VT_DOORID = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint8_t event() const {
    return GetField<uint8_t>(VT_EVENT, 0);
  }
  uint16_t doorId() const {
    return GetField<uint16_t>(VT_DOORID, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint8_t>(verifier, VT_EVENT) &&
           VerifyField<uint16_t>(verifier, VT_DOORID) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DOOR_EVENTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DOOR_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DOOR_EVENT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DOOR_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DOOR_EVENTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DOOR_EVENT::VT_FRAME, frame, 0);
  }
  void add_event(uint8_t event) {
    fbb_.AddElement<uint8_t>(ACK_BT_DOOR_EVENT::VT_EVENT, event, 0);
  }
  void add_doorId(uint16_t doorId) {
    fbb_.AddElement<uint16_t>(ACK_BT_DOOR_EVENT::VT_DOORID, doorId, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DOOR_EVENT::VT_ERROR, error);
  }
  explicit ACK_BT_DOOR_EVENTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DOOR_EVENTBuilder &operator=(const ACK_BT_DOOR_EVENTBuilder &);
  flatbuffers::Offset<ACK_BT_DOOR_EVENT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DOOR_EVENT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DOOR_EVENT> CreateACK_BT_DOOR_EVENT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint8_t event = 0,
    uint16_t doorId = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DOOR_EVENTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_doorId(doorId);
  builder_.add_event(event);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_DOOR_EVENT> CreateACK_BT_DOOR_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DOOR_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_SYNC_TIME_REMAINT : public flatbuffers::NativeTable {
  typedef ACK_BT_SYNC_TIME_REMAIN TableType;
  uint32_t frame;
  uint16_t remainSec;
  bool notify;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_SYNC_TIME_REMAINT()
      : frame(0),
        remainSec(0),
        notify(false) {
  }
};

struct ACK_BT_SYNC_TIME_REMAIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_SYNC_TIME_REMAINT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_REMAINSEC = 6,
    VT_NOTIFY = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t remainSec() const {
    return GetField<uint16_t>(VT_REMAINSEC, 0);
  }
  bool notify() const {
    return GetField<uint8_t>(VT_NOTIFY, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_REMAINSEC) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFY) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_SYNC_TIME_REMAINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_SYNC_TIME_REMAINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_TIME_REMAINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_SYNC_TIME_REMAINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_SYNC_TIME_REMAIN::VT_FRAME, frame, 0);
  }
  void add_remainSec(uint16_t remainSec) {
    fbb_.AddElement<uint16_t>(ACK_BT_SYNC_TIME_REMAIN::VT_REMAINSEC, remainSec, 0);
  }
  void add_notify(bool notify) {
    fbb_.AddElement<uint8_t>(ACK_BT_SYNC_TIME_REMAIN::VT_NOTIFY, static_cast<uint8_t>(notify), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_SYNC_TIME_REMAIN::VT_ERROR, error);
  }
  explicit ACK_BT_SYNC_TIME_REMAINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_SYNC_TIME_REMAINBuilder &operator=(const ACK_BT_SYNC_TIME_REMAINBuilder &);
  flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> CreateACK_BT_SYNC_TIME_REMAIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t remainSec = 0,
    bool notify = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_SYNC_TIME_REMAINBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_remainSec(remainSec);
  builder_.add_notify(notify);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> CreateACK_BT_SYNC_TIME_REMAIN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_TIME_REMAINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_TELEPORTT : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_TELEPORT TableType;
  uint16_t actorUK;
  std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET> update;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_TELEPORTT()
      : actorUK(0) {
  }
};

struct ACK_BT_ACTOR_TELEPORT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_TELEPORTT NativeTableType;
  enum {
    VT_ACTORUK = 4,
    VT_UPDATE = 6,
    VT_ERROR = 8
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  const OVERLORD::RTS::STRUCT::ACTOR_UPDATE *update() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::ACTOR_UPDATE *>(VT_UPDATE);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyOffset(verifier, VT_UPDATE) &&
           verifier.VerifyTable(update()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_TELEPORTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_TELEPORTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_TELEPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_TELEPORTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_TELEPORT::VT_ACTORUK, actorUK, 0);
  }
  void add_update(flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE> update) {
    fbb_.AddOffset(ACK_BT_ACTOR_TELEPORT::VT_UPDATE, update);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_TELEPORT::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_TELEPORTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_TELEPORTBuilder &operator=(const ACK_BT_ACTOR_TELEPORTBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> CreateACK_BT_ACTOR_TELEPORT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE> update = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_TELEPORTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_update(update);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> CreateACK_BT_ACTOR_TELEPORT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_TELEPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_FORMATIONT : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_FORMATION TableType;
  uint16_t actorUK;
  ACK_BT_ACTOR_FORMATIONT()
      : actorUK(0) {
  }
};

struct ACK_BT_ACTOR_FORMATION FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_FORMATIONT NativeTableType;
  enum {
    VT_ACTORUK = 4
  };
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_FORMATIONT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_FORMATIONT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_FORMATIONT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_FORMATIONBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_FORMATION::VT_ACTORUK, actorUK, 0);
  }
  explicit ACK_BT_ACTOR_FORMATIONBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_FORMATIONBuilder &operator=(const ACK_BT_ACTOR_FORMATIONBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_FORMATION>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> CreateACK_BT_ACTOR_FORMATION(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t actorUK = 0) {
  ACK_BT_ACTOR_FORMATIONBuilder builder_(_fbb);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> CreateACK_BT_ACTOR_FORMATION(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_FORMATIONT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_ACTOR_MEDAL_UPDATET : public flatbuffers::NativeTable {
  typedef ACK_BT_ACTOR_MEDAL_UPDATE TableType;
  uint32_t frame;
  uint16_t actorUK;
  uint16_t actorMedal;
  std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET> actorScore;
  uint16_t victimUK;
  uint16_t victimMedal;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_ACTOR_MEDAL_UPDATET()
      : frame(0),
        actorUK(0),
        actorMedal(0),
        victimUK(0),
        victimMedal(0) {
  }
};

struct ACK_BT_ACTOR_MEDAL_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_ACTOR_MEDAL_UPDATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ACTORUK = 6,
    VT_ACTORMEDAL = 8,
    VT_ACTORSCORE = 10,
    VT_VICTIMUK = 12,
    VT_VICTIMMEDAL = 14,
    VT_ERROR = 16
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t actorMedal() const {
    return GetField<uint16_t>(VT_ACTORMEDAL, 0);
  }
  const OVERLORD::RTS::STRUCT::PLAYER_SCORE *actorScore() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::PLAYER_SCORE *>(VT_ACTORSCORE);
  }
  uint16_t victimUK() const {
    return GetField<uint16_t>(VT_VICTIMUK, 0);
  }
  uint16_t victimMedal() const {
    return GetField<uint16_t>(VT_VICTIMMEDAL, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_ACTORMEDAL) &&
           VerifyOffset(verifier, VT_ACTORSCORE) &&
           verifier.VerifyTable(actorScore()) &&
           VerifyField<uint16_t>(verifier, VT_VICTIMUK) &&
           VerifyField<uint16_t>(verifier, VT_VICTIMMEDAL) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_ACTOR_MEDAL_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_ACTOR_MEDAL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_MEDAL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_ACTOR_MEDAL_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_ACTOR_MEDAL_UPDATE::VT_FRAME, frame, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_MEDAL_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_actorMedal(uint16_t actorMedal) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_MEDAL_UPDATE::VT_ACTORMEDAL, actorMedal, 0);
  }
  void add_actorScore(flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE> actorScore) {
    fbb_.AddOffset(ACK_BT_ACTOR_MEDAL_UPDATE::VT_ACTORSCORE, actorScore);
  }
  void add_victimUK(uint16_t victimUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_MEDAL_UPDATE::VT_VICTIMUK, victimUK, 0);
  }
  void add_victimMedal(uint16_t victimMedal) {
    fbb_.AddElement<uint16_t>(ACK_BT_ACTOR_MEDAL_UPDATE::VT_VICTIMMEDAL, victimMedal, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_ACTOR_MEDAL_UPDATE::VT_ERROR, error);
  }
  explicit ACK_BT_ACTOR_MEDAL_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_ACTOR_MEDAL_UPDATEBuilder &operator=(const ACK_BT_ACTOR_MEDAL_UPDATEBuilder &);
  flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> CreateACK_BT_ACTOR_MEDAL_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t actorUK = 0,
    uint16_t actorMedal = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE> actorScore = 0,
    uint16_t victimUK = 0,
    uint16_t victimMedal = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_ACTOR_MEDAL_UPDATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_actorScore(actorScore);
  builder_.add_frame(frame);
  builder_.add_victimMedal(victimMedal);
  builder_.add_victimUK(victimUK);
  builder_.add_actorMedal(actorMedal);
  builder_.add_actorUK(actorUK);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> CreateACK_BT_ACTOR_MEDAL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_MEDAL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_TEAM_POINT_UPDATET : public flatbuffers::NativeTable {
  typedef ACK_BT_TEAM_POINT_UPDATE TableType;
  uint32_t frame;
  uint16_t team;
  uint32_t point;
  uint16_t pointDelta;
  uint16_t actorUK;
  uint16_t actorMedal;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>> rank;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_TEAM_POINT_UPDATET()
      : frame(0),
        team(0),
        point(0),
        pointDelta(0),
        actorUK(0),
        actorMedal(0) {
  }
};

struct ACK_BT_TEAM_POINT_UPDATE FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_TEAM_POINT_UPDATET NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_TEAM = 6,
    VT_POINT = 8,
    VT_POINTDELTA = 10,
    VT_ACTORUK = 12,
    VT_ACTORMEDAL = 14,
    VT_RANK = 16,
    VT_ERROR = 18
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t team() const {
    return GetField<uint16_t>(VT_TEAM, 0);
  }
  uint32_t point() const {
    return GetField<uint32_t>(VT_POINT, 0);
  }
  uint16_t pointDelta() const {
    return GetField<uint16_t>(VT_POINTDELTA, 0);
  }
  uint16_t actorUK() const {
    return GetField<uint16_t>(VT_ACTORUK, 0);
  }
  uint16_t actorMedal() const {
    return GetField<uint16_t>(VT_ACTORMEDAL, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *rank() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *>(VT_RANK);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_TEAM) &&
           VerifyField<uint32_t>(verifier, VT_POINT) &&
           VerifyField<uint16_t>(verifier, VT_POINTDELTA) &&
           VerifyField<uint16_t>(verifier, VT_ACTORUK) &&
           VerifyField<uint16_t>(verifier, VT_ACTORMEDAL) &&
           VerifyOffset(verifier, VT_RANK) &&
           verifier.Verify(rank()) &&
           verifier.VerifyVectorOfTables(rank()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_TEAM_POINT_UPDATET *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_TEAM_POINT_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_TEAM_POINT_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_TEAM_POINT_UPDATEBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_TEAM_POINT_UPDATE::VT_FRAME, frame, 0);
  }
  void add_team(uint16_t team) {
    fbb_.AddElement<uint16_t>(ACK_BT_TEAM_POINT_UPDATE::VT_TEAM, team, 0);
  }
  void add_point(uint32_t point) {
    fbb_.AddElement<uint32_t>(ACK_BT_TEAM_POINT_UPDATE::VT_POINT, point, 0);
  }
  void add_pointDelta(uint16_t pointDelta) {
    fbb_.AddElement<uint16_t>(ACK_BT_TEAM_POINT_UPDATE::VT_POINTDELTA, pointDelta, 0);
  }
  void add_actorUK(uint16_t actorUK) {
    fbb_.AddElement<uint16_t>(ACK_BT_TEAM_POINT_UPDATE::VT_ACTORUK, actorUK, 0);
  }
  void add_actorMedal(uint16_t actorMedal) {
    fbb_.AddElement<uint16_t>(ACK_BT_TEAM_POINT_UPDATE::VT_ACTORMEDAL, actorMedal, 0);
  }
  void add_rank(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> rank) {
    fbb_.AddOffset(ACK_BT_TEAM_POINT_UPDATE::VT_RANK, rank);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_TEAM_POINT_UPDATE::VT_ERROR, error);
  }
  explicit ACK_BT_TEAM_POINT_UPDATEBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_TEAM_POINT_UPDATEBuilder &operator=(const ACK_BT_TEAM_POINT_UPDATEBuilder &);
  flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> CreateACK_BT_TEAM_POINT_UPDATE(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t team = 0,
    uint32_t point = 0,
    uint16_t pointDelta = 0,
    uint16_t actorUK = 0,
    uint16_t actorMedal = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>> rank = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_TEAM_POINT_UPDATEBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_rank(rank);
  builder_.add_point(point);
  builder_.add_frame(frame);
  builder_.add_actorMedal(actorMedal);
  builder_.add_actorUK(actorUK);
  builder_.add_pointDelta(pointDelta);
  builder_.add_team(team);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> CreateACK_BT_TEAM_POINT_UPDATEDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t team = 0,
    uint32_t point = 0,
    uint16_t pointDelta = 0,
    uint16_t actorUK = 0,
    uint16_t actorMedal = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> *rank = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_TEAM_POINT_UPDATE(
      _fbb,
      frame,
      team,
      point,
      pointDelta,
      actorUK,
      actorMedal,
      rank ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>>(*rank) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> CreateACK_BT_TEAM_POINT_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_TEAM_POINT_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_COMMON_ERRORT : public flatbuffers::NativeTable {
  typedef ACK_COMMON_ERROR TableType;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_COMMON_ERRORT() {
  }
};

struct ACK_COMMON_ERROR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_COMMON_ERRORT NativeTableType;
  enum {
    VT_ERROR = 4
  };
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_COMMON_ERRORT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_COMMON_ERRORT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_COMMON_ERROR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COMMON_ERRORT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_COMMON_ERRORBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_COMMON_ERROR::VT_ERROR, error);
  }
  explicit ACK_COMMON_ERRORBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_COMMON_ERRORBuilder &operator=(const ACK_COMMON_ERRORBuilder &);
  flatbuffers::Offset<ACK_COMMON_ERROR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_COMMON_ERROR>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_COMMON_ERROR> CreateACK_COMMON_ERROR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_COMMON_ERRORBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_COMMON_ERROR> CreateACK_COMMON_ERROR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COMMON_ERRORT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_COST_UPDATE_AVATART : public flatbuffers::NativeTable {
  typedef ACK_COST_UPDATE_AVATAR TableType;
  std::string avatar;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_COST_UPDATE_AVATART() {
  }
};

struct ACK_COST_UPDATE_AVATAR FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_COST_UPDATE_AVATART NativeTableType;
  enum {
    VT_AVATAR = 4,
    VT_ERROR = 6
  };
  const flatbuffers::String *avatar() const {
    return GetPointer<const flatbuffers::String *>(VT_AVATAR);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AVATAR) &&
           verifier.Verify(avatar()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_COST_UPDATE_AVATART *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_COST_UPDATE_AVATART *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COST_UPDATE_AVATART* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_COST_UPDATE_AVATARBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_avatar(flatbuffers::Offset<flatbuffers::String> avatar) {
    fbb_.AddOffset(ACK_COST_UPDATE_AVATAR::VT_AVATAR, avatar);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_COST_UPDATE_AVATAR::VT_ERROR, error);
  }
  explicit ACK_COST_UPDATE_AVATARBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_COST_UPDATE_AVATARBuilder &operator=(const ACK_COST_UPDATE_AVATARBuilder &);
  flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_COST_UPDATE_AVATAR>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> CreateACK_COST_UPDATE_AVATAR(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> avatar = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_COST_UPDATE_AVATARBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_avatar(avatar);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> CreateACK_COST_UPDATE_AVATARDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *avatar = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_COST_UPDATE_AVATAR(
      _fbb,
      avatar ? _fbb.CreateString(avatar) : 0,
      error);
}

flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> CreateACK_COST_UPDATE_AVATAR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COST_UPDATE_AVATART *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_DISCONNECTEDT : public flatbuffers::NativeTable {
  typedef ACK_DISCONNECTED TableType;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_DISCONNECTEDT() {
  }
};

struct ACK_DISCONNECTED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_DISCONNECTEDT NativeTableType;
  enum {
    VT_ERROR = 4
  };
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_DISCONNECTEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_DISCONNECTEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_DISCONNECTED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DISCONNECTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_DISCONNECTEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_DISCONNECTED::VT_ERROR, error);
  }
  explicit ACK_DISCONNECTEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_DISCONNECTEDBuilder &operator=(const ACK_DISCONNECTEDBuilder &);
  flatbuffers::Offset<ACK_DISCONNECTED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_DISCONNECTED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_DISCONNECTED> CreateACK_DISCONNECTED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_DISCONNECTEDBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_DISCONNECTED> CreateACK_DISCONNECTED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DISCONNECTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_DECK_SCENE_LOADEDT : public flatbuffers::NativeTable {
  typedef ACK_DECK_SCENE_LOADED TableType;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_DECK_SCENE_LOADEDT() {
  }
};

////////////////////////////////////////////////////////////////////////
struct ACK_DECK_SCENE_LOADED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_DECK_SCENE_LOADEDT NativeTableType;
  enum {
    VT_ERROR = 4
  };
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_DECK_SCENE_LOADEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_DECK_SCENE_LOADEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_DECK_SCENE_LOADED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SCENE_LOADEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_DECK_SCENE_LOADEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_DECK_SCENE_LOADED::VT_ERROR, error);
  }
  explicit ACK_DECK_SCENE_LOADEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_DECK_SCENE_LOADEDBuilder &operator=(const ACK_DECK_SCENE_LOADEDBuilder &);
  flatbuffers::Offset<ACK_DECK_SCENE_LOADED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_DECK_SCENE_LOADED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_DECK_SCENE_LOADED> CreateACK_DECK_SCENE_LOADED(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_DECK_SCENE_LOADEDBuilder builder_(_fbb);
  builder_.add_error(error);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_DECK_SCENE_LOADED> CreateACK_DECK_SCENE_LOADED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SCENE_LOADEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CS_MATCHEDT : public flatbuffers::NativeTable {
  typedef ACK_CS_MATCHED TableType;
  int32_t modType;
  std::string modId;
  std::string roomkey;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::TEAMT>> teams;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>> players;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_CS_MATCHEDT()
      : modType(0) {
  }
};

struct ACK_CS_MATCHED FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CS_MATCHEDT NativeTableType;
  enum {
    VT_MODTYPE = 4,
    VT_MODID = 6,
    VT_ROOMKEY = 8,
    VT_TEAMS = 10,
    VT_PLAYERS = 12,
    VT_ERROR = 14
  };
  int32_t modType() const {
    return GetField<int32_t>(VT_MODTYPE, 0);
  }
  const flatbuffers::String *modId() const {
    return GetPointer<const flatbuffers::String *>(VT_MODID);
  }
  const flatbuffers::String *roomkey() const {
    return GetPointer<const flatbuffers::String *>(VT_ROOMKEY);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *teams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *>(VT_TEAMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *players() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *>(VT_PLAYERS);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MODTYPE) &&
           VerifyOffset(verifier, VT_MODID) &&
           verifier.Verify(modId()) &&
           VerifyOffset(verifier, VT_ROOMKEY) &&
           verifier.Verify(roomkey()) &&
           VerifyOffset(verifier, VT_TEAMS) &&
           verifier.Verify(teams()) &&
           verifier.VerifyVectorOfTables(teams()) &&
           VerifyOffset(verifier, VT_PLAYERS) &&
           verifier.Verify(players()) &&
           verifier.VerifyVectorOfTables(players()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_CS_MATCHEDT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CS_MATCHEDT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CS_MATCHED> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_MATCHEDT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CS_MATCHEDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modType(int32_t modType) {
    fbb_.AddElement<int32_t>(ACK_CS_MATCHED::VT_MODTYPE, modType, 0);
  }
  void add_modId(flatbuffers::Offset<flatbuffers::String> modId) {
    fbb_.AddOffset(ACK_CS_MATCHED::VT_MODID, modId);
  }
  void add_roomkey(flatbuffers::Offset<flatbuffers::String> roomkey) {
    fbb_.AddOffset(ACK_CS_MATCHED::VT_ROOMKEY, roomkey);
  }
  void add_teams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>> teams) {
    fbb_.AddOffset(ACK_CS_MATCHED::VT_TEAMS, teams);
  }
  void add_players(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>> players) {
    fbb_.AddOffset(ACK_CS_MATCHED::VT_PLAYERS, players);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_CS_MATCHED::VT_ERROR, error);
  }
  explicit ACK_CS_MATCHEDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CS_MATCHEDBuilder &operator=(const ACK_CS_MATCHEDBuilder &);
  flatbuffers::Offset<ACK_CS_MATCHED> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CS_MATCHED>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CS_MATCHED> CreateACK_CS_MATCHED(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    flatbuffers::Offset<flatbuffers::String> modId = 0,
    flatbuffers::Offset<flatbuffers::String> roomkey = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>> teams = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>> players = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_CS_MATCHEDBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_players(players);
  builder_.add_teams(teams);
  builder_.add_roomkey(roomkey);
  builder_.add_modId(modId);
  builder_.add_modType(modType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_CS_MATCHED> CreateACK_CS_MATCHEDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t modType = 0,
    const char *modId = nullptr,
    const char *roomkey = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> *teams = nullptr,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> *players = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_CS_MATCHED(
      _fbb,
      modType,
      modId ? _fbb.CreateString(modId) : 0,
      roomkey ? _fbb.CreateString(roomkey) : 0,
      teams ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>>(*teams) : 0,
      players ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>>(*players) : 0,
      error);
}

flatbuffers::Offset<ACK_CS_MATCHED> CreateACK_CS_MATCHED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_MATCHEDT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CS_DECK_SELECTT : public flatbuffers::NativeTable {
  typedef ACK_CS_DECK_SELECT TableType;
  int32_t kId;
  uint8_t crewNo;
  std::string heroUD;
  std::string heroId;
  int32_t level;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_CS_DECK_SELECTT()
      : kId(0),
        crewNo(0),
        level(1) {
  }
};

struct ACK_CS_DECK_SELECT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CS_DECK_SELECTT NativeTableType;
  enum {
    VT_KID = 4,
    VT_CREWNO = 6,
    VT_HEROUD = 8,
    VT_HEROID = 10,
    VT_LEVEL = 12,
    VT_ERROR = 14
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  uint8_t crewNo() const {
    return GetField<uint8_t>(VT_CREWNO, 0);
  }
  const flatbuffers::String *heroUD() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROUD);
  }
  const flatbuffers::String *heroId() const {
    return GetPointer<const flatbuffers::String *>(VT_HEROID);
  }
  int32_t level() const {
    return GetField<int32_t>(VT_LEVEL, 1);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint8_t>(verifier, VT_CREWNO) &&
           VerifyOffset(verifier, VT_HEROUD) &&
           verifier.Verify(heroUD()) &&
           VerifyOffset(verifier, VT_HEROID) &&
           verifier.Verify(heroId()) &&
           VerifyField<int32_t>(verifier, VT_LEVEL) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_CS_DECK_SELECTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CS_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CS_DECK_SELECT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CS_DECK_SELECTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ACK_CS_DECK_SELECT::VT_KID, kId, 0);
  }
  void add_crewNo(uint8_t crewNo) {
    fbb_.AddElement<uint8_t>(ACK_CS_DECK_SELECT::VT_CREWNO, crewNo, 0);
  }
  void add_heroUD(flatbuffers::Offset<flatbuffers::String> heroUD) {
    fbb_.AddOffset(ACK_CS_DECK_SELECT::VT_HEROUD, heroUD);
  }
  void add_heroId(flatbuffers::Offset<flatbuffers::String> heroId) {
    fbb_.AddOffset(ACK_CS_DECK_SELECT::VT_HEROID, heroId);
  }
  void add_level(int32_t level) {
    fbb_.AddElement<int32_t>(ACK_CS_DECK_SELECT::VT_LEVEL, level, 1);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_CS_DECK_SELECT::VT_ERROR, error);
  }
  explicit ACK_CS_DECK_SELECTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CS_DECK_SELECTBuilder &operator=(const ACK_CS_DECK_SELECTBuilder &);
  flatbuffers::Offset<ACK_CS_DECK_SELECT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CS_DECK_SELECT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CS_DECK_SELECT> CreateACK_CS_DECK_SELECT(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    uint8_t crewNo = 0,
    flatbuffers::Offset<flatbuffers::String> heroUD = 0,
    flatbuffers::Offset<flatbuffers::String> heroId = 0,
    int32_t level = 1,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_CS_DECK_SELECTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_level(level);
  builder_.add_heroId(heroId);
  builder_.add_heroUD(heroUD);
  builder_.add_kId(kId);
  builder_.add_crewNo(crewNo);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_CS_DECK_SELECT> CreateACK_CS_DECK_SELECTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    uint8_t crewNo = 0,
    const char *heroUD = nullptr,
    const char *heroId = nullptr,
    int32_t level = 1,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_CS_DECK_SELECT(
      _fbb,
      kId,
      crewNo,
      heroUD ? _fbb.CreateString(heroUD) : 0,
      heroId ? _fbb.CreateString(heroId) : 0,
      level,
      error);
}

flatbuffers::Offset<ACK_CS_DECK_SELECT> CreateACK_CS_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CS_DECK_TIME_REMAINT : public flatbuffers::NativeTable {
  typedef ACK_CS_DECK_TIME_REMAIN TableType;
  uint32_t frame;
  uint16_t remainSec;
  bool notify;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_CS_DECK_TIME_REMAINT()
      : frame(0),
        remainSec(0),
        notify(false) {
  }
};

struct ACK_CS_DECK_TIME_REMAIN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CS_DECK_TIME_REMAINT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_REMAINSEC = 6,
    VT_NOTIFY = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  uint16_t remainSec() const {
    return GetField<uint16_t>(VT_REMAINSEC, 0);
  }
  bool notify() const {
    return GetField<uint8_t>(VT_NOTIFY, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyField<uint16_t>(verifier, VT_REMAINSEC) &&
           VerifyField<uint8_t>(verifier, VT_NOTIFY) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_CS_DECK_TIME_REMAINT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CS_DECK_TIME_REMAINT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_TIME_REMAINT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CS_DECK_TIME_REMAINBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_CS_DECK_TIME_REMAIN::VT_FRAME, frame, 0);
  }
  void add_remainSec(uint16_t remainSec) {
    fbb_.AddElement<uint16_t>(ACK_CS_DECK_TIME_REMAIN::VT_REMAINSEC, remainSec, 0);
  }
  void add_notify(bool notify) {
    fbb_.AddElement<uint8_t>(ACK_CS_DECK_TIME_REMAIN::VT_NOTIFY, static_cast<uint8_t>(notify), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_CS_DECK_TIME_REMAIN::VT_ERROR, error);
  }
  explicit ACK_CS_DECK_TIME_REMAINBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CS_DECK_TIME_REMAINBuilder &operator=(const ACK_CS_DECK_TIME_REMAINBuilder &);
  flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> CreateACK_CS_DECK_TIME_REMAIN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    uint16_t remainSec = 0,
    bool notify = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_CS_DECK_TIME_REMAINBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_frame(frame);
  builder_.add_remainSec(remainSec);
  builder_.add_notify(notify);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> CreateACK_CS_DECK_TIME_REMAIN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_TIME_REMAINT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_CS_DECK_SELECT_READYT : public flatbuffers::NativeTable {
  typedef ACK_CS_DECK_SELECT_READY TableType;
  int32_t kId;
  bool ready;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_CS_DECK_SELECT_READYT()
      : kId(0),
        ready(false) {
  }
};

struct ACK_CS_DECK_SELECT_READY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_CS_DECK_SELECT_READYT NativeTableType;
  enum {
    VT_KID = 4,
    VT_READY = 6,
    VT_ERROR = 8
  };
  int32_t kId() const {
    return GetField<int32_t>(VT_KID, 0);
  }
  bool ready() const {
    return GetField<uint8_t>(VT_READY, 0) != 0;
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KID) &&
           VerifyField<uint8_t>(verifier, VT_READY) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_CS_DECK_SELECT_READYT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_CS_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_CS_DECK_SELECT_READYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kId(int32_t kId) {
    fbb_.AddElement<int32_t>(ACK_CS_DECK_SELECT_READY::VT_KID, kId, 0);
  }
  void add_ready(bool ready) {
    fbb_.AddElement<uint8_t>(ACK_CS_DECK_SELECT_READY::VT_READY, static_cast<uint8_t>(ready), 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_CS_DECK_SELECT_READY::VT_ERROR, error);
  }
  explicit ACK_CS_DECK_SELECT_READYBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_CS_DECK_SELECT_READYBuilder &operator=(const ACK_CS_DECK_SELECT_READYBuilder &);
  flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_CS_DECK_SELECT_READY>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> CreateACK_CS_DECK_SELECT_READY(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t kId = 0,
    bool ready = false,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_CS_DECK_SELECT_READYBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_kId(kId);
  builder_.add_ready(ready);
  return builder_.Finish();
}

flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> CreateACK_CS_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DICE_OPENT : public flatbuffers::NativeTable {
  typedef ACK_BT_DICE_OPEN TableType;
  uint32_t frame;
  std::string itemId;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DICE_OPENT()
      : frame(0) {
  }
};

struct ACK_BT_DICE_OPEN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DICE_OPENT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ITEMID = 6,
    VT_ERROR = 8
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DICE_OPENT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DICE_OPENT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DICE_OPEN> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DICE_OPENBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DICE_OPEN::VT_FRAME, frame, 0);
  }
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ACK_BT_DICE_OPEN::VT_ITEMID, itemId);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DICE_OPEN::VT_ERROR, error);
  }
  explicit ACK_BT_DICE_OPENBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DICE_OPENBuilder &operator=(const ACK_BT_DICE_OPENBuilder &);
  flatbuffers::Offset<ACK_BT_DICE_OPEN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DICE_OPEN>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DICE_OPEN> CreateACK_BT_DICE_OPEN(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DICE_OPENBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_itemId(itemId);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_DICE_OPEN> CreateACK_BT_DICE_OPENDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const char *itemId = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_OPEN(
      _fbb,
      frame,
      itemId ? _fbb.CreateString(itemId) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_DICE_OPEN> CreateACK_BT_DICE_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DICE_COUNTT : public flatbuffers::NativeTable {
  typedef ACK_BT_DICE_COUNT TableType;
  uint32_t frame;
  std::string itemId;
  uint16_t timeLeftSec;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DICE_COUNTT()
      : frame(0),
        timeLeftSec(0) {
  }
};

struct ACK_BT_DICE_COUNT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DICE_COUNTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ITEMID = 6,
    VT_TIMELEFTSEC = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  uint16_t timeLeftSec() const {
    return GetField<uint16_t>(VT_TIMELEFTSEC, 0);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyField<uint16_t>(verifier, VT_TIMELEFTSEC) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DICE_COUNTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DICE_COUNTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DICE_COUNT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_COUNTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DICE_COUNTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DICE_COUNT::VT_FRAME, frame, 0);
  }
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ACK_BT_DICE_COUNT::VT_ITEMID, itemId);
  }
  void add_timeLeftSec(uint16_t timeLeftSec) {
    fbb_.AddElement<uint16_t>(ACK_BT_DICE_COUNT::VT_TIMELEFTSEC, timeLeftSec, 0);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DICE_COUNT::VT_ERROR, error);
  }
  explicit ACK_BT_DICE_COUNTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DICE_COUNTBuilder &operator=(const ACK_BT_DICE_COUNTBuilder &);
  flatbuffers::Offset<ACK_BT_DICE_COUNT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DICE_COUNT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DICE_COUNT> CreateACK_BT_DICE_COUNT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    uint16_t timeLeftSec = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DICE_COUNTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_itemId(itemId);
  builder_.add_frame(frame);
  builder_.add_timeLeftSec(timeLeftSec);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_DICE_COUNT> CreateACK_BT_DICE_COUNTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const char *itemId = nullptr,
    uint16_t timeLeftSec = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_COUNT(
      _fbb,
      frame,
      itemId ? _fbb.CreateString(itemId) : 0,
      timeLeftSec,
      error);
}

flatbuffers::Offset<ACK_BT_DICE_COUNT> CreateACK_BT_DICE_COUNT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_COUNTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DICE_NUMT : public flatbuffers::NativeTable {
  typedef ACK_BT_DICE_NUM TableType;
  uint32_t frame;
  std::string itemId;
  std::unique_ptr<OVERLORD::RTS::STRUCT::DICET> dice;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DICE_NUMT()
      : frame(0) {
  }
};

struct ACK_BT_DICE_NUM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DICE_NUMT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ITEMID = 6,
    VT_DICE = 8,
    VT_ERROR = 10
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  const OVERLORD::RTS::STRUCT::DICE *dice() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::DICE *>(VT_DICE);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyOffset(verifier, VT_DICE) &&
           verifier.VerifyTable(dice()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DICE_NUMT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DICE_NUMT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DICE_NUM> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_NUMT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DICE_NUMBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DICE_NUM::VT_FRAME, frame, 0);
  }
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ACK_BT_DICE_NUM::VT_ITEMID, itemId);
  }
  void add_dice(flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE> dice) {
    fbb_.AddOffset(ACK_BT_DICE_NUM::VT_DICE, dice);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DICE_NUM::VT_ERROR, error);
  }
  explicit ACK_BT_DICE_NUMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DICE_NUMBuilder &operator=(const ACK_BT_DICE_NUMBuilder &);
  flatbuffers::Offset<ACK_BT_DICE_NUM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DICE_NUM>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DICE_NUM> CreateACK_BT_DICE_NUM(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE> dice = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DICE_NUMBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_dice(dice);
  builder_.add_itemId(itemId);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_DICE_NUM> CreateACK_BT_DICE_NUMDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const char *itemId = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE> dice = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_NUM(
      _fbb,
      frame,
      itemId ? _fbb.CreateString(itemId) : 0,
      dice,
      error);
}

flatbuffers::Offset<ACK_BT_DICE_NUM> CreateACK_BT_DICE_NUM(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_NUMT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ACK_BT_DICE_RESULTT : public flatbuffers::NativeTable {
  typedef ACK_BT_DICE_RESULT TableType;
  uint32_t frame;
  std::string itemId;
  int32_t winner;
  std::vector<std::unique_ptr<OVERLORD::RTS::STRUCT::DICET>> dices;
  std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT> error;
  ACK_BT_DICE_RESULTT()
      : frame(0),
        winner(0) {
  }
};

struct ACK_BT_DICE_RESULT FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ACK_BT_DICE_RESULTT NativeTableType;
  enum {
    VT_FRAME = 4,
    VT_ITEMID = 6,
    VT_WINNER = 8,
    VT_DICES = 10,
    VT_ERROR = 12
  };
  uint32_t frame() const {
    return GetField<uint32_t>(VT_FRAME, 0);
  }
  const flatbuffers::String *itemId() const {
    return GetPointer<const flatbuffers::String *>(VT_ITEMID);
  }
  int32_t winner() const {
    return GetField<int32_t>(VT_WINNER, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>> *dices() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>> *>(VT_DICES);
  }
  const OVERLORD::RTS::STRUCT::RTS_ERROR *error() const {
    return GetPointer<const OVERLORD::RTS::STRUCT::RTS_ERROR *>(VT_ERROR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FRAME) &&
           VerifyOffset(verifier, VT_ITEMID) &&
           verifier.Verify(itemId()) &&
           VerifyField<int32_t>(verifier, VT_WINNER) &&
           VerifyOffset(verifier, VT_DICES) &&
           verifier.Verify(dices()) &&
           verifier.VerifyVectorOfTables(dices()) &&
           VerifyOffset(verifier, VT_ERROR) &&
           verifier.VerifyTable(error()) &&
           verifier.EndTable();
  }
  ACK_BT_DICE_RESULTT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ACK_BT_DICE_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ACK_BT_DICE_RESULT> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ACK_BT_DICE_RESULTBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(uint32_t frame) {
    fbb_.AddElement<uint32_t>(ACK_BT_DICE_RESULT::VT_FRAME, frame, 0);
  }
  void add_itemId(flatbuffers::Offset<flatbuffers::String> itemId) {
    fbb_.AddOffset(ACK_BT_DICE_RESULT::VT_ITEMID, itemId);
  }
  void add_winner(int32_t winner) {
    fbb_.AddElement<int32_t>(ACK_BT_DICE_RESULT::VT_WINNER, winner, 0);
  }
  void add_dices(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>>> dices) {
    fbb_.AddOffset(ACK_BT_DICE_RESULT::VT_DICES, dices);
  }
  void add_error(flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error) {
    fbb_.AddOffset(ACK_BT_DICE_RESULT::VT_ERROR, error);
  }
  explicit ACK_BT_DICE_RESULTBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ACK_BT_DICE_RESULTBuilder &operator=(const ACK_BT_DICE_RESULTBuilder &);
  flatbuffers::Offset<ACK_BT_DICE_RESULT> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ACK_BT_DICE_RESULT>(end);
    return o;
  }
};

inline flatbuffers::Offset<ACK_BT_DICE_RESULT> CreateACK_BT_DICE_RESULT(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    flatbuffers::Offset<flatbuffers::String> itemId = 0,
    int32_t winner = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>>> dices = 0,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  ACK_BT_DICE_RESULTBuilder builder_(_fbb);
  builder_.add_error(error);
  builder_.add_dices(dices);
  builder_.add_winner(winner);
  builder_.add_itemId(itemId);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<ACK_BT_DICE_RESULT> CreateACK_BT_DICE_RESULTDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t frame = 0,
    const char *itemId = nullptr,
    int32_t winner = 0,
    const std::vector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>> *dices = nullptr,
    flatbuffers::Offset<OVERLORD::RTS::STRUCT::RTS_ERROR> error = 0) {
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_RESULT(
      _fbb,
      frame,
      itemId ? _fbb.CreateString(itemId) : 0,
      winner,
      dices ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>>(*dices) : 0,
      error);
}

flatbuffers::Offset<ACK_BT_DICE_RESULT> CreateACK_BT_DICE_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ACK_AUTHT *ACK_AUTH::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_AUTHT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_AUTH::UnPackTo(ACK_AUTHT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_AUTH> ACK_AUTH::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_AUTHT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_AUTH(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_AUTH> CreateACK_AUTH(flatbuffers::FlatBufferBuilder &_fbb, const ACK_AUTHT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_AUTHT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_AUTH(
      _fbb,
      _player,
      _error);
}

inline CHAT_SUBSCRIBEDT *CHAT_SUBSCRIBED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_SUBSCRIBEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_SUBSCRIBED::UnPackTo(CHAT_SUBSCRIBEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHAT_SUBSCRIBED> CHAT_SUBSCRIBED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_SUBSCRIBED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_SUBSCRIBED> CreateCHAT_SUBSCRIBED(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_SUBSCRIBEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_SUBSCRIBEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateCHAT_SUBSCRIBED(
      _fbb,
      _channel,
      _error);
}

inline CHAT_UNSUBSCRIBEDT *CHAT_UNSUBSCRIBED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_UNSUBSCRIBEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_UNSUBSCRIBED::UnPackTo(CHAT_UNSUBSCRIBEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHAT_UNSUBSCRIBED> CHAT_UNSUBSCRIBED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_UNSUBSCRIBEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_UNSUBSCRIBED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_UNSUBSCRIBED> CreateCHAT_UNSUBSCRIBED(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_UNSUBSCRIBEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_UNSUBSCRIBEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateCHAT_UNSUBSCRIBED(
      _fbb,
      _channel,
      _error);
}

inline CHAT_CHANNEL_ENTERT *CHAT_CHANNEL_ENTER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_CHANNEL_ENTERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_CHANNEL_ENTER::UnPackTo(CHAT_CHANNEL_ENTERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHAT_CHANNEL_ENTER> CHAT_CHANNEL_ENTER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_ENTERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_CHANNEL_ENTER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_CHANNEL_ENTER> CreateCHAT_CHANNEL_ENTER(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_ENTERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_CHANNEL_ENTERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateCHAT_CHANNEL_ENTER(
      _fbb,
      _kId,
      _nick,
      _channel,
      _error);
}

inline CHAT_CHANNEL_EXITT *CHAT_CHANNEL_EXIT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_CHANNEL_EXITT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_CHANNEL_EXIT::UnPackTo(CHAT_CHANNEL_EXITT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHAT_CHANNEL_EXIT> CHAT_CHANNEL_EXIT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_CHANNEL_EXIT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_CHANNEL_EXIT> CreateCHAT_CHANNEL_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_CHANNEL_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_CHANNEL_EXITT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateCHAT_CHANNEL_EXIT(
      _fbb,
      _kId,
      _nick,
      _channel,
      _error);
}

inline CHAT_MESSAGET *CHAT_MESSAGE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new CHAT_MESSAGET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void CHAT_MESSAGE::UnPackTo(CHAT_MESSAGET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = channel(); if (_e) _o->channel = _e->str(); };
  { auto _e = chattype(); _o->chattype = _e; };
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = nick(); if (_e) _o->nick = _e->str(); };
  { auto _e = message(); if (_e) _o->message = _e->str(); };
  { auto _e = data(); if (_e) _o->data = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<CHAT_MESSAGE> CHAT_MESSAGE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCHAT_MESSAGE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CHAT_MESSAGE> CreateCHAT_MESSAGE(flatbuffers::FlatBufferBuilder &_fbb, const CHAT_MESSAGET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CHAT_MESSAGET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _channel = _o->channel.empty() ? 0 : _fbb.CreateString(_o->channel);
  auto _chattype = _o->chattype;
  auto _kId = _o->kId;
  auto _nick = _o->nick.empty() ? 0 : _fbb.CreateString(_o->nick);
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateCHAT_MESSAGE(
      _fbb,
      _channel,
      _chattype,
      _kId,
      _nick,
      _message,
      _data,
      _error);
}

inline ACK_MATCHEDT *ACK_MATCHED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_MATCHEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_MATCHED::UnPackTo(ACK_MATCHEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modType(); _o->modType = _e; };
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = partyNo(); _o->partyNo = _e; };
  { auto _e = bPublic(); _o->bPublic = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_MATCHED> ACK_MATCHED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCHEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_MATCHED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_MATCHED> CreateACK_MATCHED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCHEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_MATCHEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modType = _o->modType;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _partyNo = _o->partyNo;
  auto _bPublic = _o->bPublic;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_MATCHED(
      _fbb,
      _modType,
      _modId,
      _partyNo,
      _bPublic,
      _error);
}

inline ACK_PARTY_UPDATE_PUBLICT *ACK_PARTY_UPDATE_PUBLIC::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PARTY_UPDATE_PUBLICT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PARTY_UPDATE_PUBLIC::UnPackTo(ACK_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = partyNo(); _o->partyNo = _e; };
  { auto _e = bPublic(); _o->bPublic = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> ACK_PARTY_UPDATE_PUBLIC::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_UPDATE_PUBLICT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PARTY_UPDATE_PUBLIC(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PARTY_UPDATE_PUBLIC> CreateACK_PARTY_UPDATE_PUBLIC(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_UPDATE_PUBLICT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PARTY_UPDATE_PUBLICT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _partyNo = _o->partyNo;
  auto _bPublic = _o->bPublic;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PARTY_UPDATE_PUBLIC(
      _fbb,
      _partyNo,
      _bPublic,
      _error);
}

inline ACK_PARTY_LEADER_SLOTT *ACK_PARTY_LEADER_SLOT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PARTY_LEADER_SLOTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PARTY_LEADER_SLOT::UnPackTo(ACK_PARTY_LEADER_SLOTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = leader(); _o->leader = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> ACK_PARTY_LEADER_SLOT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_LEADER_SLOTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PARTY_LEADER_SLOT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PARTY_LEADER_SLOT> CreateACK_PARTY_LEADER_SLOT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_LEADER_SLOTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PARTY_LEADER_SLOTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _leader = _o->leader;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PARTY_LEADER_SLOT(
      _fbb,
      _slot,
      _leader,
      _error);
}

inline ACK_PARTY_PLAYERT *ACK_PARTY_PLAYER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PARTY_PLAYERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PARTY_PLAYER::UnPackTo(ACK_PARTY_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PARTY_PLAYER> ACK_PARTY_PLAYER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PARTY_PLAYER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PARTY_PLAYER> CreateACK_PARTY_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PARTY_PLAYERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PARTY_PLAYER(
      _fbb,
      _slot,
      _player,
      _error);
}

inline ACK_PARTY_PLAYER_EXITT *ACK_PARTY_PLAYER_EXIT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PARTY_PLAYER_EXITT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PARTY_PLAYER_EXIT::UnPackTo(ACK_PARTY_PLAYER_EXITT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> ACK_PARTY_PLAYER_EXIT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYER_EXITT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PARTY_PLAYER_EXIT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PARTY_PLAYER_EXIT> CreateACK_PARTY_PLAYER_EXIT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_PLAYER_EXITT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PARTY_PLAYER_EXITT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PARTY_PLAYER_EXIT(
      _fbb,
      _slot,
      _error);
}

inline ACK_DECK_CACHED_DONET *ACK_DECK_CACHED_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_DECK_CACHED_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_DECK_CACHED_DONE::UnPackTo(ACK_DECK_CACHED_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deck(); if (_e) { _o->deck.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->deck[_i] = std::unique_ptr<ACK_DECK_SELECTT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_DECK_CACHED_DONE> ACK_DECK_CACHED_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_CACHED_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_DECK_CACHED_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_DECK_CACHED_DONE> CreateACK_DECK_CACHED_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_CACHED_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_DECK_CACHED_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deck = _o->deck.size() ? _fbb.CreateVector<flatbuffers::Offset<ACK_DECK_SELECT>> (_o->deck.size(), [](size_t i, _VectorArgs *__va) { return CreateACK_DECK_SELECT(*__va->__fbb, __va->__o->deck[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_DECK_CACHED_DONE(
      _fbb,
      _deck,
      _error);
}

inline ACK_DECK_SELECTT *ACK_DECK_SELECT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_DECK_SELECTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_DECK_SELECT::UnPackTo(ACK_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = crewNo(); _o->crewNo = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_DECK_SELECT> ACK_DECK_SELECT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_DECK_SELECT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_DECK_SELECT> CreateACK_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_DECK_SELECTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _crewNo = _o->crewNo;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_DECK_SELECT(
      _fbb,
      _slot,
      _crewNo,
      _heroUD,
      _heroId,
      _level,
      _error);
}

inline ACK_DECK_SELECT_READYT *ACK_DECK_SELECT_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_DECK_SELECT_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_DECK_SELECT_READY::UnPackTo(ACK_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = ready(); _o->ready = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_DECK_SELECT_READY> ACK_DECK_SELECT_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_DECK_SELECT_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_DECK_SELECT_READY> CreateACK_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_DECK_SELECT_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _slot = _o->slot;
  auto _ready = _o->ready;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_DECK_SELECT_READY(
      _fbb,
      _slot,
      _ready,
      _error);
}

inline ACK_PARTY_GOT *ACK_PARTY_GO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PARTY_GOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PARTY_GO::UnPackTo(ACK_PARTY_GOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = partyNo(); _o->partyNo = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PARTY_GO> ACK_PARTY_GO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PARTY_GO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PARTY_GO> CreateACK_PARTY_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PARTY_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PARTY_GOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _partyNo = _o->partyNo;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PARTY_GO(
      _fbb,
      _partyNo,
      _error);
}

inline ACK_PLAY_READYT *ACK_PLAY_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PLAY_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PLAY_READY::UnPackTo(ACK_PLAY_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PLAY_READY> ACK_PLAY_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PLAY_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PLAY_READY> CreateACK_PLAY_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PLAY_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PLAY_READY(
      _fbb,
      _error);
}

inline ACK_MATCH_ROUNDT *ACK_MATCH_ROUND::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_MATCH_ROUNDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_MATCH_ROUND::UnPackTo(ACK_MATCH_ROUNDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modType(); _o->modType = _e; };
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
  { auto _e = teams(); if (_e) { _o->teams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->teams[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::TEAMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = players(); if (_e) { _o->players.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->players[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = actors(); if (_e) { _o->actors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actors[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_MATCH_ROUND> ACK_MATCH_ROUND::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCH_ROUNDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_MATCH_ROUND(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_MATCH_ROUND> CreateACK_MATCH_ROUND(flatbuffers::FlatBufferBuilder &_fbb, const ACK_MATCH_ROUNDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_MATCH_ROUNDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modType = _o->modType;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  auto _teams = _o->teams.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> (_o->teams.size(), [](size_t i, _VectorArgs *__va) { return CreateTEAM(*__va->__fbb, __va->__o->teams[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _players = _o->players.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> (_o->players.size(), [](size_t i, _VectorArgs *__va) { return CreatePLAYER(*__va->__fbb, __va->__o->players[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _actors = _o->actors.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> (_o->actors.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR(*__va->__fbb, __va->__o->actors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_MATCH_ROUND(
      _fbb,
      _modType,
      _modId,
      _roomkey,
      _teams,
      _players,
      _actors,
      _error);
}

inline REQ_CINEMATIC_PLAYT *REQ_CINEMATIC_PLAY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_CINEMATIC_PLAYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_CINEMATIC_PLAY::UnPackTo(REQ_CINEMATIC_PLAYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_CINEMATIC_PLAY> REQ_CINEMATIC_PLAY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CINEMATIC_PLAYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_CINEMATIC_PLAY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_CINEMATIC_PLAY> CreateREQ_CINEMATIC_PLAY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_CINEMATIC_PLAYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_CINEMATIC_PLAYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateREQ_CINEMATIC_PLAY(
      _fbb,
      _sequence,
      _error);
}

inline ACK_CINEMATIC_DONET *ACK_CINEMATIC_DONE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CINEMATIC_DONET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CINEMATIC_DONE::UnPackTo(ACK_CINEMATIC_DONET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> ACK_CINEMATIC_DONE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CINEMATIC_DONE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CINEMATIC_DONE> CreateACK_CINEMATIC_DONE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CINEMATIC_DONET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CINEMATIC_DONET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_CINEMATIC_DONE(
      _fbb,
      _sequence,
      _error);
}

inline REQ_STEP_READYT *REQ_STEP_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new REQ_STEP_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void REQ_STEP_READY::UnPackTo(REQ_STEP_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<REQ_STEP_READY> REQ_STEP_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const REQ_STEP_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateREQ_STEP_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<REQ_STEP_READY> CreateREQ_STEP_READY(flatbuffers::FlatBufferBuilder &_fbb, const REQ_STEP_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const REQ_STEP_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateREQ_STEP_READY(
      _fbb,
      _sequence,
      _error);
}

inline ACK_STEP_GOT *ACK_STEP_GO::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_STEP_GOT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_STEP_GO::UnPackTo(ACK_STEP_GOT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_STEP_GO> ACK_STEP_GO::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_GOT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_STEP_GO(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_STEP_GO> CreateACK_STEP_GO(flatbuffers::FlatBufferBuilder &_fbb, const ACK_STEP_GOT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_STEP_GOT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_STEP_GO(
      _fbb,
      _sequence,
      _error);
}

inline ACK_PLAY_COUNTT *ACK_PLAY_COUNT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PLAY_COUNTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PLAY_COUNT::UnPackTo(ACK_PLAY_COUNTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = count(); _o->count = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PLAY_COUNT> ACK_PLAY_COUNT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_COUNTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PLAY_COUNT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PLAY_COUNT> CreateACK_PLAY_COUNT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_COUNTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PLAY_COUNTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _count = _o->count;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PLAY_COUNT(
      _fbb,
      _count,
      _error);
}

inline ACK_PLAY_STARTT *ACK_PLAY_START::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PLAY_STARTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PLAY_START::UnPackTo(ACK_PLAY_STARTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PLAY_START> ACK_PLAY_START::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_STARTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PLAY_START(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PLAY_START> CreateACK_PLAY_START(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_STARTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PLAY_STARTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PLAY_START(
      _fbb,
      _frame,
      _error);
}

inline ACK_PLAY_TIMEOUTT *ACK_PLAY_TIMEOUT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PLAY_TIMEOUTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PLAY_TIMEOUT::UnPackTo(ACK_PLAY_TIMEOUTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PLAY_TIMEOUT> ACK_PLAY_TIMEOUT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_TIMEOUTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PLAY_TIMEOUT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PLAY_TIMEOUT> CreateACK_PLAY_TIMEOUT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_TIMEOUTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PLAY_TIMEOUTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PLAY_TIMEOUT(
      _fbb,
      _frame,
      _error);
}

inline ACK_PLAY_SEND_RESULTT *ACK_PLAY_SEND_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_PLAY_SEND_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_PLAY_SEND_RESULT::UnPackTo(ACK_PLAY_SEND_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = result(); _o->result = _e; };
  { auto _e = json(); if (_e) _o->json = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_PLAY_SEND_RESULT> ACK_PLAY_SEND_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_SEND_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_PLAY_SEND_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_PLAY_SEND_RESULT> CreateACK_PLAY_SEND_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_PLAY_SEND_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_PLAY_SEND_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _result = _o->result;
  auto _json = _o->json.empty() ? 0 : _fbb.CreateString(_o->json);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_PLAY_SEND_RESULT(
      _fbb,
      _result,
      _json,
      _error);
}

inline ACK_BT_NEW_PLAYERT *ACK_BT_NEW_PLAYER::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_NEW_PLAYERT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_NEW_PLAYER::UnPackTo(ACK_BT_NEW_PLAYERT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = player(); if (_e) _o->player = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_NEW_PLAYER> ACK_BT_NEW_PLAYER::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_NEW_PLAYERT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_NEW_PLAYER(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_NEW_PLAYER> CreateACK_BT_NEW_PLAYER(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_NEW_PLAYERT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_NEW_PLAYERT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _player = _o->player ? CreatePLAYER(_fbb, _o->player.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_NEW_PLAYER(
      _fbb,
      _frame,
      _player,
      _error);
}

inline ACK_BT_ACTOR_CREATET *ACK_BT_ACTOR_CREATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_CREATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_CREATE::UnPackTo(ACK_BT_ACTOR_CREATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actors(); if (_e) { _o->actors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->actors[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_CREATE> ACK_BT_ACTOR_CREATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_CREATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_CREATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_CREATE> CreateACK_BT_ACTOR_CREATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_CREATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_CREATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actors = _o->actors.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR>> (_o->actors.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR(*__va->__fbb, __va->__o->actors[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_CREATE(
      _fbb,
      _frame,
      _actors,
      _error);
}

inline ACK_BT_ACTOR_SPAWNT *ACK_BT_ACTOR_SPAWN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_SPAWNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_SPAWN::UnPackTo(ACK_BT_ACTOR_SPAWNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = updates(); if (_e) { _o->updates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->updates[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> ACK_BT_ACTOR_SPAWN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_SPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_SPAWN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_SPAWN> CreateACK_BT_ACTOR_SPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_SPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_SPAWNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _updates = _o->updates.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> (_o->updates.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_UPDATE(*__va->__fbb, __va->__o->updates[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_SPAWN(
      _fbb,
      _frame,
      _updates,
      _error);
}

inline ACK_BT_ACTOR_DESPAWNT *ACK_BT_ACTOR_DESPAWN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_DESPAWNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_DESPAWN::UnPackTo(ACK_BT_ACTOR_DESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> ACK_BT_ACTOR_DESPAWN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_DESPAWN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_DESPAWN> CreateACK_BT_ACTOR_DESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_DESPAWNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_DESPAWN(
      _fbb,
      _frame,
      _actorUK,
      _error);
}

inline ACK_BT_ACTOR_RESPAWNT *ACK_BT_ACTOR_RESPAWN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_RESPAWNT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_RESPAWN::UnPackTo(ACK_BT_ACTOR_RESPAWNT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actor(); if (_e) _o->actor = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTORT>(_e->UnPack(_resolver)); };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> ACK_BT_ACTOR_RESPAWN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_RESPAWNT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_RESPAWN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_RESPAWN> CreateACK_BT_ACTOR_RESPAWN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_RESPAWNT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_RESPAWNT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _actor = _o->actor ? CreateACTOR(_fbb, _o->actor.get(), _rehasher) : 0;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_RESPAWN(
      _fbb,
      _frame,
      _actorUK,
      _actor,
      _location,
      _direction,
      _error);
}

inline ACK_BT_DROP_CREWT *ACK_BT_DROP_CREW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DROP_CREWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DROP_CREW::UnPackTo(ACK_BT_DROP_CREWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = location(); if (_e) _o->location = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = direction(); if (_e) _o->direction = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DROP_CREW> ACK_BT_DROP_CREW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DROP_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DROP_CREW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DROP_CREW> CreateACK_BT_DROP_CREW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DROP_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DROP_CREWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _location = _o->location ? CreateRTS_VECTOR(_fbb, _o->location.get(), _rehasher) : 0;
  auto _direction = _o->direction ? CreateRTS_VECTOR(_fbb, _o->direction.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DROP_CREW(
      _fbb,
      _frame,
      _actorUK,
      _location,
      _direction,
      _error);
}

inline ACK_BT_CHANGE_CREWT *ACK_BT_CHANGE_CREW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_CHANGE_CREWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_CHANGE_CREW::UnPackTo(ACK_BT_CHANGE_CREWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = updates(); if (_e) { _o->updates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->updates[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_CHANGE_CREW> ACK_BT_CHANGE_CREW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_CREWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_CHANGE_CREW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_CHANGE_CREW> CreateACK_BT_CHANGE_CREW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_CREWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_CHANGE_CREWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _targetUK = _o->targetUK;
  auto _updates = _o->updates.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> (_o->updates.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_UPDATE(*__va->__fbb, __va->__o->updates[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_CHANGE_CREW(
      _fbb,
      _frame,
      _actorUK,
      _targetUK,
      _updates,
      _error);
}

inline ACK_BT_CHANGE_SPIRITT *ACK_BT_CHANGE_SPIRIT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_CHANGE_SPIRITT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_CHANGE_SPIRIT::UnPackTo(ACK_BT_CHANGE_SPIRITT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slotOff(); _o->slotOff = _e; };
  { auto _e = slotOn(); _o->slotOn = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> ACK_BT_CHANGE_SPIRIT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_SPIRITT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_CHANGE_SPIRIT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_CHANGE_SPIRIT> CreateACK_BT_CHANGE_SPIRIT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_CHANGE_SPIRITT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_CHANGE_SPIRITT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _slotOff = _o->slotOff;
  auto _slotOn = _o->slotOn;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_CHANGE_SPIRIT(
      _fbb,
      _frame,
      _actorUK,
      _slotOff,
      _slotOn,
      _error);
}

inline ACK_BT_ACTOR_DISAPPEART *ACK_BT_ACTOR_DISAPPEAR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_DISAPPEART();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_DISAPPEAR::UnPackTo(ACK_BT_ACTOR_DISAPPEART *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = killerUK(); _o->killerUK = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> ACK_BT_ACTOR_DISAPPEAR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DISAPPEART* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_DISAPPEAR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_DISAPPEAR> CreateACK_BT_ACTOR_DISAPPEAR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_DISAPPEART *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_DISAPPEART* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _killerUK = _o->killerUK;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_DISAPPEAR(
      _fbb,
      _frame,
      _actorUK,
      _killerUK,
      _error);
}

inline ACK_BT_SYNC_ACTOR_UPDATET *ACK_BT_SYNC_ACTOR_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SYNC_ACTOR_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SYNC_ACTOR_UPDATE::UnPackTo(ACK_BT_SYNC_ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = force(); _o->force = _e; };
  { auto _e = updates(); if (_e) { _o->updates.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->updates[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> ACK_BT_SYNC_ACTOR_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SYNC_ACTOR_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_UPDATE> CreateACK_BT_SYNC_ACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SYNC_ACTOR_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _force = _o->force;
  auto _updates = _o->updates.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_UPDATE>> (_o->updates.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_UPDATE(*__va->__fbb, __va->__o->updates[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_ACTOR_UPDATE(
      _fbb,
      _frame,
      _force,
      _updates,
      _error);
}

inline ACK_BT_ACTOR_UPDATET *ACK_BT_ACTOR_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_UPDATE::UnPackTo(ACK_BT_ACTOR_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = force(); _o->force = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> ACK_BT_ACTOR_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_UPDATE> CreateACK_BT_ACTOR_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _force = _o->force;
  auto _update = _o->update ? CreateACTOR_UPDATE(_fbb, _o->update.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_UPDATE(
      _fbb,
      _frame,
      _force,
      _update,
      _error);
}

inline ACK_BT_ATTACK_NOWT *ACK_BT_ATTACK_NOW::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ATTACK_NOWT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ATTACK_NOW::UnPackTo(ACK_BT_ATTACK_NOWT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorLocation(); if (_e) _o->actorLocation = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_VECTORT>(_e->UnPack(_resolver)); };
  { auto _e = targetUK(); _o->targetUK = _e; };
  { auto _e = bAttack(); _o->bAttack = _e; };
  { auto _e = sequence(); _o->sequence = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ATTACK_NOW> ACK_BT_ATTACK_NOW::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NOWT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ATTACK_NOW(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ATTACK_NOW> CreateACK_BT_ATTACK_NOW(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NOWT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ATTACK_NOWT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _actorLocation = _o->actorLocation ? CreateRTS_VECTOR(_fbb, _o->actorLocation.get(), _rehasher) : 0;
  auto _targetUK = _o->targetUK;
  auto _bAttack = _o->bAttack;
  auto _sequence = _o->sequence;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ATTACK_NOW(
      _fbb,
      _frame,
      _actorUK,
      _actorLocation,
      _targetUK,
      _bAttack,
      _sequence,
      _error);
}

inline ACK_BT_ATTACK_NORMALT *ACK_BT_ATTACK_NORMAL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ATTACK_NORMALT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ATTACK_NORMAL::UnPackTo(ACK_BT_ATTACK_NORMALT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = targetUpdate(); if (_e) _o->targetUpdate = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_HIT_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> ACK_BT_ATTACK_NORMAL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NORMALT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ATTACK_NORMAL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ATTACK_NORMAL> CreateACK_BT_ATTACK_NORMAL(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ATTACK_NORMALT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ATTACK_NORMALT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _targetUpdate = _o->targetUpdate ? CreateACTOR_HIT_UPDATE(_fbb, _o->targetUpdate.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ATTACK_NORMAL(
      _fbb,
      _frame,
      _actorUK,
      _targetUpdate,
      _error);
}

inline ACK_BT_SKILL_ACTIVATEDT *ACK_BT_SKILL_ACTIVATED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SKILL_ACTIVATEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SKILL_ACTIVATED::UnPackTo(ACK_BT_SKILL_ACTIVATEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> ACK_BT_SKILL_ACTIVATED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_ACTIVATEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SKILL_ACTIVATED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SKILL_ACTIVATED> CreateACK_BT_SKILL_ACTIVATED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_ACTIVATEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SKILL_ACTIVATEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _slot = _o->slot;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_ACTIVATED(
      _fbb,
      _frame,
      _actorUK,
      _slot,
      _error);
}

inline ACK_BT_SKILL_BLOCKEDT *ACK_BT_SKILL_BLOCKED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SKILL_BLOCKEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SKILL_BLOCKED::UnPackTo(ACK_BT_SKILL_BLOCKEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = coolbonusMSec(); _o->coolbonusMSec = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> ACK_BT_SKILL_BLOCKED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_BLOCKEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SKILL_BLOCKED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SKILL_BLOCKED> CreateACK_BT_SKILL_BLOCKED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_BLOCKEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SKILL_BLOCKEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _slot = _o->slot;
  auto _coolbonusMSec = _o->coolbonusMSec;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_BLOCKED(
      _fbb,
      _frame,
      _actorUK,
      _slot,
      _coolbonusMSec,
      _error);
}

inline ACK_BT_SKILL_CASTEDT *ACK_BT_SKILL_CASTED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SKILL_CASTEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SKILL_CASTED::UnPackTo(ACK_BT_SKILL_CASTEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = casting(); _o->casting = _e; };
  { auto _e = pivot(); if (_e) _o->pivot = std::unique_ptr<OVERLORD::RTS::STRUCT::SKILL_PIVOTT>(_e->UnPack(_resolver)); };
  { auto _e = caster(); if (_e) _o->caster = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED> ACK_BT_SKILL_CASTED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SKILL_CASTED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED> CreateACK_BT_SKILL_CASTED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SKILL_CASTEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _slot = _o->slot;
  auto _casting = _o->casting;
  auto _pivot = _o->pivot ? CreateSKILL_PIVOT(_fbb, _o->pivot.get(), _rehasher) : 0;
  auto _caster = _o->caster ? CreateACTOR_SNA_UPDATE(_fbb, _o->caster.get(), _rehasher) : 0;
  auto _targets = _o->targets.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> (_o->targets.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_SNA_UPDATE(*__va->__fbb, __va->__o->targets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_CASTED(
      _fbb,
      _frame,
      _actorUK,
      _slot,
      _casting,
      _pivot,
      _caster,
      _targets,
      _error);
}

inline ACK_BT_SKILL_CASTED_INTERVALT *ACK_BT_SKILL_CASTED_INTERVAL::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SKILL_CASTED_INTERVALT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SKILL_CASTED_INTERVAL::UnPackTo(ACK_BT_SKILL_CASTED_INTERVALT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = slot(); _o->slot = _e; };
  { auto _e = pivot(); if (_e) _o->pivot = std::unique_ptr<OVERLORD::RTS::STRUCT::SKILL_PIVOTT>(_e->UnPack(_resolver)); };
  { auto _e = leftCount(); _o->leftCount = _e; };
  { auto _e = caster(); if (_e) _o->caster = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> ACK_BT_SKILL_CASTED_INTERVAL::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTED_INTERVALT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SKILL_CASTED_INTERVAL(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SKILL_CASTED_INTERVAL> CreateACK_BT_SKILL_CASTED_INTERVAL(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SKILL_CASTED_INTERVALT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SKILL_CASTED_INTERVALT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _slot = _o->slot;
  auto _pivot = _o->pivot ? CreateSKILL_PIVOT(_fbb, _o->pivot.get(), _rehasher) : 0;
  auto _leftCount = _o->leftCount;
  auto _caster = _o->caster ? CreateACTOR_SNA_UPDATE(_fbb, _o->caster.get(), _rehasher) : 0;
  auto _targets = _o->targets.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> (_o->targets.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_SNA_UPDATE(*__va->__fbb, __va->__o->targets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SKILL_CASTED_INTERVAL(
      _fbb,
      _frame,
      _actorUK,
      _slot,
      _pivot,
      _leftCount,
      _caster,
      _targets,
      _error);
}

inline ACK_BT_SYNC_SKILL_UPDATET *ACK_BT_SYNC_SKILL_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SYNC_SKILL_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SYNC_SKILL_UPDATE::UnPackTo(ACK_BT_SYNC_SKILL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = targets(); if (_e) { _o->targets.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->targets[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> ACK_BT_SYNC_SKILL_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_SKILL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SYNC_SKILL_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SYNC_SKILL_UPDATE> CreateACK_BT_SYNC_SKILL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_SKILL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SYNC_SKILL_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _targets = _o->targets.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::ACTOR_SNA_UPDATE>> (_o->targets.size(), [](size_t i, _VectorArgs *__va) { return CreateACTOR_SNA_UPDATE(*__va->__fbb, __va->__o->targets[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_SKILL_UPDATE(
      _fbb,
      _frame,
      _actorUK,
      _targets,
      _error);
}

inline ACK_BT_SYNC_ACTOR_SCORET *ACK_BT_SYNC_ACTOR_SCORE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SYNC_ACTOR_SCORET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SYNC_ACTOR_SCORE::UnPackTo(ACK_BT_SYNC_ACTOR_SCORET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = scores(); if (_e) { _o->scores.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scores[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> ACK_BT_SYNC_ACTOR_SCORE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SYNC_ACTOR_SCORE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SYNC_ACTOR_SCORE> CreateACK_BT_SYNC_ACTOR_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_ACTOR_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SYNC_ACTOR_SCORET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _scores = _o->scores.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> (_o->scores.size(), [](size_t i, _VectorArgs *__va) { return CreatePLAYER_SCORE(*__va->__fbb, __va->__o->scores[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_ACTOR_SCORE(
      _fbb,
      _frame,
      _scores,
      _error);
}

inline ACK_BT_SYNC_PLAYER_SCORET *ACK_BT_SYNC_PLAYER_SCORE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SYNC_PLAYER_SCORET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SYNC_PLAYER_SCORE::UnPackTo(ACK_BT_SYNC_PLAYER_SCORET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = scores(); if (_e) { _o->scores.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->scores[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> ACK_BT_SYNC_PLAYER_SCORE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_PLAYER_SCORET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SYNC_PLAYER_SCORE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SYNC_PLAYER_SCORE> CreateACK_BT_SYNC_PLAYER_SCORE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_PLAYER_SCORET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SYNC_PLAYER_SCORET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _scores = _o->scores.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> (_o->scores.size(), [](size_t i, _VectorArgs *__va) { return CreatePLAYER_SCORE(*__va->__fbb, __va->__o->scores[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_PLAYER_SCORE(
      _fbb,
      _frame,
      _scores,
      _error);
}

inline ACK_BT_ZONE_STATET *ACK_BT_ZONE_STATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ZONE_STATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ZONE_STATE::UnPackTo(ACK_BT_ZONE_STATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = zone(); _o->zone = _e; };
  { auto _e = event(); _o->event = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ZONE_STATE> ACK_BT_ZONE_STATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_STATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ZONE_STATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ZONE_STATE> CreateACK_BT_ZONE_STATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_STATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ZONE_STATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _zone = _o->zone;
  auto _event = _o->event;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ZONE_STATE(
      _fbb,
      _frame,
      _zone,
      _event,
      _error);
}

inline ACK_BT_ZONE_EVENTT *ACK_BT_ZONE_EVENT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ZONE_EVENTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ZONE_EVENT::UnPackTo(ACK_BT_ZONE_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = event(); _o->event = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ZONE_EVENT> ACK_BT_ZONE_EVENT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ZONE_EVENT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ZONE_EVENT> CreateACK_BT_ZONE_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ZONE_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ZONE_EVENTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _event = _o->event;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ZONE_EVENT(
      _fbb,
      _frame,
      _actorUK,
      _event,
      _error);
}

inline ACK_BT_DOOR_EVENTT *ACK_BT_DOOR_EVENT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DOOR_EVENTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DOOR_EVENT::UnPackTo(ACK_BT_DOOR_EVENTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = event(); _o->event = _e; };
  { auto _e = doorId(); _o->doorId = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DOOR_EVENT> ACK_BT_DOOR_EVENT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DOOR_EVENTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DOOR_EVENT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DOOR_EVENT> CreateACK_BT_DOOR_EVENT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DOOR_EVENTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DOOR_EVENTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _event = _o->event;
  auto _doorId = _o->doorId;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DOOR_EVENT(
      _fbb,
      _frame,
      _event,
      _doorId,
      _error);
}

inline ACK_BT_SYNC_TIME_REMAINT *ACK_BT_SYNC_TIME_REMAIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_SYNC_TIME_REMAINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_SYNC_TIME_REMAIN::UnPackTo(ACK_BT_SYNC_TIME_REMAINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = remainSec(); _o->remainSec = _e; };
  { auto _e = notify(); _o->notify = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> ACK_BT_SYNC_TIME_REMAIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_TIME_REMAINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_SYNC_TIME_REMAIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_SYNC_TIME_REMAIN> CreateACK_BT_SYNC_TIME_REMAIN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_SYNC_TIME_REMAINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_SYNC_TIME_REMAINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _remainSec = _o->remainSec;
  auto _notify = _o->notify;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_SYNC_TIME_REMAIN(
      _fbb,
      _frame,
      _remainSec,
      _notify,
      _error);
}

inline ACK_BT_ACTOR_TELEPORTT *ACK_BT_ACTOR_TELEPORT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_TELEPORTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_TELEPORT::UnPackTo(ACK_BT_ACTOR_TELEPORTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = update(); if (_e) _o->update = std::unique_ptr<OVERLORD::RTS::STRUCT::ACTOR_UPDATET>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> ACK_BT_ACTOR_TELEPORT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_TELEPORTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_TELEPORT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_TELEPORT> CreateACK_BT_ACTOR_TELEPORT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_TELEPORTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_TELEPORTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  auto _update = _o->update ? CreateACTOR_UPDATE(_fbb, _o->update.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_TELEPORT(
      _fbb,
      _actorUK,
      _update,
      _error);
}

inline ACK_BT_ACTOR_FORMATIONT *ACK_BT_ACTOR_FORMATION::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_FORMATIONT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_FORMATION::UnPackTo(ACK_BT_ACTOR_FORMATIONT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = actorUK(); _o->actorUK = _e; };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> ACK_BT_ACTOR_FORMATION::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_FORMATIONT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_FORMATION(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_FORMATION> CreateACK_BT_ACTOR_FORMATION(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_FORMATIONT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_FORMATIONT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _actorUK = _o->actorUK;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_FORMATION(
      _fbb,
      _actorUK);
}

inline ACK_BT_ACTOR_MEDAL_UPDATET *ACK_BT_ACTOR_MEDAL_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_ACTOR_MEDAL_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_ACTOR_MEDAL_UPDATE::UnPackTo(ACK_BT_ACTOR_MEDAL_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorMedal(); _o->actorMedal = _e; };
  { auto _e = actorScore(); if (_e) _o->actorScore = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>(_e->UnPack(_resolver)); };
  { auto _e = victimUK(); _o->victimUK = _e; };
  { auto _e = victimMedal(); _o->victimMedal = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> ACK_BT_ACTOR_MEDAL_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_MEDAL_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_ACTOR_MEDAL_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_ACTOR_MEDAL_UPDATE> CreateACK_BT_ACTOR_MEDAL_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_ACTOR_MEDAL_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_ACTOR_MEDAL_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _actorUK = _o->actorUK;
  auto _actorMedal = _o->actorMedal;
  auto _actorScore = _o->actorScore ? CreatePLAYER_SCORE(_fbb, _o->actorScore.get(), _rehasher) : 0;
  auto _victimUK = _o->victimUK;
  auto _victimMedal = _o->victimMedal;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_ACTOR_MEDAL_UPDATE(
      _fbb,
      _frame,
      _actorUK,
      _actorMedal,
      _actorScore,
      _victimUK,
      _victimMedal,
      _error);
}

inline ACK_BT_TEAM_POINT_UPDATET *ACK_BT_TEAM_POINT_UPDATE::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_TEAM_POINT_UPDATET();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_TEAM_POINT_UPDATE::UnPackTo(ACK_BT_TEAM_POINT_UPDATET *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = team(); _o->team = _e; };
  { auto _e = point(); _o->point = _e; };
  { auto _e = pointDelta(); _o->pointDelta = _e; };
  { auto _e = actorUK(); _o->actorUK = _e; };
  { auto _e = actorMedal(); _o->actorMedal = _e; };
  { auto _e = rank(); if (_e) { _o->rank.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rank[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYER_SCORET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> ACK_BT_TEAM_POINT_UPDATE::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_TEAM_POINT_UPDATET* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_TEAM_POINT_UPDATE(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_TEAM_POINT_UPDATE> CreateACK_BT_TEAM_POINT_UPDATE(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_TEAM_POINT_UPDATET *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_TEAM_POINT_UPDATET* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _team = _o->team;
  auto _point = _o->point;
  auto _pointDelta = _o->pointDelta;
  auto _actorUK = _o->actorUK;
  auto _actorMedal = _o->actorMedal;
  auto _rank = _o->rank.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER_SCORE>> (_o->rank.size(), [](size_t i, _VectorArgs *__va) { return CreatePLAYER_SCORE(*__va->__fbb, __va->__o->rank[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_TEAM_POINT_UPDATE(
      _fbb,
      _frame,
      _team,
      _point,
      _pointDelta,
      _actorUK,
      _actorMedal,
      _rank,
      _error);
}

inline ACK_COMMON_ERRORT *ACK_COMMON_ERROR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_COMMON_ERRORT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_COMMON_ERROR::UnPackTo(ACK_COMMON_ERRORT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_COMMON_ERROR> ACK_COMMON_ERROR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COMMON_ERRORT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_COMMON_ERROR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_COMMON_ERROR> CreateACK_COMMON_ERROR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COMMON_ERRORT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_COMMON_ERRORT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_COMMON_ERROR(
      _fbb,
      _error);
}

inline ACK_COST_UPDATE_AVATART *ACK_COST_UPDATE_AVATAR::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_COST_UPDATE_AVATART();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_COST_UPDATE_AVATAR::UnPackTo(ACK_COST_UPDATE_AVATART *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = avatar(); if (_e) _o->avatar = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> ACK_COST_UPDATE_AVATAR::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COST_UPDATE_AVATART* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_COST_UPDATE_AVATAR(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_COST_UPDATE_AVATAR> CreateACK_COST_UPDATE_AVATAR(flatbuffers::FlatBufferBuilder &_fbb, const ACK_COST_UPDATE_AVATART *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_COST_UPDATE_AVATART* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _avatar = _o->avatar.empty() ? 0 : _fbb.CreateString(_o->avatar);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_COST_UPDATE_AVATAR(
      _fbb,
      _avatar,
      _error);
}

inline ACK_DISCONNECTEDT *ACK_DISCONNECTED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_DISCONNECTEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_DISCONNECTED::UnPackTo(ACK_DISCONNECTEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_DISCONNECTED> ACK_DISCONNECTED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DISCONNECTEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_DISCONNECTED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_DISCONNECTED> CreateACK_DISCONNECTED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DISCONNECTEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_DISCONNECTEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_DISCONNECTED(
      _fbb,
      _error);
}

inline ACK_DECK_SCENE_LOADEDT *ACK_DECK_SCENE_LOADED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_DECK_SCENE_LOADEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_DECK_SCENE_LOADED::UnPackTo(ACK_DECK_SCENE_LOADEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_DECK_SCENE_LOADED> ACK_DECK_SCENE_LOADED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SCENE_LOADEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_DECK_SCENE_LOADED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_DECK_SCENE_LOADED> CreateACK_DECK_SCENE_LOADED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_DECK_SCENE_LOADEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_DECK_SCENE_LOADEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_DECK_SCENE_LOADED(
      _fbb,
      _error);
}

inline ACK_CS_MATCHEDT *ACK_CS_MATCHED::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CS_MATCHEDT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CS_MATCHED::UnPackTo(ACK_CS_MATCHEDT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = modType(); _o->modType = _e; };
  { auto _e = modId(); if (_e) _o->modId = _e->str(); };
  { auto _e = roomkey(); if (_e) _o->roomkey = _e->str(); };
  { auto _e = teams(); if (_e) { _o->teams.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->teams[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::TEAMT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = players(); if (_e) { _o->players.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->players[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::PLAYERT>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_CS_MATCHED> ACK_CS_MATCHED::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_MATCHEDT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CS_MATCHED(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CS_MATCHED> CreateACK_CS_MATCHED(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_MATCHEDT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CS_MATCHEDT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _modType = _o->modType;
  auto _modId = _o->modId.empty() ? 0 : _fbb.CreateString(_o->modId);
  auto _roomkey = _o->roomkey.empty() ? 0 : _fbb.CreateString(_o->roomkey);
  auto _teams = _o->teams.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::TEAM>> (_o->teams.size(), [](size_t i, _VectorArgs *__va) { return CreateTEAM(*__va->__fbb, __va->__o->teams[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _players = _o->players.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::PLAYER>> (_o->players.size(), [](size_t i, _VectorArgs *__va) { return CreatePLAYER(*__va->__fbb, __va->__o->players[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_CS_MATCHED(
      _fbb,
      _modType,
      _modId,
      _roomkey,
      _teams,
      _players,
      _error);
}

inline ACK_CS_DECK_SELECTT *ACK_CS_DECK_SELECT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CS_DECK_SELECTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CS_DECK_SELECT::UnPackTo(ACK_CS_DECK_SELECTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = crewNo(); _o->crewNo = _e; };
  { auto _e = heroUD(); if (_e) _o->heroUD = _e->str(); };
  { auto _e = heroId(); if (_e) _o->heroId = _e->str(); };
  { auto _e = level(); _o->level = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_CS_DECK_SELECT> ACK_CS_DECK_SELECT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CS_DECK_SELECT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CS_DECK_SELECT> CreateACK_CS_DECK_SELECT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CS_DECK_SELECTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _crewNo = _o->crewNo;
  auto _heroUD = _o->heroUD.empty() ? 0 : _fbb.CreateString(_o->heroUD);
  auto _heroId = _o->heroId.empty() ? 0 : _fbb.CreateString(_o->heroId);
  auto _level = _o->level;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_CS_DECK_SELECT(
      _fbb,
      _kId,
      _crewNo,
      _heroUD,
      _heroId,
      _level,
      _error);
}

inline ACK_CS_DECK_TIME_REMAINT *ACK_CS_DECK_TIME_REMAIN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CS_DECK_TIME_REMAINT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CS_DECK_TIME_REMAIN::UnPackTo(ACK_CS_DECK_TIME_REMAINT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = remainSec(); _o->remainSec = _e; };
  { auto _e = notify(); _o->notify = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> ACK_CS_DECK_TIME_REMAIN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_TIME_REMAINT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CS_DECK_TIME_REMAIN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CS_DECK_TIME_REMAIN> CreateACK_CS_DECK_TIME_REMAIN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_TIME_REMAINT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CS_DECK_TIME_REMAINT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _remainSec = _o->remainSec;
  auto _notify = _o->notify;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_CS_DECK_TIME_REMAIN(
      _fbb,
      _frame,
      _remainSec,
      _notify,
      _error);
}

inline ACK_CS_DECK_SELECT_READYT *ACK_CS_DECK_SELECT_READY::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_CS_DECK_SELECT_READYT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_CS_DECK_SELECT_READY::UnPackTo(ACK_CS_DECK_SELECT_READYT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = kId(); _o->kId = _e; };
  { auto _e = ready(); _o->ready = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> ACK_CS_DECK_SELECT_READY::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECT_READYT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_CS_DECK_SELECT_READY(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_CS_DECK_SELECT_READY> CreateACK_CS_DECK_SELECT_READY(flatbuffers::FlatBufferBuilder &_fbb, const ACK_CS_DECK_SELECT_READYT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_CS_DECK_SELECT_READYT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _kId = _o->kId;
  auto _ready = _o->ready;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_CS_DECK_SELECT_READY(
      _fbb,
      _kId,
      _ready,
      _error);
}

inline ACK_BT_DICE_OPENT *ACK_BT_DICE_OPEN::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DICE_OPENT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DICE_OPEN::UnPackTo(ACK_BT_DICE_OPENT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DICE_OPEN> ACK_BT_DICE_OPEN::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_OPENT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DICE_OPEN(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DICE_OPEN> CreateACK_BT_DICE_OPEN(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_OPENT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DICE_OPENT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_OPEN(
      _fbb,
      _frame,
      _itemId,
      _error);
}

inline ACK_BT_DICE_COUNTT *ACK_BT_DICE_COUNT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DICE_COUNTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DICE_COUNT::UnPackTo(ACK_BT_DICE_COUNTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = timeLeftSec(); _o->timeLeftSec = _e; };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DICE_COUNT> ACK_BT_DICE_COUNT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_COUNTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DICE_COUNT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DICE_COUNT> CreateACK_BT_DICE_COUNT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_COUNTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DICE_COUNTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _timeLeftSec = _o->timeLeftSec;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_COUNT(
      _fbb,
      _frame,
      _itemId,
      _timeLeftSec,
      _error);
}

inline ACK_BT_DICE_NUMT *ACK_BT_DICE_NUM::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DICE_NUMT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DICE_NUM::UnPackTo(ACK_BT_DICE_NUMT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = dice(); if (_e) _o->dice = std::unique_ptr<OVERLORD::RTS::STRUCT::DICET>(_e->UnPack(_resolver)); };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DICE_NUM> ACK_BT_DICE_NUM::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_NUMT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DICE_NUM(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DICE_NUM> CreateACK_BT_DICE_NUM(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_NUMT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DICE_NUMT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _dice = _o->dice ? CreateDICE(_fbb, _o->dice.get(), _rehasher) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_NUM(
      _fbb,
      _frame,
      _itemId,
      _dice,
      _error);
}

inline ACK_BT_DICE_RESULTT *ACK_BT_DICE_RESULT::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = new ACK_BT_DICE_RESULTT();
  UnPackTo(_o, _resolver);
  return _o;
}

inline void ACK_BT_DICE_RESULT::UnPackTo(ACK_BT_DICE_RESULTT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = frame(); _o->frame = _e; };
  { auto _e = itemId(); if (_e) _o->itemId = _e->str(); };
  { auto _e = winner(); _o->winner = _e; };
  { auto _e = dices(); if (_e) { _o->dices.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->dices[_i] = std::unique_ptr<OVERLORD::RTS::STRUCT::DICET>(_e->Get(_i)->UnPack(_resolver)); } } };
  { auto _e = error(); if (_e) _o->error = std::unique_ptr<OVERLORD::RTS::STRUCT::RTS_ERRORT>(_e->UnPack(_resolver)); };
}

inline flatbuffers::Offset<ACK_BT_DICE_RESULT> ACK_BT_DICE_RESULT::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_RESULTT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateACK_BT_DICE_RESULT(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ACK_BT_DICE_RESULT> CreateACK_BT_DICE_RESULT(flatbuffers::FlatBufferBuilder &_fbb, const ACK_BT_DICE_RESULTT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ACK_BT_DICE_RESULTT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _frame = _o->frame;
  auto _itemId = _o->itemId.empty() ? 0 : _fbb.CreateString(_o->itemId);
  auto _winner = _o->winner;
  auto _dices = _o->dices.size() ? _fbb.CreateVector<flatbuffers::Offset<OVERLORD::RTS::STRUCT::DICE>> (_o->dices.size(), [](size_t i, _VectorArgs *__va) { return CreateDICE(*__va->__fbb, __va->__o->dices[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _error = _o->error ? CreateRTS_ERROR(_fbb, _o->error.get(), _rehasher) : 0;
  return OVERLORD::RTS::S2C::CreateACK_BT_DICE_RESULT(
      _fbb,
      _frame,
      _itemId,
      _winner,
      _dices,
      _error);
}

}  // namespace S2C
}  // namespace RTS
}  // namespace OVERLORD

#endif  // FLATBUFFERS_GENERATED_RTSS2C_OVERLORD_RTS_S2C_H_
